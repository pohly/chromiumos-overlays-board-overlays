From 89bbe332ada6c2adf2cbfb6c06d0449e1d558364 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?St=C3=A9phane=20Marchesin?= <marcheu@chromium.org>
Date: Tue, 15 Sep 2015 15:45:03 -0700
Subject: [PATCH 8/8] HACK: tegra dmabuf hacks

Change-Id: I2a8efd21b4daf79b28b820758963400c919a3d65
---
 .../config/armel/chromeos-tegra.flavour.config     |   2 +-
 drivers/gpu/drm/tegra/gem.c                        |   5 +-
 drivers/video/tegra/host/dmabuf.c                  | 121 +++++++++++++++---
 drivers/video/tegra/host/dmabuf.h                  |   5 +
 drivers/video/tegra/host/nvhost_job.c              |   2 +
 drivers/video/tegra/host/nvhost_memmgr.c           |  36 +++++-
 drivers/video/tegra/host/nvhost_memmgr.h           |  14 ++-
 drivers/video/tegra/host/nvmap.c                   |   8 +-
 drivers/video/tegra/nvmap/nvmap.c                  |   2 +-
 drivers/video/tegra/nvmap/nvmap_dmabuf.c           |  58 +++++++--
 drivers/video/tegra/nvmap/nvmap_handle.c           | 138 ++++++++++++++++++++-
 drivers/video/tegra/nvmap/nvmap_priv.h             |   3 +
 include/linux/nvmap.h                              |   2 +
 13 files changed, 348 insertions(+), 48 deletions(-)

diff --git a/chromeos/config/armel/chromeos-tegra.flavour.config b/chromeos/config/armel/chromeos-tegra.flavour.config
index c615c8e..06334b1 100644
--- a/chromeos/config/armel/chromeos-tegra.flavour.config
+++ b/chromeos/config/armel/chromeos-tegra.flavour.config
@@ -114,7 +114,7 @@ CONFIG_NVMAP_PAGE_POOLS_INIT_FILLUP=y
 CONFIG_NVMAP_PAGE_POOLS_INIT_FILLUP_SIZE=0x64
 CONFIG_NVMAP_PAGE_POOL_SIZE=0x0
 # CONFIG_NVMAP_USE_CMA_FOR_CARVEOUT is not set
-CONFIG_NVMAP_USE_FD_FOR_HANDLE=y
+# CONFIG_NVMAP_USE_FD_FOR_HANDLE is not set
 # CONFIG_NVMAP_VPR is not set
 CONFIG_PAGE_OFFSET=0xC0000000
 CONFIG_PHYS_ADDR_T_64BIT=y
diff --git a/drivers/gpu/drm/tegra/gem.c b/drivers/gpu/drm/tegra/gem.c
index 00fcc00..ad34e19 100644
--- a/drivers/gpu/drm/tegra/gem.c
+++ b/drivers/gpu/drm/tegra/gem.c
@@ -638,8 +638,11 @@ struct dma_buf *tegra_gem_prime_export(struct drm_device *drm,
 				       struct drm_gem_object *gem,
 				       int flags)
 {
-	return dma_buf_export(gem, &tegra_gem_prime_dmabuf_ops, gem->size,
+	struct dma_buf *buf =  dma_buf_export(gem, &tegra_gem_prime_dmabuf_ops, gem->size,
 			      flags);
+
+	printk(KERN_ERR"export dmabuf %p from tegra drm\n",buf);
+	return buf;
 }
 
 struct drm_gem_object *tegra_gem_prime_import(struct drm_device *drm,
diff --git a/drivers/video/tegra/host/dmabuf.c b/drivers/video/tegra/host/dmabuf.c
index 62e5331..17639ee 100644
--- a/drivers/video/tegra/host/dmabuf.c
+++ b/drivers/video/tegra/host/dmabuf.c
@@ -20,12 +20,21 @@
 
 #include <linux/dma-buf.h>
 #include <linux/nvhost.h>
+#include <linux/nvmap.h>
+#include <linux/slab.h>
 #include "chip_support.h"
+#include "nvhost_allocator.h"
 #include "nvhost_memmgr.h"
+#include "../nvmap/nvmap_ioctl.h"
+
+struct nvhost_dmabuf_data {
+	struct nvhost_comptags comptags;
+	struct nvhost_allocator *comptag_allocator; // TODO implement freeing
+};
 
 static inline struct dma_buf_attachment *to_dmabuf_att(struct mem_handle *h)
 {
-	return (struct dma_buf_attachment *)(((uintptr_t)h) & ~0x3);
+	return (struct dma_buf_attachment *)h;
 }
 
 static inline struct dma_buf *to_dmabuf(struct mem_handle *h)
@@ -33,13 +42,10 @@ static inline struct dma_buf *to_dmabuf(struct mem_handle *h)
 	return to_dmabuf_att(h)->dmabuf;
 }
 
-static inline int to_dmabuf_fd(ulong id)
-{
-	return nvhost_memmgr_id(id) >> 2;
-}
 struct mem_handle *nvhost_dmabuf_alloc(size_t size, size_t align, int flags)
 {
 	/* TODO: Add allocation via DMA Mapping API */
+	WARN_ON(1);
 	return NULL;
 }
 
@@ -53,6 +59,15 @@ void nvhost_dmabuf_put(struct mem_handle *handle)
 
 struct sg_table *nvhost_dmabuf_pin(struct mem_handle *handle)
 {
+	struct dma_buf_attachment *attach = (struct dma_buf_attachment*)handle;
+	struct nvhost_dmabuf_data *priv;
+
+	WARN_ON(attach->priv);
+
+	/* Allocate priv struct */
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	attach->priv = priv;
+
 	return dma_buf_map_attachment(to_dmabuf_att(handle),
 				DMA_BIDIRECTIONAL);
 }
@@ -86,26 +101,92 @@ void nvhost_dmabuf_kunmap(struct mem_handle *handle, unsigned int pagenum,
 
 struct mem_handle *nvhost_dmabuf_get(ulong id, struct platform_device *dev)
 {
-	struct mem_handle *h;
-	struct dma_buf *buf;
-
-	buf = dma_buf_get(to_dmabuf_fd(id));
-	if (IS_ERR(buf))
-		return (struct mem_handle *)buf;
-	else {
-		h = (struct mem_handle *)dma_buf_attach(buf, &dev->dev);
-		if (IS_ERR(h)) {
-			dma_buf_put(buf);
-			return (struct mem_handle *)h;
-		}
-	}
+	struct dma_buf_attachment *attach;
 
-	return (struct mem_handle *) ((uintptr_t)h | mem_mgr_type_dmabuf);
+	attach = nvmap_get_dmabuf_attachment((struct nvmap_handle *)id);
+
+	return (struct mem_handle *)attach;
 }
 
+#if 0
+static void delete_priv(void *_priv)
+{
+	struct nvhost_dmabuf_data *priv = _priv;
+
+	WARN_ON(!priv);
+
+	if (priv->comptags.lines) {
+		BUG_ON(!priv->comptag_allocator);
+		priv->comptag_allocator->free(priv->comptag_allocator,
+					      priv->comptags.offset,
+					      priv->comptags.lines);
+	}
+	kfree(priv);
+}
+#endif
+
 int nvhost_dmabuf_get_param(struct mem_mgr *memmgr, struct mem_handle *handle,
 			    u32 param, u64 *result)
 {
-	/* TBD: find a way to associate size, kind, etc */
+	struct dma_buf_attachment *attach = (struct dma_buf_attachment*)handle;
+
+	switch(param)
+	{
+		case NVMAP_HANDLE_PARAM_SIZE:
+			*result = attach->dmabuf->size;
+			return 0;
+		case NVMAP_HANDLE_PARAM_ALIGNMENT:
+			if (attach->dmabuf->size & (128 * 1024 - 1))
+				*result = 4096;
+			else
+				*result = 128 * 1024;
+			return 0;
+		case NVMAP_HANDLE_PARAM_BASE:
+			*result = 0;
+			return 0;
+		case NVMAP_HANDLE_PARAM_HEAP:
+			*result = NVMAP_HEAP_IOVMM;
+			return 0;
+		case NVMAP_HANDLE_PARAM_KIND:
+			*result = 0xdb; // gmmu_pte_kind_c32_2cra_v();
+			return 0;
+	}
+
+	printk(KERN_ERR"Unimplemented parameter %d handle %p\n",param,handle);
 	return -EINVAL;
 }
+
+void nvhost_dmabuf_get_comptags(struct mem_handle *handle,
+				struct nvhost_comptags *comptags)
+{
+	struct dma_buf_attachment *attach = (struct dma_buf_attachment*)handle;
+	struct nvhost_dmabuf_data *priv;
+
+	WARN_ON(!attach->priv);
+
+	priv = attach->priv;
+	*comptags = priv->comptags;
+}
+
+int nvhost_dmabuf_alloc_comptags(struct mem_handle *handle,
+				 struct nvhost_allocator *allocator,
+				 int lines)
+{
+	struct dma_buf_attachment *attach = (struct dma_buf_attachment*)handle;
+	struct nvhost_dmabuf_data *priv;
+	u32 offset = 0;
+	int err;
+
+	BUG_ON(!lines);
+	WARN_ON(!attach->priv);
+	priv = attach->priv;
+
+	/* store the allocator so we can use it when we free the ctags */
+	priv->comptag_allocator = allocator;
+	err = allocator->alloc(allocator, &offset, lines);
+	if (!err) {
+		priv->comptags.lines = lines;
+		priv->comptags.offset = offset;
+	}
+	return err;
+}
diff --git a/drivers/video/tegra/host/dmabuf.h b/drivers/video/tegra/host/dmabuf.h
index 2646184..85a280e 100644
--- a/drivers/video/tegra/host/dmabuf.h
+++ b/drivers/video/tegra/host/dmabuf.h
@@ -43,4 +43,9 @@ void nvhost_dmabuf_kunmap(struct mem_handle *handle, unsigned int pagenum,
 struct mem_handle *nvhost_dmabuf_get(ulong id, struct platform_device *dev);
 int nvhost_dmabuf_get_param(struct mem_mgr *memmgr, struct mem_handle *handle,
 			   u32 param, u64 *result);
+void nvhost_dmabuf_get_comptags(struct mem_handle *handle,
+				struct nvhost_comptags *comptags);
+int nvhost_dmabuf_alloc_comptags(struct mem_handle *handle,
+				 struct nvhost_allocator *allocator,
+				 int lines);
 #endif
diff --git a/drivers/video/tegra/host/nvhost_job.c b/drivers/video/tegra/host/nvhost_job.c
index ffe3cab..98fcdcf 100644
--- a/drivers/video/tegra/host/nvhost_job.c
+++ b/drivers/video/tegra/host/nvhost_job.c
@@ -270,6 +270,7 @@ static int pin_array_ids(struct platform_device *dev,
 			return -EINVAL;
 
 		attach = dma_buf_attach(buf, &dev->dev);
+		printk("[%s:%d] ATTACH %p\n",__func__,__LINE__,buf);
 		if (IS_ERR(attach))
 			return PTR_ERR(attach);
 
@@ -448,6 +449,7 @@ void nvhost_job_unpin(struct nvhost_job *job)
 		struct nvhost_job_unpin *unpin = &job->unpins[i];
 		dma_buf_unmap_attachment(unpin->attach, unpin->sgt,
 						DMA_BIDIRECTIONAL);
+		printk("[%s:%d] DETACH %p\n",__func__,__LINE__,unpin->buf);
 		dma_buf_detach(unpin->buf, unpin->attach);
 		dma_buf_put(unpin->buf);
 	}
diff --git a/drivers/video/tegra/host/nvhost_memmgr.c b/drivers/video/tegra/host/nvhost_memmgr.c
index 6fb668c..71f4bc1 100644
--- a/drivers/video/tegra/host/nvhost_memmgr.c
+++ b/drivers/video/tegra/host/nvhost_memmgr.c
@@ -119,6 +119,7 @@ struct mem_handle *nvhost_memmgr_get(struct mem_mgr *mgr,
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 
@@ -139,6 +140,7 @@ void nvhost_memmgr_put(struct mem_mgr *mgr, struct mem_handle *handle)
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 }
@@ -158,6 +160,7 @@ struct sg_table *nvhost_memmgr_pin(struct mem_mgr *mgr,
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		return 0;
 		break;
 	}
@@ -179,6 +182,7 @@ void nvhost_memmgr_unpin(struct mem_mgr *mgr,
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 }
@@ -197,6 +201,7 @@ void *nvhost_memmgr_mmap(struct mem_handle *handle)
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		return 0;
 		break;
 	}
@@ -216,6 +221,7 @@ void nvhost_memmgr_munmap(struct mem_handle *handle, void *addr)
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 }
@@ -242,6 +248,7 @@ int nvhost_memmgr_get_param(struct mem_mgr *mem_mgr,
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 	return -EINVAL;
@@ -262,6 +269,7 @@ void *nvhost_memmgr_kmap(struct mem_handle *handle, unsigned int pagenum)
 #endif
 	default:
 		return 0;
+		WARN_ON(1);
 		break;
 	}
 }
@@ -281,6 +289,7 @@ void nvhost_memmgr_kunmap(struct mem_handle *handle, unsigned int pagenum,
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 }
@@ -300,6 +309,7 @@ u32 nvhost_memmgr_handle_to_id(struct mem_handle *handle)
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 
@@ -344,6 +354,7 @@ void nvhost_memmgr_free_sg_table(struct mem_mgr *mgr,
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 	return;
@@ -353,11 +364,20 @@ void nvhost_memmgr_get_comptags(struct mem_handle *mem,
 				struct nvhost_comptags *comptags)
 {
 #ifdef CONFIG_TEGRA_GRHOST_USE_NVMAP
-	return nvhost_nvmap_get_comptags(mem, comptags);
+	switch (nvhost_memmgr_type((ulong)mem)) {
+	case mem_mgr_type_nvmap:
+		nvhost_nvmap_get_comptags(mem, comptags);
+		return;
 #endif
 #ifdef CONFIG_TEGRA_GRHOST_USE_DMABUF
-	WARN_ON(1);
+	case mem_mgr_type_dmabuf:
+		nvhost_dmabuf_get_comptags(mem, comptags);
+		return;
 #endif
+	default:
+		WARN_ON(1);
+		return;
+	}
 }
 
 int nvhost_memmgr_alloc_comptags(struct mem_handle *mem,
@@ -365,12 +385,18 @@ int nvhost_memmgr_alloc_comptags(struct mem_handle *mem,
 				 int lines)
 {
 #ifdef CONFIG_TEGRA_GRHOST_USE_NVMAP
-	return nvhost_nvmap_alloc_comptags(mem, allocator, lines);
+	switch (nvhost_memmgr_type((ulong)mem)) {
+	case mem_mgr_type_nvmap:
+		return nvhost_nvmap_alloc_comptags(mem, allocator, lines);
 #endif
 #ifdef CONFIG_TEGRA_GRHOST_USE_DMABUF
-	WARN_ON(1);
-	return 0;
+	case mem_mgr_type_dmabuf:
+		return nvhost_dmabuf_alloc_comptags(mem, allocator, lines);
 #endif
+	default:
+		WARN_ON(1);
+		return 0;
+	}
 }
 
 int nvhost_memmgr_init(struct nvhost_chip_support *chip)
diff --git a/drivers/video/tegra/host/nvhost_memmgr.h b/drivers/video/tegra/host/nvhost_memmgr.h
index 8e65151..14eebb8 100644
--- a/drivers/video/tegra/host/nvhost_memmgr.h
+++ b/drivers/video/tegra/host/nvhost_memmgr.h
@@ -21,6 +21,7 @@
 #ifndef _NVHOST_MEM_MGR_H_
 #define _NVHOST_MEM_MGR_H_
 
+#include <linux/dma-buf.h>
 #include <linux/dma-mapping.h>
 #include <linux/scatterlist.h>
 
@@ -87,7 +88,18 @@ struct sg_table *nvhost_memmgr_sg_table(struct mem_mgr *mgr,
 		struct mem_handle *handle);
 void nvhost_memmgr_free_sg_table(struct mem_mgr *mgr,
 		struct mem_handle *handle, struct sg_table *sgt);
-static inline int nvhost_memmgr_type(ulong id) { return id & MEMMGR_TYPE_MASK; }
+extern struct dma_buf_ops nvmap_dma_buf_ops;
+static inline int nvhost_memmgr_type(ulong id) {
+	struct dma_buf* db = (struct dma_buf*)id;
+	if (id < 4096)
+		return mem_mgr_type_dmabuf;
+
+	if (db->ops == &nvmap_dma_buf_ops)
+		return mem_mgr_type_nvmap;
+	else
+		return mem_mgr_type_dmabuf;
+}
+
 static inline int nvhost_memmgr_id(ulong id) { return id & MEMMGR_ID_MASK; }
 u32 nvhost_memmgr_handle_to_id(struct mem_handle *handle);
 
diff --git a/drivers/video/tegra/host/nvmap.c b/drivers/video/tegra/host/nvmap.c
index fb10ee6..f9eb0f9 100644
--- a/drivers/video/tegra/host/nvmap.c
+++ b/drivers/video/tegra/host/nvmap.c
@@ -181,6 +181,7 @@ priv_exist_or_err:
 			}
 		}
 	} else if (as_priv->pin_count == 0) {
+		printk("[%s:%d] ATTACH %p\n",__func__,__LINE__,dmabuf);
 		as_priv->attach = dma_buf_attach(dmabuf, dev);
 		if (IS_ERR(as_priv->attach)) {
 			mutex_unlock(&priv->lock);
@@ -190,7 +191,9 @@ priv_exist_or_err:
 		as_priv->sgt = dma_buf_map_attachment(as_priv->attach,
 						      DMA_BIDIRECTIONAL);
 		if (IS_ERR(as_priv->sgt)) {
+			printk("[%s:%d] DETACH %p\n",__func__,__LINE__,dmabuf);
 			dma_buf_detach(dmabuf, as_priv->attach);
+			as_priv->attach = NULL;
 			mutex_unlock(&priv->lock);
 			return as_priv->sgt;
 		}
@@ -229,6 +232,7 @@ void nvhost_nvmap_unpin(struct mem_mgr *mgr, struct mem_handle *handle,
 			dma_buf_unmap_attachment(as_priv->attach,
 				as_priv->sgt, DMA_BIDIRECTIONAL);
 			dma_buf_detach(dmabuf, as_priv->attach);
+			as_priv->attach = NULL;
 		}
 		trace_nvhost_nvmap_unpin(dev_name(dev),
 			dmabuf, as_priv->len, dma_addr);
@@ -260,12 +264,8 @@ void nvhost_nvmap_kunmap(struct mem_handle *handle, unsigned int pagenum,
 struct mem_handle *nvhost_nvmap_get(struct mem_mgr *mgr,
 		ulong id, struct platform_device *dev)
 {
-#ifdef CONFIG_NVMAP_USE_FD_FOR_HANDLE
-	return (struct mem_handle *)dma_buf_get(id);
-#else
 	return (struct mem_handle *)
 		nvmap_dmabuf_export((struct nvmap_client *)mgr, id);
-#endif
 }
 
 int nvhost_nvmap_get_param(struct mem_mgr *mgr, struct mem_handle *handle,
diff --git a/drivers/video/tegra/nvmap/nvmap.c b/drivers/video/tegra/nvmap/nvmap.c
index 66f0902..66f7529 100644
--- a/drivers/video/tegra/nvmap/nvmap.c
+++ b/drivers/video/tegra/nvmap/nvmap.c
@@ -447,7 +447,7 @@ void nvmap_handle_put(struct nvmap_handle *h)
 {
 	int cnt;
 
-	if (WARN_ON(!virt_addr_valid(h)))
+	if (((unsigned long)h < 4096) || WARN_ON(!virt_addr_valid(h)))
 		return;
 	cnt = atomic_dec_return(&h->ref);
 
diff --git a/drivers/video/tegra/nvmap/nvmap_dmabuf.c b/drivers/video/tegra/nvmap/nvmap_dmabuf.c
index 8f09b02..bd8f293 100644
--- a/drivers/video/tegra/nvmap/nvmap_dmabuf.c
+++ b/drivers/video/tegra/nvmap/nvmap_dmabuf.c
@@ -164,6 +164,7 @@ static void nvmap_dmabuf_detach(struct dma_buf *dmabuf,
  * Add this sgt to the stash - should be called when the SGT's ref count hits
  * 0.
  */
+/*
 static void __nvmap_dmabuf_add_stash(struct nvmap_handle_sgt *nvmap_sgt)
 {
 	pr_debug("Adding mapping to stash.\n");
@@ -173,7 +174,7 @@ static void __nvmap_dmabuf_add_stash(struct nvmap_handle_sgt *nvmap_sgt)
 	stash_stat_inc(stashed_maps);
 	stash_stat_add_iova(nvmap_sgt->owner->handle);
 }
-
+*/
 /*
  * Make sure this mapping is no longer stashed - this corresponds to a "hit". If
  * the mapping is not stashed this is just a no-op.
@@ -290,11 +291,11 @@ static void __nvmap_dmabuf_stash_sgt_locked(struct dma_buf_attachment *attach,
 			 * If we get here, the ref count is zero. Stash the
 			 * mapping.
 			 */
-#ifdef CONFIG_NVMAP_DMABUF_STASH
-			__nvmap_dmabuf_add_stash(nvmap_sgt);
-#else
+//#ifdef CONFIG_NVMAP_DMABUF_STASH
+//			__nvmap_dmabuf_add_stash(nvmap_sgt);
+//#else
 			__nvmap_dmabuf_free_sgt_locked(nvmap_sgt);
-#endif
+//#endif
 			goto done;
 		}
 	}
@@ -388,10 +389,10 @@ static struct sg_table *nvmap_dmabuf_map_dma_buf(
 	}
 
 cache_hit:
-#ifdef CONFIG_NVMAP_DMABUF_STASH
-	BUG_ON(attach->priv && attach->priv != sgt);
-#endif
-	attach->priv = sgt;
+//#ifdef CONFIG_NVMAP_DMABUF_STASH
+//	BUG_ON(attach->priv && attach->priv != sgt);
+//#endif
+//	attach->priv = sgt;
 	mutex_unlock(&info->maps_lock);
 	return sgt;
 
@@ -422,11 +423,22 @@ static void nvmap_dmabuf_unmap_dma_buf(struct dma_buf_attachment *attach,
 	mutex_unlock(&info->maps_lock);
 }
 
+extern struct dma_buf_ops nvmap_dma_buf_ops;
+
 static void nvmap_dmabuf_release(struct dma_buf *dmabuf)
 {
 	struct nvmap_handle_info *info = dmabuf->priv;
 	struct nvmap_handle_sgt *nvmap_sgt;
 
+	if (dmabuf->ops == &nvmap_dma_buf_ops) {
+		printk("MINE %p handle %p\n",dmabuf,info->handle);
+		nvmap_handle_put(info->handle);
+		return;
+	}
+	else
+		printk("NOT MINE %p\n",dmabuf);
+
+
 	trace_nvmap_dmabuf_release(info->handle->owner ?
 				   info->handle->owner->name : "unknown",
 				   info->handle,
@@ -442,9 +454,12 @@ static void nvmap_dmabuf_release(struct dma_buf *dmabuf)
 	}
 	mutex_unlock(&info->maps_lock);
 
+	printk("[%s:%d] DETACH %p\n",__func__,__LINE__,info->handle->dmabuf);
 	dma_buf_detach(info->handle->dmabuf, info->handle->attachment);
+	info->handle->attachment = NULL;
 	info->handle->dmabuf = NULL;
 	nvmap_handle_put(info->handle);
+	printk("[%s:%d] DETACHED %p\n",__func__,__LINE__,info->handle->dmabuf);
 	kfree(info);
 }
 
@@ -520,7 +535,7 @@ static void nvmap_dmabuf_vunmap(struct dma_buf *dmabuf, void *vaddr)
 	__nvmap_munmap(info->handle, vaddr);
 }
 
-static struct dma_buf_ops nvmap_dma_buf_ops = {
+struct dma_buf_ops nvmap_dma_buf_ops = {
 	.attach		= nvmap_dmabuf_attach,
 	.detach		= nvmap_dmabuf_detach,
 	.map_dma_buf	= nvmap_dmabuf_map_dma_buf,
@@ -683,14 +698,27 @@ ulong nvmap_get_id_from_dmabuf_fd(struct nvmap_client *client, int fd)
 	struct dma_buf *dmabuf;
 	struct nvmap_handle_info *info;
 
+	dump_stack();
+	/* FIXME this whole function is leaking the handle info struct. */
+
 	dmabuf = dma_buf_get(fd);
 	if (IS_ERR(dmabuf))
 		return PTR_ERR(dmabuf);
 	if (dmabuf->ops == &nvmap_dma_buf_ops) {
+		printk("GET SELF IMPORTED %p\n",info->handle);
+		/* Self-imported dmabuf, we can just get a ref and move on */
 		info = dmabuf->priv;
 		id = (ulong) info->handle;
 		if (!nvmap_handle_get(info->handle))
 			id = -EINVAL;
+	} else {
+		/* Foreign dmabuf, need to import */
+		struct nvmap_handle_ref *ref;
+		ref = nvmap_create_handle_dmabuf(client, dmabuf);
+		if (!nvmap_handle_get(ref->handle))
+			id = -EINVAL;
+		else
+			id = (ulong) (ref->handle);
 	}
 	dma_buf_put(dmabuf);
 	return id;
@@ -761,6 +789,7 @@ void nvmap_set_dmabuf_private(struct dma_buf *dmabuf, void *priv,
 	if (WARN_ON(!virt_addr_valid(dmabuf)))
 		return;
 
+
 	info = dmabuf->priv;
 	info->handle->nvhost_priv = priv;
 	info->handle->nvhost_priv_delete = delete;
@@ -774,8 +803,13 @@ void *nvmap_get_dmabuf_private(struct dma_buf *dmabuf)
 	if (WARN_ON(!virt_addr_valid(dmabuf)))
 		return ERR_PTR(-EINVAL);
 
-	info = dmabuf->priv;
-	priv = info->handle->nvhost_priv;
+	if (dmabuf->ops == &nvmap_dma_buf_ops) {
+		info = dmabuf->priv;
+		priv = info->handle->nvhost_priv;
+	} else {
+		WARN_ON(1);
+		return NULL;
+	}
 	return priv;
 }
 
diff --git a/drivers/video/tegra/nvmap/nvmap_handle.c b/drivers/video/tegra/nvmap/nvmap_handle.c
index 02db3ed..f5ffedd 100644
--- a/drivers/video/tegra/nvmap/nvmap_handle.c
+++ b/drivers/video/tegra/nvmap/nvmap_handle.c
@@ -596,6 +596,35 @@ static struct page *nvmap_alloc_pages_exact(gfp_t gfp, size_t size)
 	return page;
 }
 
+static int handle_page_alloc_dmabuf(struct nvmap_client *client,
+				    struct nvmap_handle *h)
+{
+	size_t size = PAGE_ALIGN(h->size);
+	unsigned int nr_page = size >> PAGE_SHIFT;
+	unsigned int i = 0;
+	struct page **pages;
+	struct sg_table *sg_table;
+	struct sg_page_iter sg_iter;
+
+	pages = altalloc(nr_page * sizeof(*pages));
+	if (!pages)
+		return -ENOMEM;
+
+	sg_table = dma_buf_map_attachment(h->attachment, DMA_BIDIRECTIONAL);
+	if (!IS_ERR(sg_table)) {
+		altfree(pages, nr_page * sizeof(*pages));
+		return -ENOMEM;
+	}
+
+	for_each_sg_page(sg_table->sgl, &sg_iter, sg_table->nents, 0)
+                pages[i++] = sg_page_iter_page(&sg_iter);
+
+	h->size = size;
+	h->pgalloc.pages = pages;
+	h->pgalloc.contig = false;
+	return 0;
+}
+
 static int handle_page_alloc(struct nvmap_client *client,
 			     struct nvmap_handle *h, bool contiguous)
 {
@@ -957,6 +986,69 @@ static void add_handle_ref(struct nvmap_client *client,
 	nvmap_ref_unlock(client);
 }
 
+struct nvmap_handle_ref *nvmap_create_handle_dmabuf(struct nvmap_client *client,
+						    struct dma_buf *dmabuf)
+{
+	void *err = ERR_PTR(-ENOMEM);
+	struct nvmap_handle *h;
+	struct nvmap_handle_ref *ref = NULL;
+
+	if (!client)
+		return ERR_PTR(-EINVAL);
+
+	if (!dmabuf->size)
+		return ERR_PTR(-EINVAL);
+
+	h = kzalloc(sizeof(*h), GFP_KERNEL);
+	if (!h)
+		return ERR_PTR(-ENOMEM);
+
+	ref = kzalloc(sizeof(*ref), GFP_KERNEL);
+	if (!ref)
+		goto ref_alloc_fail;
+
+	atomic_set(&h->ref, 1);
+	atomic_set(&h->pin, 0);
+	h->owner = client;
+	h->owner_ref = ref;
+	h->dev = nvmap_dev;
+	BUG_ON(!h->owner);
+	h->size = h->orig_size = dmabuf->size;
+	h->flags = NVMAP_HANDLE_WRITE_COMBINE;
+	mutex_init(&h->lock);
+
+	h->dmabuf = dmabuf;
+
+	/*
+	 * Pre-attach nvmap to this dmabuf. This gets unattached during the
+	 * dma_buf_release() operation.
+	 */
+	h->attachment = dma_buf_attach(h->dmabuf, &nvmap_pdev->dev);
+	if (IS_ERR(h->attachment)) {
+		err = h->attachment;
+		goto dma_buf_attach_fail;
+	}
+
+	nvmap_handle_add(nvmap_dev, h);
+
+	/*
+	 * Major assumption here: the dma_buf object that the handle contains
+	 * is created with a ref count of 1.
+	 */
+	atomic_set(&ref->dupes, 1);
+	ref->handle = h;
+	atomic_set(&ref->pin, 0);
+	add_handle_ref(client, ref);
+	trace_nvmap_create_handle(client, client->name, h, dmabuf->size, ref);
+	return ref;
+
+dma_buf_attach_fail:
+	kfree(ref);
+ref_alloc_fail:
+	kfree(h);
+	return err;
+}
+
 struct nvmap_handle_ref *nvmap_create_handle(struct nvmap_client *client,
 					     size_t size)
 {
@@ -1105,14 +1197,49 @@ struct nvmap_handle_ref *nvmap_create_handle_from_fd(
 {
 	unsigned long id;
 	struct nvmap_handle_ref *ref;
+	struct dma_buf *dmabuf;
 
 	BUG_ON(!client);
 
-	id = nvmap_get_id_from_dmabuf_fd(client, fd);
-	if (IS_ERR_VALUE(id))
-		return ERR_PTR(id);
+
+	dump_stack();
+
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR(dmabuf))
+		BUG_ON(1);
+
+	/* Foreign dmabuf, need to import */
+	ref = nvmap_create_handle_dmabuf(client, dmabuf);
+	if (IS_ERR(ref))
+		goto fail;
+
+	if (!nvmap_handle_get(ref->handle))
+		id = -EINVAL;
+	else
+		id = (ulong) (ref->handle);
+
+	/* give it some IOVM backing */
+	{
+		int ret;
+		struct nvmap_handle *h = (struct nvmap_handle *)id;
+		size_t reserved = PAGE_ALIGN(h->size);
+
+		atomic_add_return(reserved, &client->iovm_commit);
+		ret = handle_page_alloc_dmabuf(client, h);
+		if (ret) {
+			atomic_sub(reserved, &client->iovm_commit);
+			goto fail;
+		}
+		h->heap_pgalloc = true;
+		mb();
+		h->alloc = true;
+	}
+
 	ref = nvmap_duplicate_handle_id(client, id, 1);
+
+fail:
 	nvmap_handle_put((struct nvmap_handle *)id);
+	dma_buf_put(dmabuf);
 	return ref;
 }
 
@@ -1293,3 +1420,8 @@ int nvmap_get_handle_param(struct nvmap_client *client,
 
 	return __nvmap_get_handle_param(client, ref->handle, param, result);
 }
+
+struct dma_buf_attachment *nvmap_get_dmabuf_attachment(struct nvmap_handle *h)
+{
+	return h->attachment;
+}
diff --git a/drivers/video/tegra/nvmap/nvmap_priv.h b/drivers/video/tegra/nvmap/nvmap_priv.h
index a21b7c9..0d1ddaf 100644
--- a/drivers/video/tegra/nvmap/nvmap_priv.h
+++ b/drivers/video/tegra/nvmap/nvmap_priv.h
@@ -293,6 +293,9 @@ void nvmap_handle_put(struct nvmap_handle *h);
 struct nvmap_handle_ref *__nvmap_validate_id_locked(struct nvmap_client *priv,
 						   unsigned long id);
 
+struct nvmap_handle_ref *nvmap_create_handle_dmabuf(struct nvmap_client *client,
+						    struct dma_buf *dmabuf);
+
 struct nvmap_handle_ref *nvmap_create_handle(struct nvmap_client *client,
 					     size_t size);
 
diff --git a/include/linux/nvmap.h b/include/linux/nvmap.h
index a4970ee..673d2f6 100644
--- a/include/linux/nvmap.h
+++ b/include/linux/nvmap.h
@@ -86,6 +86,8 @@ void *nvmap_get_dmabuf_private(struct dma_buf *dmabuf);
 
 int nvmap_get_dmabuf_param(struct dma_buf *dmabuf, u32 param, u64 *result);
 
+struct dma_buf_attachment *nvmap_get_dmabuf_attachment(struct nvmap_handle *h);
+
 #ifdef CONFIG_NVMAP_PAGE_POOLS
 ulong nvmap_page_pool_get_unused_pages(void);
 #else
-- 
2.6.0.rc2.230.g3dd15c0

