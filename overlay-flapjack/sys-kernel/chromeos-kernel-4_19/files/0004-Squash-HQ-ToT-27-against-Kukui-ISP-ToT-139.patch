From 5b7fee9d14c92c26c37e602dda4d8730dd6192c5 Mon Sep 17 00:00:00 2001
From: YH Lin <yueherngl@google.com>
Date: Sun, 21 Apr 2019 10:59:46 -0700
Subject: [PATCH 4/4] Squash HQ ToT #27 against Kukui ISP ToT #139.

Excluding CL:1547642 from HQ ToT #27 and remove it6505dptx from dts.

Change-Id: I9883ce94af6fef842969766748ea56881b9c473b
---
 .../bindings/iio/proximity/sx9311.txt         |   19 +
 README                                        |    3 +-
 arch/arm64/boot/dts/mediatek/Makefile         |    4 +
 .../mt8183-flapjack-rev4-sku1-hwconfig2.dts   |  270 ++++
 .../mt8183-flapjack-rev4-sku1-hwconfig4.dts   |  260 ++++
 .../mt8183-flapjack-rev4-sku3-hwconfig1.dts   |  272 ++++
 .../mt8183-flapjack-rev4-sku3-hwconfig3.dts   |  262 ++++
 .../boot/dts/mediatek/mt8183-flapjack.dtsi    |  141 ++
 .../arm64/chromiumos-arm64.flavour.config     |    2 +-
 .../arm64/chromiumos-mediatek.flavour.config  |    5 +-
 drivers/gpu/drm/mediatek/mtk_disp_ovl.c       |   15 +
 drivers/gpu/drm/panel/panel-boe-himax8279d.c  |  954 ++++++++++++++
 drivers/iio/proximity/Kconfig                 |   13 +
 drivers/iio/proximity/Makefile                |    1 +
 drivers/iio/proximity/sx9311.c                | 1144 +++++++++++++++++
 drivers/net/wireless/ath/ath10k/core.c        |    2 +-
 drivers/net/wireless/ath/ath10k/hif.h         |    6 +-
 drivers/net/wireless/ath/ath10k/sdio.c        |    4 +-
 drivers/thermal/mtk_thermal.c                 |  117 +-
 sound/soc/codecs/max98357a.c                  |   96 +-
 .../mediatek/mt8183/mt8183-da7219-max98357.c  |    2 +-
 21 files changed, 3557 insertions(+), 35 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/iio/proximity/sx9311.txt
 create mode 100755 arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku1-hwconfig2.dts
 create mode 100755 arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku1-hwconfig4.dts
 create mode 100755 arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku3-hwconfig1.dts
 create mode 100755 arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku3-hwconfig3.dts
 create mode 100644 arch/arm64/boot/dts/mediatek/mt8183-flapjack.dtsi
 create mode 100644 drivers/iio/proximity/sx9311.c
 mode change 100644 => 100755 drivers/thermal/mtk_thermal.c
 mode change 100644 => 100755 sound/soc/mediatek/mt8183/mt8183-da7219-max98357.c

diff --git a/Documentation/devicetree/bindings/iio/proximity/sx9311.txt b/Documentation/devicetree/bindings/iio/proximity/sx9311.txt
new file mode 100644
index 000000000000..65a1114e4147
--- /dev/null
+++ b/Documentation/devicetree/bindings/iio/proximity/sx9311.txt
@@ -0,0 +1,19 @@
+Semtech's SX9311 capacitive proximity device driver
+
+Required properties:
+	- compatible: must be "semtech,sx9311"
+	- reg: i2c address where to find the device
+	- interrupts : the sole interrupt generated by the device
+
+	Refer to interrupt-controller/interrupts.txt for generic
+	interrupt client node bindings.
+
+Example:
+
+sx9311@28 {
+		compatible = "semtech,sx9311";
+		reg = <0x28>;
+		interrupt-parent = <&pio>;
+		interrupts = <5 IRQ_TYPE_LEVEL_LOW 5 0>;
+		int-gpio = <&pio 5 0>;
+	};
diff --git a/README b/README
index 977bc3b04f5a..7ef1f3441b8e 100644
--- a/README
+++ b/README
@@ -1,5 +1,6 @@
+HUAQIN FLAPJACK TOT
 ISP TOT
-
+MTK TOT
 Linux kernel
 ============
 
diff --git a/arch/arm64/boot/dts/mediatek/Makefile b/arch/arm64/boot/dts/mediatek/Makefile
index 3a55c454b65d..56a31a765632 100644
--- a/arch/arm64/boot/dts/mediatek/Makefile
+++ b/arch/arm64/boot/dts/mediatek/Makefile
@@ -10,3 +10,7 @@ dtb-$(CONFIG_ARCH_MEDIATEK) += mt8173-evb.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-evb.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-kukui-rev1.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-kukui-rev2.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-flapjack-rev4-sku1-hwconfig2.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-flapjack-rev4-sku1-hwconfig4.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-flapjack-rev4-sku3-hwconfig1.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-flapjack-rev4-sku3-hwconfig3.dtb
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku1-hwconfig2.dts b/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku1-hwconfig2.dts
new file mode 100755
index 000000000000..222092041d1e
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku1-hwconfig2.dts
@@ -0,0 +1,270 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/dts-v1/;
+#include "mt8183-flapjack.dtsi"
+
+/ {
+	model = "MediaTek Flapjack Rev 4 board Sku 1 BOE TV080WUM NG0";
+
+	/* SKU_ID: 0x20001 BOE_TV080WUM_NG0 for REV >=3 */
+	compatible =	"google,flapjack-rev3-sku131073",
+			"google,flapjack-rev4-sku131073",
+			"google,flapjack-sku131073",
+
+			/* SKU_ID: 0x1 for Rev 2 */
+			"google,flapjack-rev2-sku1",
+
+			/* SKU_ID: 0x50001 Panel Unknown */
+			"google,flapjack-rev2-sku327681",
+			"google,flapjack-rev3-sku327681",
+			"google,flapjack-rev4-sku327681",
+			"google,flapjack-sku327681",
+
+			"google,flapjack-rev2",
+			"google,flapjack-rev3",
+			"google,flapjack-rev4",
+			"google,flapjack",
+			"google,kukui", "mediatek,mt8183";
+};
+
+&dsi0 {
+	/delete-node/ panel@0;
+	panel: panel@0 {
+		compatible = "boe,tv080wum_ng0";
+		reg = <0>;
+		enable-gpios = <&pio 45 0>;
+		pp33-gpios = <&pio 35 0>;
+		pp18-gpios = <&pio 36 0>;
+		pinctrl-names = "default", "state_3300mv", "state_1800mv";
+		pinctrl-0 = <&panel_pins_default>;
+		pinctrl-1 = <&panel_pins_3300mv>;
+		pinctrl-2 = <&panel_pins_1800mv>;
+		backlight = <&backlight_lcd0>;
+		status = "okay";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&pio {
+	/* 192 lines */
+	gpio-line-names =
+		"SPI_AP_EC_CS_L",
+		"SPI_AP_EC_MOSI",
+		"SPI_AP_EC_CLK",
+		"I2S3_DO",
+		"USB_PD_INT_ODL",
+		"",
+		"",
+		"",
+		"",
+		"IT6505_HPD_L",
+		"I2S3_TDM_D3",
+		"SOC_I2C6_1V8_SCL",
+		"SOC_I2C6_1V8_SDA",
+		"DPI_D0",
+		"DPI_D1",
+		"DPI_D2",
+		"DPI_D3",
+		"DPI_D4",
+		"DPI_D5",
+		"DPI_D6",
+		"DPI_D7",
+		"DPI_D8",
+		"DPI_D9",
+		"DPI_D10",
+		"DPI_D11",
+		"DPI_HSYNC",
+		"DPI_VSYNC",
+		"DPI_DE",
+		"DPI_CK",
+		"AP_MSDC1_CLK",
+		"AP_MSDC1_DAT3",
+		"AP_MSDC1_CMD",
+		"AP_MSDC1_DAT0",
+		"AP_MSDC1_DAT2",
+		"AP_MSDC1_DAT1",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"OTG_EN",
+		"DRVBUS",
+		"DISP_PWM",
+		"DSI_TE",
+		"LCM_RST_1V8",
+		"AP_CTS_WIFI_RTS",
+		"AP_RTS_WIFI_CTS",
+		"SOC_I2C5_1V8_SCL",
+		"SOC_I2C5_1V8_SDA",
+		"SOC_I2C3_1V8_SCL",
+		"SOC_I2C3_1V8_SDA",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"SOC_I2C1_1V8_SDA",
+		"SOC_I2C0_1V8_SDA",
+		"SOC_I2C0_1V8_SCL",
+		"SOC_I2C1_1V8_SCL",
+		"AP_SPI_H1_MISO",
+		"AP_SPI_H1_CS_L",
+		"AP_SPI_H1_MOSI",
+		"AP_SPI_H1_CLK",
+		"I2S5_BCK",
+		"I2S5_LRCK",
+		"I2S5_DO",
+		"BOOTBLOCK_EN_L",
+		"MT8183_KPCOL0",
+		"SPI_AP_EC_MISO",
+		"UART_DBG_TX_AP_RX",
+		"UART_AP_TX_DBG_RX",
+		"I2S2_MCK",
+		"I2S2_BCK",
+		"CLK_5M_WCAM",
+		"CLK_2M_UCAM",
+		"I2S2_LRCK",
+		"I2S2_DI",
+		"SOC_I2C2_1V8_SCL",
+		"SOC_I2C2_1V8_SDA",
+		"SOC_I2C4_1V8_SCL",
+		"SOC_I2C4_1V8_SDA",
+		"",
+		"SCL8",
+		"SDA8",
+		"FCAM_PWDN_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		/*
+		 * AP_FLASH_WP_L is crossystem ABI. Rev1 schematics
+		 * call it BIOS_FLASH_WP_R_L.
+		 */
+		"AP_FLASH_WP_L",
+		"EC_AP_INT_ODL",
+		"IT6505_INT_ODL",
+		"H1_INT_OD_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"AP_SPI_FLASH_MISO",
+		"AP_SPI_FLASH_CS_L",
+		"AP_SPI_FLASH_MOSI",
+		"AP_SPI_FLASH_CLK",
+		"DA7219_IRQ",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"";
+};
+
+&scp_pins {
+	/* EINT pins are used for other purpose on rev2. */
+	/delete-node/ pins_eint;
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku1-hwconfig4.dts b/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku1-hwconfig4.dts
new file mode 100755
index 000000000000..55109dcf6bfd
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku1-hwconfig4.dts
@@ -0,0 +1,260 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/dts-v1/;
+#include "mt8183-flapjack.dtsi"
+
+/ {
+	model = "MediaTek Flapjack Rev 4 board Sku 1 AUO NT51021D8P";
+
+	/* SKU_ID: 0x40001 AUO_NT51021D8P for REV >=3 */
+	compatible =	"google,flapjack-rev3-sku262145",
+			"google,flapjack-rev4-sku262145",
+			"google,flapjack-sku262145",
+
+			"google,flapjack-rev3",
+			"google,flapjack-rev4",
+			"google,flapjack",
+			"google,kukui", "mediatek,mt8183";
+};
+
+&dsi0 {
+	/delete-node/ panel@0;
+	panel: panel@0 {
+		compatible = "auo,nt51021d8p";
+		reg = <0>;
+		enable-gpios = <&pio 45 0>;
+		pp33-gpios = <&pio 35 0>;
+		pp18-gpios = <&pio 36 0>;
+		pinctrl-names = "default", "state_3300mv", "state_1800mv";
+		pinctrl-0 = <&panel_pins_default>;
+		pinctrl-1 = <&panel_pins_3300mv>;
+		pinctrl-2 = <&panel_pins_1800mv>;
+		backlight = <&backlight_lcd0>;
+		status = "okay";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&pio {
+	/* 192 lines */
+	gpio-line-names =
+		"SPI_AP_EC_CS_L",
+		"SPI_AP_EC_MOSI",
+		"SPI_AP_EC_CLK",
+		"I2S3_DO",
+		"USB_PD_INT_ODL",
+		"",
+		"",
+		"",
+		"",
+		"IT6505_HPD_L",
+		"I2S3_TDM_D3",
+		"SOC_I2C6_1V8_SCL",
+		"SOC_I2C6_1V8_SDA",
+		"DPI_D0",
+		"DPI_D1",
+		"DPI_D2",
+		"DPI_D3",
+		"DPI_D4",
+		"DPI_D5",
+		"DPI_D6",
+		"DPI_D7",
+		"DPI_D8",
+		"DPI_D9",
+		"DPI_D10",
+		"DPI_D11",
+		"DPI_HSYNC",
+		"DPI_VSYNC",
+		"DPI_DE",
+		"DPI_CK",
+		"AP_MSDC1_CLK",
+		"AP_MSDC1_DAT3",
+		"AP_MSDC1_CMD",
+		"AP_MSDC1_DAT0",
+		"AP_MSDC1_DAT2",
+		"AP_MSDC1_DAT1",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"OTG_EN",
+		"DRVBUS",
+		"DISP_PWM",
+		"DSI_TE",
+		"LCM_RST_1V8",
+		"AP_CTS_WIFI_RTS",
+		"AP_RTS_WIFI_CTS",
+		"SOC_I2C5_1V8_SCL",
+		"SOC_I2C5_1V8_SDA",
+		"SOC_I2C3_1V8_SCL",
+		"SOC_I2C3_1V8_SDA",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"SOC_I2C1_1V8_SDA",
+		"SOC_I2C0_1V8_SDA",
+		"SOC_I2C0_1V8_SCL",
+		"SOC_I2C1_1V8_SCL",
+		"AP_SPI_H1_MISO",
+		"AP_SPI_H1_CS_L",
+		"AP_SPI_H1_MOSI",
+		"AP_SPI_H1_CLK",
+		"I2S5_BCK",
+		"I2S5_LRCK",
+		"I2S5_DO",
+		"BOOTBLOCK_EN_L",
+		"MT8183_KPCOL0",
+		"SPI_AP_EC_MISO",
+		"UART_DBG_TX_AP_RX",
+		"UART_AP_TX_DBG_RX",
+		"I2S2_MCK",
+		"I2S2_BCK",
+		"CLK_5M_WCAM",
+		"CLK_2M_UCAM",
+		"I2S2_LRCK",
+		"I2S2_DI",
+		"SOC_I2C2_1V8_SCL",
+		"SOC_I2C2_1V8_SDA",
+		"SOC_I2C4_1V8_SCL",
+		"SOC_I2C4_1V8_SDA",
+		"",
+		"SCL8",
+		"SDA8",
+		"FCAM_PWDN_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		/*
+		 * AP_FLASH_WP_L is crossystem ABI. Rev1 schematics
+		 * call it BIOS_FLASH_WP_R_L.
+		 */
+		"AP_FLASH_WP_L",
+		"EC_AP_INT_ODL",
+		"IT6505_INT_ODL",
+		"H1_INT_OD_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"AP_SPI_FLASH_MISO",
+		"AP_SPI_FLASH_CS_L",
+		"AP_SPI_FLASH_MOSI",
+		"AP_SPI_FLASH_CLK",
+		"DA7219_IRQ",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"";
+};
+
+&scp_pins {
+	/* EINT pins are used for other purpose on rev2. */
+	/delete-node/ pins_eint;
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku3-hwconfig1.dts b/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku3-hwconfig1.dts
new file mode 100755
index 000000000000..f003a0c1f181
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku3-hwconfig1.dts
@@ -0,0 +1,272 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ *
+ * Device Tree Source for the Google flapjack board
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/dts-v1/;
+#include "mt8183-flapjack.dtsi"
+
+/ {
+	model = "MediaTek Flapjack Rev 4 board Sku 3 BOE TV101WUM NG0";
+
+	/* SKU_ID: 0x10003 BOE_TV101WUM_NG0 for REV >=3 */
+	compatible =	"google,flapjack-rev3-sku65539",
+			"google,flapjack-rev4-sku65539",
+			"google,flapjack-sku65539",
+
+			/* SKU_ID: 0x3 for Rev 2 */
+			"google,flapjack-rev2-sku3",
+
+			/* SKU_ID: 0x50003 Panel Unknown */
+			"google,flapjack-rev2-sku327683",
+			"google,flapjack-rev3-sku327683",
+			"google,flapjack-rev4-sku327683",
+			"google,flapjack-sku327683",
+
+			"google,flapjack-rev2",
+			"google,flapjack-rev3",
+			"google,flapjack-rev4",
+			"google,flapjack",
+			"google,kukui", "mediatek,mt8183";
+};
+
+&dsi0 {
+	/delete-node/ panel@0;
+	panel: panel@0 {
+		compatible = "boe,tv101wum_ng0";
+		reg = <0>;
+		enable-gpios = <&pio 45 0>;
+		pp33-gpios = <&pio 35 0>;
+		pp18-gpios = <&pio 36 0>;
+		pinctrl-names = "default", "state_3300mv", "state_1800mv";
+		pinctrl-0 = <&panel_pins_default>;
+		pinctrl-1 = <&panel_pins_3300mv>;
+		pinctrl-2 = <&panel_pins_1800mv>;
+		backlight = <&backlight_lcd0>;
+		status = "okay";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&pio {
+	/* 192 lines */
+	gpio-line-names =
+		"SPI_AP_EC_CS_L",
+		"SPI_AP_EC_MOSI",
+		"SPI_AP_EC_CLK",
+		"I2S3_DO",
+		"USB_PD_INT_ODL",
+		"",
+		"",
+		"",
+		"",
+		"IT6505_HPD_L",
+		"I2S3_TDM_D3",
+		"SOC_I2C6_1V8_SCL",
+		"SOC_I2C6_1V8_SDA",
+		"DPI_D0",
+		"DPI_D1",
+		"DPI_D2",
+		"DPI_D3",
+		"DPI_D4",
+		"DPI_D5",
+		"DPI_D6",
+		"DPI_D7",
+		"DPI_D8",
+		"DPI_D9",
+		"DPI_D10",
+		"DPI_D11",
+		"DPI_HSYNC",
+		"DPI_VSYNC",
+		"DPI_DE",
+		"DPI_CK",
+		"AP_MSDC1_CLK",
+		"AP_MSDC1_DAT3",
+		"AP_MSDC1_CMD",
+		"AP_MSDC1_DAT0",
+		"AP_MSDC1_DAT2",
+		"AP_MSDC1_DAT1",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"OTG_EN",
+		"DRVBUS",
+		"DISP_PWM",
+		"DSI_TE",
+		"LCM_RST_1V8",
+		"AP_CTS_WIFI_RTS",
+		"AP_RTS_WIFI_CTS",
+		"SOC_I2C5_1V8_SCL",
+		"SOC_I2C5_1V8_SDA",
+		"SOC_I2C3_1V8_SCL",
+		"SOC_I2C3_1V8_SDA",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"SOC_I2C1_1V8_SDA",
+		"SOC_I2C0_1V8_SDA",
+		"SOC_I2C0_1V8_SCL",
+		"SOC_I2C1_1V8_SCL",
+		"AP_SPI_H1_MISO",
+		"AP_SPI_H1_CS_L",
+		"AP_SPI_H1_MOSI",
+		"AP_SPI_H1_CLK",
+		"I2S5_BCK",
+		"I2S5_LRCK",
+		"I2S5_DO",
+		"BOOTBLOCK_EN_L",
+		"MT8183_KPCOL0",
+		"SPI_AP_EC_MISO",
+		"UART_DBG_TX_AP_RX",
+		"UART_AP_TX_DBG_RX",
+		"I2S2_MCK",
+		"I2S2_BCK",
+		"CLK_5M_WCAM",
+		"CLK_2M_UCAM",
+		"I2S2_LRCK",
+		"I2S2_DI",
+		"SOC_I2C2_1V8_SCL",
+		"SOC_I2C2_1V8_SDA",
+		"SOC_I2C4_1V8_SCL",
+		"SOC_I2C4_1V8_SDA",
+		"",
+		"SCL8",
+		"SDA8",
+		"FCAM_PWDN_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		/*
+		 * AP_FLASH_WP_L is crossystem ABI. Rev1 schematics
+		 * call it BIOS_FLASH_WP_R_L.
+		 */
+		"AP_FLASH_WP_L",
+		"EC_AP_INT_ODL",
+		"IT6505_INT_ODL",
+		"H1_INT_OD_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"AP_SPI_FLASH_MISO",
+		"AP_SPI_FLASH_CS_L",
+		"AP_SPI_FLASH_MOSI",
+		"AP_SPI_FLASH_CLK",
+		"DA7219_IRQ",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"";
+};
+
+&scp_pins {
+	/* EINT pins are used for other purpose on rev2. */
+	/delete-node/ pins_eint;
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku3-hwconfig3.dts b/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku3-hwconfig3.dts
new file mode 100755
index 000000000000..ea40b3fc04e6
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev4-sku3-hwconfig3.dts
@@ -0,0 +1,262 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ *
+ * Device Tree Source for the Google flapjack board
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/dts-v1/;
+#include "mt8183-flapjack.dtsi"
+
+/ {
+	model = "MediaTek Flapjack Rev 3 board Sku 3 INX OTA7290D10P";
+	/* SKU_ID: 0x30003 INX OTA7290D10 for REV >=3 */
+	compatible =	"google,flapjack-rev3-sku196611",
+			"google,flapjack-rev4-sku196611",
+			"google,flapjack-sku196611",
+
+
+			"google,flapjack-rev3",
+			"google,flapjack-rev4",
+			"google,flapjack",
+			"google,kukui", "mediatek,mt8183";
+};
+
+&dsi0 {
+	/delete-node/ panel@0;
+	panel: panel@0 {
+		compatible = "inx,ota7290d10p";
+		reg = <0>;
+		enable-gpios = <&pio 45 0>;
+		pp33-gpios = <&pio 35 0>;
+		pp18-gpios = <&pio 36 0>;
+		pinctrl-names = "default", "state_3300mv", "state_1800mv";
+		pinctrl-0 = <&panel_pins_default>;
+		pinctrl-1 = <&panel_pins_3300mv>;
+		pinctrl-2 = <&panel_pins_1800mv>;
+		backlight = <&backlight_lcd0>;
+		status = "okay";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&pio {
+	/* 192 lines */
+	gpio-line-names =
+		"SPI_AP_EC_CS_L",
+		"SPI_AP_EC_MOSI",
+		"SPI_AP_EC_CLK",
+		"I2S3_DO",
+		"USB_PD_INT_ODL",
+		"",
+		"",
+		"",
+		"",
+		"IT6505_HPD_L",
+		"I2S3_TDM_D3",
+		"SOC_I2C6_1V8_SCL",
+		"SOC_I2C6_1V8_SDA",
+		"DPI_D0",
+		"DPI_D1",
+		"DPI_D2",
+		"DPI_D3",
+		"DPI_D4",
+		"DPI_D5",
+		"DPI_D6",
+		"DPI_D7",
+		"DPI_D8",
+		"DPI_D9",
+		"DPI_D10",
+		"DPI_D11",
+		"DPI_HSYNC",
+		"DPI_VSYNC",
+		"DPI_DE",
+		"DPI_CK",
+		"AP_MSDC1_CLK",
+		"AP_MSDC1_DAT3",
+		"AP_MSDC1_CMD",
+		"AP_MSDC1_DAT0",
+		"AP_MSDC1_DAT2",
+		"AP_MSDC1_DAT1",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"OTG_EN",
+		"DRVBUS",
+		"DISP_PWM",
+		"DSI_TE",
+		"LCM_RST_1V8",
+		"AP_CTS_WIFI_RTS",
+		"AP_RTS_WIFI_CTS",
+		"SOC_I2C5_1V8_SCL",
+		"SOC_I2C5_1V8_SDA",
+		"SOC_I2C3_1V8_SCL",
+		"SOC_I2C3_1V8_SDA",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"SOC_I2C1_1V8_SDA",
+		"SOC_I2C0_1V8_SDA",
+		"SOC_I2C0_1V8_SCL",
+		"SOC_I2C1_1V8_SCL",
+		"AP_SPI_H1_MISO",
+		"AP_SPI_H1_CS_L",
+		"AP_SPI_H1_MOSI",
+		"AP_SPI_H1_CLK",
+		"I2S5_BCK",
+		"I2S5_LRCK",
+		"I2S5_DO",
+		"BOOTBLOCK_EN_L",
+		"MT8183_KPCOL0",
+		"SPI_AP_EC_MISO",
+		"UART_DBG_TX_AP_RX",
+		"UART_AP_TX_DBG_RX",
+		"I2S2_MCK",
+		"I2S2_BCK",
+		"CLK_5M_WCAM",
+		"CLK_2M_UCAM",
+		"I2S2_LRCK",
+		"I2S2_DI",
+		"SOC_I2C2_1V8_SCL",
+		"SOC_I2C2_1V8_SDA",
+		"SOC_I2C4_1V8_SCL",
+		"SOC_I2C4_1V8_SDA",
+		"",
+		"SCL8",
+		"SDA8",
+		"FCAM_PWDN_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		/*
+		 * AP_FLASH_WP_L is crossystem ABI. Rev1 schematics
+		 * call it BIOS_FLASH_WP_R_L.
+		 */
+		"AP_FLASH_WP_L",
+		"EC_AP_INT_ODL",
+		"IT6505_INT_ODL",
+		"H1_INT_OD_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"AP_SPI_FLASH_MISO",
+		"AP_SPI_FLASH_CS_L",
+		"AP_SPI_FLASH_MOSI",
+		"AP_SPI_FLASH_CLK",
+		"DA7219_IRQ",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"";
+};
+
+&scp_pins {
+	/* EINT pins are used for other purpose on rev2. */
+	/delete-node/ pins_eint;
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-flapjack.dtsi b/arch/arm64/boot/dts/mediatek/mt8183-flapjack.dtsi
new file mode 100644
index 000000000000..4ccd2c91db5c
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-flapjack.dtsi
@@ -0,0 +1,141 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ *
+ * Device Tree Source for the Google flapjack board
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "mt8183-kukui.dtsi"
+
+/ {
+	/delete-node/ mt8183-mt6358-ts3a227e-max98357a;
+
+	sound: mt8183-da7219-max98357a {
+		compatible = "mediatek,mt8183_da7219_max98357";
+		mediatek,platform = <&afe>;
+		mediatek,headset-codec = <&da7219>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&aud_pins>;
+		status = "okay";
+	};
+};
+
+&i2c0 {
+	/delete-node/ digitizer@9;
+	/delete-node/ touchscreen@10;
+
+	touchscreen@0a {
+		compatible = "hid-over-i2c";
+		reg = <0x0a>;
+		interrupt-parent = <&pio>;
+		interrupts = <155 IRQ_TYPE_LEVEL_LOW 155>;
+		int-gpio = <&pio 155 0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&touch_default>;
+		hid-descr-addr = <0x1>;
+		wakeup-source;
+	};
+};
+
+&i2c1 {
+	sx9311@28 {
+		compatible = "semtech,sx9311";
+		reg = <0x28>;
+		interrupt-parent = <&pio>;
+		interrupts = <5 IRQ_TYPE_LEVEL_LOW 5>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&sx9311_pins>;
+	};
+};
+
+&i2c5 {
+	/delete-node/ ts3a227e@3b;
+	da7219: da7219@1a {
+		pinctrl-names = "default";
+		pinctrl-0 = <&da7219_pins>;
+		compatible = "dlg,da7219";
+		reg = <0x1a>;
+		interrupt-parent = <&pio>;
+		interrupts = <165 IRQ_TYPE_LEVEL_LOW 165>;
+
+		dlg,micbias-lvl = <2600>;
+		dlg,mic-amp-in-sel = "diff";
+
+		da7219_aad {
+			dlg,adc-1bit-rpt = <1>;
+			dlg,btn-avg = <4>;
+			dlg,btn-cfg = <50>;
+			dlg,mic-det-thr = <500>;
+			dlg,jack-ins-deb = <20>;
+			dlg,jack-det-rate = "32ms_64ms";
+			dlg,jack-rem-deb = <1>;
+
+			dlg,a-d-btn-thr = <0xa>;
+			dlg,d-b-btn-thr = <0x16>;
+			dlg,b-c-btn-thr = <0x21>;
+			dlg,c-mic-btn-thr = <0x3E>;
+		};
+	};
+};
+
+&pio {
+	/delete-node/ ts3a227e_pins;
+
+	da7219_pins: da7219_pins {
+		pins1 {
+			pinmux = <PINMUX_GPIO165__FUNC_GPIO165>;
+			input-enable;
+			bias-enable;
+			bias-pull-up;
+		};
+	};
+
+	panel_pins_1800mv: panel_pins_1800mv {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO36__FUNC_GPIO36>;
+			output-low;
+			bias-pull-up;
+		};
+	};
+
+	panel_pins_3300mv: panel_pins_3300mv {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO35__FUNC_GPIO35>;
+			output-low;
+			bias-pull-up;
+		};
+	};
+
+	/delete-node/ touchdefault;
+	touch_default: touchdefault {
+		pin_irq {
+			pinmux = <PINMUX_GPIO155__FUNC_GPIO155>;
+			input-enable;
+			bias-pull-up;
+		};
+
+		touch_pin_reset: pin_reset {
+			pinmux = <PINMUX_GPIO156__FUNC_GPIO156>;
+			output-low;
+		};
+	};
+
+	sx9311_pins: sx9311_pins {
+		pins_eint {
+			pinmux = <PINMUX_GPIO5__FUNC_GPIO5>;
+			input-enable;
+			bias-pull-up;
+		};
+	};
+};
+
diff --git a/chromeos/config/arm64/chromiumos-arm64.flavour.config b/chromeos/config/arm64/chromiumos-arm64.flavour.config
index 065254f44892..c3ed47888fbc 100644
--- a/chromeos/config/arm64/chromiumos-arm64.flavour.config
+++ b/chromeos/config/arm64/chromiumos-arm64.flavour.config
@@ -903,7 +903,7 @@ CONFIG_SND_SOC_MT8173_RT5650=y
 CONFIG_SND_SOC_MT8173_RT5650_RT5514=y
 CONFIG_SND_SOC_MT8173_RT5650_RT5676=y
 CONFIG_SND_SOC_MT8183=y
-# CONFIG_SND_SOC_MT8183_DA7219_MAX98357A is not set
+CONFIG_SND_SOC_MT8183_DA7219_MAX98357A=y
 CONFIG_SND_SOC_MT8183_MT6358_TS3A227E_MAX98357A=y
 # CONFIG_SND_SOC_QCOM is not set
 # CONFIG_SND_SOC_RK3288_HDMI_ANALOG is not set
diff --git a/chromeos/config/arm64/chromiumos-mediatek.flavour.config b/chromeos/config/arm64/chromiumos-mediatek.flavour.config
index 1dec1fdc2932..8a2e7692450c 100644
--- a/chromeos/config/arm64/chromiumos-mediatek.flavour.config
+++ b/chromeos/config/arm64/chromiumos-mediatek.flavour.config
@@ -67,7 +67,7 @@ CONFIG_DRM_GEM_CMA_HELPER=y
 CONFIG_DRM_MEDIATEK=y
 CONFIG_DRM_MEDIATEK_HDMI=y
 CONFIG_DRM_MIPI_DSI=y
-# CONFIG_DRM_PANEL_BOE_HIMAX8279D is not set
+CONFIG_DRM_PANEL_BOE_HIMAX8279D=y
 # CONFIG_DRM_PANEL_ILITEK_ILI9881C is not set
 CONFIG_DRM_PANEL_INNOLUX_P079ZCA=y
 # CONFIG_DRM_PANEL_JDI_LT070ME05000 is not set
@@ -226,7 +226,7 @@ CONFIG_SND_SOC_MT8173_RT5650=y
 CONFIG_SND_SOC_MT8173_RT5650_RT5514=y
 CONFIG_SND_SOC_MT8173_RT5650_RT5676=y
 CONFIG_SND_SOC_MT8183=y
-# CONFIG_SND_SOC_MT8183_DA7219_MAX98357A is not set
+CONFIG_SND_SOC_MT8183_DA7219_MAX98357A=y
 CONFIG_SND_SOC_MT8183_MT6358_TS3A227E_MAX98357A=y
 CONFIG_SND_SOC_RL6231=y
 CONFIG_SND_SOC_RT5514=y
@@ -302,3 +302,4 @@ CONFIG_VIRTIO=y
 # CONFIG_VIRTIO_MMIO is not set
 # CONFIG_VIRTIO_NET is not set
 # CONFIG_VIRTIO_WL is not set
+CONFIG_SX9311=y
diff --git a/drivers/gpu/drm/mediatek/mtk_disp_ovl.c b/drivers/gpu/drm/mediatek/mtk_disp_ovl.c
index ebadcfed3a0a..c92f0e6d5387 100644
--- a/drivers/gpu/drm/mediatek/mtk_disp_ovl.c
+++ b/drivers/gpu/drm/mediatek/mtk_disp_ovl.c
@@ -32,6 +32,8 @@
 #define DISP_REG_OVL_ROI_BGCLR			0x0028
 #define DISP_REG_OVL_SRC_CON			0x002c
 #define DISP_REG_OVL_CON(n)			(0x0030 + 0x20 * (n))
+#define DISP_REG_OVL_V_FLIP_EN			BIT(9)
+#define DISP_REG_OVL_H_FLIP_EN			BIT(10)
 #define DISP_REG_OVL_SRC_SIZE(n)		(0x0038 + 0x20 * (n))
 #define DISP_REG_OVL_OFFSET(n)			(0x003c + 0x20 * (n))
 #define DISP_REG_OVL_PITCH(n)			(0x0044 + 0x20 * (n))
@@ -218,6 +220,7 @@ static unsigned int ovl_fmt_convert(struct mtk_disp_ovl *ovl, unsigned int fmt)
 	}
 }
 
+static int ovl_rotate_180 = 1;
 static void mtk_ovl_layer_config(struct mtk_ddp_comp *comp, unsigned int idx,
 				 struct mtk_plane_state *state)
 {
@@ -229,6 +232,13 @@ static void mtk_ovl_layer_config(struct mtk_ddp_comp *comp, unsigned int idx,
 	unsigned int offset = (pending->y << 16) | pending->x;
 	unsigned int src_size = (pending->height << 16) | pending->width;
 	unsigned int con;
+	unsigned int bpp = drm_format_plane_cpp(fmt, 0);
+
+	DRM_DEBUG_DRIVER(
+	"layer %d enable %d fmt 0x%x (%X %X %X %X) pitch %X addr 0x%X bpp %d\n",
+	idx, pending->enable, fmt,
+	pending->x, pending->y, pending->width, pending->height, pitch,
+	pending->addr, bpp);
 
 	if (!pending->enable)
 		mtk_ovl_layer_off(comp, idx);
@@ -236,6 +246,11 @@ static void mtk_ovl_layer_config(struct mtk_ddp_comp *comp, unsigned int idx,
 	con = ovl_fmt_convert(ovl, fmt);
 	if (idx != 0)
 		con |= OVL_CON_AEN | OVL_CON_ALPHA;
+	if (ovl_rotate_180) {
+		con |= (DISP_REG_OVL_V_FLIP_EN | DISP_REG_OVL_H_FLIP_EN);
+		addr += (pitch*pending->height -
+			(pitch - pending->width * bpp) - 1);
+	}
 
 	writel_relaxed(con, comp->regs + DISP_REG_OVL_CON(idx));
 	writel_relaxed(pitch, comp->regs + DISP_REG_OVL_PITCH(idx));
diff --git a/drivers/gpu/drm/panel/panel-boe-himax8279d.c b/drivers/gpu/drm/panel/panel-boe-himax8279d.c
index ff5a89e38fd7..722b65c222ce 100644
--- a/drivers/gpu/drm/panel/panel-boe-himax8279d.c
+++ b/drivers/gpu/drm/panel/panel-boe-himax8279d.c
@@ -587,6 +587,294 @@ static const struct panel_desc boe_himax8279d8p_panel_desc = {
 	.off_cmds = default_off_cmds,
 };
 
+/* 8 inch Positive scanning*/
+static const struct panel_cmd boe_tv080wumng0_on_cmds[] = {
+	_INIT_CMD(0x22, 0x10),
+	_INIT_CMD(0x00, 0xB0, 0x05),
+	_INIT_CMD(0x00, 0xB1, 0xE5),
+	_INIT_CMD(0x00, 0xB3, 0x52),
+	_INIT_CMD(0x00, 0xB0, 0x00),
+	_INIT_CMD(0x00, 0xB3, 0x88),
+	_INIT_CMD(0x00, 0xB0, 0x04),
+	_INIT_CMD(0x00, 0xB8, 0x00),
+	_INIT_CMD(0x00, 0xB0, 0x00),
+	_INIT_CMD(0x00, 0xB1, 0x00),
+	_INIT_CMD(0x00, 0xB6, 0x03),
+	_INIT_CMD(0x00, 0xBA, 0x8B),
+	_INIT_CMD(0x00, 0xBF, 0x15),
+	_INIT_CMD(0x00, 0xC0, 0x0F),
+	_INIT_CMD(0x00, 0xC2, 0x14),
+	_INIT_CMD(0x00, 0xC3, 0x02),
+	_INIT_CMD(0x00, 0xC4, 0x14),
+	_INIT_CMD(0x00, 0xC5, 0x02),
+	_INIT_CMD(0x00, 0xB0, 0x01),
+	_INIT_CMD(0x00, 0xCC, 0x26),
+	_INIT_CMD(0x00, 0xCD, 0x26),
+	_INIT_CMD(0x00, 0xCE, 0x26),
+	_INIT_CMD(0x00, 0xCF, 0x26),
+	_INIT_CMD(0x00, 0xE0, 0x26),
+	_INIT_CMD(0x00, 0xE1, 0x26),
+	_INIT_CMD(0x00, 0xE2, 0x26),
+	_INIT_CMD(0x00, 0xE3, 0x26),
+	_INIT_CMD(0x00, 0xB0, 0x03),
+	_INIT_CMD(0x00, 0xC8, 0x0D),
+	_INIT_CMD(0x00, 0xC9, 0x0B),
+	_INIT_CMD(0x00, 0xC3, 0x2A),
+	_INIT_CMD(0x00, 0xE7, 0x2A),
+	_INIT_CMD(0x00, 0xC5, 0x2A),
+	_INIT_CMD(0x00, 0xDE, 0x2A),
+	_INIT_CMD(0x00, 0xB0, 0x06),
+	_INIT_CMD(0x00, 0xC0, 0xA5),
+	_INIT_CMD(0x00, 0xD5, 0x20),
+	_INIT_CMD(0x00, 0xB0, 0x02),
+	_INIT_CMD(0x00, 0xC0, 0x00),
+	_INIT_CMD(0x00, 0xC1, 0x0F),
+	_INIT_CMD(0x00, 0xC2, 0x1C),
+	_INIT_CMD(0x00, 0xC3, 0x2D),
+	_INIT_CMD(0x00, 0xC4, 0x3A),
+	_INIT_CMD(0x00, 0xC5, 0x38),
+	_INIT_CMD(0x00, 0xC6, 0x3A),
+	_INIT_CMD(0x00, 0xC7, 0x3C),
+	_INIT_CMD(0x00, 0xC8, 0x3C),
+	_INIT_CMD(0x00, 0xC9, 0x3A),
+	_INIT_CMD(0x00, 0xCA, 0x3B),
+	_INIT_CMD(0x00, 0xCB, 0x3B),
+	_INIT_CMD(0x00, 0xCC, 0x3D),
+	_INIT_CMD(0x00, 0xCD, 0x2F),
+	_INIT_CMD(0x00, 0xCE, 0x2F),
+	_INIT_CMD(0x00, 0xCF, 0x2F),
+	_INIT_CMD(0x00, 0xD0, 0x07),
+	_INIT_CMD(0x00, 0xD2, 0x00),
+	_INIT_CMD(0x00, 0xD3, 0x0F),
+	_INIT_CMD(0x00, 0xD4, 0x18),
+	_INIT_CMD(0x00, 0xD5, 0x29),
+	_INIT_CMD(0x00, 0xD6, 0x36),
+	_INIT_CMD(0x00, 0xD7, 0x37),
+	_INIT_CMD(0x00, 0xD8, 0x36),
+	_INIT_CMD(0x00, 0xD9, 0x38),
+	_INIT_CMD(0x00, 0xDA, 0x38),
+	_INIT_CMD(0x00, 0xDB, 0x36),
+	_INIT_CMD(0x00, 0xDC, 0x37),
+	_INIT_CMD(0x00, 0xDD, 0x36),
+	_INIT_CMD(0x00, 0xDE, 0x39),
+	_INIT_CMD(0x00, 0xDF, 0x2F),
+	_INIT_CMD(0x00, 0xE0, 0x2F),
+	_INIT_CMD(0x00, 0xE1, 0x2F),
+	_INIT_CMD(0x00, 0xE2, 0x07),
+	_INIT_CMD(0x00, 0xB0, 0x07),
+	_INIT_CMD(0x00, 0xB1, 0x08),
+	_INIT_CMD(0x00, 0xB2, 0x09),
+	_INIT_CMD(0x00, 0xB3, 0x14),
+	_INIT_CMD(0x00, 0xB4, 0x25),
+	_INIT_CMD(0x00, 0xB5, 0x39),
+	_INIT_CMD(0x00, 0xB6, 0x52),
+	_INIT_CMD(0x00, 0xB7, 0x82),
+	_INIT_CMD(0x00, 0xB8, 0xBC),
+	_INIT_CMD(0x00, 0xB9, 0x33),
+	_INIT_CMD(0x00, 0xBA, 0x99),
+	_INIT_CMD(0x00, 0xBB, 0x3F),
+	_INIT_CMD(0x00, 0xBC, 0xB4),
+	_INIT_CMD(0x00, 0xBD, 0xB7),
+	_INIT_CMD(0x00, 0xBE, 0x16),
+	_INIT_CMD(0x00, 0xBF, 0x6F),
+	_INIT_CMD(0x00, 0xC0, 0x97),
+	_INIT_CMD(0x00, 0xC1, 0xBD),
+	_INIT_CMD(0x00, 0xC2, 0xD0),
+	_INIT_CMD(0x00, 0xC3, 0xE1),
+	_INIT_CMD(0x00, 0xC4, 0xE9),
+	_INIT_CMD(0x00, 0xC5, 0xF1),
+	_INIT_CMD(0x00, 0xC6, 0xF8),
+	_INIT_CMD(0x00, 0xC7, 0xFA),
+	_INIT_CMD(0x00, 0xC8, 0xFC),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x5A),
+	_INIT_CMD(0x00, 0xCC, 0xBF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x08),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x07),
+	_INIT_CMD(0x00, 0xB3, 0x13),
+	_INIT_CMD(0x00, 0xB4, 0x26),
+	_INIT_CMD(0x00, 0xB5, 0x3A),
+	_INIT_CMD(0x00, 0xB6, 0x53),
+	_INIT_CMD(0x00, 0xB7, 0x85),
+	_INIT_CMD(0x00, 0xB8, 0xC0),
+	_INIT_CMD(0x00, 0xB9, 0x38),
+	_INIT_CMD(0x00, 0xBA, 0xA0),
+	_INIT_CMD(0x00, 0xBB, 0x45),
+	_INIT_CMD(0x00, 0xBC, 0xB9),
+	_INIT_CMD(0x00, 0xBD, 0xBC),
+	_INIT_CMD(0x00, 0xBE, 0x19),
+	_INIT_CMD(0x00, 0xBF, 0x72),
+	_INIT_CMD(0x00, 0xC0, 0x99),
+	_INIT_CMD(0x00, 0xC1, 0xBE),
+	_INIT_CMD(0x00, 0xC2, 0xD0),
+	_INIT_CMD(0x00, 0xC3, 0xE1),
+	_INIT_CMD(0x00, 0xC4, 0xE9),
+	_INIT_CMD(0x00, 0xC5, 0xF1),
+	_INIT_CMD(0x00, 0xC6, 0xF8),
+	_INIT_CMD(0x00, 0xC7, 0xFA),
+	_INIT_CMD(0x00, 0xC8, 0xFC),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x5A),
+	_INIT_CMD(0x00, 0xCC, 0xBF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x09),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x08),
+	_INIT_CMD(0x00, 0xB3, 0x11),
+	_INIT_CMD(0x00, 0xB4, 0x26),
+	_INIT_CMD(0x00, 0xB5, 0x3B),
+	_INIT_CMD(0x00, 0xB6, 0x54),
+	_INIT_CMD(0x00, 0xB7, 0x86),
+	_INIT_CMD(0x00, 0xB8, 0xC3),
+	_INIT_CMD(0x00, 0xB9, 0x3B),
+	_INIT_CMD(0x00, 0xBA, 0xA5),
+	_INIT_CMD(0x00, 0xBB, 0x4C),
+	_INIT_CMD(0x00, 0xBC, 0xBF),
+	_INIT_CMD(0x00, 0xBD, 0xC2),
+	_INIT_CMD(0x00, 0xBE, 0x1E),
+	_INIT_CMD(0x00, 0xBF, 0x75),
+	_INIT_CMD(0x00, 0xC0, 0x9B),
+	_INIT_CMD(0x00, 0xC1, 0xBF),
+	_INIT_CMD(0x00, 0xC2, 0xD1),
+	_INIT_CMD(0x00, 0xC3, 0xE2),
+	_INIT_CMD(0x00, 0xC4, 0xEA),
+	_INIT_CMD(0x00, 0xC5, 0xF1),
+	_INIT_CMD(0x00, 0xC6, 0xF8),
+	_INIT_CMD(0x00, 0xC7, 0xFA),
+	_INIT_CMD(0x00, 0xC8, 0xFC),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x5A),
+	_INIT_CMD(0x00, 0xCC, 0xBF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x0A),
+	_INIT_CMD(0x00, 0xB1, 0x08),
+	_INIT_CMD(0x00, 0xB2, 0x09),
+	_INIT_CMD(0x00, 0xB3, 0x14),
+	_INIT_CMD(0x00, 0xB4, 0x25),
+	_INIT_CMD(0x00, 0xB5, 0x39),
+	_INIT_CMD(0x00, 0xB6, 0x52),
+	_INIT_CMD(0x00, 0xB7, 0x82),
+	_INIT_CMD(0x00, 0xB8, 0xBC),
+	_INIT_CMD(0x00, 0xB9, 0x33),
+	_INIT_CMD(0x00, 0xBA, 0x99),
+	_INIT_CMD(0x00, 0xBB, 0x3F),
+	_INIT_CMD(0x00, 0xBC, 0xB4),
+	_INIT_CMD(0x00, 0xBD, 0xB7),
+	_INIT_CMD(0x00, 0xBE, 0x16),
+	_INIT_CMD(0x00, 0xBF, 0x6F),
+	_INIT_CMD(0x00, 0xC0, 0x97),
+	_INIT_CMD(0x00, 0xC1, 0xBD),
+	_INIT_CMD(0x00, 0xC2, 0xD0),
+	_INIT_CMD(0x00, 0xC3, 0xE1),
+	_INIT_CMD(0x00, 0xC4, 0xE9),
+	_INIT_CMD(0x00, 0xC5, 0xF1),
+	_INIT_CMD(0x00, 0xC6, 0xF8),
+	_INIT_CMD(0x00, 0xC7, 0xFA),
+	_INIT_CMD(0x00, 0xC8, 0xFC),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x5A),
+	_INIT_CMD(0x00, 0xCC, 0xBF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x0B),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x07),
+	_INIT_CMD(0x00, 0xB3, 0x13),
+	_INIT_CMD(0x00, 0xB4, 0x26),
+	_INIT_CMD(0x00, 0xB5, 0x3A),
+	_INIT_CMD(0x00, 0xB6, 0x53),
+	_INIT_CMD(0x00, 0xB7, 0x85),
+	_INIT_CMD(0x00, 0xB8, 0xC0),
+	_INIT_CMD(0x00, 0xB9, 0x38),
+	_INIT_CMD(0x00, 0xBA, 0xA0),
+	_INIT_CMD(0x00, 0xBB, 0x45),
+	_INIT_CMD(0x00, 0xBC, 0xB9),
+	_INIT_CMD(0x00, 0xBD, 0xBC),
+	_INIT_CMD(0x00, 0xBE, 0x19),
+	_INIT_CMD(0x00, 0xBF, 0x72),
+	_INIT_CMD(0x00, 0xC0, 0x99),
+	_INIT_CMD(0x00, 0xC1, 0xBE),
+	_INIT_CMD(0x00, 0xC2, 0xD0),
+	_INIT_CMD(0x00, 0xC3, 0xE1),
+	_INIT_CMD(0x00, 0xC4, 0xE9),
+	_INIT_CMD(0x00, 0xC5, 0xF1),
+	_INIT_CMD(0x00, 0xC6, 0xF8),
+	_INIT_CMD(0x00, 0xC7, 0xFA),
+	_INIT_CMD(0x00, 0xC8, 0xFC),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x5A),
+	_INIT_CMD(0x00, 0xCC, 0xBF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x0C),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x08),
+	_INIT_CMD(0x00, 0xB3, 0x11),
+	_INIT_CMD(0x00, 0xB4, 0x26),
+	_INIT_CMD(0x00, 0xB5, 0x3B),
+	_INIT_CMD(0x00, 0xB6, 0x54),
+	_INIT_CMD(0x00, 0xB7, 0x86),
+	_INIT_CMD(0x00, 0xB8, 0xC3),
+	_INIT_CMD(0x00, 0xB9, 0x3B),
+	_INIT_CMD(0x00, 0xBA, 0xA5),
+	_INIT_CMD(0x00, 0xBB, 0x4C),
+	_INIT_CMD(0x00, 0xBC, 0xBF),
+	_INIT_CMD(0x00, 0xBD, 0xC2),
+	_INIT_CMD(0x00, 0xBE, 0x1E),
+	_INIT_CMD(0x00, 0xBF, 0x75),
+	_INIT_CMD(0x00, 0xC0, 0x9B),
+	_INIT_CMD(0x00, 0xC1, 0xBF),
+	_INIT_CMD(0x00, 0xC2, 0xD1),
+	_INIT_CMD(0x00, 0xC3, 0xE2),
+	_INIT_CMD(0x00, 0xC4, 0xEA),
+	_INIT_CMD(0x00, 0xC5, 0xF1),
+	_INIT_CMD(0x00, 0xC6, 0xF8),
+	_INIT_CMD(0x00, 0xC7, 0xFA),
+	_INIT_CMD(0x00, 0xC8, 0xFC),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x5A),
+	_INIT_CMD(0x00, 0xCC, 0xBF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x64, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x00),
+	_INIT_CMD(0x00, 0xB3, 0x08),
+	_INIT_CMD(0x00, 0xB0, 0x04),
+	_INIT_CMD(0x0A, 0xB8, 0x68),
+	_INIT_CMD(0x64, 0x11),
+	_INIT_CMD(0x32, 0x29),
+
+	{},
+};
+
+static const struct panel_desc boe_tv080wumng0_panel_desc = {
+	.display_mode = &default_display_mode,
+	.bpc = 8,
+	.width_mm = 107,
+	.height_mm = 172,
+	.delay_t1 = 5000,
+	.reset_delay_t2 = 14000,
+	.reset_delay_t3 = 1000,
+	.reset_delay_t4 = 1000,
+	.reset_delay_t5 = 5000,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+	.on_cmds = boe_tv080wumng0_on_cmds,
+	.off_cmds = default_off_cmds,
+};
+
 /* 10 inch */
 static const struct panel_cmd boe_himax8279d10p_on_cmds[] = {
 	_INIT_CMD(0x00, 0xB0, 0x05),
@@ -910,11 +1198,677 @@ static const struct panel_desc boe_himax8279d10p_panel_desc = {
 	.off_cmds = default_off_cmds,
 };
 
+/* 10 inch Positive scanning*/
+static const struct panel_cmd boe_tv101wumng0_on_cmds[] = {
+	_INIT_CMD(0x00, 0xB0, 0x05),
+	_INIT_CMD(0x00, 0xB1, 0xE5),
+	_INIT_CMD(0x00, 0xB3, 0x52),
+	_INIT_CMD(0x00, 0xB0, 0x00),
+	_INIT_CMD(0x00, 0xB3, 0x88),
+	_INIT_CMD(0x00, 0xB0, 0x04),
+	_INIT_CMD(0x00, 0xB8, 0x00),
+	_INIT_CMD(0x00, 0xB0, 0x00),
+	_INIT_CMD(0x00, 0xB6, 0x03),
+	_INIT_CMD(0x00, 0xBA, 0x8B),
+	_INIT_CMD(0x00, 0xBF, 0x1A),
+	_INIT_CMD(0x00, 0xC0, 0x0F),
+	_INIT_CMD(0x00, 0xC2, 0x0C),
+	_INIT_CMD(0x00, 0xC3, 0x02),
+	_INIT_CMD(0x00, 0xC4, 0x0C),
+	_INIT_CMD(0x00, 0xC5, 0x02),
+	_INIT_CMD(0x00, 0xB0, 0x01),
+	_INIT_CMD(0x00, 0xE0, 0x26),
+	_INIT_CMD(0x00, 0xE1, 0x26),
+	_INIT_CMD(0x00, 0xDC, 0x00),
+	_INIT_CMD(0x00, 0xDD, 0x00),
+	_INIT_CMD(0x00, 0xCC, 0x26),
+	_INIT_CMD(0x00, 0xCD, 0x26),
+	_INIT_CMD(0x00, 0xC8, 0x00),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xD2, 0x03),
+	_INIT_CMD(0x00, 0xD3, 0x03),
+	_INIT_CMD(0x00, 0xE6, 0x04),
+	_INIT_CMD(0x00, 0xE7, 0x04),
+	_INIT_CMD(0x00, 0xC4, 0x09),
+	_INIT_CMD(0x00, 0xC5, 0x09),
+	_INIT_CMD(0x00, 0xD8, 0x0A),
+	_INIT_CMD(0x00, 0xD9, 0x0A),
+	_INIT_CMD(0x00, 0xC2, 0x0B),
+	_INIT_CMD(0x00, 0xC3, 0x0B),
+	_INIT_CMD(0x00, 0xD6, 0x0C),
+	_INIT_CMD(0x00, 0xD7, 0x0C),
+	_INIT_CMD(0x00, 0xC0, 0x05),
+	_INIT_CMD(0x00, 0xC1, 0x05),
+	_INIT_CMD(0x00, 0xD4, 0x06),
+	_INIT_CMD(0x00, 0xD5, 0x06),
+	_INIT_CMD(0x00, 0xCA, 0x07),
+	_INIT_CMD(0x00, 0xCB, 0x07),
+	_INIT_CMD(0x00, 0xDE, 0x08),
+	_INIT_CMD(0x00, 0xDF, 0x08),
+	_INIT_CMD(0x00, 0xB0, 0x02),
+	_INIT_CMD(0x00, 0xC0, 0x00),
+	_INIT_CMD(0x00, 0xC1, 0x07),
+	_INIT_CMD(0x00, 0xC2, 0x0D),
+	_INIT_CMD(0x00, 0xC3, 0x18),
+	_INIT_CMD(0x00, 0xC4, 0x27),
+	_INIT_CMD(0x00, 0xC5, 0x28),
+	_INIT_CMD(0x00, 0xC6, 0x30),
+	_INIT_CMD(0x00, 0xC7, 0x2E),
+	_INIT_CMD(0x00, 0xC8, 0x2F),
+	_INIT_CMD(0x00, 0xC9, 0x1A),
+	_INIT_CMD(0x00, 0xCA, 0x20),
+	_INIT_CMD(0x00, 0xCB, 0x29),
+	_INIT_CMD(0x00, 0xCC, 0x26),
+	_INIT_CMD(0x00, 0xCD, 0x32),
+	_INIT_CMD(0x00, 0xCE, 0x33),
+	_INIT_CMD(0x00, 0xCF, 0x31),
+	_INIT_CMD(0x00, 0xD0, 0x06),
+	_INIT_CMD(0x00, 0xD2, 0x00),
+	_INIT_CMD(0x00, 0xD3, 0x07),
+	_INIT_CMD(0x00, 0xD4, 0x12),
+	_INIT_CMD(0x00, 0xD5, 0x26),
+	_INIT_CMD(0x00, 0xD6, 0x3D),
+	_INIT_CMD(0x00, 0xD7, 0x3F),
+	_INIT_CMD(0x00, 0xD8, 0x3F),
+	_INIT_CMD(0x00, 0xD9, 0x3F),
+	_INIT_CMD(0x00, 0xDA, 0x3F),
+	_INIT_CMD(0x00, 0xDB, 0x3F),
+	_INIT_CMD(0x00, 0xDC, 0x3F),
+	_INIT_CMD(0x00, 0xDD, 0x3F),
+	_INIT_CMD(0x00, 0xDE, 0x3F),
+	_INIT_CMD(0x00, 0xDF, 0x3A),
+	_INIT_CMD(0x00, 0xE0, 0x37),
+	_INIT_CMD(0x00, 0xE1, 0x35),
+	_INIT_CMD(0x00, 0xE2, 0x07),
+	_INIT_CMD(0x00, 0xB0, 0x03),
+	_INIT_CMD(0x00, 0xC8, 0x0B),
+	_INIT_CMD(0x00, 0xC9, 0x07),
+	_INIT_CMD(0x00, 0xC3, 0x00),
+	_INIT_CMD(0x00, 0xE7, 0x00),
+	_INIT_CMD(0x00, 0xC5, 0x2A),
+	_INIT_CMD(0x00, 0xDE, 0x2A),
+	_INIT_CMD(0x00, 0xCA, 0x43),
+	_INIT_CMD(0x00, 0xC9, 0x07),
+	_INIT_CMD(0x00, 0xE4, 0xC0),
+	_INIT_CMD(0x00, 0xE5, 0x0D),
+	_INIT_CMD(0x00, 0xCB, 0x00),
+	_INIT_CMD(0x00, 0xB0, 0x06),
+	_INIT_CMD(0x00, 0xB8, 0xA5),
+	_INIT_CMD(0x00, 0xC0, 0xA5),
+	_INIT_CMD(0x00, 0xC7, 0x0F),
+	_INIT_CMD(0x00, 0xD5, 0x32),
+	_INIT_CMD(0x00, 0xB8, 0x00),
+	_INIT_CMD(0x00, 0xC0, 0x00),
+	_INIT_CMD(0x00, 0xBC, 0x00),
+	_INIT_CMD(0x00, 0xB0, 0x07),
+	_INIT_CMD(0x00, 0xB1, 0x00),
+	_INIT_CMD(0x00, 0xB2, 0x07),
+	_INIT_CMD(0x00, 0xB3, 0x18),
+	_INIT_CMD(0x00, 0xB4, 0x31),
+	_INIT_CMD(0x00, 0xB5, 0x47),
+	_INIT_CMD(0x00, 0xB6, 0x56),
+	_INIT_CMD(0x00, 0xB7, 0x70),
+	_INIT_CMD(0x00, 0xB8, 0x98),
+	_INIT_CMD(0x00, 0xB9, 0xDB),
+	_INIT_CMD(0x00, 0xBA, 0x2A),
+	_INIT_CMD(0x00, 0xBB, 0xAE),
+	_INIT_CMD(0x00, 0xBC, 0x39),
+	_INIT_CMD(0x00, 0xBD, 0x3D),
+	_INIT_CMD(0x00, 0xBE, 0xC6),
+	_INIT_CMD(0x00, 0xBF, 0x2A),
+	_INIT_CMD(0x00, 0xC0, 0x59),
+	_INIT_CMD(0x00, 0xC1, 0x91),
+	_INIT_CMD(0x00, 0xC2, 0xA1),
+	_INIT_CMD(0x00, 0xC3, 0xB1),
+	_INIT_CMD(0x00, 0xC4, 0xBA),
+	_INIT_CMD(0x00, 0xC5, 0xC5),
+	_INIT_CMD(0x00, 0xC6, 0xD4),
+	_INIT_CMD(0x00, 0xC7, 0xDC),
+	_INIT_CMD(0x00, 0xC8, 0xE0),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x08),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x07),
+	_INIT_CMD(0x00, 0xB3, 0x19),
+	_INIT_CMD(0x00, 0xB4, 0x32),
+	_INIT_CMD(0x00, 0xB5, 0x48),
+	_INIT_CMD(0x00, 0xB6, 0x58),
+	_INIT_CMD(0x00, 0xB7, 0x74),
+	_INIT_CMD(0x00, 0xB8, 0x9D),
+	_INIT_CMD(0x00, 0xB9, 0xE2),
+	_INIT_CMD(0x00, 0xBA, 0x34),
+	_INIT_CMD(0x00, 0xBB, 0xBB),
+	_INIT_CMD(0x00, 0xBC, 0x4A),
+	_INIT_CMD(0x00, 0xBD, 0x4F),
+	_INIT_CMD(0x00, 0xBE, 0xD5),
+	_INIT_CMD(0x00, 0xBF, 0x3C),
+	_INIT_CMD(0x00, 0xC0, 0x70),
+	_INIT_CMD(0x00, 0xC1, 0x9F),
+	_INIT_CMD(0x00, 0xC2, 0xAF),
+	_INIT_CMD(0x00, 0xC3, 0xC2),
+	_INIT_CMD(0x00, 0xC4, 0xD2),
+	_INIT_CMD(0x00, 0xC5, 0xE1),
+	_INIT_CMD(0x00, 0xC6, 0xF0),
+	_INIT_CMD(0x00, 0xC7, 0xF9),
+	_INIT_CMD(0x00, 0xC8, 0xFC),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x09),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x05),
+	_INIT_CMD(0x00, 0xB3, 0x18),
+	_INIT_CMD(0x00, 0xB4, 0x31),
+	_INIT_CMD(0x00, 0xB5, 0x47),
+	_INIT_CMD(0x00, 0xB6, 0x57),
+	_INIT_CMD(0x00, 0xB7, 0x72),
+	_INIT_CMD(0x00, 0xB8, 0x9B),
+	_INIT_CMD(0x00, 0xB9, 0xE0),
+	_INIT_CMD(0x00, 0xBA, 0x32),
+	_INIT_CMD(0x00, 0xBB, 0xB8),
+	_INIT_CMD(0x00, 0xBC, 0x46),
+	_INIT_CMD(0x00, 0xBD, 0x4A),
+	_INIT_CMD(0x00, 0xBE, 0xD0),
+	_INIT_CMD(0x00, 0xBF, 0x35),
+	_INIT_CMD(0x00, 0xC0, 0x65),
+	_INIT_CMD(0x00, 0xC1, 0x97),
+	_INIT_CMD(0x00, 0xC2, 0xA7),
+	_INIT_CMD(0x00, 0xC3, 0xB7),
+	_INIT_CMD(0x00, 0xC4, 0xC0),
+	_INIT_CMD(0x00, 0xC5, 0xCF),
+	_INIT_CMD(0x00, 0xC6, 0xDC),
+	_INIT_CMD(0x00, 0xC7, 0xE4),
+	_INIT_CMD(0x00, 0xC8, 0xE8),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x0A),
+	_INIT_CMD(0x00, 0xB1, 0x00),
+	_INIT_CMD(0x00, 0xB2, 0x07),
+	_INIT_CMD(0x00, 0xB3, 0x18),
+	_INIT_CMD(0x00, 0xB4, 0x31),
+	_INIT_CMD(0x00, 0xB5, 0x47),
+	_INIT_CMD(0x00, 0xB6, 0x56),
+	_INIT_CMD(0x00, 0xB7, 0x70),
+	_INIT_CMD(0x00, 0xB8, 0x98),
+	_INIT_CMD(0x00, 0xB9, 0xDB),
+	_INIT_CMD(0x00, 0xBA, 0x2A),
+	_INIT_CMD(0x00, 0xBB, 0xAE),
+	_INIT_CMD(0x00, 0xBC, 0x39),
+	_INIT_CMD(0x00, 0xBD, 0x3D),
+	_INIT_CMD(0x00, 0xBE, 0xC6),
+	_INIT_CMD(0x00, 0xBF, 0x2A),
+	_INIT_CMD(0x00, 0xC0, 0x59),
+	_INIT_CMD(0x00, 0xC1, 0x91),
+	_INIT_CMD(0x00, 0xC2, 0xA1),
+	_INIT_CMD(0x00, 0xC3, 0xB1),
+	_INIT_CMD(0x00, 0xC4, 0xBA),
+	_INIT_CMD(0x00, 0xC5, 0xC5),
+	_INIT_CMD(0x00, 0xC6, 0xD4),
+	_INIT_CMD(0x00, 0xC7, 0xDC),
+	_INIT_CMD(0x00, 0xC8, 0xE0),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x0B),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x07),
+	_INIT_CMD(0x00, 0xB3, 0x19),
+	_INIT_CMD(0x00, 0xB4, 0x32),
+	_INIT_CMD(0x00, 0xB5, 0x48),
+	_INIT_CMD(0x00, 0xB6, 0x58),
+	_INIT_CMD(0x00, 0xB7, 0x74),
+	_INIT_CMD(0x00, 0xB8, 0x9D),
+	_INIT_CMD(0x00, 0xB9, 0xE2),
+	_INIT_CMD(0x00, 0xBA, 0x34),
+	_INIT_CMD(0x00, 0xBB, 0xBB),
+	_INIT_CMD(0x00, 0xBC, 0x4A),
+	_INIT_CMD(0x00, 0xBD, 0x4F),
+	_INIT_CMD(0x00, 0xBE, 0xD5),
+	_INIT_CMD(0x00, 0xBF, 0x3C),
+	_INIT_CMD(0x00, 0xC0, 0x70),
+	_INIT_CMD(0x00, 0xC1, 0x9F),
+	_INIT_CMD(0x00, 0xC2, 0xAF),
+	_INIT_CMD(0x00, 0xC3, 0xC2),
+	_INIT_CMD(0x00, 0xC4, 0xD2),
+	_INIT_CMD(0x00, 0xC5, 0xE1),
+	_INIT_CMD(0x00, 0xC6, 0xF0),
+	_INIT_CMD(0x00, 0xC7, 0xF9),
+	_INIT_CMD(0x00, 0xC8, 0xFC),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x0C),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x05),
+	_INIT_CMD(0x00, 0xB3, 0x18),
+	_INIT_CMD(0x00, 0xB4, 0x31),
+	_INIT_CMD(0x00, 0xB5, 0x47),
+	_INIT_CMD(0x00, 0xB6, 0x57),
+	_INIT_CMD(0x00, 0xB7, 0x72),
+	_INIT_CMD(0x00, 0xB8, 0x9B),
+	_INIT_CMD(0x00, 0xB9, 0xE0),
+	_INIT_CMD(0x00, 0xBA, 0x32),
+	_INIT_CMD(0x00, 0xBB, 0xB8),
+	_INIT_CMD(0x00, 0xBC, 0x46),
+	_INIT_CMD(0x00, 0xBD, 0x4A),
+	_INIT_CMD(0x00, 0xBE, 0xD0),
+	_INIT_CMD(0x00, 0xBF, 0x35),
+	_INIT_CMD(0x00, 0xC0, 0x65),
+	_INIT_CMD(0x00, 0xC1, 0x97),
+	_INIT_CMD(0x00, 0xC2, 0xA7),
+	_INIT_CMD(0x00, 0xC3, 0xB7),
+	_INIT_CMD(0x00, 0xC4, 0xC0),
+	_INIT_CMD(0x00, 0xC5, 0xCF),
+	_INIT_CMD(0x00, 0xC6, 0xDC),
+	_INIT_CMD(0x00, 0xC7, 0xE4),
+	_INIT_CMD(0x00, 0xC8, 0xE8),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x00),
+	_INIT_CMD(0x00, 0xB3, 0x08),
+	_INIT_CMD(0x00, 0xB0, 0x04),
+	_INIT_CMD(0x64, 0xB8, 0x68),
+	{},
+};
+
+static const struct panel_desc boe_tv101wumng0_panel_desc = {
+	.display_mode = &default_display_mode,
+	.bpc = 8,
+	.width_mm = 135,
+	.height_mm = 216,
+	.delay_t1 = 5000,
+	.reset_delay_t2 = 14000,
+	.reset_delay_t3 = 1000,
+	.reset_delay_t4 = 1000,
+	.reset_delay_t5 = 5000,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+	.on_cmds = boe_tv101wumng0_on_cmds,
+	.off_cmds = default_off_cmds,
+};
+
+/* auo,nt51021d8p */
+static const struct drm_display_mode auo_nt51021d8p_display_mode = {
+	.clock = 159420,
+	.hdisplay = 1200,
+	.hsync_start = 1200 + 80,
+	.hsync_end = 1200 + 80 + 60,
+	.htotal = 1200 + 80 + 60 + 1,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 35,
+	.vsync_end = 1920 + 35 + 25,
+	.vtotal = 1920 + 35 + 25 + 1,
+	.vrefresh = 60,
+};
+
+static const struct panel_cmd auo_nt51021d8p_on_cmds[] = {
+	_INIT_CMD(0x78, 0x11),
+	_INIT_CMD(0x14, 0x29),
+
+	{},
+};
+
+static const struct panel_cmd auo_nt51021d8p_off_cmds[] = {
+	_INIT_CMD(0x00, 0x28),
+	_INIT_CMD(0x01, 0x10),
+
+	{},
+};
+
+static const struct panel_desc auo_nt51021d8p_panel_desc = {
+	.display_mode = &auo_nt51021d8p_display_mode,
+	.bpc = 8,
+	.width_mm = 107,
+	.height_mm = 172,
+	.delay_t1 = 5000,
+	.reset_delay_t2 = 14000,
+	.reset_delay_t3 = 1000,
+	.reset_delay_t4 = 1000,
+	.reset_delay_t5 = 5000,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+	.on_cmds = auo_nt51021d8p_on_cmds,
+	.off_cmds = auo_nt51021d8p_off_cmds,
+};
+
+/* inx,ota7290d10p */
+static const struct drm_display_mode inx_ota7290d10p_display_mode = {
+	.clock = 159420,
+	.hdisplay = 1200,
+	.hsync_start = 1200 + 80,
+	.hsync_end = 1200 + 80 + 60,
+	.htotal = 1200 + 80 + 60 + 1,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 35,
+	.vsync_end = 1920 + 35 + 25,
+	.vtotal = 1920 + 35 + 25 + 1,
+	.vrefresh = 60,
+};
+
+static const struct panel_cmd inx_ota7290d10p_on_cmds[] = {
+	_INIT_CMD(0x00, 0xB0, 0x5A),
+	_INIT_CMD(0x00, 0xB1, 0x00),
+	_INIT_CMD(0x00, 0x89, 0x01),
+	_INIT_CMD(0x00, 0x91, 0x17),
+	_INIT_CMD(0x00, 0xB1, 0x03),
+	_INIT_CMD(0x00, 0x2C, 0x28),
+	_INIT_CMD(0x00, 0x00, 0xF1),
+	_INIT_CMD(0x00, 0x01, 0x78),
+	_INIT_CMD(0x00, 0x02, 0x3C),
+	_INIT_CMD(0x00, 0x03, 0x1E),
+	_INIT_CMD(0x00, 0x04, 0x8F),
+	_INIT_CMD(0x00, 0x05, 0x01),
+	_INIT_CMD(0x00, 0x06, 0x00),
+	_INIT_CMD(0x00, 0x07, 0x00),
+	_INIT_CMD(0x00, 0x08, 0x00),
+	_INIT_CMD(0x00, 0x09, 0x00),
+	_INIT_CMD(0x00, 0x0A, 0x01),
+	_INIT_CMD(0x00, 0x0B, 0x3C),
+	_INIT_CMD(0x00, 0x0C, 0x00),
+	_INIT_CMD(0x00, 0x0D, 0x00),
+	_INIT_CMD(0x00, 0x0E, 0x24),
+	_INIT_CMD(0x00, 0x0F, 0x1C),
+	_INIT_CMD(0x00, 0x10, 0xC8),
+	_INIT_CMD(0x00, 0x11, 0x60),
+	_INIT_CMD(0x00, 0x12, 0x70),
+	_INIT_CMD(0x00, 0x13, 0x01),
+	_INIT_CMD(0x00, 0x14, 0xE3),
+	_INIT_CMD(0x00, 0x15, 0xFF),
+	_INIT_CMD(0x00, 0x16, 0x3D),
+	_INIT_CMD(0x00, 0x17, 0x0E),
+	_INIT_CMD(0x00, 0x18, 0x01),
+	_INIT_CMD(0x00, 0x19, 0x00),
+	_INIT_CMD(0x00, 0x1A, 0x00),
+	_INIT_CMD(0x00, 0x1B, 0xFC),
+	_INIT_CMD(0x00, 0x1C, 0x0B),
+	_INIT_CMD(0x00, 0x1D, 0xA0),
+	_INIT_CMD(0x00, 0x1E, 0x03),
+	_INIT_CMD(0x00, 0x1F, 0x04),
+	_INIT_CMD(0x00, 0x20, 0x0C),
+	_INIT_CMD(0x00, 0x21, 0x00),
+	_INIT_CMD(0x00, 0x22, 0x04),
+	_INIT_CMD(0x00, 0x23, 0x81),
+	_INIT_CMD(0x00, 0x24, 0x1F),
+	_INIT_CMD(0x00, 0x25, 0x10),
+	_INIT_CMD(0x00, 0x26, 0x9B),
+	_INIT_CMD(0x00, 0x2D, 0x01),
+	_INIT_CMD(0x00, 0x2E, 0x84),
+	_INIT_CMD(0x00, 0x2F, 0x00),
+	_INIT_CMD(0x00, 0x30, 0x02),
+	_INIT_CMD(0x00, 0x31, 0x08),
+	_INIT_CMD(0x00, 0x32, 0x01),
+	_INIT_CMD(0x00, 0x33, 0x1C),
+	_INIT_CMD(0x00, 0x34, 0x70),
+	_INIT_CMD(0x00, 0x35, 0xFF),
+	_INIT_CMD(0x00, 0x36, 0xFF),
+	_INIT_CMD(0x00, 0x37, 0xFF),
+	_INIT_CMD(0x00, 0x38, 0xFF),
+	_INIT_CMD(0x00, 0x39, 0xFF),
+	_INIT_CMD(0x00, 0x3A, 0x05),
+	_INIT_CMD(0x00, 0x3B, 0x00),
+	_INIT_CMD(0x00, 0x3C, 0x00),
+	_INIT_CMD(0x00, 0x3D, 0x00),
+	_INIT_CMD(0x00, 0x3E, 0x0F),
+	_INIT_CMD(0x00, 0x3F, 0xA4),
+	_INIT_CMD(0x00, 0x40, 0x28),
+	_INIT_CMD(0x00, 0x41, 0xFC),
+	_INIT_CMD(0x00, 0x42, 0x01),
+	_INIT_CMD(0x00, 0x43, 0x08),
+	_INIT_CMD(0x00, 0x44, 0x05),
+	_INIT_CMD(0x00, 0x45, 0xF0),
+	_INIT_CMD(0x00, 0x46, 0x01),
+	_INIT_CMD(0x00, 0x47, 0x02),
+	_INIT_CMD(0x00, 0x48, 0x00),
+	_INIT_CMD(0x00, 0x49, 0x58),
+	_INIT_CMD(0x00, 0x4A, 0x00),
+	_INIT_CMD(0x00, 0x4B, 0x05),
+	_INIT_CMD(0x00, 0x4C, 0x03),
+	_INIT_CMD(0x00, 0x4D, 0xD0),
+	_INIT_CMD(0x00, 0x4E, 0x13),
+	_INIT_CMD(0x00, 0x4F, 0xFF),
+	_INIT_CMD(0x00, 0x50, 0x0A),
+	_INIT_CMD(0x00, 0x51, 0x53),
+	_INIT_CMD(0x00, 0x52, 0x26),
+	_INIT_CMD(0x00, 0x53, 0x22),
+	_INIT_CMD(0x00, 0x54, 0x09),
+	_INIT_CMD(0x00, 0x55, 0x22),
+	_INIT_CMD(0x00, 0x56, 0x00),
+	_INIT_CMD(0x00, 0x57, 0x1C),
+	_INIT_CMD(0x00, 0x58, 0x03),
+	_INIT_CMD(0x00, 0x59, 0x3F),
+	_INIT_CMD(0x00, 0x5A, 0x28),
+	_INIT_CMD(0x00, 0x5B, 0x01),
+	_INIT_CMD(0x00, 0x5C, 0xCC),
+	_INIT_CMD(0x00, 0x5D, 0x21),
+	_INIT_CMD(0x00, 0x5E, 0x04),
+	_INIT_CMD(0x00, 0x5F, 0x13),
+	_INIT_CMD(0x00, 0x60, 0x42),
+	_INIT_CMD(0x00, 0x61, 0x08),
+	_INIT_CMD(0x00, 0x62, 0x64),
+	_INIT_CMD(0x00, 0x63, 0xEB),
+	_INIT_CMD(0x00, 0x64, 0x10),
+	_INIT_CMD(0x00, 0x65, 0xA8),
+	_INIT_CMD(0x00, 0x66, 0x84),
+	_INIT_CMD(0x00, 0x67, 0x8E),
+	_INIT_CMD(0x00, 0x68, 0x29),
+	_INIT_CMD(0x00, 0x69, 0x11),
+	_INIT_CMD(0x00, 0x6A, 0x42),
+	_INIT_CMD(0x00, 0x6B, 0x38),
+	_INIT_CMD(0x00, 0x6C, 0x21),
+	_INIT_CMD(0x00, 0x6D, 0x84),
+	_INIT_CMD(0x00, 0x6E, 0x50),
+	_INIT_CMD(0x00, 0x6F, 0xB6),
+	_INIT_CMD(0x00, 0x70, 0x0E),
+	_INIT_CMD(0x00, 0x71, 0xA1),
+	_INIT_CMD(0x00, 0x72, 0xCE),
+	_INIT_CMD(0x00, 0x73, 0xF8),
+	_INIT_CMD(0x00, 0x74, 0xDA),
+	_INIT_CMD(0x00, 0x75, 0x1A),
+	_INIT_CMD(0x00, 0x76, 0x00),
+	_INIT_CMD(0x00, 0x77, 0x00),
+	_INIT_CMD(0x00, 0x78, 0x5F),
+	_INIT_CMD(0x00, 0x79, 0xE0),
+	_INIT_CMD(0x00, 0x7A, 0x01),
+	_INIT_CMD(0x00, 0x7B, 0xFF),
+	_INIT_CMD(0x00, 0x7C, 0xFF),
+	_INIT_CMD(0x00, 0x7D, 0xFF),
+	_INIT_CMD(0x00, 0x7E, 0xFF),
+	_INIT_CMD(0x00, 0x7F, 0xFE),
+	_INIT_CMD(0x00, 0xB1, 0x02),
+	_INIT_CMD(0x00, 0x00, 0xFF),
+	_INIT_CMD(0x00, 0x01, 0x01),
+	_INIT_CMD(0x00, 0x02, 0x00),
+	_INIT_CMD(0x00, 0x03, 0x00),
+	_INIT_CMD(0x00, 0x04, 0x00),
+	_INIT_CMD(0x00, 0x05, 0x00),
+	_INIT_CMD(0x00, 0x06, 0x00),
+	_INIT_CMD(0x00, 0x07, 0x00),
+	_INIT_CMD(0x00, 0x08, 0xC0),
+	_INIT_CMD(0x00, 0x09, 0x00),
+	_INIT_CMD(0x00, 0x0A, 0x00),
+	_INIT_CMD(0x00, 0x0B, 0x04),
+	_INIT_CMD(0x00, 0x0C, 0xE6),
+	_INIT_CMD(0x00, 0x0D, 0x0D),
+	_INIT_CMD(0x00, 0x0F, 0x08),
+	_INIT_CMD(0x00, 0x10, 0xE5),
+	_INIT_CMD(0x00, 0x11, 0xA8),
+	_INIT_CMD(0x00, 0x12, 0xEC),
+	_INIT_CMD(0x00, 0x13, 0x54),
+	_INIT_CMD(0x00, 0x14, 0x5A),
+	_INIT_CMD(0x00, 0x15, 0xD5),
+	_INIT_CMD(0x00, 0x16, 0x23),
+	_INIT_CMD(0x00, 0x17, 0x11),
+	_INIT_CMD(0x00, 0x18, 0x2F),
+	_INIT_CMD(0x00, 0x19, 0x93),
+	_INIT_CMD(0x00, 0x1A, 0xA6),
+	_INIT_CMD(0x00, 0x1B, 0x0F),
+	_INIT_CMD(0x00, 0x1C, 0xFF),
+	_INIT_CMD(0x00, 0x1D, 0xFF),
+	_INIT_CMD(0x00, 0x1E, 0xFF),
+	_INIT_CMD(0x00, 0x1F, 0xFF),
+	_INIT_CMD(0x00, 0x20, 0xFF),
+	_INIT_CMD(0x00, 0x21, 0xFF),
+	_INIT_CMD(0x00, 0x22, 0xFF),
+	_INIT_CMD(0x00, 0x23, 0xFF),
+	_INIT_CMD(0x00, 0x24, 0xFF),
+	_INIT_CMD(0x00, 0x25, 0xFF),
+	_INIT_CMD(0x00, 0x26, 0xFF),
+	_INIT_CMD(0x00, 0x27, 0x1F),
+	_INIT_CMD(0x00, 0x28, 0xC8),
+	_INIT_CMD(0x00, 0x29, 0xFF),
+	_INIT_CMD(0x00, 0x2A, 0xFF),
+	_INIT_CMD(0x00, 0x2B, 0xFF),
+	_INIT_CMD(0x00, 0x2C, 0x07),
+	_INIT_CMD(0x00, 0x2D, 0x03),
+	_INIT_CMD(0x00, 0x33, 0x09),
+	_INIT_CMD(0x00, 0x35, 0x7F),
+	_INIT_CMD(0x00, 0x36, 0x0C),
+	_INIT_CMD(0x00, 0x38, 0x7F),
+	_INIT_CMD(0x00, 0x3A, 0x80),
+	_INIT_CMD(0x00, 0x3B, 0x55),
+	_INIT_CMD(0x00, 0x3C, 0xE2),
+	_INIT_CMD(0x00, 0x3D, 0x32),
+	_INIT_CMD(0x00, 0x3E, 0x00),
+	_INIT_CMD(0x00, 0x3F, 0x58),
+	_INIT_CMD(0x00, 0x40, 0x06),
+	_INIT_CMD(0x00, 0x41, 0x80),
+	_INIT_CMD(0x00, 0x42, 0xCB),
+	_INIT_CMD(0x00, 0x43, 0x2C),
+	_INIT_CMD(0x00, 0x44, 0x61),
+	_INIT_CMD(0x00, 0x45, 0x39),
+	_INIT_CMD(0x00, 0x46, 0x00),
+	_INIT_CMD(0x00, 0x47, 0x00),
+	_INIT_CMD(0x00, 0x48, 0x8B),
+	_INIT_CMD(0x00, 0x49, 0xD2),
+	_INIT_CMD(0x00, 0x4A, 0x01),
+	_INIT_CMD(0x00, 0x4B, 0x00),
+	_INIT_CMD(0x00, 0x4C, 0x10),
+	_INIT_CMD(0x00, 0x4D, 0xC0),
+	_INIT_CMD(0x00, 0x4E, 0x0F),
+	_INIT_CMD(0x00, 0x4F, 0xF1),
+	_INIT_CMD(0x00, 0x50, 0x78),
+	_INIT_CMD(0x00, 0x51, 0x7A),
+	_INIT_CMD(0x00, 0x52, 0x34),
+	_INIT_CMD(0x00, 0x53, 0x99),
+	_INIT_CMD(0x00, 0x54, 0xA2),
+	_INIT_CMD(0x00, 0x55, 0x03),
+	_INIT_CMD(0x00, 0x56, 0x6C),
+	_INIT_CMD(0x00, 0x57, 0x1A),
+	_INIT_CMD(0x00, 0x58, 0x05),
+	_INIT_CMD(0x00, 0x59, 0x30),
+	_INIT_CMD(0x00, 0x5A, 0x1E),
+	_INIT_CMD(0x00, 0x5B, 0x8F),
+	_INIT_CMD(0x00, 0x5C, 0xC7),
+	_INIT_CMD(0x00, 0x5D, 0xE3),
+	_INIT_CMD(0x00, 0x5E, 0xF1),
+	_INIT_CMD(0x00, 0x5F, 0x78),
+	_INIT_CMD(0x00, 0x60, 0x3C),
+	_INIT_CMD(0x00, 0x61, 0x36),
+	_INIT_CMD(0x00, 0x62, 0x1E),
+	_INIT_CMD(0x00, 0x63, 0x1B),
+	_INIT_CMD(0x00, 0x64, 0x8F),
+	_INIT_CMD(0x00, 0x65, 0xC7),
+	_INIT_CMD(0x00, 0x66, 0xE3),
+	_INIT_CMD(0x00, 0x67, 0x31),
+	_INIT_CMD(0x00, 0x68, 0x14),
+	_INIT_CMD(0x00, 0x69, 0x89),
+	_INIT_CMD(0x00, 0x6A, 0x70),
+	_INIT_CMD(0x00, 0x6B, 0x8C),
+	_INIT_CMD(0x00, 0x6C, 0x8D),
+	_INIT_CMD(0x00, 0x6D, 0x8D),
+	_INIT_CMD(0x00, 0x6E, 0x8D),
+	_INIT_CMD(0x00, 0x6F, 0x8D),
+	_INIT_CMD(0x00, 0x70, 0xC7),
+	_INIT_CMD(0x00, 0x71, 0xE3),
+	_INIT_CMD(0x00, 0x72, 0xF1),
+	_INIT_CMD(0x00, 0x73, 0xD8),
+	_INIT_CMD(0x00, 0x74, 0xD8),
+	_INIT_CMD(0x00, 0x75, 0xD8),
+	_INIT_CMD(0x00, 0x76, 0x18),
+	_INIT_CMD(0x00, 0x77, 0x00),
+	_INIT_CMD(0x00, 0x78, 0x00),
+	_INIT_CMD(0x00, 0x79, 0x00),
+	_INIT_CMD(0x00, 0x7A, 0xC6),
+	_INIT_CMD(0x00, 0x7B, 0xC6),
+	_INIT_CMD(0x00, 0x7C, 0xC6),
+	_INIT_CMD(0x00, 0x7D, 0xC6),
+	_INIT_CMD(0x00, 0x7E, 0xC6),
+	_INIT_CMD(0x00, 0x7F, 0xE3),
+	_INIT_CMD(0x00, 0x0B, 0x04),
+	_INIT_CMD(0x00, 0xB1, 0x03),
+	_INIT_CMD(0x00, 0x2C, 0x2C),
+	_INIT_CMD(0x00, 0xB1, 0x00),
+	_INIT_CMD(0x00, 0x89, 0x03),
+	_INIT_CMD(0x78, 0x11),
+	_INIT_CMD(0x14, 0x29),
+
+	{},
+};
+
+static const struct panel_cmd inx_ota7290d10p_off_cmds[] = {
+	_INIT_CMD(0x00, 0x28),
+	_INIT_CMD(0x01, 0x10),
+
+	{},
+};
+
+static const struct panel_desc inx_ota7290d10p_panel_desc = {
+	.display_mode = &inx_ota7290d10p_display_mode,
+	.bpc = 8,
+	.width_mm = 107,
+	.height_mm = 172,
+	.delay_t1 = 5000,
+	.reset_delay_t2 = 14000,
+	.reset_delay_t3 = 1000,
+	.reset_delay_t4 = 1000,
+	.reset_delay_t5 = 5000,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+	.on_cmds = inx_ota7290d10p_on_cmds,
+	.off_cmds = inx_ota7290d10p_off_cmds,
+};
+
 static const struct of_device_id panel_of_match[] = {
 	{ .compatible = "boe,himax8279d8p",
 	  .data = &boe_himax8279d8p_panel_desc
 	}, { .compatible = "boe,himax8279d10p",
 	  .data = &boe_himax8279d10p_panel_desc
+	}, { .compatible = "auo,nt51021d8p",
+	    .data = &auo_nt51021d8p_panel_desc
+	}, { .compatible = "inx,ota7290d10p",
+	    .data = &inx_ota7290d10p_panel_desc
+	}, { .compatible = "boe,tv080wum_ng0",
+	  .data = &boe_tv080wumng0_panel_desc
+	}, { .compatible = "boe,tv101wum_ng0",
+	  .data = &boe_tv101wumng0_panel_desc
 	}, {
 		/* sentinel */
 	}
diff --git a/drivers/iio/proximity/Kconfig b/drivers/iio/proximity/Kconfig
index 388ef70c11d2..d16c1d4649ce 100644
--- a/drivers/iio/proximity/Kconfig
+++ b/drivers/iio/proximity/Kconfig
@@ -79,6 +79,19 @@ config SX9500
 	  To compile this driver as a module, choose M here: the
 	  module will be called sx9500.
 
+config SX9311
+	tristate "SX9311 Semtech proximity sensor"
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+	select REGMAP_I2C
+	depends on I2C
+	help
+	  Say Y here to build a driver for Semtech's SX9311 capacitive
+	  proximity/button sensor.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called sx9311.
+
 config SRF08
 	tristate "Devantech SRF02/SRF08/SRF10 ultrasonic ranger sensor"
 	select IIO_BUFFER
diff --git a/drivers/iio/proximity/Makefile b/drivers/iio/proximity/Makefile
index cac3d7d3325e..c0ac5af12015 100644
--- a/drivers/iio/proximity/Makefile
+++ b/drivers/iio/proximity/Makefile
@@ -11,3 +11,4 @@ obj-$(CONFIG_RFD77402)		+= rfd77402.o
 obj-$(CONFIG_SRF04)		+= srf04.o
 obj-$(CONFIG_SRF08)		+= srf08.o
 obj-$(CONFIG_SX9500)		+= sx9500.o
+obj-$(CONFIG_SX9311)		+= sx9311.o
diff --git a/drivers/iio/proximity/sx9311.c b/drivers/iio/proximity/sx9311.c
new file mode 100644
index 000000000000..408c349dd436
--- /dev/null
+++ b/drivers/iio/proximity/sx9311.c
@@ -0,0 +1,1144 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2019, Google LLC.
+ *
+ * Driver for Semtech's SX9311 capacitive proximity/button solution.
+ * Datasheet available at
+ * <http://www.semtech.com/images/datasheet/sx9311.pdf>.
+ * Based on SX9310 driver and Semtech driver using the input framework
+ * <https://my.syncplicity.com/share/teouwsim8niiaud/
+ *          linux-driver-SX9311_NoSmartHSensing>.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/acpi.h>
+#include <linux/gpio/consumer.h>
+#include <linux/regmap.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/events.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/iio/trigger_consumer.h>
+
+#define SX9311_DRIVER_NAME		"sx9311"
+#define SX9311_ACPI_NAME		"STH9311"
+#define SX9311_IRQ_NAME			"sx9311_event"
+
+#define SX9311_GPIO_INT			"interrupt"
+
+/* Register definitions. */
+#define SX9311_REG_IRQ_SRC		0x00
+#define SX9311_REG_STAT0		0x01
+#define SX9311_REG_STAT1		0x02
+#define SX9311_REG_IRQ_MSK		0x03
+#define SX9311_REG_IRQ_FUNC		0x04
+
+#define SX9311_REG_PROX_CTRL0		0x10
+#define SX9311_REG_PROX_CTRL1		0x11
+#define SX9311_REG_PROX_CTRL2		0x12
+#define SX9311_REG_PROX_CTRL3		0x13
+#define SX9311_REG_PROX_CTRL4		0x14
+#define SX9311_REG_PROX_CTRL5		0x15
+#define SX9311_REG_PROX_CTRL6		0x16
+#define SX9311_REG_PROX_CTRL7		0x17
+#define SX9311_REG_PROX_CTRL8		0x18
+#define SX9311_REG_PROX_CTRL9		0x19
+#define SX9311_REG_PROX_CTRL10		0x1A
+#define SX9311_REG_PROX_CTRL11		0x1B
+#define SX9311_REG_PROX_CTRL12		0x1C
+#define SX9311_REG_PROX_CTRL13		0x1D
+#define SX9311_REG_PROX_CTRL14		0x1E
+#define SX9311_REG_PROX_CTRL15		0x1F
+#define SX9311_REG_PROX_CTRL16		0x20
+#define SX9311_REG_PROX_CTRL17		0x21
+#define SX9311_REG_PROX_CTRL18		0x22
+#define SX9311_REG_PROX_CTRL19		0x23
+#define SX9311_REG_SAR_CTRL0		0x2A
+#define SX9311_REG_SAR_CTRL1		0x2B
+#define SX9311_REG_SAR_CTRL2		0x2C
+
+#define SX9311_REG_SENSOR_SEL		0x30
+
+#define SX9311_REG_USE_MSB		0x31
+#define SX9311_REG_USE_LSB		0x32
+
+#define SX9311_REG_AVG_MSB		0x33
+#define SX9311_REG_AVG_LSB		0x34
+
+#define SX9311_REG_DIFF_MSB		0x35
+#define SX9311_REG_DIFF_LSB		0x36
+
+#define SX9311_REG_OFFSET_MSB		0x37
+#define SX9311_REG_OFFSET_LSB		0x38
+
+#define SX9311_REG_SAR_MSB		0x39
+#define SX9311_REG_SAR_LSB		0x3A
+
+#define SX9311_REG_I2CADDR		0x40
+#define SX9311_REG_PAUSE		0x41
+#define SX9311_REG_WHOAMI		0x42
+/* Expected content of the WHOAMI register. */
+#define SX9311_WHOAMI_VALUE		0x02
+
+#define SX9311_REG_RESET		0x7f
+/* Write this to REG_RESET to do a soft reset. */
+#define SX9311_SOFT_RESET		0xde
+
+
+/* Sensor Readback */
+
+/*
+ * These serve for identifying IRQ source in the IRQ_SRC register, and
+ * also for masking the IRQs in the IRQ_MSK register.
+ */
+#define SX9311_RESET_IRQ		BIT(7)
+#define SX9311_CLOSE_IRQ		BIT(6)
+#define SX9311_FAR_IRQ			BIT(5)
+#define SX9311_COMPDONE_IRQ		BIT(4)
+#define SX9311_CONVDONE_IRQ		BIT(3)
+
+#define SX9311_SCAN_PERIOD_MASK		GENMASK(7, 4)
+#define SX9311_SCAN_PERIOD_SHIFT	4
+
+#define SX9311_COMPSTAT_MASK		GENMASK(3, 0)
+
+/* 4 channels, as defined in STAT0: COMB, CS2, CS1 and CS0. */
+#define SX9311_NUM_CHANNELS		4
+#define SX9311_CHAN_MASK		GENMASK(2, 0)
+
+struct sx9311_data {
+	struct mutex mutex;
+	struct i2c_client *client;
+	struct iio_trigger *trig;
+	struct regmap *regmap;
+	/*
+	 * Last reading of the proximity status for each channel.
+	 * We only send an event to user space when this changes.
+	 */
+	bool prox_stat[SX9311_NUM_CHANNELS];
+	bool event_enabled[SX9311_NUM_CHANNELS];
+	bool trigger_enabled;
+	u16 *buffer;
+	/* Remember enabled channels and sample rate during suspend. */
+	unsigned int suspend_ctrl0;
+	struct completion completion;
+	int data_rdy_users, close_far_users;
+	int channel_users[SX9311_NUM_CHANNELS];
+	unsigned int num_irqs;
+};
+
+static const struct iio_event_spec sx9311_events[] = {
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_EITHER,
+		.mask_separate = BIT(IIO_EV_INFO_ENABLE),
+	},
+};
+
+#define SX9311_CHANNEL(idx, name, addr)				\
+	{							\
+		.type = IIO_PROXIMITY,				\
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),	\
+		.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \
+		.indexed = 1,					\
+		.channel = idx,					\
+		.address = addr,				\
+		.event_spec = sx9311_events,			\
+		.num_event_specs = ARRAY_SIZE(sx9311_events),	\
+		.extend_name = name,				\
+		.scan_index = idx,				\
+		.scan_type = {					\
+			.sign = 's',				\
+			.realbits = 16,				\
+			.storagebits = 16,			\
+			.shift = 0,				\
+		},						\
+	}
+
+static const struct iio_chan_spec sx9311_channels[] = {
+	SX9311_CHANNEL(0, "USE_CS0", SX9311_REG_USE_MSB),
+	SX9311_CHANNEL(1, "USE_CS1", SX9311_REG_USE_MSB),
+	SX9311_CHANNEL(2, "USE_CS2", SX9311_REG_USE_MSB),
+	SX9311_CHANNEL(3, "USE_COMB", SX9311_REG_USE_MSB),
+
+	SX9311_CHANNEL(4, "DIFF_CS0", SX9311_REG_DIFF_MSB),
+	SX9311_CHANNEL(5, "DIFF_CS1", SX9311_REG_DIFF_MSB),
+	SX9311_CHANNEL(6, "DIFF_CS2", SX9311_REG_DIFF_MSB),
+	SX9311_CHANNEL(7, "DIFF_COMB", SX9311_REG_DIFF_MSB),
+
+	IIO_CHAN_SOFT_TIMESTAMP(8),
+};
+
+/*
+ * Each entry contains the integer part (val) and the fractional part, in micro
+ * seconds. It conforms to the IIO output IIO_VAL_INT_PLUS_MICRO.
+ */
+static const struct {
+	int val;
+	int val2;
+} sx9311_samp_freq_table[] = {
+	{500, 0}, /* 0000: Min (no idle time) */
+	{66, 666666}, /* 0001: 15 ms */
+	{33, 333333}, /* 0010: 30 ms (Typ.) */
+	{22, 222222}, /* 0011: 45 ms */
+	{16, 666666}, /* 0100: 60 ms */
+	{11, 111111}, /* 0101: 90 ms */
+	{8, 333333}, /* 0110: 120 ms */
+	{5, 0}, /* 0111: 200 ms */
+	{2, 500000}, /* 1000: 400 ms */
+	{1, 666666}, /* 1001: 600 ms */
+	{1, 250000}, /* 1010: 800 ms */
+	{1, 0}, /* 1011: 1 s */
+	{0, 500000}, /* 1100: 2 s */
+	{8, 333333}, /* 1101: 3 s */
+	{0, 250000}, /* 1110: 4 s */
+	{0, 200000}, /* 1111: 5 s */
+};
+static const unsigned int sx9311_scan_period_table[] = {
+	2, 15, 30, 45, 60, 90, 120, 200, 400, 800, 1000, 2000, 3000, 4000, 5000,
+};
+
+static IIO_CONST_ATTR_SAMP_FREQ_AVAIL(
+	"500.0 66.666666 33.333333 22.222222 16.666666 "
+	"11.111111 8.333333 5.0 2.500000 1.666666 1.250000 "
+	"1.0 0.500000 8.333333 0.250000 0.200000");
+
+
+static const struct regmap_range sx9311_writable_reg_ranges[] = {
+	regmap_reg_range(SX9311_REG_IRQ_MSK, SX9311_REG_IRQ_FUNC),
+	regmap_reg_range(SX9311_REG_PROX_CTRL0, SX9311_REG_PROX_CTRL19),
+	regmap_reg_range(SX9311_REG_SAR_CTRL0, SX9311_REG_SAR_CTRL2),
+	regmap_reg_range(SX9311_REG_SENSOR_SEL, SX9311_REG_SENSOR_SEL),
+	regmap_reg_range(SX9311_REG_OFFSET_MSB, SX9311_REG_OFFSET_LSB),
+	regmap_reg_range(SX9311_REG_PAUSE, SX9311_REG_PAUSE),
+	regmap_reg_range(SX9311_REG_RESET, SX9311_REG_RESET),
+};
+
+static const struct regmap_access_table sx9311_writeable_regs = {
+	.yes_ranges = sx9311_writable_reg_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sx9311_writable_reg_ranges),
+};
+
+/*
+ * All allocated registers are readable, so we just list unallocated
+ * ones.
+ */
+static const struct regmap_range sx9311_non_readable_reg_ranges[] = {
+	regmap_reg_range(SX9311_REG_IRQ_FUNC + 1, SX9311_REG_PROX_CTRL0 - 1),
+	regmap_reg_range(SX9311_REG_SAR_CTRL2 + 1, SX9311_REG_SENSOR_SEL - 1),
+	regmap_reg_range(SX9311_REG_SAR_LSB + 1, SX9311_REG_I2CADDR - 1),
+	regmap_reg_range(SX9311_REG_WHOAMI + 1, SX9311_REG_RESET - 1),
+};
+
+static const struct regmap_access_table sx9311_readable_regs = {
+	.no_ranges = sx9311_non_readable_reg_ranges,
+	.n_no_ranges = ARRAY_SIZE(sx9311_non_readable_reg_ranges),
+};
+
+static const struct regmap_range sx9311_volatile_reg_ranges[] = {
+	regmap_reg_range(SX9311_REG_IRQ_SRC, SX9311_REG_STAT1),
+	regmap_reg_range(SX9311_REG_USE_MSB, SX9311_REG_DIFF_LSB),
+	regmap_reg_range(SX9311_REG_SAR_MSB, SX9311_REG_SAR_LSB),
+	regmap_reg_range(SX9311_REG_RESET, SX9311_REG_RESET),
+};
+
+static const struct regmap_access_table sx9311_volatile_regs = {
+	.yes_ranges = sx9311_volatile_reg_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sx9311_volatile_reg_ranges),
+};
+
+static const struct regmap_config sx9311_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = SX9311_REG_RESET,
+	.cache_type = REGCACHE_RBTREE,
+
+	.wr_table = &sx9311_writeable_regs,
+	.rd_table = &sx9311_readable_regs,
+	.volatile_table = &sx9311_volatile_regs,
+};
+
+static int sx9311_inc_users(struct sx9311_data *data, int *counter,
+			    unsigned int reg, unsigned int bitmask)
+{
+	++(*counter);
+	if (*counter != 1)
+		/* Bit is already active, nothing to do. */
+		return 0;
+
+	return regmap_update_bits(data->regmap, reg, bitmask, bitmask);
+}
+
+static int sx9311_dec_users(struct sx9311_data *data, int *counter,
+			    unsigned int reg, unsigned int bitmask)
+{
+	--(*counter);
+	if (*counter != 0)
+		/* There are more users, do not deactivate. */
+		return 0;
+
+	return regmap_update_bits(data->regmap, reg, bitmask, 0);
+}
+
+static int sx9311_inc_chan_users(struct sx9311_data *data, int chan)
+{
+	return sx9311_inc_users(data, &data->channel_users[chan],
+				SX9311_REG_PROX_CTRL0, BIT(chan));
+}
+
+static int sx9311_dec_chan_users(struct sx9311_data *data, int chan)
+{
+	return sx9311_dec_users(data, &data->channel_users[chan],
+				SX9311_REG_PROX_CTRL0, BIT(chan));
+}
+
+static int sx9311_inc_data_rdy_users(struct sx9311_data *data)
+{
+	return sx9311_inc_users(data, &data->data_rdy_users,
+				SX9311_REG_IRQ_MSK, SX9311_CONVDONE_IRQ);
+}
+
+static int sx9311_dec_data_rdy_users(struct sx9311_data *data)
+{
+	return sx9311_dec_users(data, &data->data_rdy_users,
+				SX9311_REG_IRQ_MSK, SX9311_CONVDONE_IRQ);
+}
+
+static int sx9311_inc_close_far_users(struct sx9311_data *data)
+{
+	return sx9311_inc_users(data, &data->close_far_users,
+				SX9311_REG_IRQ_MSK,
+				SX9311_CLOSE_IRQ | SX9311_FAR_IRQ);
+}
+
+static int sx9311_dec_close_far_users(struct sx9311_data *data)
+{
+	return sx9311_dec_users(data, &data->close_far_users,
+				SX9311_REG_IRQ_MSK,
+				SX9311_CLOSE_IRQ | SX9311_FAR_IRQ);
+}
+
+static int sx9311_read_prox_data(struct sx9311_data *data,
+				 const struct iio_chan_spec *chan,
+				 int *val)
+{
+	int ret;
+	__be16 regval;
+
+	ret = regmap_write(data->regmap, SX9311_REG_SENSOR_SEL, chan->channel);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_bulk_read(data->regmap, chan->address, &regval, 2);
+	if (ret < 0)
+		return ret;
+
+	*val = sign_extend32(be16_to_cpu(regval),
+			(chan->address == SX9311_REG_DIFF_MSB ? 11 : 15));
+
+	return 0;
+}
+
+/*
+ * If we have no interrupt support, we have to wait for a scan period
+ * after enabling a channel to get a result.
+ */
+static int sx9311_wait_for_sample(struct sx9311_data *data)
+{
+	int ret;
+	unsigned int val;
+
+	ret = regmap_read(data->regmap, SX9311_REG_PROX_CTRL0, &val);
+	if (ret < 0)
+		return ret;
+
+	val = (val & SX9311_SCAN_PERIOD_MASK) >> SX9311_SCAN_PERIOD_SHIFT;
+
+	msleep(sx9311_scan_period_table[val]);
+
+	return 0;
+}
+
+static int sx9311_read_proximity(struct sx9311_data *data,
+				 const struct iio_chan_spec *chan,
+				 int *val)
+{
+	int ret;
+
+	mutex_lock(&data->mutex);
+
+	ret = sx9311_inc_chan_users(data, chan->channel & SX9311_CHAN_MASK);
+	if (ret < 0)
+		goto out;
+
+	ret = sx9311_inc_data_rdy_users(data);
+	if (ret < 0)
+		goto out_dec_chan;
+
+	mutex_unlock(&data->mutex);
+
+	if (data->client->irq > 0)
+		ret = wait_for_completion_interruptible(&data->completion);
+	else
+		ret = sx9311_wait_for_sample(data);
+
+	mutex_lock(&data->mutex);
+
+	if (ret < 0)
+		goto out_dec_data_rdy;
+
+	ret = sx9311_read_prox_data(data, chan, val);
+	if (ret < 0)
+		goto out_dec_data_rdy;
+
+	ret = sx9311_dec_data_rdy_users(data);
+	if (ret < 0)
+		goto out_dec_chan;
+
+	ret = sx9311_dec_chan_users(data, chan->channel & SX9311_CHAN_MASK);
+	if (ret < 0)
+		goto out;
+
+	ret = IIO_VAL_INT;
+
+	goto out;
+
+out_dec_data_rdy:
+	sx9311_dec_data_rdy_users(data);
+out_dec_chan:
+	sx9311_dec_chan_users(data, chan->channel & SX9311_CHAN_MASK);
+out:
+	mutex_unlock(&data->mutex);
+	reinit_completion(&data->completion);
+
+	return ret;
+}
+
+static int sx9311_read_samp_freq(struct sx9311_data *data,
+				 int *val, int *val2)
+{
+	int ret;
+	unsigned int regval;
+
+	mutex_lock(&data->mutex);
+	ret = regmap_read(data->regmap, SX9311_REG_PROX_CTRL0, &regval);
+
+	mutex_unlock(&data->mutex);
+	if (ret < 0)
+		return ret;
+
+	regval = (regval & SX9311_SCAN_PERIOD_MASK) >> SX9311_SCAN_PERIOD_SHIFT;
+	*val = sx9311_samp_freq_table[regval].val;
+	*val2 = sx9311_samp_freq_table[regval].val2;
+
+	return IIO_VAL_INT_PLUS_MICRO;
+}
+
+static int sx9311_read_raw(struct iio_dev *indio_dev,
+			   const struct iio_chan_spec *chan,
+			   int *val, int *val2, long mask)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret;
+
+	switch (chan->type) {
+	case IIO_PROXIMITY:
+		switch (mask) {
+		case IIO_CHAN_INFO_RAW:
+			mutex_lock(&indio_dev->mlock);
+
+			if (iio_buffer_enabled(indio_dev)) {
+				mutex_unlock(&indio_dev->mlock);
+				return -EBUSY;
+			}
+			ret = sx9311_read_proximity(data, chan, val);
+			mutex_unlock(&indio_dev->mlock);
+			return ret;
+		case IIO_CHAN_INFO_SAMP_FREQ:
+			return sx9311_read_samp_freq(data, val, val2);
+		default:
+			return -EINVAL;
+		}
+	default:
+		return -EINVAL;
+	}
+}
+
+static int sx9311_set_samp_freq(struct sx9311_data *data,
+				int val, int val2)
+{
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(sx9311_samp_freq_table); i++)
+		if (val == sx9311_samp_freq_table[i].val &&
+		    val2 == sx9311_samp_freq_table[i].val2)
+			break;
+
+	if (i == ARRAY_SIZE(sx9311_samp_freq_table))
+		return -EINVAL;
+
+	mutex_lock(&data->mutex);
+
+	ret = regmap_update_bits(data->regmap, SX9311_REG_PROX_CTRL0,
+				 SX9311_SCAN_PERIOD_MASK,
+				 i << SX9311_SCAN_PERIOD_SHIFT);
+
+	mutex_unlock(&data->mutex);
+
+	return ret;
+}
+
+static int sx9311_write_raw(struct iio_dev *indio_dev,
+			    const struct iio_chan_spec *chan,
+			    int val, int val2, long mask)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+
+	switch (chan->type) {
+	case IIO_PROXIMITY:
+		switch (mask) {
+		case IIO_CHAN_INFO_SAMP_FREQ:
+			return sx9311_set_samp_freq(data, val, val2);
+		default:
+			return -EINVAL;
+		}
+	default:
+		return -EINVAL;
+	}
+}
+
+static irqreturn_t sx9311_irq_handler(int irq, void *private)
+{
+	struct iio_dev *indio_dev = private;
+	struct sx9311_data *data = iio_priv(indio_dev);
+
+	if (data->trigger_enabled)
+		iio_trigger_poll(data->trig);
+
+	/*
+	 * Even if no event is enabled, we need to wake the thread to
+	 * clear the interrupt state by reading SX9311_REG_IRQ_SRC.  It
+	 * is not possible to do that here because regmap_read takes a
+	 * mutex.
+	 */
+	return IRQ_WAKE_THREAD;
+}
+
+static void sx9311_push_events(struct iio_dev *indio_dev)
+{
+	int ret;
+	unsigned int val, chan;
+	struct sx9311_data *data = iio_priv(indio_dev);
+
+	ret = regmap_read(data->regmap, SX9311_REG_STAT0, &val);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "i2c transfer error in irq\n");
+		return;
+	}
+
+	for (chan = 0; chan < SX9311_NUM_CHANNELS; chan++) {
+		int dir;
+		u64 ev;
+		bool new_prox = val & BIT(chan);
+
+		if (!data->event_enabled[chan])
+			continue;
+		if (new_prox == data->prox_stat[chan])
+			/* No change on this channel. */
+			continue;
+
+		dir = new_prox ? IIO_EV_DIR_FALLING : IIO_EV_DIR_RISING;
+		ev = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, chan,
+					  IIO_EV_TYPE_THRESH, dir);
+		iio_push_event(indio_dev, ev, iio_get_time_ns(indio_dev));
+		data->prox_stat[chan] = new_prox;
+	}
+}
+
+static irqreturn_t sx9311_irq_thread_handler(int irq, void *private)
+{
+	struct iio_dev *indio_dev = private;
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret;
+	unsigned int val;
+
+	mutex_lock(&data->mutex);
+
+	ret = regmap_read(data->regmap, SX9311_REG_IRQ_SRC, &val);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "i2c transfer error in irq\n");
+		goto out;
+	}
+
+	if (val & (SX9311_CLOSE_IRQ | SX9311_FAR_IRQ))
+		sx9311_push_events(indio_dev);
+
+	if (val & SX9311_CONVDONE_IRQ)
+		complete(&data->completion);
+
+out:
+	mutex_unlock(&data->mutex);
+
+	return IRQ_HANDLED;
+}
+
+static int sx9311_read_event_config(struct iio_dev *indio_dev,
+				    const struct iio_chan_spec *chan,
+				    enum iio_event_type type,
+				    enum iio_event_direction dir)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+
+	if (chan->type != IIO_PROXIMITY || type != IIO_EV_TYPE_THRESH ||
+	    dir != IIO_EV_DIR_EITHER)
+		return -EINVAL;
+
+	return data->event_enabled[chan->channel & SX9311_CHAN_MASK];
+}
+
+static int sx9311_write_event_config(struct iio_dev *indio_dev,
+				     const struct iio_chan_spec *chan,
+				     enum iio_event_type type,
+				     enum iio_event_direction dir,
+				     int state)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret, sx_channel = chan->channel & SX9311_CHAN_MASK;
+
+	if (chan->type != IIO_PROXIMITY || type != IIO_EV_TYPE_THRESH ||
+	    dir != IIO_EV_DIR_EITHER)
+		return -EINVAL;
+
+	mutex_lock(&data->mutex);
+
+	if (state == 1) {
+		ret = sx9311_inc_chan_users(data, sx_channel);
+		if (ret < 0)
+			goto out_unlock;
+		ret = sx9311_inc_close_far_users(data);
+		if (ret < 0)
+			goto out_undo_chan;
+	} else {
+		ret = sx9311_dec_chan_users(data, sx_channel);
+		if (ret < 0)
+			goto out_unlock;
+		ret = sx9311_dec_close_far_users(data);
+		if (ret < 0)
+			goto out_undo_chan;
+	}
+
+	data->event_enabled[sx_channel] = state;
+	goto out_unlock;
+
+out_undo_chan:
+	if (state == 1)
+		sx9311_dec_chan_users(data, sx_channel);
+	else
+		sx9311_inc_chan_users(data, sx_channel);
+out_unlock:
+	mutex_unlock(&data->mutex);
+	return ret;
+}
+
+static int sx9311_update_scan_mode(struct iio_dev *indio_dev,
+				   const unsigned long *scan_mask)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+
+	mutex_lock(&data->mutex);
+	kfree(data->buffer);
+	data->buffer = kzalloc(indio_dev->scan_bytes, GFP_KERNEL);
+	mutex_unlock(&data->mutex);
+
+	if (data->buffer == NULL)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static struct attribute *sx9311_attributes[] = {
+	&iio_const_attr_sampling_frequency_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group sx9311_attribute_group = {
+	.attrs = sx9311_attributes,
+};
+
+static const struct iio_info sx9311_info = {
+	.attrs = &sx9311_attribute_group,
+	.read_raw = &sx9311_read_raw,
+	.write_raw = &sx9311_write_raw,
+	.read_event_config = &sx9311_read_event_config,
+	.write_event_config = &sx9311_write_event_config,
+	.update_scan_mode = &sx9311_update_scan_mode,
+};
+
+static int sx9311_set_trigger_state(struct iio_trigger *trig,
+				    bool state)
+{
+	struct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret;
+
+	mutex_lock(&data->mutex);
+
+	if (state)
+		ret = sx9311_inc_data_rdy_users(data);
+	else
+		ret = sx9311_dec_data_rdy_users(data);
+	if (ret < 0)
+		goto out;
+
+	data->trigger_enabled = state;
+
+out:
+	mutex_unlock(&data->mutex);
+
+	return ret;
+}
+
+static const struct iio_trigger_ops sx9311_trigger_ops = {
+	.set_trigger_state = sx9311_set_trigger_state,
+};
+
+static irqreturn_t sx9311_trigger_handler(int irq, void *private)
+{
+	struct iio_poll_func *pf = private;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int val, bit, ret, i = 0;
+
+	mutex_lock(&data->mutex);
+
+	for_each_set_bit(bit, indio_dev->active_scan_mask,
+			 indio_dev->masklength) {
+		ret = sx9311_read_prox_data(data, &indio_dev->channels[bit],
+					    &val);
+		if (ret < 0)
+			goto out;
+
+		data->buffer[i++] = val;
+	}
+
+	iio_push_to_buffers_with_timestamp(indio_dev, data->buffer,
+					   iio_get_time_ns(indio_dev));
+
+out:
+	mutex_unlock(&data->mutex);
+
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+}
+
+static int sx9311_buffer_preenable(struct iio_dev *indio_dev)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret = 0, i;
+
+	mutex_lock(&data->mutex);
+
+	for (i = 0; i < SX9311_NUM_CHANNELS; i++)
+		if (test_bit(i, indio_dev->active_scan_mask)) {
+			ret = sx9311_inc_chan_users(data, i);
+			if (ret)
+				break;
+		}
+
+	if (ret)
+		for (i = i - 1; i >= 0; i--)
+			if (test_bit(i, indio_dev->active_scan_mask))
+				sx9311_dec_chan_users(data, i);
+
+	mutex_unlock(&data->mutex);
+
+	return ret;
+}
+
+static int sx9311_buffer_predisable(struct iio_dev *indio_dev)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret = 0, i;
+
+	iio_triggered_buffer_predisable(indio_dev);
+
+	mutex_lock(&data->mutex);
+
+	for (i = 0; i < SX9311_NUM_CHANNELS; i++)
+		if (test_bit(i, indio_dev->active_scan_mask)) {
+			ret = sx9311_dec_chan_users(data, i);
+			if (ret)
+				break;
+		}
+
+	if (ret)
+		for (i = i - 1; i >= 0; i--)
+			if (test_bit(i, indio_dev->active_scan_mask))
+				sx9311_inc_chan_users(data, i);
+
+	mutex_unlock(&data->mutex);
+
+	return ret;
+}
+
+static const struct iio_buffer_setup_ops sx9311_buffer_setup_ops = {
+	.preenable = sx9311_buffer_preenable,
+	.postenable = iio_triggered_buffer_postenable,
+	.predisable = sx9311_buffer_predisable,
+};
+
+struct sx9311_reg_config {
+	const char *register_name;
+	u8 reg;
+	u8 def;
+};
+
+#define SX9311_REG_CONFIG(_name, _reg, _def) \
+{ \
+	.register_name = SX9311_ACPI_NAME ",reg_" _name, \
+	.reg = SX9311_REG_##_reg, \
+	.def = _def \
+}
+
+static const struct sx9311_reg_config sx9311_default_regs[] = {
+	{
+		.register_name = NULL,
+		.reg = SX9311_REG_IRQ_MSK,
+		.def = 0x60,
+	},
+	{
+		.register_name = NULL,
+		.reg = SX9311_REG_IRQ_FUNC,
+		.def = 0x00,
+	},
+	/*
+	 * The lower 4 bits should not be set as it enable sensors measurements.
+	 * Turning the detection on before the configuration values are set to
+	 * good values can cause the device to return erroneous readings.
+	 */
+	SX9311_REG_CONFIG("prox_ctrl0",  PROX_CTRL0,  0x23),
+	SX9311_REG_CONFIG("prox_ctrl1",  PROX_CTRL1,  0x00),
+	SX9311_REG_CONFIG("prox_ctrl2",  PROX_CTRL2,  0x0B),
+	SX9311_REG_CONFIG("prox_ctrl3",  PROX_CTRL3,  0x0F),
+	SX9311_REG_CONFIG("prox_ctrl4",  PROX_CTRL4,  0x0D),
+	SX9311_REG_CONFIG("prox_ctrl5",  PROX_CTRL5,  0xC3),
+	SX9311_REG_CONFIG("prox_ctrl6",  PROX_CTRL6,  0x20),
+	SX9311_REG_CONFIG("prox_ctrl7",  PROX_CTRL7,  0x4C),
+	SX9311_REG_CONFIG("prox_ctrl8",  PROX_CTRL8,  0x68),
+	SX9311_REG_CONFIG("prox_ctrl9",  PROX_CTRL9,  0x68),
+	SX9311_REG_CONFIG("prox_ctrl10", PROX_CTRL10, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl11", PROX_CTRL11, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl12", PROX_CTRL12, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl13", PROX_CTRL13, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl14", PROX_CTRL14, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl15", PROX_CTRL15, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl16", PROX_CTRL16, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl17", PROX_CTRL17, 0x04),
+	SX9311_REG_CONFIG("prox_ctrl18", PROX_CTRL18, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl19", PROX_CTRL19, 0x00),
+	SX9311_REG_CONFIG("sar_ctrl0",   SAR_CTRL0,   0x00),
+	SX9311_REG_CONFIG("sar_ctrl1",   SAR_CTRL1,   0x80),
+	SX9311_REG_CONFIG("sar_ctrl2",   SAR_CTRL2,   0x0C),
+};
+
+static int sx9311_read_register_property(struct acpi_device *adev,
+					const struct sx9311_reg_config *cfg,
+					u8 *value)
+{
+	/* FIXME: only ACPI supported. */
+	const union acpi_object *acpi_value = NULL;
+	int ret;
+
+	if ((adev == NULL) || (cfg->register_name == NULL)) {
+		*value = cfg->def;
+		return 0;
+	}
+
+	ret = acpi_dev_get_property(adev, cfg->register_name,
+				    ACPI_TYPE_INTEGER, &acpi_value);
+	switch (ret) {
+	case -EPROTO:
+		break;
+	case -EINVAL:
+		break;
+	}
+
+	*value = acpi_value ? (u8)acpi_value->integer.value : cfg->def;
+	return 0;
+}
+
+static int sx9311_load_config(struct device *dev, struct regmap *regmap)
+{
+	u8 val;
+	int i, ret;
+	const struct sx9311_reg_config *cfg;
+	struct acpi_device *adev = ACPI_COMPANION(dev);
+
+	if (adev == NULL)
+		dev_warn(dev, "ACPI configuration missing\n");
+
+	for (i = 0; i < ARRAY_SIZE(sx9311_default_regs); ++i) {
+		cfg = &sx9311_default_regs[i];
+		ret = sx9311_read_register_property(adev, cfg, &val);
+		if (ret < 0)
+			return ret;
+		ret = regmap_write(regmap, cfg->reg, val);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+/* Activate all channels and perform an initial compensation. */
+static int sx9311_init_compensation(struct iio_dev *indio_dev)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int i, ret;
+	unsigned int val;
+	unsigned int ctrl0;
+
+	ret = regmap_read(data->regmap, SX9311_REG_PROX_CTRL0, &ctrl0);
+	if (ret < 0)
+		return ret;
+
+	/* run the compensation phase on all channels */
+	ret = regmap_write(data->regmap, SX9311_REG_PROX_CTRL0, ctrl0 | 0xF);
+	if (ret < 0)
+		return ret;
+
+	for (i = 100; i >= 0; i--) {
+		usleep_range(10000, 20000);
+		ret = regmap_read(data->regmap, SX9311_REG_STAT1, &val);
+		if (ret < 0)
+			goto out;
+		if (!(val & SX9311_COMPSTAT_MASK))
+			break;
+	}
+
+	if (i < 0) {
+		dev_err(&data->client->dev,
+			"initial compensation timed out: 0x%02x", val);
+		ret = -ETIMEDOUT;
+	}
+
+out:
+	regmap_write(data->regmap, SX9311_REG_PROX_CTRL0, ctrl0);
+	return ret;
+}
+
+static int sx9311_init_device(struct iio_dev *indio_dev)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret;
+	unsigned int val;
+
+	ret = regmap_write(data->regmap, SX9311_REG_IRQ_MSK, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_write(data->regmap, SX9311_REG_RESET,
+			   SX9311_SOFT_RESET);
+	if (ret < 0)
+		return ret;
+
+	usleep_range(1000, 2000);  /* power-up time is ~1ms. */
+
+	ret = regmap_write(data->regmap, SX9311_REG_RESET, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_read(data->regmap, SX9311_REG_IRQ_SRC, &val);
+	if (ret < 0)
+		return ret;
+
+	ret = sx9311_load_config(&indio_dev->dev, data->regmap);
+	if (ret < 0)
+		return ret;
+
+	return sx9311_init_compensation(indio_dev);
+}
+
+static int sx9311_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int ret;
+	struct iio_dev *indio_dev;
+	struct sx9311_data *data;
+	unsigned int whoami;
+
+	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
+	if (indio_dev == NULL)
+		return -ENOMEM;
+
+	data = iio_priv(indio_dev);
+	data->client = client;
+	mutex_init(&data->mutex);
+	init_completion(&data->completion);
+	data->trigger_enabled = false;
+
+	data->regmap = devm_regmap_init_i2c(client, &sx9311_regmap_config);
+	if (IS_ERR(data->regmap))
+		return PTR_ERR(data->regmap);
+
+	ret = regmap_read(data->regmap, SX9311_REG_WHOAMI, &whoami);
+	if (ret < 0) {
+		dev_err(&client->dev,
+				"error in reading WHOAMI register: %d", ret);
+		return -ENODEV;
+	}
+	if (whoami != SX9311_WHOAMI_VALUE) {
+		dev_err(&client->dev, "unexpected WHOAMI response: %u", whoami);
+		return -ENODEV;
+	}
+
+	ACPI_COMPANION_SET(&indio_dev->dev, ACPI_COMPANION(&client->dev));
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->name = SX9311_DRIVER_NAME;
+	indio_dev->channels = sx9311_channels;
+	indio_dev->num_channels = ARRAY_SIZE(sx9311_channels);
+	indio_dev->info = &sx9311_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	i2c_set_clientdata(client, indio_dev);
+
+	ret = sx9311_init_device(indio_dev);
+	if (ret < 0)
+		return ret;
+
+	if (client->irq <= 0)
+		dev_warn(&client->dev, "no valid irq found\n");
+	else {
+		ret = devm_request_threaded_irq(&client->dev, client->irq,
+				sx9311_irq_handler, sx9311_irq_thread_handler,
+				IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+				SX9311_IRQ_NAME, indio_dev);
+		if (ret < 0)
+			return ret;
+
+		data->trig = devm_iio_trigger_alloc(&client->dev,
+				"%s-dev%d", indio_dev->name, indio_dev->id);
+		if (!data->trig)
+			return -ENOMEM;
+
+		data->trig->dev.parent = &client->dev;
+		data->trig->ops = &sx9311_trigger_ops;
+		iio_trigger_set_drvdata(data->trig, indio_dev);
+
+		ret = iio_trigger_register(data->trig);
+		if (ret)
+			return ret;
+	}
+
+	ret = devm_iio_triggered_buffer_setup(&client->dev, indio_dev,
+					      NULL, sx9311_trigger_handler,
+					      &sx9311_buffer_setup_ops);
+	if (ret < 0)
+		goto out_trigger_unregister;
+
+	ret = devm_iio_device_register(&client->dev, indio_dev);
+	if (ret < 0)
+		goto out_trigger_unregister;
+
+	return 0;
+
+out_trigger_unregister:
+	if (client->irq > 0)
+		iio_trigger_unregister(data->trig);
+
+	return ret;
+}
+
+static int sx9311_remove(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct sx9311_data *data = iio_priv(indio_dev);
+
+	if (client->irq > 0)
+		iio_trigger_unregister(data->trig);
+	kfree(data->buffer);
+	return 0;
+}
+
+static int __maybe_unused sx9311_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret;
+
+	disable_irq_nosync(data->client->irq);
+
+	mutex_lock(&data->mutex);
+	ret = regmap_write(data->regmap, SX9311_REG_PAUSE, 0);
+	mutex_unlock(&data->mutex);
+
+	return ret;
+}
+
+static int __maybe_unused sx9311_resume(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret;
+
+	mutex_lock(&data->mutex);
+	ret = regmap_write(data->regmap, SX9311_REG_PAUSE, 1);
+	mutex_unlock(&data->mutex);
+
+	enable_irq(data->client->irq);
+
+	return ret;
+}
+
+static const struct dev_pm_ops sx9311_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sx9311_suspend, sx9311_resume)
+};
+
+static const struct acpi_device_id sx9311_acpi_match[] = {
+	{SX9311_ACPI_NAME, 0},
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, sx9311_acpi_match);
+
+static const struct of_device_id sx9311_of_match[] = {
+	{ .compatible = "semtech," SX9311_DRIVER_NAME, },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, sx9311_of_match);
+
+static const struct i2c_device_id sx9311_id[] = {
+	{SX9311_DRIVER_NAME, 0},
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, sx9311_id);
+
+static struct i2c_driver sx9311_driver = {
+	.driver = {
+		.name	= SX9311_DRIVER_NAME,
+		.acpi_match_table = ACPI_PTR(sx9311_acpi_match),
+		.of_match_table = of_match_ptr(sx9311_of_match),
+		.pm = &sx9311_pm_ops,
+	},
+	.probe		= sx9311_probe,
+	.remove		= sx9311_remove,
+	.id_table	= sx9311_id,
+};
+module_i2c_driver(sx9311_driver);
+
+MODULE_AUTHOR("Phoenix Wu <wujing6@huaqin.corp-partner.google.com>");
+MODULE_DESCRIPTION("Driver for Semtech SX9311 proximity sensor");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
index 6e9af1a15bf6..91786567cebc 100644
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -2455,7 +2455,7 @@ int ath10k_core_start(struct ath10k *ar, enum ath10k_firmware_mode mode,
 		goto err_hif_stop;
 	}
 
-	status = ath10k_hif_swap_mailbox(ar);
+	status = ath10k_hif_swap_mailbox(ar, mode);
 	if (status) {
 		ath10k_err(ar, "failed to swap mailbox: %d\n", status);
 		goto err_hif_stop;
diff --git a/drivers/net/wireless/ath/ath10k/hif.h b/drivers/net/wireless/ath/ath10k/hif.h
index 5f7f1e08866f..5c342a1a2b9a 100644
--- a/drivers/net/wireless/ath/ath10k/hif.h
+++ b/drivers/net/wireless/ath/ath10k/hif.h
@@ -59,7 +59,7 @@ struct ath10k_hif_ops {
 	 */
 	void (*stop)(struct ath10k *ar);
 
-	int (*swap_mailbox)(struct ath10k *ar);
+	int (*swap_mailbox)(struct ath10k *ar, enum ath10k_firmware_mode mode);
 
 	int (*map_service_to_pipe)(struct ath10k *ar, u16 service_id,
 				   u8 *ul_pipe, u8 *dl_pipe);
@@ -141,10 +141,10 @@ static inline void ath10k_hif_stop(struct ath10k *ar)
 	return ar->hif.ops->stop(ar);
 }
 
-static inline int ath10k_hif_swap_mailbox(struct ath10k *ar)
+static inline int ath10k_hif_swap_mailbox(struct ath10k *ar, enum ath10k_firmware_mode mode)
 {
 	if (ar->hif.ops->swap_mailbox)
-		return ar->hif.ops->swap_mailbox(ar);
+		return ar->hif.ops->swap_mailbox(ar, mode);
 	return 0;
 }
 
diff --git a/drivers/net/wireless/ath/ath10k/sdio.c b/drivers/net/wireless/ath/ath10k/sdio.c
index 35a7ff36f821..1d7f00171dc8 100644
--- a/drivers/net/wireless/ath/ath10k/sdio.c
+++ b/drivers/net/wireless/ath/ath10k/sdio.c
@@ -1633,7 +1633,7 @@ static int ath10k_sdio_hif_diag_write_mem(struct ath10k *ar, u32 address,
 	return 0;
 }
 
-static int ath10k_sdio_hif_swap_mailbox(struct ath10k *ar)
+static int ath10k_sdio_hif_swap_mailbox(struct ath10k *ar, enum ath10k_firmware_mode mode)
 {
 	struct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);
 	u32 addr, val;
@@ -1652,6 +1652,8 @@ static int ath10k_sdio_hif_swap_mailbox(struct ath10k *ar)
 			   "sdio mailbox swap service enabled\n");
 		ar_sdio->swap_mbox = true;
 	}
+        if(mode == ATH10K_FIRMWARE_MODE_UTF)
+                ar_sdio->swap_mbox = false;
 	return 0;
 }
 
diff --git a/drivers/thermal/mtk_thermal.c b/drivers/thermal/mtk_thermal.c
old mode 100644
new mode 100755
index e4ea7f6aef20..61a18c0d271c
--- a/drivers/thermal/mtk_thermal.c
+++ b/drivers/thermal/mtk_thermal.c
@@ -219,6 +219,9 @@ enum {
 /* The total number of temperature sensors in the MT8183 */
 #define MT8183_NUM_SENSORS	6
 
+/* The number of banks in the MT8183 */
+#define MT8183_NUM_ZONES               5
+
 /* The number of sensing points per bank */
 #define MT8183_NUM_SENSORS_PER_ZONE	 6
 
@@ -275,8 +278,12 @@ struct mtk_thermal {
 };
 
 /* MT8183 thermal sensor data */
-static const int mt8183_bank_data[MT8183_NUM_SENSORS] = {
-	MT8183_TS1, MT8183_TS2, MT8183_TS3, MT8183_TS4, MT8183_TS5, MT8183_TSABB
+static const int mt8183_bank_data[MT8183_NUM_ZONES][2] = {
+	{MT8183_TS1},
+	{MT8183_TS2},
+	{MT8183_TS3},
+	{MT8183_TS4},
+	{MT8183_TS5},
 };
 
 static const int mt8183_msr[MT8183_NUM_SENSORS_PER_ZONE] = {
@@ -506,7 +513,7 @@ static const struct mtk_thermal_data mt7622_thermal_data = {
 
 static const struct mtk_thermal_data mt8183_thermal_data = {
 	.auxadc_channel = MT8183_TEMP_AUXADC_CHANNEL,
-	.num_banks = MT8183_NUM_SENSORS_PER_ZONE,
+	.num_banks = MT8183_NUM_ZONES,
 	.num_sensors = MT8183_NUM_SENSORS,
 	.vts_index = mt8183_vts_index,
 	.cali_val = MT8183_CALIBRATION,
@@ -515,8 +522,24 @@ static const struct mtk_thermal_data mt8183_thermal_data = {
 	.need_switch_bank = false,
 	.bank_data = {
 		{
-			.num_sensors = 6,
-			.sensors = mt8183_bank_data,
+			.num_sensors = 1,
+			.sensors = mt8183_bank_data[0],
+		},
+                {
+			.num_sensors = 1,
+			.sensors = mt8183_bank_data[1],
+		},
+		{
+			.num_sensors = 1,
+			.sensors = mt8183_bank_data[2],
+		},
+		{
+			.num_sensors = 1,
+			.sensors = mt8183_bank_data[3],
+		},
+		{
+			.num_sensors = 1,
+			.sensors = mt8183_bank_data[4],
 		},
 	},
 
@@ -605,7 +628,6 @@ static int mtk_thermal_bank_temperature(struct mtk_thermal_bank *bank)
 		temp = raw_to_mcelsius(mt,
 				       conf->bank_data[bank->id].sensors[i],
 				       raw);
-
 		/*
 		 * The first read of a sensor often contains very high bogus
 		 * temperature value. Filter these out so that the system does
@@ -617,7 +639,6 @@ static int mtk_thermal_bank_temperature(struct mtk_thermal_bank *bank)
 		if (temp > max)
 			max = temp;
 	}
-
 	return max;
 }
 
@@ -642,10 +663,80 @@ static int mtk_read_temp(void *data, int *temperature)
 	return 0;
 }
 
+static int mtk_read_zone1_temp(void *data, int *temperature)
+{
+        struct mtk_thermal *mt = data;
+	struct mtk_thermal_bank *bank = &mt->banks[0];
+
+        *temperature = mtk_thermal_bank_temperature(bank);
+
+	return 0;
+}
+
+static int mtk_read_zone2_temp(void *data, int *temperature)
+{
+        struct mtk_thermal *mt = data;
+        struct mtk_thermal_bank *bank = &mt->banks[1];
+
+        *temperature = mtk_thermal_bank_temperature(bank);
+
+        return 0;
+}
+
+static int mtk_read_zone3_temp(void *data, int *temperature)
+{
+        struct mtk_thermal *mt = data;
+        struct mtk_thermal_bank *bank = &mt->banks[2];
+
+        *temperature = mtk_thermal_bank_temperature(bank);
+
+        return 0;
+}
+
+static int mtk_read_zone4_temp(void *data, int *temperature)
+{
+        struct mtk_thermal *mt = data;
+        struct mtk_thermal_bank *bank = &mt->banks[3];
+
+        *temperature = mtk_thermal_bank_temperature(bank);
+
+        return 0;
+}
+
+static int mtk_read_zone5_temp(void *data, int *temperature)
+{
+        struct mtk_thermal *mt = data;
+        struct mtk_thermal_bank *bank = &mt->banks[4];
+
+        *temperature = mtk_thermal_bank_temperature(bank);
+
+        return 0;
+}
+
 static const struct thermal_zone_of_device_ops mtk_thermal_ops = {
 	.get_temp = mtk_read_temp,
 };
 
+static const struct thermal_zone_of_device_ops mtk_thermal_zone1_ops = {
+        .get_temp = mtk_read_zone1_temp,
+};
+
+static const struct thermal_zone_of_device_ops mtk_thermal_zone2_ops = {
+        .get_temp = mtk_read_zone2_temp,
+};
+
+static const struct thermal_zone_of_device_ops mtk_thermal_zone3_ops = {
+        .get_temp = mtk_read_zone3_temp,
+};
+
+static const struct thermal_zone_of_device_ops mtk_thermal_zone4_ops = {
+        .get_temp = mtk_read_zone4_temp,
+};
+
+static const struct thermal_zone_of_device_ops mtk_thermal_zone5_ops = {
+        .get_temp = mtk_read_zone5_temp,
+};
+
 static void mtk_thermal_init_bank(struct mtk_thermal *mt, int num,
 				  u32 apmixed_phys_base, u32 auxadc_phys_base,
 				  int ctrl_id)
@@ -960,7 +1051,17 @@ static int mtk_thermal_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, mt);
 
 	tzdev = devm_thermal_zone_of_sensor_register(&pdev->dev, 0, mt,
-						     &mtk_thermal_ops);
+							&mtk_thermal_ops);
+        tzdev = devm_thermal_zone_of_sensor_register(&pdev->dev, 1, mt,
+							&mtk_thermal_zone1_ops);
+	tzdev = devm_thermal_zone_of_sensor_register(&pdev->dev, 2, mt,
+							&mtk_thermal_zone2_ops);
+	tzdev = devm_thermal_zone_of_sensor_register(&pdev->dev, 3, mt,
+							&mtk_thermal_zone3_ops);
+	tzdev = devm_thermal_zone_of_sensor_register(&pdev->dev, 4, mt,
+							&mtk_thermal_zone4_ops);
+	tzdev = devm_thermal_zone_of_sensor_register(&pdev->dev, 5, mt,
+							&mtk_thermal_zone5_ops);
 	if (IS_ERR(tzdev)) {
 		ret = PTR_ERR(tzdev);
 		goto err_disable_clk_peri_therm;
diff --git a/sound/soc/codecs/max98357a.c b/sound/soc/codecs/max98357a.c
index 9aac1fda94c8..cfecbdaa5853 100644
--- a/sound/soc/codecs/max98357a.c
+++ b/sound/soc/codecs/max98357a.c
@@ -69,12 +69,54 @@ static int max98357a_daiops_trigger(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+static const char * const ext_spk_text[] = {
+	"Off", "On"
+};
+
+static const struct soc_enum ext_spk_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0,
+		ARRAY_SIZE(ext_spk_text), ext_spk_text);
+
+
+static const struct snd_kcontrol_new ext_spk_mux =
+	SOC_DAPM_ENUM("Ext Spk Switch Mux", ext_spk_enum);
+
+
+static int max98357a_enable_spk_pa(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *cmpnt = snd_soc_dapm_to_component(w->dapm);
+	struct max98357a_priv *max98357a = snd_soc_component_get_drvdata(cmpnt);
+
+	if (!max98357a->sdmode)
+		return 0;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		queue_delayed_work(system_power_efficient_wq,
+				&max98357a->enable_sdmode_work,
+				msecs_to_jiffies(max98357a->sdmode_delay));
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		cancel_delayed_work(&max98357a->enable_sdmode_work);
+		gpiod_set_value(max98357a->sdmode, 0);
+		break;
+	}
+	return 0;
+}
+
 static const struct snd_soc_dapm_widget max98357a_dapm_widgets[] = {
 	SND_SOC_DAPM_OUTPUT("Speaker"),
+	SND_SOC_DAPM_SPK("Spk PA", max98357a_enable_spk_pa),
+	SND_SOC_DAPM_MUX("Spk PA Switch", SND_SOC_NOPM, 0, 0,
+			&ext_spk_mux),
 };
 
 static const struct snd_soc_dapm_route max98357a_dapm_routes[] = {
 	{"Speaker", NULL, "HiFi Playback"},
+	{"Speaker", NULL, "Spk PA"},
+	{"Spk PA", NULL, "Spk PA Switch"},
+	{"Spk PA Switch", "On", "HiFi Playback1"},
 };
 
 static int max98357a_component_probe(struct snd_soc_component *component)
@@ -119,23 +161,43 @@ static const struct snd_soc_dai_ops max98357a_dai_ops = {
 	.trigger	= max98357a_daiops_trigger,
 };
 
-static struct snd_soc_dai_driver max98357a_dai_driver = {
-	.name = "HiFi",
-	.playback = {
-		.stream_name	= "HiFi Playback",
-		.formats	= SNDRV_PCM_FMTBIT_S16 |
-					SNDRV_PCM_FMTBIT_S24 |
-					SNDRV_PCM_FMTBIT_S32,
-		.rates		= SNDRV_PCM_RATE_8000 |
-					SNDRV_PCM_RATE_16000 |
-					SNDRV_PCM_RATE_48000 |
-					SNDRV_PCM_RATE_96000,
-		.rate_min	= 8000,
-		.rate_max	= 96000,
-		.channels_min	= 1,
-		.channels_max	= 2,
+static struct snd_soc_dai_driver max98357a_dai_driver[] = {
+	{
+		.name = "HiFi",
+		.playback = {
+			.stream_name	= "HiFi Playback",
+			.formats	= SNDRV_PCM_FMTBIT_S16 |
+						SNDRV_PCM_FMTBIT_S24 |
+						SNDRV_PCM_FMTBIT_S32,
+			.rates		= SNDRV_PCM_RATE_8000 |
+						SNDRV_PCM_RATE_16000 |
+						SNDRV_PCM_RATE_48000 |
+						SNDRV_PCM_RATE_96000,
+			.rate_min	= 8000,
+			.rate_max	= 96000,
+			.channels_min	= 1,
+			.channels_max	= 2,
+		},
+		.ops    = &max98357a_dai_ops,
+	},
+	{
+		.name = "max98357a-hifi",
+		.playback = {
+			.stream_name	= "HiFi Playback1",
+			.formats	= SNDRV_PCM_FMTBIT_S16 |
+						SNDRV_PCM_FMTBIT_S24 |
+						SNDRV_PCM_FMTBIT_S32,
+			.rates		= SNDRV_PCM_RATE_8000 |
+						SNDRV_PCM_RATE_16000 |
+						SNDRV_PCM_RATE_48000 |
+						SNDRV_PCM_RATE_96000,
+			.rate_min	= 8000,
+			.rate_max	= 96000,
+			.channels_min	= 1,
+			.channels_max	= 2,
+		},
+		.ops    = NULL,
 	},
-	.ops    = &max98357a_dai_ops,
 };
 
 static int max98357a_platform_probe(struct platform_device *pdev)
@@ -161,7 +223,7 @@ static int max98357a_platform_probe(struct platform_device *pdev)
 
 	return devm_snd_soc_register_component(&pdev->dev,
 			&max98357a_component_driver,
-			&max98357a_dai_driver, 1);
+			max98357a_dai_driver, ARRAY_SIZE(max98357a_dai_driver));
 }
 
 static int max98357a_platform_remove(struct platform_device *pdev)
diff --git a/sound/soc/mediatek/mt8183/mt8183-da7219-max98357.c b/sound/soc/mediatek/mt8183/mt8183-da7219-max98357.c
old mode 100644
new mode 100755
index 1e7e8aed8707..c25ed84e2117
--- a/sound/soc/mediatek/mt8183/mt8183-da7219-max98357.c
+++ b/sound/soc/mediatek/mt8183/mt8183-da7219-max98357.c
@@ -34,7 +34,7 @@ static struct snd_soc_dai_link_component
 mt8183_da7219_max98357_external_codecs[] = {
 	{
 		.name = "max98357a",
-		.dai_name = "HiFi",
+		.dai_name = "max98357a-hifi",
 	},
 	{
 		.name = "da7219.5-001a",
-- 
2.21.0.593.g511ec345e18-goog

