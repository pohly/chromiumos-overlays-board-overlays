diff --git a/Documentation/devicetree/bindings/display/panel/boe,himax8279d.txt b/Documentation/devicetree/bindings/display/panel/boe,himax8279d.txt
new file mode 100644
index 000000000000..3caea2172b1b
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/panel/boe,himax8279d.txt
@@ -0,0 +1,24 @@
+Boe Himax8279d 1200x1920 TFT LCD panel
+
+Required properties:
+- compatible: should be "boe,himax8279d8p" and one of: "boe,himax8279d10p"
+- reg: DSI virtual channel of the peripheral
+- enable-gpios: panel enable gpio
+- pp33-gpios: a GPIO phandle for the 3.3v pin that provides the supply voltage
+- pp18-gpios: a GPIO phandle for the 1.8v pin that provides the supply voltage
+
+Optional properties:
+- backlight: phandle of the backlight device attached to the panel
+
+Example:
+
+	&mipi_dsi {
+		panel {
+			compatible = "boe,himax8279d8p", "boe,himax8279d10p";
+			reg = <0>;
+			backlight = <&backlight>;
+			enable-gpios = <&gpio 45 GPIO_ACTIVE_HIGH>;
+			pp33-gpios = <&gpio 35 GPIO_ACTIVE_HIGH>;
+			pp18-gpios = <&gpio 36 GPIO_ACTIVE_HIGH>;
+		};
+	};
diff --git a/Documentation/devicetree/bindings/iio/proximity/sx9311.txt b/Documentation/devicetree/bindings/iio/proximity/sx9311.txt
new file mode 100644
index 000000000000..65a1114e4147
--- /dev/null
+++ b/Documentation/devicetree/bindings/iio/proximity/sx9311.txt
@@ -0,0 +1,19 @@
+Semtech's SX9311 capacitive proximity device driver
+
+Required properties:
+	- compatible: must be "semtech,sx9311"
+	- reg: i2c address where to find the device
+	- interrupts : the sole interrupt generated by the device
+
+	Refer to interrupt-controller/interrupts.txt for generic
+	interrupt client node bindings.
+
+Example:
+
+sx9311@28 {
+		compatible = "semtech,sx9311";
+		reg = <0x28>;
+		interrupt-parent = <&pio>;
+		interrupts = <5 IRQ_TYPE_LEVEL_LOW 5 0>;
+		int-gpio = <&pio 5 0>;
+	};
diff --git a/MAINTAINERS b/MAINTAINERS
index 1e4e16751d83..7c7d0b6bd983 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -4632,6 +4632,12 @@ T:	git git://anongit.freedesktop.org/drm/drm-misc
 S:	Maintained
 F:	drivers/gpu/drm/bochs/
 
+DRM DRIVER FOR BOE HIMAX8279D PANELS
+M:	Jerry Han <hanxu5@huaqin.corp-partner.google.com>
+S:	Maintained
+F:	drivers/gpu/drm/panel/panel-boe-himax8279d.c
+F:	Documentation/devicetree/bindings/display/panel/boe,himax8279d.txt
+
 DRM DRIVER FOR FARADAY TVE200 TV ENCODER
 M:	Linus Walleij <linus.walleij@linaro.org>
 T:	git git://anongit.freedesktop.org/drm/drm-misc
diff --git a/README b/README
index 768caa3970ef..185abb9dd570 100644
--- a/README
+++ b/README
@@ -1,3 +1,4 @@
+HUAQIN FLAPJACK TOT
 MTK TOT
 Linux kernel
 ============
diff --git a/arch/arm64/boot/dts/mediatek/Makefile b/arch/arm64/boot/dts/mediatek/Makefile
index 3a55c454b65d..285e05e7c0a6 100644
--- a/arch/arm64/boot/dts/mediatek/Makefile
+++ b/arch/arm64/boot/dts/mediatek/Makefile
@@ -10,3 +10,5 @@ dtb-$(CONFIG_ARCH_MEDIATEK) += mt8173-evb.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-evb.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-kukui-rev1.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-kukui-rev2.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-flapjack-rev3-sku1-hwconfig1.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-flapjack-rev3-sku3-hwconfig0.dtb
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev3-sku1-hwconfig1.dts b/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev3-sku1-hwconfig1.dts
new file mode 100644
index 000000000000..687ebf0c07c1
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev3-sku1-hwconfig1.dts
@@ -0,0 +1,255 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/dts-v1/;
+#include "mt8183-flapjack.dtsi"
+
+/ {
+	model = "MediaTek Flapjack Rev 3 board Sku 1 BOE Himax8279D8P";
+	compatible = "google,flapjack-rev3-sku1-hwconfig1",
+		     "google,flapjack-rev0-sku0-hwconfig1",
+		     "google,flapjack-rev3-sku1",
+		     "google,flapjack-rev3", "google,flapjack",
+		     "google,kukui", "mediatek,mt8183";
+};
+
+&dsi0 {
+	/delete-node/ panel@0;
+	panel: panel@0 {
+		compatible = "boe,himax8279d8p";
+		reg = <0>;
+		enable-gpios = <&pio 45 0>;
+		pp33-gpios = <&pio 35 0>;
+		pp18-gpios = <&pio 36 0>;
+		pinctrl-names = "default", "state_3300mv", "state_1800mv";
+		pinctrl-0 = <&panel_pins_default>;
+		pinctrl-1 = <&panel_pins_3300mv>;
+		pinctrl-2 = <&panel_pins_1800mv>;
+		backlight = <&backlight_lcd0>;
+		status = "okay";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&pio {
+	/* 192 lines */
+	gpio-line-names =
+		"SPI_AP_EC_CS_L",
+		"SPI_AP_EC_MOSI",
+		"SPI_AP_EC_CLK",
+		"I2S3_DO",
+		"USB_PD_INT_ODL",
+		"",
+		"",
+		"",
+		"",
+		"IT6505_HPD_L",
+		"I2S3_TDM_D3",
+		"SOC_I2C6_1V8_SCL",
+		"SOC_I2C6_1V8_SDA",
+		"DPI_D0",
+		"DPI_D1",
+		"DPI_D2",
+		"DPI_D3",
+		"DPI_D4",
+		"DPI_D5",
+		"DPI_D6",
+		"DPI_D7",
+		"DPI_D8",
+		"DPI_D9",
+		"DPI_D10",
+		"DPI_D11",
+		"DPI_HSYNC",
+		"DPI_VSYNC",
+		"DPI_DE",
+		"DPI_CK",
+		"AP_MSDC1_CLK",
+		"AP_MSDC1_DAT3",
+		"AP_MSDC1_CMD",
+		"AP_MSDC1_DAT0",
+		"AP_MSDC1_DAT2",
+		"AP_MSDC1_DAT1",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"OTG_EN",
+		"DRVBUS",
+		"DISP_PWM",
+		"DSI_TE",
+		"LCM_RST_1V8",
+		"AP_CTS_WIFI_RTS",
+		"AP_RTS_WIFI_CTS",
+		"SOC_I2C5_1V8_SCL",
+		"SOC_I2C5_1V8_SDA",
+		"SOC_I2C3_1V8_SCL",
+		"SOC_I2C3_1V8_SDA",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"SOC_I2C1_1V8_SDA",
+		"SOC_I2C0_1V8_SDA",
+		"SOC_I2C0_1V8_SCL",
+		"SOC_I2C1_1V8_SCL",
+		"AP_SPI_H1_MISO",
+		"AP_SPI_H1_CS_L",
+		"AP_SPI_H1_MOSI",
+		"AP_SPI_H1_CLK",
+		"I2S5_BCK",
+		"I2S5_LRCK",
+		"I2S5_DO",
+		"BOOTBLOCK_EN_L",
+		"MT8183_KPCOL0",
+		"SPI_AP_EC_MISO",
+		"UART_DBG_TX_AP_RX",
+		"UART_AP_TX_DBG_RX",
+		"I2S2_MCK",
+		"I2S2_BCK",
+		"CLK_5M_WCAM",
+		"CLK_2M_UCAM",
+		"I2S2_LRCK",
+		"I2S2_DI",
+		"SOC_I2C2_1V8_SCL",
+		"SOC_I2C2_1V8_SDA",
+		"SOC_I2C4_1V8_SCL",
+		"SOC_I2C4_1V8_SDA",
+		"",
+		"SCL8",
+		"SDA8",
+		"FCAM_PWDN_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		/*
+		 * AP_FLASH_WP_L is crossystem ABI. Rev1 schematics
+		 * call it BIOS_FLASH_WP_R_L.
+		 */
+		"AP_FLASH_WP_L",
+		"EC_AP_INT_ODL",
+		"IT6505_INT_ODL",
+		"H1_INT_OD_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"AP_SPI_FLASH_MISO",
+		"AP_SPI_FLASH_CS_L",
+		"AP_SPI_FLASH_MOSI",
+		"AP_SPI_FLASH_CLK",
+		"DA7219_IRQ",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"";
+};
+
+&scp_pins {
+	/* EINT pins are used for other purpose on rev2. */
+	/delete-node/ pins_eint;
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev3-sku3-hwconfig0.dts b/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev3-sku3-hwconfig0.dts
new file mode 100644
index 000000000000..00305b341f0b
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-flapjack-rev3-sku3-hwconfig0.dts
@@ -0,0 +1,257 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ *
+ * Device Tree Source for the Google flapjack board
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/dts-v1/;
+#include "mt8183-flapjack.dtsi"
+
+/ {
+	model = "MediaTek Flapjack Rev 3 board Sku 3 BOE Himax8279D10P";
+	compatible = "google,flapjack-rev3-sku3-hwconfig0",
+		     "google,flapjack-rev0-sku0-hwconfig0",
+		     "google,flapjack-rev3-sku3",
+		     "google,flapjack-rev3", "google,flapjack",
+		     "google,kukui", "mediatek,mt8183";
+};
+
+&dsi0 {
+	/delete-node/ panel@0;
+	panel: panel@0 {
+		compatible = "boe,himax8279d10p";
+		reg = <0>;
+		enable-gpios = <&pio 45 0>;
+		pp33-gpios = <&pio 35 0>;
+		pp18-gpios = <&pio 36 0>;
+		pinctrl-names = "default", "state_3300mv", "state_1800mv";
+		pinctrl-0 = <&panel_pins_default>;
+		pinctrl-1 = <&panel_pins_3300mv>;
+		pinctrl-2 = <&panel_pins_1800mv>;
+		backlight = <&backlight_lcd0>;
+		status = "okay";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&pio {
+	/* 192 lines */
+	gpio-line-names =
+		"SPI_AP_EC_CS_L",
+		"SPI_AP_EC_MOSI",
+		"SPI_AP_EC_CLK",
+		"I2S3_DO",
+		"USB_PD_INT_ODL",
+		"",
+		"",
+		"",
+		"",
+		"IT6505_HPD_L",
+		"I2S3_TDM_D3",
+		"SOC_I2C6_1V8_SCL",
+		"SOC_I2C6_1V8_SDA",
+		"DPI_D0",
+		"DPI_D1",
+		"DPI_D2",
+		"DPI_D3",
+		"DPI_D4",
+		"DPI_D5",
+		"DPI_D6",
+		"DPI_D7",
+		"DPI_D8",
+		"DPI_D9",
+		"DPI_D10",
+		"DPI_D11",
+		"DPI_HSYNC",
+		"DPI_VSYNC",
+		"DPI_DE",
+		"DPI_CK",
+		"AP_MSDC1_CLK",
+		"AP_MSDC1_DAT3",
+		"AP_MSDC1_CMD",
+		"AP_MSDC1_DAT0",
+		"AP_MSDC1_DAT2",
+		"AP_MSDC1_DAT1",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"OTG_EN",
+		"DRVBUS",
+		"DISP_PWM",
+		"DSI_TE",
+		"LCM_RST_1V8",
+		"AP_CTS_WIFI_RTS",
+		"AP_RTS_WIFI_CTS",
+		"SOC_I2C5_1V8_SCL",
+		"SOC_I2C5_1V8_SDA",
+		"SOC_I2C3_1V8_SCL",
+		"SOC_I2C3_1V8_SDA",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"SOC_I2C1_1V8_SDA",
+		"SOC_I2C0_1V8_SDA",
+		"SOC_I2C0_1V8_SCL",
+		"SOC_I2C1_1V8_SCL",
+		"AP_SPI_H1_MISO",
+		"AP_SPI_H1_CS_L",
+		"AP_SPI_H1_MOSI",
+		"AP_SPI_H1_CLK",
+		"I2S5_BCK",
+		"I2S5_LRCK",
+		"I2S5_DO",
+		"BOOTBLOCK_EN_L",
+		"MT8183_KPCOL0",
+		"SPI_AP_EC_MISO",
+		"UART_DBG_TX_AP_RX",
+		"UART_AP_TX_DBG_RX",
+		"I2S2_MCK",
+		"I2S2_BCK",
+		"CLK_5M_WCAM",
+		"CLK_2M_UCAM",
+		"I2S2_LRCK",
+		"I2S2_DI",
+		"SOC_I2C2_1V8_SCL",
+		"SOC_I2C2_1V8_SDA",
+		"SOC_I2C4_1V8_SCL",
+		"SOC_I2C4_1V8_SDA",
+		"",
+		"SCL8",
+		"SDA8",
+		"FCAM_PWDN_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		/*
+		 * AP_FLASH_WP_L is crossystem ABI. Rev1 schematics
+		 * call it BIOS_FLASH_WP_R_L.
+		 */
+		"AP_FLASH_WP_L",
+		"EC_AP_INT_ODL",
+		"IT6505_INT_ODL",
+		"H1_INT_OD_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"AP_SPI_FLASH_MISO",
+		"AP_SPI_FLASH_CS_L",
+		"AP_SPI_FLASH_MOSI",
+		"AP_SPI_FLASH_CLK",
+		"DA7219_IRQ",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"";
+};
+
+&scp_pins {
+	/* EINT pins are used for other purpose on rev2. */
+	/delete-node/ pins_eint;
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-flapjack.dtsi b/arch/arm64/boot/dts/mediatek/mt8183-flapjack.dtsi
new file mode 100644
index 000000000000..4ccd2c91db5c
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-flapjack.dtsi
@@ -0,0 +1,141 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ *
+ * Device Tree Source for the Google flapjack board
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "mt8183-kukui.dtsi"
+
+/ {
+	/delete-node/ mt8183-mt6358-ts3a227e-max98357a;
+
+	sound: mt8183-da7219-max98357a {
+		compatible = "mediatek,mt8183_da7219_max98357";
+		mediatek,platform = <&afe>;
+		mediatek,headset-codec = <&da7219>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&aud_pins>;
+		status = "okay";
+	};
+};
+
+&i2c0 {
+	/delete-node/ digitizer@9;
+	/delete-node/ touchscreen@10;
+
+	touchscreen@0a {
+		compatible = "hid-over-i2c";
+		reg = <0x0a>;
+		interrupt-parent = <&pio>;
+		interrupts = <155 IRQ_TYPE_LEVEL_LOW 155>;
+		int-gpio = <&pio 155 0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&touch_default>;
+		hid-descr-addr = <0x1>;
+		wakeup-source;
+	};
+};
+
+&i2c1 {
+	sx9311@28 {
+		compatible = "semtech,sx9311";
+		reg = <0x28>;
+		interrupt-parent = <&pio>;
+		interrupts = <5 IRQ_TYPE_LEVEL_LOW 5>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&sx9311_pins>;
+	};
+};
+
+&i2c5 {
+	/delete-node/ ts3a227e@3b;
+	da7219: da7219@1a {
+		pinctrl-names = "default";
+		pinctrl-0 = <&da7219_pins>;
+		compatible = "dlg,da7219";
+		reg = <0x1a>;
+		interrupt-parent = <&pio>;
+		interrupts = <165 IRQ_TYPE_LEVEL_LOW 165>;
+
+		dlg,micbias-lvl = <2600>;
+		dlg,mic-amp-in-sel = "diff";
+
+		da7219_aad {
+			dlg,adc-1bit-rpt = <1>;
+			dlg,btn-avg = <4>;
+			dlg,btn-cfg = <50>;
+			dlg,mic-det-thr = <500>;
+			dlg,jack-ins-deb = <20>;
+			dlg,jack-det-rate = "32ms_64ms";
+			dlg,jack-rem-deb = <1>;
+
+			dlg,a-d-btn-thr = <0xa>;
+			dlg,d-b-btn-thr = <0x16>;
+			dlg,b-c-btn-thr = <0x21>;
+			dlg,c-mic-btn-thr = <0x3E>;
+		};
+	};
+};
+
+&pio {
+	/delete-node/ ts3a227e_pins;
+
+	da7219_pins: da7219_pins {
+		pins1 {
+			pinmux = <PINMUX_GPIO165__FUNC_GPIO165>;
+			input-enable;
+			bias-enable;
+			bias-pull-up;
+		};
+	};
+
+	panel_pins_1800mv: panel_pins_1800mv {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO36__FUNC_GPIO36>;
+			output-low;
+			bias-pull-up;
+		};
+	};
+
+	panel_pins_3300mv: panel_pins_3300mv {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO35__FUNC_GPIO35>;
+			output-low;
+			bias-pull-up;
+		};
+	};
+
+	/delete-node/ touchdefault;
+	touch_default: touchdefault {
+		pin_irq {
+			pinmux = <PINMUX_GPIO155__FUNC_GPIO155>;
+			input-enable;
+			bias-pull-up;
+		};
+
+		touch_pin_reset: pin_reset {
+			pinmux = <PINMUX_GPIO156__FUNC_GPIO156>;
+			output-low;
+		};
+	};
+
+	sx9311_pins: sx9311_pins {
+		pins_eint {
+			pinmux = <PINMUX_GPIO5__FUNC_GPIO5>;
+			input-enable;
+			bias-pull-up;
+		};
+	};
+};
+
diff --git a/chromeos/config/arm64/chromiumos-arm64.flavour.config b/chromeos/config/arm64/chromiumos-arm64.flavour.config
index e6a7ea7aa6e6..d4c1104fd944 100644
--- a/chromeos/config/arm64/chromiumos-arm64.flavour.config
+++ b/chromeos/config/arm64/chromiumos-arm64.flavour.config
@@ -864,7 +864,7 @@ CONFIG_SND_SOC_MT8173_RT5650=y
 CONFIG_SND_SOC_MT8173_RT5650_RT5514=y
 CONFIG_SND_SOC_MT8173_RT5650_RT5676=y
 CONFIG_SND_SOC_MT8183=y
-# CONFIG_SND_SOC_MT8183_DA7219_MAX98357A is not set
+CONFIG_SND_SOC_MT8183_DA7219_MAX98357A=y
 CONFIG_SND_SOC_MT8183_MT6358_TS3A227E_MAX98357A=y
 # CONFIG_SND_SOC_QCOM is not set
 # CONFIG_SND_SOC_RK3288_HDMI_ANALOG is not set
diff --git a/chromeos/config/arm64/chromiumos-mediatek.flavour.config b/chromeos/config/arm64/chromiumos-mediatek.flavour.config
index 233c489ba83a..c67e1d2f570a 100644
--- a/chromeos/config/arm64/chromiumos-mediatek.flavour.config
+++ b/chromeos/config/arm64/chromiumos-mediatek.flavour.config
@@ -68,6 +68,7 @@ CONFIG_DRM_MEDIATEK_HDMI=y
 CONFIG_DRM_MIPI_DSI=y
 # CONFIG_DRM_PANEL_ILITEK_ILI9881C is not set
 CONFIG_DRM_PANEL_INNOLUX_P079ZCA=y
+CONFIG_DRM_PANEL_BOE_HIMAX8279D=y
 # CONFIG_DRM_PANEL_JDI_LT070ME05000 is not set
 # CONFIG_DRM_PANEL_ORISETECH_OTM8009A is not set
 # CONFIG_DRM_PANEL_PANASONIC_VVX10F034N00 is not set
@@ -192,7 +193,7 @@ CONFIG_SND_SOC_MT8173_RT5650=y
 CONFIG_SND_SOC_MT8173_RT5650_RT5514=y
 CONFIG_SND_SOC_MT8173_RT5650_RT5676=y
 CONFIG_SND_SOC_MT8183=y
-# CONFIG_SND_SOC_MT8183_DA7219_MAX98357A is not set
+CONFIG_SND_SOC_MT8183_DA7219_MAX98357A=y
 CONFIG_SND_SOC_MT8183_MT6358_TS3A227E_MAX98357A=y
 CONFIG_SND_SOC_RL6231=y
 CONFIG_SND_SOC_RT5514=y
@@ -244,3 +245,4 @@ CONFIG_VIRTIO=y
 # CONFIG_VIRTIO_MMIO is not set
 # CONFIG_VIRTIO_NET is not set
 # CONFIG_VIRTIO_WL is not set
+CONFIG_SX9311=y
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 6020c30a33b3..4aae4a7d9f71 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -17,6 +17,17 @@ config DRM_PANEL_ARM_VERSATILE
 	  reference designs. The panel is detected using special registers
 	  in the Versatile family syscon registers.
 
+config DRM_PANEL_BOE_HIMAX8279D
+	tristate "Boe Himax8279d panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to enable support for Boe Himax8279d
+	  TFT-LCD modules. The panel has a 1200x1920 resolution and uses
+	  24 bit RGB per pixel. It provides a MIPI DSI interface to
+	  the host and has a built-in LED backlight.
+
 config DRM_PANEL_LVDS
 	tristate "Generic LVDS panel driver"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 5ccaaa9d13af..7285539d8015 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -1,5 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_DRM_PANEL_ARM_VERSATILE) += panel-arm-versatile.o
+obj-$(CONFIG_DRM_PANEL_BOE_HIMAX8279D) += panel-boe-himax8279d.o
 obj-$(CONFIG_DRM_PANEL_LVDS) += panel-lvds.o
 obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-simple.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_IL9322) += panel-ilitek-ili9322.o
diff --git a/drivers/gpu/drm/panel/panel-boe-himax8279d.c b/drivers/gpu/drm/panel/panel-boe-himax8279d.c
new file mode 100644
index 000000000000..ff5a89e38fd7
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-boe-himax8279d.c
@@ -0,0 +1,1050 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019, Huaqin Telecom Technology Co., Ltd
+ *
+ * Author: Jerry Han <hanxu5@huaqin.corp-partner.google.com>
+ *
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+
+#include <linux/gpio/consumer.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_device.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_print.h>
+
+#include <video/mipi_display.h>
+
+struct panel_cmd {
+	size_t len;
+	const char *data;
+};
+
+#define _INIT_CMD(...) { \
+	.len = sizeof((char[]){__VA_ARGS__}), \
+	.data = (char[]){__VA_ARGS__} }
+
+struct panel_desc {
+	const struct drm_display_mode *display_mode;
+	unsigned int bpc;
+	unsigned int width_mm;
+	unsigned int height_mm;
+
+	unsigned int delay_t1;
+	unsigned int reset_delay_t2;
+	unsigned int reset_delay_t3;
+	unsigned int reset_delay_t4;
+	unsigned int reset_delay_t5;
+
+	unsigned long mode_flags;
+	enum mipi_dsi_pixel_format format;
+	unsigned int lanes;
+	const struct panel_cmd *on_cmds;
+	const struct panel_cmd *off_cmds;
+};
+
+struct panel_info {
+	struct drm_panel base;
+	struct mipi_dsi_device *link;
+	const struct panel_desc *desc;
+
+	struct backlight_device *backlight;
+	struct gpio_desc *enable_gpio;
+	struct gpio_desc *pp33_gpio;
+	struct gpio_desc *pp18_gpio;
+
+	bool prepared;
+	bool enabled;
+};
+
+static inline struct panel_info *to_panel_info(struct drm_panel *panel)
+{
+	return container_of(panel, struct panel_info, base);
+}
+
+static void set_gpios(struct panel_info *pinfo, int enable)
+{
+	gpiod_set_value(pinfo->enable_gpio, enable);
+	gpiod_set_value(pinfo->pp33_gpio, enable);
+	gpiod_set_value(pinfo->pp18_gpio, enable);
+}
+
+static int send_mipi_cmds(struct drm_panel *panel, const struct panel_cmd *cmds)
+{
+	struct panel_info *pinfo = to_panel_info(panel);
+	unsigned int i = 0;
+	int err;
+
+	if (!cmds)
+		return -EFAULT;
+
+	for (i = 0; cmds[i].len != 0; i++) {
+		const struct panel_cmd *cmd = &cmds[i];
+
+		if (cmd->len == 2)
+			err = mipi_dsi_dcs_write(pinfo->link,
+						    cmd->data[1], NULL, 0);
+		else
+			err = mipi_dsi_dcs_write(pinfo->link,
+						    cmd->data[1], cmd->data + 2,
+						    cmd->len - 2);
+
+		if (err < 0)
+			return err;
+
+		usleep_range((cmd->data[0]) * 1000,
+			    (1 + cmd->data[0]) * 1000);
+	}
+
+	return 0;
+}
+
+static int boe_panel_disable(struct drm_panel *panel)
+{
+	struct panel_info *pinfo = to_panel_info(panel);
+
+	backlight_disable(pinfo->backlight);
+
+	pinfo->enabled = false;
+
+	return 0;
+}
+
+static int boe_panel_unprepare(struct drm_panel *panel)
+{
+	struct panel_info *pinfo = to_panel_info(panel);
+	int err;
+
+	if (!pinfo->prepared)
+		return 0;
+
+	/* send off code */
+	err = send_mipi_cmds(panel, pinfo->desc->off_cmds);
+	if (err < 0) {
+		DRM_DEV_ERROR(panel->dev,
+				"failed to send DCS Off Code: %d\n", err);
+		goto poweroff;
+	}
+
+	set_gpios(pinfo, 0);
+
+	pinfo->prepared = false;
+
+	return 0;
+
+poweroff:
+	set_gpios(pinfo, 0);
+	return err;
+}
+
+static int boe_panel_prepare(struct drm_panel *panel)
+{
+	struct panel_info *pinfo = to_panel_info(panel);
+	const struct panel_desc *desc = pinfo->desc;
+	int err;
+
+	if (pinfo->prepared)
+		return 0;
+
+	gpiod_set_value(pinfo->pp18_gpio, 1);
+	/* T1 (> 5ms) */
+	usleep_range(desc->delay_t1, 1000 + desc->delay_t1);
+	gpiod_set_value(pinfo->pp33_gpio, 1);
+
+	/* reset sequence */
+	usleep_range(desc->reset_delay_t2, 1000 + desc->reset_delay_t2);
+
+	gpiod_set_value(pinfo->enable_gpio, 1);
+	usleep_range(desc->reset_delay_t3, 1000 + desc->reset_delay_t3);
+	gpiod_set_value(pinfo->enable_gpio, 0);
+
+	usleep_range(desc->reset_delay_t4, 1000 + desc->reset_delay_t4);
+	gpiod_set_value(pinfo->enable_gpio, 1);
+
+	usleep_range(desc->reset_delay_t5, 1000 + desc->reset_delay_t5);
+
+	/* send init code */
+	err = send_mipi_cmds(panel, pinfo->desc->on_cmds);
+	if (err < 0) {
+		DRM_DEV_ERROR(panel->dev,
+				"failed to send DCS Init Code: %d\n", err);
+		goto poweroff;
+	}
+
+	pinfo->prepared = true;
+
+	return 0;
+
+poweroff:
+	set_gpios(pinfo, 0);
+	return err;
+}
+
+static int boe_panel_enable(struct drm_panel *panel)
+{
+	struct panel_info *pinfo = to_panel_info(panel);
+	int ret;
+
+	if (pinfo->enabled)
+		return 0;
+
+	ret = backlight_enable(pinfo->backlight);
+	if (ret) {
+		DRM_DEV_ERROR(panel->drm->dev,
+				"Failed to enable backlight %d\n", ret);
+		return ret;
+	}
+
+	pinfo->enabled = true;
+
+	return 0;
+}
+
+static int boe_panel_get_modes(struct drm_panel *panel)
+{
+	struct panel_info *pinfo = to_panel_info(panel);
+	const struct drm_display_mode *m = pinfo->desc->display_mode;
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(panel->drm, m);
+	if (!mode) {
+		DRM_DEV_ERROR(panel->drm->dev, "failed to add mode %ux%u@%u\n",
+				m->hdisplay, m->vdisplay, m->vrefresh);
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	drm_mode_probed_add(panel->connector, mode);
+
+	panel->connector->display_info.width_mm = pinfo->desc->width_mm;
+	panel->connector->display_info.height_mm = pinfo->desc->height_mm;
+	panel->connector->display_info.bpc = pinfo->desc->bpc;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs panel_funcs = {
+	.disable = boe_panel_disable,
+	.unprepare = boe_panel_unprepare,
+	.prepare = boe_panel_prepare,
+	.enable = boe_panel_enable,
+	.get_modes = boe_panel_get_modes,
+};
+
+static const struct drm_display_mode default_display_mode = {
+	.clock = 159420,
+	.hdisplay = 1200,
+	.hsync_start = 1200 + 80,
+	.hsync_end = 1200 + 80 + 60,
+	.htotal = 1200 + 80 + 60 + 24,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 10,
+	.vsync_end = 1920 + 10 + 14,
+	.vtotal = 1920 + 10 + 14 + 4,
+	.vrefresh = 60,
+};
+
+static const struct panel_cmd default_off_cmds[] = {
+	_INIT_CMD(0x00, 0x28),
+	_INIT_CMD(0x01, 0x10),
+
+	{},
+};
+
+/* 8 inch */
+static const struct panel_cmd boe_himax8279d8p_on_cmds[] = {
+	_INIT_CMD(0x22, 0x10),
+	_INIT_CMD(0x00, 0xB0, 0x05),
+	_INIT_CMD(0x00, 0xB1, 0xE5),
+	_INIT_CMD(0x00, 0xB3, 0x52),
+	_INIT_CMD(0x00, 0xB0, 0x00),
+	_INIT_CMD(0x00, 0xB3, 0x88),
+	_INIT_CMD(0x00, 0xB0, 0x04),
+	_INIT_CMD(0x00, 0xB8, 0x00),
+	_INIT_CMD(0x00, 0xB0, 0x00),
+	_INIT_CMD(0x00, 0xB2, 0x50),
+	_INIT_CMD(0x00, 0xB6, 0x03),
+	_INIT_CMD(0x00, 0xBA, 0x8B),
+	_INIT_CMD(0x00, 0xBF, 0x15),
+	_INIT_CMD(0x00, 0xC0, 0x0F),
+	_INIT_CMD(0x00, 0xC2, 0x0C),
+	_INIT_CMD(0x00, 0xC3, 0x02),
+	_INIT_CMD(0x00, 0xC4, 0x0C),
+	_INIT_CMD(0x00, 0xC5, 0x02),
+	_INIT_CMD(0x00, 0xB0, 0x01),
+	_INIT_CMD(0x00, 0xE0, 0x26),
+	_INIT_CMD(0x00, 0xE1, 0x26),
+	_INIT_CMD(0x00, 0xDC, 0x00),
+	_INIT_CMD(0x00, 0xDD, 0x00),
+	_INIT_CMD(0x00, 0xCC, 0x26),
+	_INIT_CMD(0x00, 0xCD, 0x26),
+	_INIT_CMD(0x00, 0xC8, 0x00),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xD2, 0x04),
+	_INIT_CMD(0x00, 0xD3, 0x04),
+	_INIT_CMD(0x00, 0xE6, 0x03),
+	_INIT_CMD(0x00, 0xE7, 0x03),
+	_INIT_CMD(0x00, 0xC4, 0x08),
+	_INIT_CMD(0x00, 0xC5, 0x08),
+	_INIT_CMD(0x00, 0xD8, 0x07),
+	_INIT_CMD(0x00, 0xD9, 0x07),
+	_INIT_CMD(0x00, 0xC2, 0x06),
+	_INIT_CMD(0x00, 0xC3, 0x06),
+	_INIT_CMD(0x00, 0xD6, 0x05),
+	_INIT_CMD(0x00, 0xD7, 0x05),
+	_INIT_CMD(0x00, 0xC0, 0x0C),
+	_INIT_CMD(0x00, 0xC1, 0x0C),
+	_INIT_CMD(0x00, 0xD4, 0x0B),
+	_INIT_CMD(0x00, 0xD5, 0x0B),
+	_INIT_CMD(0x00, 0xCA, 0x0A),
+	_INIT_CMD(0x00, 0xCB, 0x0A),
+	_INIT_CMD(0x00, 0xDE, 0x09),
+	_INIT_CMD(0x00, 0xDF, 0x09),
+	_INIT_CMD(0x00, 0xC6, 0x26),
+	_INIT_CMD(0x00, 0xC7, 0x26),
+	_INIT_CMD(0x00, 0xCE, 0x00),
+	_INIT_CMD(0x00, 0xCF, 0x00),
+	_INIT_CMD(0x00, 0xDA, 0x26),
+	_INIT_CMD(0x00, 0xDB, 0x26),
+	_INIT_CMD(0x00, 0xE2, 0x00),
+	_INIT_CMD(0x00, 0xE3, 0x00),
+	_INIT_CMD(0x00, 0xB0, 0x02),
+	_INIT_CMD(0x00, 0xC0, 0x00),
+	_INIT_CMD(0x00, 0xC1, 0x07),
+	_INIT_CMD(0x00, 0xC2, 0x0D),
+	_INIT_CMD(0x00, 0xC3, 0x18),
+	_INIT_CMD(0x00, 0xC4, 0x27),
+	_INIT_CMD(0x00, 0xC5, 0x28),
+	_INIT_CMD(0x00, 0xC6, 0x30),
+	_INIT_CMD(0x00, 0xC7, 0x2E),
+	_INIT_CMD(0x00, 0xC8, 0x2F),
+	_INIT_CMD(0x00, 0xC9, 0x1A),
+	_INIT_CMD(0x00, 0xCA, 0x20),
+	_INIT_CMD(0x00, 0xCB, 0x29),
+	_INIT_CMD(0x00, 0xCC, 0x26),
+	_INIT_CMD(0x00, 0xCD, 0x32),
+	_INIT_CMD(0x00, 0xCE, 0x33),
+	_INIT_CMD(0x00, 0xCF, 0x31),
+	_INIT_CMD(0x00, 0xD0, 0x06),
+	_INIT_CMD(0x00, 0xD2, 0x00),
+	_INIT_CMD(0x00, 0xD3, 0x07),
+	_INIT_CMD(0x00, 0xD4, 0x12),
+	_INIT_CMD(0x00, 0xD5, 0x26),
+	_INIT_CMD(0x00, 0xD6, 0x3D),
+	_INIT_CMD(0x00, 0xD7, 0x3F),
+	_INIT_CMD(0x00, 0xD8, 0x3F),
+	_INIT_CMD(0x00, 0xD9, 0x3F),
+	_INIT_CMD(0x00, 0xDA, 0x3F),
+	_INIT_CMD(0x00, 0xDB, 0x3F),
+	_INIT_CMD(0x00, 0xDC, 0x3F),
+	_INIT_CMD(0x00, 0xDD, 0x3F),
+	_INIT_CMD(0x00, 0xDE, 0x3F),
+	_INIT_CMD(0x00, 0xDF, 0x3A),
+	_INIT_CMD(0x00, 0xE0, 0x37),
+	_INIT_CMD(0x00, 0xE1, 0x35),
+	_INIT_CMD(0x00, 0xE2, 0x07),
+	_INIT_CMD(0x00, 0xB0, 0x03),
+	_INIT_CMD(0x00, 0xC8, 0x0B),
+	_INIT_CMD(0x00, 0xC9, 0x07),
+	_INIT_CMD(0x00, 0xC3, 0x00),
+	_INIT_CMD(0x00, 0xE7, 0x00),
+	_INIT_CMD(0x00, 0xC5, 0x2A),
+	_INIT_CMD(0x00, 0xDE, 0x2A),
+	_INIT_CMD(0x00, 0xCA, 0x43),
+	_INIT_CMD(0x00, 0xC9, 0x07),
+	_INIT_CMD(0x00, 0xE4, 0xC0),
+	_INIT_CMD(0x00, 0xE5, 0x0D),
+	_INIT_CMD(0x00, 0xCB, 0x00),
+	_INIT_CMD(0x00, 0xB0, 0x06),
+	_INIT_CMD(0x00, 0xB8, 0xA5),
+	_INIT_CMD(0x00, 0xC0, 0xA5),
+	_INIT_CMD(0x00, 0xC7, 0x0F),
+	_INIT_CMD(0x00, 0xD5, 0x32),
+	_INIT_CMD(0x00, 0xB8, 0x00),
+	_INIT_CMD(0x00, 0xC0, 0x00),
+	_INIT_CMD(0x00, 0xBC, 0x00),
+	_INIT_CMD(0x00, 0xB0, 0x07),
+	_INIT_CMD(0x00, 0xB1, 0x00),
+	_INIT_CMD(0x00, 0xB2, 0x09),
+	_INIT_CMD(0x00, 0xB3, 0x19),
+	_INIT_CMD(0x00, 0xB4, 0x2F),
+	_INIT_CMD(0x00, 0xB5, 0x44),
+	_INIT_CMD(0x00, 0xB6, 0x52),
+	_INIT_CMD(0x00, 0xB7, 0x6A),
+	_INIT_CMD(0x00, 0xB8, 0x8A),
+	_INIT_CMD(0x00, 0xB9, 0xCA),
+	_INIT_CMD(0x00, 0xBA, 0x0C),
+	_INIT_CMD(0x05, 0xBB, 0x87),
+	_INIT_CMD(0x00, 0xBC, 0x06),
+	_INIT_CMD(0x00, 0xBD, 0x0A),
+	_INIT_CMD(0x00, 0xBE, 0x9B),
+	_INIT_CMD(0x00, 0xBF, 0x0C),
+	_INIT_CMD(0x00, 0xC0, 0x3D),
+	_INIT_CMD(0x00, 0xC1, 0x71),
+	_INIT_CMD(0x00, 0xC2, 0x90),
+	_INIT_CMD(0x00, 0xC3, 0xA0),
+	_INIT_CMD(0x00, 0xC4, 0xA8),
+	_INIT_CMD(0x00, 0xC5, 0xB1),
+	_INIT_CMD(0x00, 0xC6, 0xBB),
+	_INIT_CMD(0x00, 0xC7, 0xC0),
+	_INIT_CMD(0x00, 0xC8, 0xC4),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x08),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x08),
+	_INIT_CMD(0x00, 0xB3, 0x19),
+	_INIT_CMD(0x00, 0xB4, 0x31),
+	_INIT_CMD(0x00, 0xB5, 0x46),
+	_INIT_CMD(0x00, 0xB6, 0x55),
+	_INIT_CMD(0x00, 0xB7, 0x6E),
+	_INIT_CMD(0x00, 0xB8, 0x92),
+	_INIT_CMD(0x00, 0xB9, 0xD4),
+	_INIT_CMD(0x00, 0xBA, 0x1B),
+	_INIT_CMD(0x05, 0xBB, 0x9B),
+	_INIT_CMD(0x00, 0xBC, 0x28),
+	_INIT_CMD(0x00, 0xBD, 0x2D),
+	_INIT_CMD(0x00, 0xBE, 0xC3),
+	_INIT_CMD(0x00, 0xBF, 0x2F),
+	_INIT_CMD(0x00, 0xC0, 0x62),
+	_INIT_CMD(0x00, 0xC1, 0x99),
+	_INIT_CMD(0x00, 0xC2, 0xAB),
+	_INIT_CMD(0x00, 0xC3, 0xBF),
+	_INIT_CMD(0x00, 0xC4, 0xCF),
+	_INIT_CMD(0x00, 0xC5, 0xDF),
+	_INIT_CMD(0x00, 0xC6, 0xF0),
+	_INIT_CMD(0x00, 0xC7, 0xF9),
+	_INIT_CMD(0x00, 0xC8, 0xFC),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x09),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x05),
+	_INIT_CMD(0x00, 0xB3, 0x17),
+	_INIT_CMD(0x00, 0xB4, 0x2E),
+	_INIT_CMD(0x00, 0xB5, 0x42),
+	_INIT_CMD(0x00, 0xB6, 0x51),
+	_INIT_CMD(0x00, 0xB7, 0x69),
+	_INIT_CMD(0x00, 0xB8, 0x88),
+	_INIT_CMD(0x00, 0xB9, 0xC9),
+	_INIT_CMD(0x00, 0xBA, 0x0C),
+	_INIT_CMD(0x05, 0xBB, 0x86),
+	_INIT_CMD(0x00, 0xBC, 0x03),
+	_INIT_CMD(0x00, 0xBD, 0x08),
+	_INIT_CMD(0x00, 0xBE, 0x95),
+	_INIT_CMD(0x00, 0xBF, 0x05),
+	_INIT_CMD(0x00, 0xC0, 0x35),
+	_INIT_CMD(0x00, 0xC1, 0x62),
+	_INIT_CMD(0x00, 0xC2, 0x81),
+	_INIT_CMD(0x00, 0xC3, 0x96),
+	_INIT_CMD(0x00, 0xC4, 0x9E),
+	_INIT_CMD(0x00, 0xC5, 0xA5),
+	_INIT_CMD(0x00, 0xC6, 0xAD),
+	_INIT_CMD(0x00, 0xC7, 0xB1),
+	_INIT_CMD(0x00, 0xC8, 0xB4),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x0A),
+	_INIT_CMD(0x00, 0xB1, 0x00),
+	_INIT_CMD(0x00, 0xB2, 0x09),
+	_INIT_CMD(0x00, 0xB3, 0x19),
+	_INIT_CMD(0x00, 0xB4, 0x2F),
+	_INIT_CMD(0x00, 0xB5, 0x44),
+	_INIT_CMD(0x00, 0xB6, 0x52),
+	_INIT_CMD(0x00, 0xB7, 0x6A),
+	_INIT_CMD(0x00, 0xB8, 0x8A),
+	_INIT_CMD(0x00, 0xB9, 0xCA),
+	_INIT_CMD(0x00, 0xBA, 0x0C),
+	_INIT_CMD(0x05, 0xBB, 0x87),
+	_INIT_CMD(0x00, 0xBC, 0x06),
+	_INIT_CMD(0x00, 0xBD, 0x0A),
+	_INIT_CMD(0x00, 0xBE, 0x9B),
+	_INIT_CMD(0x00, 0xBF, 0x0C),
+	_INIT_CMD(0x00, 0xC0, 0x3D),
+	_INIT_CMD(0x00, 0xC1, 0x71),
+	_INIT_CMD(0x00, 0xC2, 0x90),
+	_INIT_CMD(0x00, 0xC3, 0xA0),
+	_INIT_CMD(0x00, 0xC4, 0xA8),
+	_INIT_CMD(0x00, 0xC5, 0xB1),
+	_INIT_CMD(0x00, 0xC6, 0xBB),
+	_INIT_CMD(0x00, 0xC7, 0xC0),
+	_INIT_CMD(0x00, 0xC8, 0xC4),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x0B),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x08),
+	_INIT_CMD(0x00, 0xB3, 0x19),
+	_INIT_CMD(0x00, 0xB4, 0x31),
+	_INIT_CMD(0x00, 0xB5, 0x46),
+	_INIT_CMD(0x00, 0xB6, 0x55),
+	_INIT_CMD(0x00, 0xB7, 0x6E),
+	_INIT_CMD(0x00, 0xB8, 0x92),
+	_INIT_CMD(0x00, 0xB9, 0xD4),
+	_INIT_CMD(0x00, 0xBA, 0x1B),
+	_INIT_CMD(0x05, 0xBB, 0x9B),
+	_INIT_CMD(0x00, 0xBC, 0x28),
+	_INIT_CMD(0x00, 0xBD, 0x2D),
+	_INIT_CMD(0x00, 0xBE, 0xC3),
+	_INIT_CMD(0x00, 0xBF, 0x2F),
+	_INIT_CMD(0x00, 0xC0, 0x62),
+	_INIT_CMD(0x00, 0xC1, 0x99),
+	_INIT_CMD(0x00, 0xC2, 0xAB),
+	_INIT_CMD(0x00, 0xC3, 0xBF),
+	_INIT_CMD(0x00, 0xC4, 0xCF),
+	_INIT_CMD(0x00, 0xC5, 0xDF),
+	_INIT_CMD(0x00, 0xC6, 0xF0),
+	_INIT_CMD(0x00, 0xC7, 0xF9),
+	_INIT_CMD(0x00, 0xC8, 0xFC),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x0C),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x05),
+	_INIT_CMD(0x00, 0xB3, 0x17),
+	_INIT_CMD(0x00, 0xB4, 0x2E),
+	_INIT_CMD(0x00, 0xB5, 0x42),
+	_INIT_CMD(0x00, 0xB6, 0x51),
+	_INIT_CMD(0x00, 0xB7, 0x69),
+	_INIT_CMD(0x00, 0xB8, 0x88),
+	_INIT_CMD(0x00, 0xB9, 0xC9),
+	_INIT_CMD(0x00, 0xBA, 0x0C),
+	_INIT_CMD(0x05, 0xBB, 0x86),
+	_INIT_CMD(0x00, 0xBC, 0x03),
+	_INIT_CMD(0x00, 0xBD, 0x08),
+	_INIT_CMD(0x00, 0xBE, 0x95),
+	_INIT_CMD(0x00, 0xBF, 0x05),
+	_INIT_CMD(0x00, 0xC0, 0x35),
+	_INIT_CMD(0x00, 0xC1, 0x62),
+	_INIT_CMD(0x00, 0xC2, 0x81),
+	_INIT_CMD(0x00, 0xC3, 0x96),
+	_INIT_CMD(0x00, 0xC4, 0x9E),
+	_INIT_CMD(0x00, 0xC5, 0xA5),
+	_INIT_CMD(0x00, 0xC6, 0xAD),
+	_INIT_CMD(0x00, 0xC7, 0xB1),
+	_INIT_CMD(0x00, 0xC8, 0xB4),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x64, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x00),
+	_INIT_CMD(0x00, 0xB3, 0x08),
+	_INIT_CMD(0x00, 0xB0, 0x04),
+	_INIT_CMD(0x0A, 0xB8, 0x68),
+	_INIT_CMD(0x78, 0x11),
+	_INIT_CMD(0x14, 0x29),
+
+	{},
+};
+
+static const struct panel_desc boe_himax8279d8p_panel_desc = {
+	.display_mode = &default_display_mode,
+	.bpc = 8,
+	.width_mm = 107,
+	.height_mm = 172,
+	.delay_t1 = 5000,
+	.reset_delay_t2 = 14000,
+	.reset_delay_t3 = 1000,
+	.reset_delay_t4 = 1000,
+	.reset_delay_t5 = 5000,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+	.on_cmds = boe_himax8279d8p_on_cmds,
+	.off_cmds = default_off_cmds,
+};
+
+/* 10 inch */
+static const struct panel_cmd boe_himax8279d10p_on_cmds[] = {
+	_INIT_CMD(0x00, 0xB0, 0x05),
+	_INIT_CMD(0x00, 0xB1, 0xE5),
+	_INIT_CMD(0x00, 0xB3, 0x52),
+	_INIT_CMD(0x00, 0xB0, 0x00),
+	_INIT_CMD(0x00, 0xB3, 0x88),
+	_INIT_CMD(0x00, 0xB0, 0x04),
+	_INIT_CMD(0x00, 0xB8, 0x00),
+	_INIT_CMD(0x00, 0xB0, 0x00),
+	_INIT_CMD(0x00, 0xB2, 0x50),
+	_INIT_CMD(0x00, 0xB6, 0x03),
+	_INIT_CMD(0x00, 0xBA, 0x8B),
+	_INIT_CMD(0x00, 0xBF, 0x1A),
+	_INIT_CMD(0x00, 0xC0, 0x0F),
+	_INIT_CMD(0x00, 0xC2, 0x0C),
+	_INIT_CMD(0x00, 0xC3, 0x02),
+	_INIT_CMD(0x00, 0xC4, 0x0C),
+	_INIT_CMD(0x00, 0xC5, 0x02),
+	_INIT_CMD(0x00, 0xB0, 0x01),
+	_INIT_CMD(0x00, 0xE0, 0x26),
+	_INIT_CMD(0x00, 0xE1, 0x26),
+	_INIT_CMD(0x00, 0xDC, 0x00),
+	_INIT_CMD(0x00, 0xDD, 0x00),
+	_INIT_CMD(0x00, 0xCC, 0x26),
+	_INIT_CMD(0x00, 0xCD, 0x26),
+	_INIT_CMD(0x00, 0xC8, 0x00),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xD2, 0x04),
+	_INIT_CMD(0x00, 0xD3, 0x04),
+	_INIT_CMD(0x00, 0xE6, 0x03),
+	_INIT_CMD(0x00, 0xE7, 0x03),
+	_INIT_CMD(0x00, 0xC4, 0x08),
+	_INIT_CMD(0x00, 0xC5, 0x08),
+	_INIT_CMD(0x00, 0xD8, 0x07),
+	_INIT_CMD(0x00, 0xD9, 0x07),
+	_INIT_CMD(0x00, 0xC2, 0x06),
+	_INIT_CMD(0x00, 0xC3, 0x06),
+	_INIT_CMD(0x00, 0xD6, 0x05),
+	_INIT_CMD(0x00, 0xD7, 0x05),
+	_INIT_CMD(0x00, 0xC0, 0x0C),
+	_INIT_CMD(0x00, 0xC1, 0x0C),
+	_INIT_CMD(0x00, 0xD4, 0x0B),
+	_INIT_CMD(0x00, 0xD5, 0x0B),
+	_INIT_CMD(0x00, 0xCA, 0x0A),
+	_INIT_CMD(0x00, 0xCB, 0x0A),
+	_INIT_CMD(0x00, 0xDE, 0x09),
+	_INIT_CMD(0x00, 0xDF, 0x09),
+	_INIT_CMD(0x00, 0xC6, 0x26),
+	_INIT_CMD(0x00, 0xC7, 0x26),
+	_INIT_CMD(0x00, 0xCE, 0x00),
+	_INIT_CMD(0x00, 0xCF, 0x00),
+	_INIT_CMD(0x00, 0xDA, 0x26),
+	_INIT_CMD(0x00, 0xDB, 0x26),
+	_INIT_CMD(0x00, 0xE2, 0x00),
+	_INIT_CMD(0x00, 0xE3, 0x00),
+	_INIT_CMD(0x00, 0xB0, 0x02),
+	_INIT_CMD(0x00, 0xC0, 0x00),
+	_INIT_CMD(0x00, 0xC1, 0x07),
+	_INIT_CMD(0x00, 0xC2, 0x0D),
+	_INIT_CMD(0x00, 0xC3, 0x18),
+	_INIT_CMD(0x00, 0xC4, 0x27),
+	_INIT_CMD(0x00, 0xC5, 0x28),
+	_INIT_CMD(0x00, 0xC6, 0x30),
+	_INIT_CMD(0x00, 0xC7, 0x2E),
+	_INIT_CMD(0x00, 0xC8, 0x2F),
+	_INIT_CMD(0x00, 0xC9, 0x1A),
+	_INIT_CMD(0x00, 0xCA, 0x20),
+	_INIT_CMD(0x00, 0xCB, 0x29),
+	_INIT_CMD(0x00, 0xCC, 0x26),
+	_INIT_CMD(0x00, 0xCD, 0x32),
+	_INIT_CMD(0x00, 0xCE, 0x33),
+	_INIT_CMD(0x00, 0xCF, 0x31),
+	_INIT_CMD(0x00, 0xD0, 0x06),
+	_INIT_CMD(0x00, 0xD2, 0x00),
+	_INIT_CMD(0x00, 0xD3, 0x07),
+	_INIT_CMD(0x00, 0xD4, 0x12),
+	_INIT_CMD(0x00, 0xD5, 0x26),
+	_INIT_CMD(0x00, 0xD6, 0x3D),
+	_INIT_CMD(0x00, 0xD7, 0x3F),
+	_INIT_CMD(0x00, 0xD8, 0x3F),
+	_INIT_CMD(0x00, 0xD9, 0x3F),
+	_INIT_CMD(0x00, 0xDA, 0x3F),
+	_INIT_CMD(0x00, 0xDB, 0x3F),
+	_INIT_CMD(0x00, 0xDC, 0x3F),
+	_INIT_CMD(0x00, 0xDD, 0x3F),
+	_INIT_CMD(0x00, 0xDE, 0x3F),
+	_INIT_CMD(0x00, 0xDF, 0x3A),
+	_INIT_CMD(0x00, 0xE0, 0x37),
+	_INIT_CMD(0x00, 0xE1, 0x35),
+	_INIT_CMD(0x00, 0xE2, 0x07),
+	_INIT_CMD(0x00, 0xB0, 0x03),
+	_INIT_CMD(0x00, 0xC8, 0x0B),
+	_INIT_CMD(0x00, 0xC9, 0x07),
+	_INIT_CMD(0x00, 0xC3, 0x00),
+	_INIT_CMD(0x00, 0xE7, 0x00),
+	_INIT_CMD(0x00, 0xC5, 0x2A),
+	_INIT_CMD(0x00, 0xDE, 0x2A),
+	_INIT_CMD(0x00, 0xCA, 0x43),
+	_INIT_CMD(0x00, 0xC9, 0x07),
+	_INIT_CMD(0x00, 0xE4, 0xC0),
+	_INIT_CMD(0x00, 0xE5, 0x0D),
+	_INIT_CMD(0x00, 0xCB, 0x00),
+	_INIT_CMD(0x00, 0xB0, 0x06),
+	_INIT_CMD(0x00, 0xB8, 0xA5),
+	_INIT_CMD(0x00, 0xC0, 0xA5),
+	_INIT_CMD(0x00, 0xC7, 0x0F),
+	_INIT_CMD(0x00, 0xD5, 0x32),
+	_INIT_CMD(0x00, 0xB8, 0x00),
+	_INIT_CMD(0x00, 0xC0, 0x00),
+	_INIT_CMD(0x00, 0xBC, 0x00),
+	_INIT_CMD(0x00, 0xB0, 0x07),
+	_INIT_CMD(0x00, 0xB1, 0x00),
+	_INIT_CMD(0x00, 0xB2, 0x09),
+	_INIT_CMD(0x00, 0xB3, 0x19),
+	_INIT_CMD(0x00, 0xB4, 0x2F),
+	_INIT_CMD(0x00, 0xB5, 0x44),
+	_INIT_CMD(0x00, 0xB6, 0x52),
+	_INIT_CMD(0x00, 0xB7, 0x6A),
+	_INIT_CMD(0x00, 0xB8, 0x8A),
+	_INIT_CMD(0x00, 0xB9, 0xCA),
+	_INIT_CMD(0x00, 0xBA, 0x0C),
+	_INIT_CMD(0x00, 0xBB, 0x87),
+	_INIT_CMD(0x00, 0xBC, 0x06),
+	_INIT_CMD(0x00, 0xBD, 0x0A),
+	_INIT_CMD(0x00, 0xBE, 0x9B),
+	_INIT_CMD(0x00, 0xBF, 0x0C),
+	_INIT_CMD(0x00, 0xC0, 0x3D),
+	_INIT_CMD(0x00, 0xC1, 0x71),
+	_INIT_CMD(0x00, 0xC2, 0x90),
+	_INIT_CMD(0x00, 0xC3, 0xA0),
+	_INIT_CMD(0x00, 0xC4, 0xA8),
+	_INIT_CMD(0x00, 0xC5, 0xB1),
+	_INIT_CMD(0x00, 0xC6, 0xBB),
+	_INIT_CMD(0x00, 0xC7, 0xC0),
+	_INIT_CMD(0x00, 0xC8, 0xC4),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x08),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x08),
+	_INIT_CMD(0x00, 0xB3, 0x19),
+	_INIT_CMD(0x00, 0xB4, 0x31),
+	_INIT_CMD(0x00, 0xB5, 0x46),
+	_INIT_CMD(0x00, 0xB6, 0x55),
+	_INIT_CMD(0x00, 0xB7, 0x6E),
+	_INIT_CMD(0x00, 0xB8, 0x92),
+	_INIT_CMD(0x00, 0xB9, 0xD4),
+	_INIT_CMD(0x00, 0xBA, 0x1B),
+	_INIT_CMD(0x00, 0xBB, 0x9B),
+	_INIT_CMD(0x00, 0xBC, 0x28),
+	_INIT_CMD(0x00, 0xBD, 0x2D),
+	_INIT_CMD(0x00, 0xBE, 0xC3),
+	_INIT_CMD(0x00, 0xBF, 0x2F),
+	_INIT_CMD(0x00, 0xC0, 0x62),
+	_INIT_CMD(0x00, 0xC1, 0x99),
+	_INIT_CMD(0x00, 0xC2, 0xAB),
+	_INIT_CMD(0x00, 0xC3, 0xBF),
+	_INIT_CMD(0x00, 0xC4, 0xCF),
+	_INIT_CMD(0x00, 0xC5, 0xDF),
+	_INIT_CMD(0x00, 0xC6, 0xF0),
+	_INIT_CMD(0x00, 0xC7, 0xF9),
+	_INIT_CMD(0x00, 0xC8, 0xFC),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x09),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x05),
+	_INIT_CMD(0x00, 0xB3, 0x17),
+	_INIT_CMD(0x00, 0xB4, 0x2E),
+	_INIT_CMD(0x00, 0xB5, 0x42),
+	_INIT_CMD(0x00, 0xB6, 0x51),
+	_INIT_CMD(0x00, 0xB7, 0x69),
+	_INIT_CMD(0x00, 0xB8, 0x88),
+	_INIT_CMD(0x00, 0xB9, 0xC9),
+	_INIT_CMD(0x00, 0xBA, 0x0C),
+	_INIT_CMD(0x00, 0xBB, 0x86),
+	_INIT_CMD(0x00, 0xBC, 0x03),
+	_INIT_CMD(0x00, 0xBD, 0x08),
+	_INIT_CMD(0x00, 0xBE, 0x95),
+	_INIT_CMD(0x00, 0xBF, 0x05),
+	_INIT_CMD(0x00, 0xC0, 0x35),
+	_INIT_CMD(0x00, 0xC1, 0x62),
+	_INIT_CMD(0x00, 0xC2, 0x81),
+	_INIT_CMD(0x00, 0xC3, 0x96),
+	_INIT_CMD(0x00, 0xC4, 0x9E),
+	_INIT_CMD(0x00, 0xC5, 0xA5),
+	_INIT_CMD(0x00, 0xC6, 0xAD),
+	_INIT_CMD(0x00, 0xC7, 0xB1),
+	_INIT_CMD(0x00, 0xC8, 0xB4),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x0A),
+	_INIT_CMD(0x00, 0xB1, 0x00),
+	_INIT_CMD(0x00, 0xB2, 0x09),
+	_INIT_CMD(0x00, 0xB3, 0x19),
+	_INIT_CMD(0x00, 0xB4, 0x2F),
+	_INIT_CMD(0x00, 0xB5, 0x44),
+	_INIT_CMD(0x00, 0xB6, 0x52),
+	_INIT_CMD(0x00, 0xB7, 0x6A),
+	_INIT_CMD(0x00, 0xB8, 0x8A),
+	_INIT_CMD(0x00, 0xB9, 0xCA),
+	_INIT_CMD(0x00, 0xBA, 0x0C),
+	_INIT_CMD(0x00, 0xBB, 0x87),
+	_INIT_CMD(0x00, 0xBC, 0x06),
+	_INIT_CMD(0x00, 0xBD, 0x0A),
+	_INIT_CMD(0x00, 0xBE, 0x9B),
+	_INIT_CMD(0x00, 0xBF, 0x0C),
+	_INIT_CMD(0x00, 0xC0, 0x3D),
+	_INIT_CMD(0x00, 0xC1, 0x71),
+	_INIT_CMD(0x00, 0xC2, 0x90),
+	_INIT_CMD(0x00, 0xC3, 0xA0),
+	_INIT_CMD(0x00, 0xC4, 0xA8),
+	_INIT_CMD(0x00, 0xC5, 0xB1),
+	_INIT_CMD(0x00, 0xC6, 0xBB),
+	_INIT_CMD(0x00, 0xC7, 0xC0),
+	_INIT_CMD(0x00, 0xC8, 0xC4),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x0B),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x08),
+	_INIT_CMD(0x00, 0xB3, 0x19),
+	_INIT_CMD(0x00, 0xB4, 0x31),
+	_INIT_CMD(0x00, 0xB5, 0x46),
+	_INIT_CMD(0x00, 0xB6, 0x55),
+	_INIT_CMD(0x00, 0xB7, 0x6E),
+	_INIT_CMD(0x00, 0xB8, 0x92),
+	_INIT_CMD(0x00, 0xB9, 0xD4),
+	_INIT_CMD(0x00, 0xBA, 0x1B),
+	_INIT_CMD(0x00, 0xBB, 0x9B),
+	_INIT_CMD(0x00, 0xBC, 0x28),
+	_INIT_CMD(0x00, 0xBD, 0x2D),
+	_INIT_CMD(0x00, 0xBE, 0xC3),
+	_INIT_CMD(0x00, 0xBF, 0x2F),
+	_INIT_CMD(0x00, 0xC0, 0x62),
+	_INIT_CMD(0x00, 0xC1, 0x99),
+	_INIT_CMD(0x00, 0xC2, 0xAB),
+	_INIT_CMD(0x00, 0xC3, 0xBF),
+	_INIT_CMD(0x00, 0xC4, 0xCF),
+	_INIT_CMD(0x00, 0xC5, 0xDF),
+	_INIT_CMD(0x00, 0xC6, 0xF0),
+	_INIT_CMD(0x00, 0xC7, 0xF9),
+	_INIT_CMD(0x00, 0xC8, 0xFC),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x0C),
+	_INIT_CMD(0x00, 0xB1, 0x04),
+	_INIT_CMD(0x00, 0xB2, 0x05),
+	_INIT_CMD(0x00, 0xB3, 0x17),
+	_INIT_CMD(0x00, 0xB4, 0x2E),
+	_INIT_CMD(0x00, 0xB5, 0x42),
+	_INIT_CMD(0x00, 0xB6, 0x51),
+	_INIT_CMD(0x00, 0xB7, 0x69),
+	_INIT_CMD(0x00, 0xB8, 0x88),
+	_INIT_CMD(0x00, 0xB9, 0xC9),
+	_INIT_CMD(0x00, 0xBA, 0x0C),
+	_INIT_CMD(0x00, 0xBB, 0x86),
+	_INIT_CMD(0x00, 0xBC, 0x03),
+	_INIT_CMD(0x00, 0xBD, 0x08),
+	_INIT_CMD(0x00, 0xBE, 0x95),
+	_INIT_CMD(0x00, 0xBF, 0x05),
+	_INIT_CMD(0x00, 0xC0, 0x35),
+	_INIT_CMD(0x00, 0xC1, 0x62),
+	_INIT_CMD(0x00, 0xC2, 0x81),
+	_INIT_CMD(0x00, 0xC3, 0x96),
+	_INIT_CMD(0x00, 0xC4, 0x9E),
+	_INIT_CMD(0x00, 0xC5, 0xA5),
+	_INIT_CMD(0x00, 0xC6, 0xAD),
+	_INIT_CMD(0x00, 0xC7, 0xB1),
+	_INIT_CMD(0x00, 0xC8, 0xB4),
+	_INIT_CMD(0x00, 0xC9, 0x00),
+	_INIT_CMD(0x00, 0xCA, 0x00),
+	_INIT_CMD(0x00, 0xCB, 0x16),
+	_INIT_CMD(0x00, 0xCC, 0xAF),
+	_INIT_CMD(0x00, 0xCD, 0xFF),
+	_INIT_CMD(0x00, 0xCE, 0xFF),
+	_INIT_CMD(0x00, 0xB0, 0x00),
+	_INIT_CMD(0x00, 0xB3, 0x08),
+	_INIT_CMD(0x00, 0xB0, 0x04),
+	_INIT_CMD(0x64, 0xB8, 0x68),
+
+	{},
+};
+
+static const struct panel_desc boe_himax8279d10p_panel_desc = {
+	.display_mode = &default_display_mode,
+	.bpc = 8,
+	.width_mm = 135,
+	.height_mm = 216,
+	.delay_t1 = 5000,
+	.reset_delay_t2 = 14000,
+	.reset_delay_t3 = 1000,
+	.reset_delay_t4 = 1000,
+	.reset_delay_t5 = 5000,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+	.on_cmds = boe_himax8279d10p_on_cmds,
+	.off_cmds = default_off_cmds,
+};
+
+static const struct of_device_id panel_of_match[] = {
+	{ .compatible = "boe,himax8279d8p",
+	  .data = &boe_himax8279d8p_panel_desc
+	}, { .compatible = "boe,himax8279d10p",
+	  .data = &boe_himax8279d10p_panel_desc
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(of, panel_of_match);
+
+static int panel_add(struct panel_info *pinfo)
+{
+	struct device *dev = &pinfo->link->dev;
+	int ret;
+
+	pinfo->pp18_gpio = devm_gpiod_get_optional(dev, "pp18", GPIOD_OUT_HIGH);
+	if (IS_ERR(pinfo->pp18_gpio)) {
+		ret = PTR_ERR(pinfo->pp18_gpio);
+		if (ret != -EPROBE_DEFER)
+			DRM_DEV_ERROR(dev, "failed to get pp18 gpio: %d\n",
+					ret);
+		return ret;
+	}
+
+	pinfo->pp33_gpio = devm_gpiod_get_optional(dev, "pp33", GPIOD_OUT_HIGH);
+	if (IS_ERR(pinfo->pp33_gpio)) {
+		ret = PTR_ERR(pinfo->pp33_gpio);
+		if (ret != -EPROBE_DEFER)
+			DRM_DEV_ERROR(dev, "failed to get pp33 gpio: %d\n",
+					ret);
+		return ret;
+	}
+
+	pinfo->enable_gpio = devm_gpiod_get_optional(dev, "enable",
+							GPIOD_OUT_HIGH);
+	if (IS_ERR(pinfo->enable_gpio)) {
+		ret = PTR_ERR(pinfo->enable_gpio);
+		if (ret != -EPROBE_DEFER)
+			DRM_DEV_ERROR(dev, "failed to get enable gpio: %d\n",
+					ret);
+		return ret;
+	}
+
+	pinfo->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(pinfo->backlight))
+		return PTR_ERR(pinfo->backlight);
+
+	drm_panel_init(&pinfo->base);
+	pinfo->base.funcs = &panel_funcs;
+	pinfo->base.dev = &pinfo->link->dev;
+
+	ret = drm_panel_add(&pinfo->base);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void panel_del(struct panel_info *pinfo)
+{
+	if (pinfo->base.dev)
+		drm_panel_remove(&pinfo->base);
+}
+
+static int panel_probe(struct mipi_dsi_device *dsi)
+{
+	struct panel_info *pinfo;
+	const struct panel_desc *desc;
+	int err;
+
+	pinfo = devm_kzalloc(&dsi->dev, sizeof(*pinfo), GFP_KERNEL);
+	if (!pinfo)
+		return -ENOMEM;
+
+	desc = of_device_get_match_data(&dsi->dev);
+	dsi->mode_flags = desc->mode_flags;
+	dsi->format = desc->format;
+	dsi->lanes = desc->lanes;
+	pinfo->desc = desc;
+
+	pinfo->link = dsi;
+	mipi_dsi_set_drvdata(dsi, pinfo);
+
+	err = panel_add(pinfo);
+	if (err < 0)
+		return err;
+
+	return mipi_dsi_attach(dsi);
+}
+
+static int panel_remove(struct mipi_dsi_device *dsi)
+{
+	struct panel_info *pinfo = mipi_dsi_get_drvdata(dsi);
+	int err;
+
+	err = boe_panel_unprepare(&pinfo->base);
+	if (err < 0)
+		DRM_DEV_ERROR(&dsi->dev, "failed to unprepare panel: %d\n",
+				err);
+
+	err = boe_panel_disable(&pinfo->base);
+	if (err < 0)
+		DRM_DEV_ERROR(&dsi->dev, "failed to disable panel: %d\n", err);
+
+	err = mipi_dsi_detach(dsi);
+	if (err < 0)
+		DRM_DEV_ERROR(&dsi->dev, "failed to detach from DSI host: %d\n",
+				err);
+
+	drm_panel_detach(&pinfo->base);
+	panel_del(pinfo);
+
+	return 0;
+}
+
+static void panel_shutdown(struct mipi_dsi_device *dsi)
+{
+	struct panel_info *pinfo = mipi_dsi_get_drvdata(dsi);
+
+	boe_panel_disable(&pinfo->base);
+	boe_panel_unprepare(&pinfo->base);
+}
+
+static struct mipi_dsi_driver panel_driver = {
+	.driver = {
+		.name = "panel-boe-himax8279d",
+		.of_match_table = panel_of_match,
+	},
+	.probe = panel_probe,
+	.remove = panel_remove,
+	.shutdown = panel_shutdown,
+};
+module_mipi_dsi_driver(panel_driver);
+
+MODULE_AUTHOR("Jerry Han <hanxu5@huaqin.corp-partner.google.com>");
+MODULE_DESCRIPTION("Boe Himax8279d driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/proximity/Kconfig b/drivers/iio/proximity/Kconfig
index 388ef70c11d2..d16c1d4649ce 100644
--- a/drivers/iio/proximity/Kconfig
+++ b/drivers/iio/proximity/Kconfig
@@ -79,6 +79,19 @@ config SX9500
 	  To compile this driver as a module, choose M here: the
 	  module will be called sx9500.
 
+config SX9311
+	tristate "SX9311 Semtech proximity sensor"
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+	select REGMAP_I2C
+	depends on I2C
+	help
+	  Say Y here to build a driver for Semtech's SX9311 capacitive
+	  proximity/button sensor.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called sx9311.
+
 config SRF08
 	tristate "Devantech SRF02/SRF08/SRF10 ultrasonic ranger sensor"
 	select IIO_BUFFER
diff --git a/drivers/iio/proximity/Makefile b/drivers/iio/proximity/Makefile
index cac3d7d3325e..c0ac5af12015 100644
--- a/drivers/iio/proximity/Makefile
+++ b/drivers/iio/proximity/Makefile
@@ -11,3 +11,4 @@ obj-$(CONFIG_RFD77402)		+= rfd77402.o
 obj-$(CONFIG_SRF04)		+= srf04.o
 obj-$(CONFIG_SRF08)		+= srf08.o
 obj-$(CONFIG_SX9500)		+= sx9500.o
+obj-$(CONFIG_SX9311)		+= sx9311.o
diff --git a/drivers/iio/proximity/sx9311.c b/drivers/iio/proximity/sx9311.c
new file mode 100644
index 000000000000..408c349dd436
--- /dev/null
+++ b/drivers/iio/proximity/sx9311.c
@@ -0,0 +1,1144 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2019, Google LLC.
+ *
+ * Driver for Semtech's SX9311 capacitive proximity/button solution.
+ * Datasheet available at
+ * <http://www.semtech.com/images/datasheet/sx9311.pdf>.
+ * Based on SX9310 driver and Semtech driver using the input framework
+ * <https://my.syncplicity.com/share/teouwsim8niiaud/
+ *          linux-driver-SX9311_NoSmartHSensing>.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/acpi.h>
+#include <linux/gpio/consumer.h>
+#include <linux/regmap.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/events.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/iio/trigger_consumer.h>
+
+#define SX9311_DRIVER_NAME		"sx9311"
+#define SX9311_ACPI_NAME		"STH9311"
+#define SX9311_IRQ_NAME			"sx9311_event"
+
+#define SX9311_GPIO_INT			"interrupt"
+
+/* Register definitions. */
+#define SX9311_REG_IRQ_SRC		0x00
+#define SX9311_REG_STAT0		0x01
+#define SX9311_REG_STAT1		0x02
+#define SX9311_REG_IRQ_MSK		0x03
+#define SX9311_REG_IRQ_FUNC		0x04
+
+#define SX9311_REG_PROX_CTRL0		0x10
+#define SX9311_REG_PROX_CTRL1		0x11
+#define SX9311_REG_PROX_CTRL2		0x12
+#define SX9311_REG_PROX_CTRL3		0x13
+#define SX9311_REG_PROX_CTRL4		0x14
+#define SX9311_REG_PROX_CTRL5		0x15
+#define SX9311_REG_PROX_CTRL6		0x16
+#define SX9311_REG_PROX_CTRL7		0x17
+#define SX9311_REG_PROX_CTRL8		0x18
+#define SX9311_REG_PROX_CTRL9		0x19
+#define SX9311_REG_PROX_CTRL10		0x1A
+#define SX9311_REG_PROX_CTRL11		0x1B
+#define SX9311_REG_PROX_CTRL12		0x1C
+#define SX9311_REG_PROX_CTRL13		0x1D
+#define SX9311_REG_PROX_CTRL14		0x1E
+#define SX9311_REG_PROX_CTRL15		0x1F
+#define SX9311_REG_PROX_CTRL16		0x20
+#define SX9311_REG_PROX_CTRL17		0x21
+#define SX9311_REG_PROX_CTRL18		0x22
+#define SX9311_REG_PROX_CTRL19		0x23
+#define SX9311_REG_SAR_CTRL0		0x2A
+#define SX9311_REG_SAR_CTRL1		0x2B
+#define SX9311_REG_SAR_CTRL2		0x2C
+
+#define SX9311_REG_SENSOR_SEL		0x30
+
+#define SX9311_REG_USE_MSB		0x31
+#define SX9311_REG_USE_LSB		0x32
+
+#define SX9311_REG_AVG_MSB		0x33
+#define SX9311_REG_AVG_LSB		0x34
+
+#define SX9311_REG_DIFF_MSB		0x35
+#define SX9311_REG_DIFF_LSB		0x36
+
+#define SX9311_REG_OFFSET_MSB		0x37
+#define SX9311_REG_OFFSET_LSB		0x38
+
+#define SX9311_REG_SAR_MSB		0x39
+#define SX9311_REG_SAR_LSB		0x3A
+
+#define SX9311_REG_I2CADDR		0x40
+#define SX9311_REG_PAUSE		0x41
+#define SX9311_REG_WHOAMI		0x42
+/* Expected content of the WHOAMI register. */
+#define SX9311_WHOAMI_VALUE		0x02
+
+#define SX9311_REG_RESET		0x7f
+/* Write this to REG_RESET to do a soft reset. */
+#define SX9311_SOFT_RESET		0xde
+
+
+/* Sensor Readback */
+
+/*
+ * These serve for identifying IRQ source in the IRQ_SRC register, and
+ * also for masking the IRQs in the IRQ_MSK register.
+ */
+#define SX9311_RESET_IRQ		BIT(7)
+#define SX9311_CLOSE_IRQ		BIT(6)
+#define SX9311_FAR_IRQ			BIT(5)
+#define SX9311_COMPDONE_IRQ		BIT(4)
+#define SX9311_CONVDONE_IRQ		BIT(3)
+
+#define SX9311_SCAN_PERIOD_MASK		GENMASK(7, 4)
+#define SX9311_SCAN_PERIOD_SHIFT	4
+
+#define SX9311_COMPSTAT_MASK		GENMASK(3, 0)
+
+/* 4 channels, as defined in STAT0: COMB, CS2, CS1 and CS0. */
+#define SX9311_NUM_CHANNELS		4
+#define SX9311_CHAN_MASK		GENMASK(2, 0)
+
+struct sx9311_data {
+	struct mutex mutex;
+	struct i2c_client *client;
+	struct iio_trigger *trig;
+	struct regmap *regmap;
+	/*
+	 * Last reading of the proximity status for each channel.
+	 * We only send an event to user space when this changes.
+	 */
+	bool prox_stat[SX9311_NUM_CHANNELS];
+	bool event_enabled[SX9311_NUM_CHANNELS];
+	bool trigger_enabled;
+	u16 *buffer;
+	/* Remember enabled channels and sample rate during suspend. */
+	unsigned int suspend_ctrl0;
+	struct completion completion;
+	int data_rdy_users, close_far_users;
+	int channel_users[SX9311_NUM_CHANNELS];
+	unsigned int num_irqs;
+};
+
+static const struct iio_event_spec sx9311_events[] = {
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_EITHER,
+		.mask_separate = BIT(IIO_EV_INFO_ENABLE),
+	},
+};
+
+#define SX9311_CHANNEL(idx, name, addr)				\
+	{							\
+		.type = IIO_PROXIMITY,				\
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),	\
+		.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \
+		.indexed = 1,					\
+		.channel = idx,					\
+		.address = addr,				\
+		.event_spec = sx9311_events,			\
+		.num_event_specs = ARRAY_SIZE(sx9311_events),	\
+		.extend_name = name,				\
+		.scan_index = idx,				\
+		.scan_type = {					\
+			.sign = 's',				\
+			.realbits = 16,				\
+			.storagebits = 16,			\
+			.shift = 0,				\
+		},						\
+	}
+
+static const struct iio_chan_spec sx9311_channels[] = {
+	SX9311_CHANNEL(0, "USE_CS0", SX9311_REG_USE_MSB),
+	SX9311_CHANNEL(1, "USE_CS1", SX9311_REG_USE_MSB),
+	SX9311_CHANNEL(2, "USE_CS2", SX9311_REG_USE_MSB),
+	SX9311_CHANNEL(3, "USE_COMB", SX9311_REG_USE_MSB),
+
+	SX9311_CHANNEL(4, "DIFF_CS0", SX9311_REG_DIFF_MSB),
+	SX9311_CHANNEL(5, "DIFF_CS1", SX9311_REG_DIFF_MSB),
+	SX9311_CHANNEL(6, "DIFF_CS2", SX9311_REG_DIFF_MSB),
+	SX9311_CHANNEL(7, "DIFF_COMB", SX9311_REG_DIFF_MSB),
+
+	IIO_CHAN_SOFT_TIMESTAMP(8),
+};
+
+/*
+ * Each entry contains the integer part (val) and the fractional part, in micro
+ * seconds. It conforms to the IIO output IIO_VAL_INT_PLUS_MICRO.
+ */
+static const struct {
+	int val;
+	int val2;
+} sx9311_samp_freq_table[] = {
+	{500, 0}, /* 0000: Min (no idle time) */
+	{66, 666666}, /* 0001: 15 ms */
+	{33, 333333}, /* 0010: 30 ms (Typ.) */
+	{22, 222222}, /* 0011: 45 ms */
+	{16, 666666}, /* 0100: 60 ms */
+	{11, 111111}, /* 0101: 90 ms */
+	{8, 333333}, /* 0110: 120 ms */
+	{5, 0}, /* 0111: 200 ms */
+	{2, 500000}, /* 1000: 400 ms */
+	{1, 666666}, /* 1001: 600 ms */
+	{1, 250000}, /* 1010: 800 ms */
+	{1, 0}, /* 1011: 1 s */
+	{0, 500000}, /* 1100: 2 s */
+	{8, 333333}, /* 1101: 3 s */
+	{0, 250000}, /* 1110: 4 s */
+	{0, 200000}, /* 1111: 5 s */
+};
+static const unsigned int sx9311_scan_period_table[] = {
+	2, 15, 30, 45, 60, 90, 120, 200, 400, 800, 1000, 2000, 3000, 4000, 5000,
+};
+
+static IIO_CONST_ATTR_SAMP_FREQ_AVAIL(
+	"500.0 66.666666 33.333333 22.222222 16.666666 "
+	"11.111111 8.333333 5.0 2.500000 1.666666 1.250000 "
+	"1.0 0.500000 8.333333 0.250000 0.200000");
+
+
+static const struct regmap_range sx9311_writable_reg_ranges[] = {
+	regmap_reg_range(SX9311_REG_IRQ_MSK, SX9311_REG_IRQ_FUNC),
+	regmap_reg_range(SX9311_REG_PROX_CTRL0, SX9311_REG_PROX_CTRL19),
+	regmap_reg_range(SX9311_REG_SAR_CTRL0, SX9311_REG_SAR_CTRL2),
+	regmap_reg_range(SX9311_REG_SENSOR_SEL, SX9311_REG_SENSOR_SEL),
+	regmap_reg_range(SX9311_REG_OFFSET_MSB, SX9311_REG_OFFSET_LSB),
+	regmap_reg_range(SX9311_REG_PAUSE, SX9311_REG_PAUSE),
+	regmap_reg_range(SX9311_REG_RESET, SX9311_REG_RESET),
+};
+
+static const struct regmap_access_table sx9311_writeable_regs = {
+	.yes_ranges = sx9311_writable_reg_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sx9311_writable_reg_ranges),
+};
+
+/*
+ * All allocated registers are readable, so we just list unallocated
+ * ones.
+ */
+static const struct regmap_range sx9311_non_readable_reg_ranges[] = {
+	regmap_reg_range(SX9311_REG_IRQ_FUNC + 1, SX9311_REG_PROX_CTRL0 - 1),
+	regmap_reg_range(SX9311_REG_SAR_CTRL2 + 1, SX9311_REG_SENSOR_SEL - 1),
+	regmap_reg_range(SX9311_REG_SAR_LSB + 1, SX9311_REG_I2CADDR - 1),
+	regmap_reg_range(SX9311_REG_WHOAMI + 1, SX9311_REG_RESET - 1),
+};
+
+static const struct regmap_access_table sx9311_readable_regs = {
+	.no_ranges = sx9311_non_readable_reg_ranges,
+	.n_no_ranges = ARRAY_SIZE(sx9311_non_readable_reg_ranges),
+};
+
+static const struct regmap_range sx9311_volatile_reg_ranges[] = {
+	regmap_reg_range(SX9311_REG_IRQ_SRC, SX9311_REG_STAT1),
+	regmap_reg_range(SX9311_REG_USE_MSB, SX9311_REG_DIFF_LSB),
+	regmap_reg_range(SX9311_REG_SAR_MSB, SX9311_REG_SAR_LSB),
+	regmap_reg_range(SX9311_REG_RESET, SX9311_REG_RESET),
+};
+
+static const struct regmap_access_table sx9311_volatile_regs = {
+	.yes_ranges = sx9311_volatile_reg_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sx9311_volatile_reg_ranges),
+};
+
+static const struct regmap_config sx9311_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = SX9311_REG_RESET,
+	.cache_type = REGCACHE_RBTREE,
+
+	.wr_table = &sx9311_writeable_regs,
+	.rd_table = &sx9311_readable_regs,
+	.volatile_table = &sx9311_volatile_regs,
+};
+
+static int sx9311_inc_users(struct sx9311_data *data, int *counter,
+			    unsigned int reg, unsigned int bitmask)
+{
+	++(*counter);
+	if (*counter != 1)
+		/* Bit is already active, nothing to do. */
+		return 0;
+
+	return regmap_update_bits(data->regmap, reg, bitmask, bitmask);
+}
+
+static int sx9311_dec_users(struct sx9311_data *data, int *counter,
+			    unsigned int reg, unsigned int bitmask)
+{
+	--(*counter);
+	if (*counter != 0)
+		/* There are more users, do not deactivate. */
+		return 0;
+
+	return regmap_update_bits(data->regmap, reg, bitmask, 0);
+}
+
+static int sx9311_inc_chan_users(struct sx9311_data *data, int chan)
+{
+	return sx9311_inc_users(data, &data->channel_users[chan],
+				SX9311_REG_PROX_CTRL0, BIT(chan));
+}
+
+static int sx9311_dec_chan_users(struct sx9311_data *data, int chan)
+{
+	return sx9311_dec_users(data, &data->channel_users[chan],
+				SX9311_REG_PROX_CTRL0, BIT(chan));
+}
+
+static int sx9311_inc_data_rdy_users(struct sx9311_data *data)
+{
+	return sx9311_inc_users(data, &data->data_rdy_users,
+				SX9311_REG_IRQ_MSK, SX9311_CONVDONE_IRQ);
+}
+
+static int sx9311_dec_data_rdy_users(struct sx9311_data *data)
+{
+	return sx9311_dec_users(data, &data->data_rdy_users,
+				SX9311_REG_IRQ_MSK, SX9311_CONVDONE_IRQ);
+}
+
+static int sx9311_inc_close_far_users(struct sx9311_data *data)
+{
+	return sx9311_inc_users(data, &data->close_far_users,
+				SX9311_REG_IRQ_MSK,
+				SX9311_CLOSE_IRQ | SX9311_FAR_IRQ);
+}
+
+static int sx9311_dec_close_far_users(struct sx9311_data *data)
+{
+	return sx9311_dec_users(data, &data->close_far_users,
+				SX9311_REG_IRQ_MSK,
+				SX9311_CLOSE_IRQ | SX9311_FAR_IRQ);
+}
+
+static int sx9311_read_prox_data(struct sx9311_data *data,
+				 const struct iio_chan_spec *chan,
+				 int *val)
+{
+	int ret;
+	__be16 regval;
+
+	ret = regmap_write(data->regmap, SX9311_REG_SENSOR_SEL, chan->channel);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_bulk_read(data->regmap, chan->address, &regval, 2);
+	if (ret < 0)
+		return ret;
+
+	*val = sign_extend32(be16_to_cpu(regval),
+			(chan->address == SX9311_REG_DIFF_MSB ? 11 : 15));
+
+	return 0;
+}
+
+/*
+ * If we have no interrupt support, we have to wait for a scan period
+ * after enabling a channel to get a result.
+ */
+static int sx9311_wait_for_sample(struct sx9311_data *data)
+{
+	int ret;
+	unsigned int val;
+
+	ret = regmap_read(data->regmap, SX9311_REG_PROX_CTRL0, &val);
+	if (ret < 0)
+		return ret;
+
+	val = (val & SX9311_SCAN_PERIOD_MASK) >> SX9311_SCAN_PERIOD_SHIFT;
+
+	msleep(sx9311_scan_period_table[val]);
+
+	return 0;
+}
+
+static int sx9311_read_proximity(struct sx9311_data *data,
+				 const struct iio_chan_spec *chan,
+				 int *val)
+{
+	int ret;
+
+	mutex_lock(&data->mutex);
+
+	ret = sx9311_inc_chan_users(data, chan->channel & SX9311_CHAN_MASK);
+	if (ret < 0)
+		goto out;
+
+	ret = sx9311_inc_data_rdy_users(data);
+	if (ret < 0)
+		goto out_dec_chan;
+
+	mutex_unlock(&data->mutex);
+
+	if (data->client->irq > 0)
+		ret = wait_for_completion_interruptible(&data->completion);
+	else
+		ret = sx9311_wait_for_sample(data);
+
+	mutex_lock(&data->mutex);
+
+	if (ret < 0)
+		goto out_dec_data_rdy;
+
+	ret = sx9311_read_prox_data(data, chan, val);
+	if (ret < 0)
+		goto out_dec_data_rdy;
+
+	ret = sx9311_dec_data_rdy_users(data);
+	if (ret < 0)
+		goto out_dec_chan;
+
+	ret = sx9311_dec_chan_users(data, chan->channel & SX9311_CHAN_MASK);
+	if (ret < 0)
+		goto out;
+
+	ret = IIO_VAL_INT;
+
+	goto out;
+
+out_dec_data_rdy:
+	sx9311_dec_data_rdy_users(data);
+out_dec_chan:
+	sx9311_dec_chan_users(data, chan->channel & SX9311_CHAN_MASK);
+out:
+	mutex_unlock(&data->mutex);
+	reinit_completion(&data->completion);
+
+	return ret;
+}
+
+static int sx9311_read_samp_freq(struct sx9311_data *data,
+				 int *val, int *val2)
+{
+	int ret;
+	unsigned int regval;
+
+	mutex_lock(&data->mutex);
+	ret = regmap_read(data->regmap, SX9311_REG_PROX_CTRL0, &regval);
+
+	mutex_unlock(&data->mutex);
+	if (ret < 0)
+		return ret;
+
+	regval = (regval & SX9311_SCAN_PERIOD_MASK) >> SX9311_SCAN_PERIOD_SHIFT;
+	*val = sx9311_samp_freq_table[regval].val;
+	*val2 = sx9311_samp_freq_table[regval].val2;
+
+	return IIO_VAL_INT_PLUS_MICRO;
+}
+
+static int sx9311_read_raw(struct iio_dev *indio_dev,
+			   const struct iio_chan_spec *chan,
+			   int *val, int *val2, long mask)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret;
+
+	switch (chan->type) {
+	case IIO_PROXIMITY:
+		switch (mask) {
+		case IIO_CHAN_INFO_RAW:
+			mutex_lock(&indio_dev->mlock);
+
+			if (iio_buffer_enabled(indio_dev)) {
+				mutex_unlock(&indio_dev->mlock);
+				return -EBUSY;
+			}
+			ret = sx9311_read_proximity(data, chan, val);
+			mutex_unlock(&indio_dev->mlock);
+			return ret;
+		case IIO_CHAN_INFO_SAMP_FREQ:
+			return sx9311_read_samp_freq(data, val, val2);
+		default:
+			return -EINVAL;
+		}
+	default:
+		return -EINVAL;
+	}
+}
+
+static int sx9311_set_samp_freq(struct sx9311_data *data,
+				int val, int val2)
+{
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(sx9311_samp_freq_table); i++)
+		if (val == sx9311_samp_freq_table[i].val &&
+		    val2 == sx9311_samp_freq_table[i].val2)
+			break;
+
+	if (i == ARRAY_SIZE(sx9311_samp_freq_table))
+		return -EINVAL;
+
+	mutex_lock(&data->mutex);
+
+	ret = regmap_update_bits(data->regmap, SX9311_REG_PROX_CTRL0,
+				 SX9311_SCAN_PERIOD_MASK,
+				 i << SX9311_SCAN_PERIOD_SHIFT);
+
+	mutex_unlock(&data->mutex);
+
+	return ret;
+}
+
+static int sx9311_write_raw(struct iio_dev *indio_dev,
+			    const struct iio_chan_spec *chan,
+			    int val, int val2, long mask)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+
+	switch (chan->type) {
+	case IIO_PROXIMITY:
+		switch (mask) {
+		case IIO_CHAN_INFO_SAMP_FREQ:
+			return sx9311_set_samp_freq(data, val, val2);
+		default:
+			return -EINVAL;
+		}
+	default:
+		return -EINVAL;
+	}
+}
+
+static irqreturn_t sx9311_irq_handler(int irq, void *private)
+{
+	struct iio_dev *indio_dev = private;
+	struct sx9311_data *data = iio_priv(indio_dev);
+
+	if (data->trigger_enabled)
+		iio_trigger_poll(data->trig);
+
+	/*
+	 * Even if no event is enabled, we need to wake the thread to
+	 * clear the interrupt state by reading SX9311_REG_IRQ_SRC.  It
+	 * is not possible to do that here because regmap_read takes a
+	 * mutex.
+	 */
+	return IRQ_WAKE_THREAD;
+}
+
+static void sx9311_push_events(struct iio_dev *indio_dev)
+{
+	int ret;
+	unsigned int val, chan;
+	struct sx9311_data *data = iio_priv(indio_dev);
+
+	ret = regmap_read(data->regmap, SX9311_REG_STAT0, &val);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "i2c transfer error in irq\n");
+		return;
+	}
+
+	for (chan = 0; chan < SX9311_NUM_CHANNELS; chan++) {
+		int dir;
+		u64 ev;
+		bool new_prox = val & BIT(chan);
+
+		if (!data->event_enabled[chan])
+			continue;
+		if (new_prox == data->prox_stat[chan])
+			/* No change on this channel. */
+			continue;
+
+		dir = new_prox ? IIO_EV_DIR_FALLING : IIO_EV_DIR_RISING;
+		ev = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, chan,
+					  IIO_EV_TYPE_THRESH, dir);
+		iio_push_event(indio_dev, ev, iio_get_time_ns(indio_dev));
+		data->prox_stat[chan] = new_prox;
+	}
+}
+
+static irqreturn_t sx9311_irq_thread_handler(int irq, void *private)
+{
+	struct iio_dev *indio_dev = private;
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret;
+	unsigned int val;
+
+	mutex_lock(&data->mutex);
+
+	ret = regmap_read(data->regmap, SX9311_REG_IRQ_SRC, &val);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "i2c transfer error in irq\n");
+		goto out;
+	}
+
+	if (val & (SX9311_CLOSE_IRQ | SX9311_FAR_IRQ))
+		sx9311_push_events(indio_dev);
+
+	if (val & SX9311_CONVDONE_IRQ)
+		complete(&data->completion);
+
+out:
+	mutex_unlock(&data->mutex);
+
+	return IRQ_HANDLED;
+}
+
+static int sx9311_read_event_config(struct iio_dev *indio_dev,
+				    const struct iio_chan_spec *chan,
+				    enum iio_event_type type,
+				    enum iio_event_direction dir)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+
+	if (chan->type != IIO_PROXIMITY || type != IIO_EV_TYPE_THRESH ||
+	    dir != IIO_EV_DIR_EITHER)
+		return -EINVAL;
+
+	return data->event_enabled[chan->channel & SX9311_CHAN_MASK];
+}
+
+static int sx9311_write_event_config(struct iio_dev *indio_dev,
+				     const struct iio_chan_spec *chan,
+				     enum iio_event_type type,
+				     enum iio_event_direction dir,
+				     int state)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret, sx_channel = chan->channel & SX9311_CHAN_MASK;
+
+	if (chan->type != IIO_PROXIMITY || type != IIO_EV_TYPE_THRESH ||
+	    dir != IIO_EV_DIR_EITHER)
+		return -EINVAL;
+
+	mutex_lock(&data->mutex);
+
+	if (state == 1) {
+		ret = sx9311_inc_chan_users(data, sx_channel);
+		if (ret < 0)
+			goto out_unlock;
+		ret = sx9311_inc_close_far_users(data);
+		if (ret < 0)
+			goto out_undo_chan;
+	} else {
+		ret = sx9311_dec_chan_users(data, sx_channel);
+		if (ret < 0)
+			goto out_unlock;
+		ret = sx9311_dec_close_far_users(data);
+		if (ret < 0)
+			goto out_undo_chan;
+	}
+
+	data->event_enabled[sx_channel] = state;
+	goto out_unlock;
+
+out_undo_chan:
+	if (state == 1)
+		sx9311_dec_chan_users(data, sx_channel);
+	else
+		sx9311_inc_chan_users(data, sx_channel);
+out_unlock:
+	mutex_unlock(&data->mutex);
+	return ret;
+}
+
+static int sx9311_update_scan_mode(struct iio_dev *indio_dev,
+				   const unsigned long *scan_mask)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+
+	mutex_lock(&data->mutex);
+	kfree(data->buffer);
+	data->buffer = kzalloc(indio_dev->scan_bytes, GFP_KERNEL);
+	mutex_unlock(&data->mutex);
+
+	if (data->buffer == NULL)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static struct attribute *sx9311_attributes[] = {
+	&iio_const_attr_sampling_frequency_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group sx9311_attribute_group = {
+	.attrs = sx9311_attributes,
+};
+
+static const struct iio_info sx9311_info = {
+	.attrs = &sx9311_attribute_group,
+	.read_raw = &sx9311_read_raw,
+	.write_raw = &sx9311_write_raw,
+	.read_event_config = &sx9311_read_event_config,
+	.write_event_config = &sx9311_write_event_config,
+	.update_scan_mode = &sx9311_update_scan_mode,
+};
+
+static int sx9311_set_trigger_state(struct iio_trigger *trig,
+				    bool state)
+{
+	struct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret;
+
+	mutex_lock(&data->mutex);
+
+	if (state)
+		ret = sx9311_inc_data_rdy_users(data);
+	else
+		ret = sx9311_dec_data_rdy_users(data);
+	if (ret < 0)
+		goto out;
+
+	data->trigger_enabled = state;
+
+out:
+	mutex_unlock(&data->mutex);
+
+	return ret;
+}
+
+static const struct iio_trigger_ops sx9311_trigger_ops = {
+	.set_trigger_state = sx9311_set_trigger_state,
+};
+
+static irqreturn_t sx9311_trigger_handler(int irq, void *private)
+{
+	struct iio_poll_func *pf = private;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int val, bit, ret, i = 0;
+
+	mutex_lock(&data->mutex);
+
+	for_each_set_bit(bit, indio_dev->active_scan_mask,
+			 indio_dev->masklength) {
+		ret = sx9311_read_prox_data(data, &indio_dev->channels[bit],
+					    &val);
+		if (ret < 0)
+			goto out;
+
+		data->buffer[i++] = val;
+	}
+
+	iio_push_to_buffers_with_timestamp(indio_dev, data->buffer,
+					   iio_get_time_ns(indio_dev));
+
+out:
+	mutex_unlock(&data->mutex);
+
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+}
+
+static int sx9311_buffer_preenable(struct iio_dev *indio_dev)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret = 0, i;
+
+	mutex_lock(&data->mutex);
+
+	for (i = 0; i < SX9311_NUM_CHANNELS; i++)
+		if (test_bit(i, indio_dev->active_scan_mask)) {
+			ret = sx9311_inc_chan_users(data, i);
+			if (ret)
+				break;
+		}
+
+	if (ret)
+		for (i = i - 1; i >= 0; i--)
+			if (test_bit(i, indio_dev->active_scan_mask))
+				sx9311_dec_chan_users(data, i);
+
+	mutex_unlock(&data->mutex);
+
+	return ret;
+}
+
+static int sx9311_buffer_predisable(struct iio_dev *indio_dev)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret = 0, i;
+
+	iio_triggered_buffer_predisable(indio_dev);
+
+	mutex_lock(&data->mutex);
+
+	for (i = 0; i < SX9311_NUM_CHANNELS; i++)
+		if (test_bit(i, indio_dev->active_scan_mask)) {
+			ret = sx9311_dec_chan_users(data, i);
+			if (ret)
+				break;
+		}
+
+	if (ret)
+		for (i = i - 1; i >= 0; i--)
+			if (test_bit(i, indio_dev->active_scan_mask))
+				sx9311_inc_chan_users(data, i);
+
+	mutex_unlock(&data->mutex);
+
+	return ret;
+}
+
+static const struct iio_buffer_setup_ops sx9311_buffer_setup_ops = {
+	.preenable = sx9311_buffer_preenable,
+	.postenable = iio_triggered_buffer_postenable,
+	.predisable = sx9311_buffer_predisable,
+};
+
+struct sx9311_reg_config {
+	const char *register_name;
+	u8 reg;
+	u8 def;
+};
+
+#define SX9311_REG_CONFIG(_name, _reg, _def) \
+{ \
+	.register_name = SX9311_ACPI_NAME ",reg_" _name, \
+	.reg = SX9311_REG_##_reg, \
+	.def = _def \
+}
+
+static const struct sx9311_reg_config sx9311_default_regs[] = {
+	{
+		.register_name = NULL,
+		.reg = SX9311_REG_IRQ_MSK,
+		.def = 0x60,
+	},
+	{
+		.register_name = NULL,
+		.reg = SX9311_REG_IRQ_FUNC,
+		.def = 0x00,
+	},
+	/*
+	 * The lower 4 bits should not be set as it enable sensors measurements.
+	 * Turning the detection on before the configuration values are set to
+	 * good values can cause the device to return erroneous readings.
+	 */
+	SX9311_REG_CONFIG("prox_ctrl0",  PROX_CTRL0,  0x23),
+	SX9311_REG_CONFIG("prox_ctrl1",  PROX_CTRL1,  0x00),
+	SX9311_REG_CONFIG("prox_ctrl2",  PROX_CTRL2,  0x0B),
+	SX9311_REG_CONFIG("prox_ctrl3",  PROX_CTRL3,  0x0F),
+	SX9311_REG_CONFIG("prox_ctrl4",  PROX_CTRL4,  0x0D),
+	SX9311_REG_CONFIG("prox_ctrl5",  PROX_CTRL5,  0xC3),
+	SX9311_REG_CONFIG("prox_ctrl6",  PROX_CTRL6,  0x20),
+	SX9311_REG_CONFIG("prox_ctrl7",  PROX_CTRL7,  0x4C),
+	SX9311_REG_CONFIG("prox_ctrl8",  PROX_CTRL8,  0x68),
+	SX9311_REG_CONFIG("prox_ctrl9",  PROX_CTRL9,  0x68),
+	SX9311_REG_CONFIG("prox_ctrl10", PROX_CTRL10, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl11", PROX_CTRL11, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl12", PROX_CTRL12, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl13", PROX_CTRL13, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl14", PROX_CTRL14, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl15", PROX_CTRL15, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl16", PROX_CTRL16, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl17", PROX_CTRL17, 0x04),
+	SX9311_REG_CONFIG("prox_ctrl18", PROX_CTRL18, 0x00),
+	SX9311_REG_CONFIG("prox_ctrl19", PROX_CTRL19, 0x00),
+	SX9311_REG_CONFIG("sar_ctrl0",   SAR_CTRL0,   0x00),
+	SX9311_REG_CONFIG("sar_ctrl1",   SAR_CTRL1,   0x80),
+	SX9311_REG_CONFIG("sar_ctrl2",   SAR_CTRL2,   0x0C),
+};
+
+static int sx9311_read_register_property(struct acpi_device *adev,
+					const struct sx9311_reg_config *cfg,
+					u8 *value)
+{
+	/* FIXME: only ACPI supported. */
+	const union acpi_object *acpi_value = NULL;
+	int ret;
+
+	if ((adev == NULL) || (cfg->register_name == NULL)) {
+		*value = cfg->def;
+		return 0;
+	}
+
+	ret = acpi_dev_get_property(adev, cfg->register_name,
+				    ACPI_TYPE_INTEGER, &acpi_value);
+	switch (ret) {
+	case -EPROTO:
+		break;
+	case -EINVAL:
+		break;
+	}
+
+	*value = acpi_value ? (u8)acpi_value->integer.value : cfg->def;
+	return 0;
+}
+
+static int sx9311_load_config(struct device *dev, struct regmap *regmap)
+{
+	u8 val;
+	int i, ret;
+	const struct sx9311_reg_config *cfg;
+	struct acpi_device *adev = ACPI_COMPANION(dev);
+
+	if (adev == NULL)
+		dev_warn(dev, "ACPI configuration missing\n");
+
+	for (i = 0; i < ARRAY_SIZE(sx9311_default_regs); ++i) {
+		cfg = &sx9311_default_regs[i];
+		ret = sx9311_read_register_property(adev, cfg, &val);
+		if (ret < 0)
+			return ret;
+		ret = regmap_write(regmap, cfg->reg, val);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+/* Activate all channels and perform an initial compensation. */
+static int sx9311_init_compensation(struct iio_dev *indio_dev)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int i, ret;
+	unsigned int val;
+	unsigned int ctrl0;
+
+	ret = regmap_read(data->regmap, SX9311_REG_PROX_CTRL0, &ctrl0);
+	if (ret < 0)
+		return ret;
+
+	/* run the compensation phase on all channels */
+	ret = regmap_write(data->regmap, SX9311_REG_PROX_CTRL0, ctrl0 | 0xF);
+	if (ret < 0)
+		return ret;
+
+	for (i = 100; i >= 0; i--) {
+		usleep_range(10000, 20000);
+		ret = regmap_read(data->regmap, SX9311_REG_STAT1, &val);
+		if (ret < 0)
+			goto out;
+		if (!(val & SX9311_COMPSTAT_MASK))
+			break;
+	}
+
+	if (i < 0) {
+		dev_err(&data->client->dev,
+			"initial compensation timed out: 0x%02x", val);
+		ret = -ETIMEDOUT;
+	}
+
+out:
+	regmap_write(data->regmap, SX9311_REG_PROX_CTRL0, ctrl0);
+	return ret;
+}
+
+static int sx9311_init_device(struct iio_dev *indio_dev)
+{
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret;
+	unsigned int val;
+
+	ret = regmap_write(data->regmap, SX9311_REG_IRQ_MSK, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_write(data->regmap, SX9311_REG_RESET,
+			   SX9311_SOFT_RESET);
+	if (ret < 0)
+		return ret;
+
+	usleep_range(1000, 2000);  /* power-up time is ~1ms. */
+
+	ret = regmap_write(data->regmap, SX9311_REG_RESET, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_read(data->regmap, SX9311_REG_IRQ_SRC, &val);
+	if (ret < 0)
+		return ret;
+
+	ret = sx9311_load_config(&indio_dev->dev, data->regmap);
+	if (ret < 0)
+		return ret;
+
+	return sx9311_init_compensation(indio_dev);
+}
+
+static int sx9311_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int ret;
+	struct iio_dev *indio_dev;
+	struct sx9311_data *data;
+	unsigned int whoami;
+
+	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
+	if (indio_dev == NULL)
+		return -ENOMEM;
+
+	data = iio_priv(indio_dev);
+	data->client = client;
+	mutex_init(&data->mutex);
+	init_completion(&data->completion);
+	data->trigger_enabled = false;
+
+	data->regmap = devm_regmap_init_i2c(client, &sx9311_regmap_config);
+	if (IS_ERR(data->regmap))
+		return PTR_ERR(data->regmap);
+
+	ret = regmap_read(data->regmap, SX9311_REG_WHOAMI, &whoami);
+	if (ret < 0) {
+		dev_err(&client->dev,
+				"error in reading WHOAMI register: %d", ret);
+		return -ENODEV;
+	}
+	if (whoami != SX9311_WHOAMI_VALUE) {
+		dev_err(&client->dev, "unexpected WHOAMI response: %u", whoami);
+		return -ENODEV;
+	}
+
+	ACPI_COMPANION_SET(&indio_dev->dev, ACPI_COMPANION(&client->dev));
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->name = SX9311_DRIVER_NAME;
+	indio_dev->channels = sx9311_channels;
+	indio_dev->num_channels = ARRAY_SIZE(sx9311_channels);
+	indio_dev->info = &sx9311_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	i2c_set_clientdata(client, indio_dev);
+
+	ret = sx9311_init_device(indio_dev);
+	if (ret < 0)
+		return ret;
+
+	if (client->irq <= 0)
+		dev_warn(&client->dev, "no valid irq found\n");
+	else {
+		ret = devm_request_threaded_irq(&client->dev, client->irq,
+				sx9311_irq_handler, sx9311_irq_thread_handler,
+				IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+				SX9311_IRQ_NAME, indio_dev);
+		if (ret < 0)
+			return ret;
+
+		data->trig = devm_iio_trigger_alloc(&client->dev,
+				"%s-dev%d", indio_dev->name, indio_dev->id);
+		if (!data->trig)
+			return -ENOMEM;
+
+		data->trig->dev.parent = &client->dev;
+		data->trig->ops = &sx9311_trigger_ops;
+		iio_trigger_set_drvdata(data->trig, indio_dev);
+
+		ret = iio_trigger_register(data->trig);
+		if (ret)
+			return ret;
+	}
+
+	ret = devm_iio_triggered_buffer_setup(&client->dev, indio_dev,
+					      NULL, sx9311_trigger_handler,
+					      &sx9311_buffer_setup_ops);
+	if (ret < 0)
+		goto out_trigger_unregister;
+
+	ret = devm_iio_device_register(&client->dev, indio_dev);
+	if (ret < 0)
+		goto out_trigger_unregister;
+
+	return 0;
+
+out_trigger_unregister:
+	if (client->irq > 0)
+		iio_trigger_unregister(data->trig);
+
+	return ret;
+}
+
+static int sx9311_remove(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct sx9311_data *data = iio_priv(indio_dev);
+
+	if (client->irq > 0)
+		iio_trigger_unregister(data->trig);
+	kfree(data->buffer);
+	return 0;
+}
+
+static int __maybe_unused sx9311_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret;
+
+	disable_irq_nosync(data->client->irq);
+
+	mutex_lock(&data->mutex);
+	ret = regmap_write(data->regmap, SX9311_REG_PAUSE, 0);
+	mutex_unlock(&data->mutex);
+
+	return ret;
+}
+
+static int __maybe_unused sx9311_resume(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+	struct sx9311_data *data = iio_priv(indio_dev);
+	int ret;
+
+	mutex_lock(&data->mutex);
+	ret = regmap_write(data->regmap, SX9311_REG_PAUSE, 1);
+	mutex_unlock(&data->mutex);
+
+	enable_irq(data->client->irq);
+
+	return ret;
+}
+
+static const struct dev_pm_ops sx9311_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sx9311_suspend, sx9311_resume)
+};
+
+static const struct acpi_device_id sx9311_acpi_match[] = {
+	{SX9311_ACPI_NAME, 0},
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, sx9311_acpi_match);
+
+static const struct of_device_id sx9311_of_match[] = {
+	{ .compatible = "semtech," SX9311_DRIVER_NAME, },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, sx9311_of_match);
+
+static const struct i2c_device_id sx9311_id[] = {
+	{SX9311_DRIVER_NAME, 0},
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, sx9311_id);
+
+static struct i2c_driver sx9311_driver = {
+	.driver = {
+		.name	= SX9311_DRIVER_NAME,
+		.acpi_match_table = ACPI_PTR(sx9311_acpi_match),
+		.of_match_table = of_match_ptr(sx9311_of_match),
+		.pm = &sx9311_pm_ops,
+	},
+	.probe		= sx9311_probe,
+	.remove		= sx9311_remove,
+	.id_table	= sx9311_id,
+};
+module_i2c_driver(sx9311_driver);
+
+MODULE_AUTHOR("Phoenix Wu <wujing6@huaqin.corp-partner.google.com>");
+MODULE_DESCRIPTION("Driver for Semtech SX9311 proximity sensor");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
index 80a38ad0db15..24cbdb04764d 100644
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -2454,7 +2454,7 @@ int ath10k_core_start(struct ath10k *ar, enum ath10k_firmware_mode mode,
 		goto err_hif_stop;
 	}
 
-	status = ath10k_hif_swap_mailbox(ar);
+	status = ath10k_hif_swap_mailbox(ar, mode);
 	if (status) {
 		ath10k_err(ar, "failed to swap mailbox: %d\n", status);
 		goto err_hif_stop;
diff --git a/drivers/net/wireless/ath/ath10k/hif.h b/drivers/net/wireless/ath/ath10k/hif.h
index 5f7f1e08866f..5c342a1a2b9a 100644
--- a/drivers/net/wireless/ath/ath10k/hif.h
+++ b/drivers/net/wireless/ath/ath10k/hif.h
@@ -59,7 +59,7 @@ struct ath10k_hif_ops {
 	 */
 	void (*stop)(struct ath10k *ar);
 
-	int (*swap_mailbox)(struct ath10k *ar);
+	int (*swap_mailbox)(struct ath10k *ar, enum ath10k_firmware_mode mode);
 
 	int (*map_service_to_pipe)(struct ath10k *ar, u16 service_id,
 				   u8 *ul_pipe, u8 *dl_pipe);
@@ -141,10 +141,10 @@ static inline void ath10k_hif_stop(struct ath10k *ar)
 	return ar->hif.ops->stop(ar);
 }
 
-static inline int ath10k_hif_swap_mailbox(struct ath10k *ar)
+static inline int ath10k_hif_swap_mailbox(struct ath10k *ar, enum ath10k_firmware_mode mode)
 {
 	if (ar->hif.ops->swap_mailbox)
-		return ar->hif.ops->swap_mailbox(ar);
+		return ar->hif.ops->swap_mailbox(ar, mode);
 	return 0;
 }
 
diff --git a/drivers/net/wireless/ath/ath10k/sdio.c b/drivers/net/wireless/ath/ath10k/sdio.c
index 1ea6d2dc2f29..88eca876c716 100644
--- a/drivers/net/wireless/ath/ath10k/sdio.c
+++ b/drivers/net/wireless/ath/ath10k/sdio.c
@@ -1629,7 +1629,7 @@ static int ath10k_sdio_hif_diag_write_mem(struct ath10k *ar, u32 address,
 	return 0;
 }
 
-static int ath10k_sdio_hif_swap_mailbox(struct ath10k *ar)
+static int ath10k_sdio_hif_swap_mailbox(struct ath10k *ar, enum ath10k_firmware_mode mode)
 {
 	struct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);
 	u32 addr, val;
@@ -1648,6 +1648,8 @@ static int ath10k_sdio_hif_swap_mailbox(struct ath10k *ar)
 			   "sdio mailbox swap service enabled\n");
 		ar_sdio->swap_mbox = true;
 	}
+        if(mode == ATH10K_FIRMWARE_MODE_UTF)
+                ar_sdio->swap_mbox = false;
 	return 0;
 }
 
diff --git a/drivers/thermal/mtk_thermal.c b/drivers/thermal/mtk_thermal.c
old mode 100644
new mode 100755
index e4ea7f6aef20..61a18c0d271c
--- a/drivers/thermal/mtk_thermal.c
+++ b/drivers/thermal/mtk_thermal.c
@@ -219,6 +219,9 @@ enum {
 /* The total number of temperature sensors in the MT8183 */
 #define MT8183_NUM_SENSORS	6
 
+/* The number of banks in the MT8183 */
+#define MT8183_NUM_ZONES               5
+
 /* The number of sensing points per bank */
 #define MT8183_NUM_SENSORS_PER_ZONE	 6
 
@@ -275,8 +278,12 @@ struct mtk_thermal {
 };
 
 /* MT8183 thermal sensor data */
-static const int mt8183_bank_data[MT8183_NUM_SENSORS] = {
-	MT8183_TS1, MT8183_TS2, MT8183_TS3, MT8183_TS4, MT8183_TS5, MT8183_TSABB
+static const int mt8183_bank_data[MT8183_NUM_ZONES][2] = {
+	{MT8183_TS1},
+	{MT8183_TS2},
+	{MT8183_TS3},
+	{MT8183_TS4},
+	{MT8183_TS5},
 };
 
 static const int mt8183_msr[MT8183_NUM_SENSORS_PER_ZONE] = {
@@ -506,7 +513,7 @@ static const struct mtk_thermal_data mt7622_thermal_data = {
 
 static const struct mtk_thermal_data mt8183_thermal_data = {
 	.auxadc_channel = MT8183_TEMP_AUXADC_CHANNEL,
-	.num_banks = MT8183_NUM_SENSORS_PER_ZONE,
+	.num_banks = MT8183_NUM_ZONES,
 	.num_sensors = MT8183_NUM_SENSORS,
 	.vts_index = mt8183_vts_index,
 	.cali_val = MT8183_CALIBRATION,
@@ -515,8 +522,24 @@ static const struct mtk_thermal_data mt8183_thermal_data = {
 	.need_switch_bank = false,
 	.bank_data = {
 		{
-			.num_sensors = 6,
-			.sensors = mt8183_bank_data,
+			.num_sensors = 1,
+			.sensors = mt8183_bank_data[0],
+		},
+                {
+			.num_sensors = 1,
+			.sensors = mt8183_bank_data[1],
+		},
+		{
+			.num_sensors = 1,
+			.sensors = mt8183_bank_data[2],
+		},
+		{
+			.num_sensors = 1,
+			.sensors = mt8183_bank_data[3],
+		},
+		{
+			.num_sensors = 1,
+			.sensors = mt8183_bank_data[4],
 		},
 	},
 
@@ -605,7 +628,6 @@ static int mtk_thermal_bank_temperature(struct mtk_thermal_bank *bank)
 		temp = raw_to_mcelsius(mt,
 				       conf->bank_data[bank->id].sensors[i],
 				       raw);
-
 		/*
 		 * The first read of a sensor often contains very high bogus
 		 * temperature value. Filter these out so that the system does
@@ -617,7 +639,6 @@ static int mtk_thermal_bank_temperature(struct mtk_thermal_bank *bank)
 		if (temp > max)
 			max = temp;
 	}
-
 	return max;
 }
 
@@ -642,10 +663,80 @@ static int mtk_read_temp(void *data, int *temperature)
 	return 0;
 }
 
+static int mtk_read_zone1_temp(void *data, int *temperature)
+{
+        struct mtk_thermal *mt = data;
+	struct mtk_thermal_bank *bank = &mt->banks[0];
+
+        *temperature = mtk_thermal_bank_temperature(bank);
+
+	return 0;
+}
+
+static int mtk_read_zone2_temp(void *data, int *temperature)
+{
+        struct mtk_thermal *mt = data;
+        struct mtk_thermal_bank *bank = &mt->banks[1];
+
+        *temperature = mtk_thermal_bank_temperature(bank);
+
+        return 0;
+}
+
+static int mtk_read_zone3_temp(void *data, int *temperature)
+{
+        struct mtk_thermal *mt = data;
+        struct mtk_thermal_bank *bank = &mt->banks[2];
+
+        *temperature = mtk_thermal_bank_temperature(bank);
+
+        return 0;
+}
+
+static int mtk_read_zone4_temp(void *data, int *temperature)
+{
+        struct mtk_thermal *mt = data;
+        struct mtk_thermal_bank *bank = &mt->banks[3];
+
+        *temperature = mtk_thermal_bank_temperature(bank);
+
+        return 0;
+}
+
+static int mtk_read_zone5_temp(void *data, int *temperature)
+{
+        struct mtk_thermal *mt = data;
+        struct mtk_thermal_bank *bank = &mt->banks[4];
+
+        *temperature = mtk_thermal_bank_temperature(bank);
+
+        return 0;
+}
+
 static const struct thermal_zone_of_device_ops mtk_thermal_ops = {
 	.get_temp = mtk_read_temp,
 };
 
+static const struct thermal_zone_of_device_ops mtk_thermal_zone1_ops = {
+        .get_temp = mtk_read_zone1_temp,
+};
+
+static const struct thermal_zone_of_device_ops mtk_thermal_zone2_ops = {
+        .get_temp = mtk_read_zone2_temp,
+};
+
+static const struct thermal_zone_of_device_ops mtk_thermal_zone3_ops = {
+        .get_temp = mtk_read_zone3_temp,
+};
+
+static const struct thermal_zone_of_device_ops mtk_thermal_zone4_ops = {
+        .get_temp = mtk_read_zone4_temp,
+};
+
+static const struct thermal_zone_of_device_ops mtk_thermal_zone5_ops = {
+        .get_temp = mtk_read_zone5_temp,
+};
+
 static void mtk_thermal_init_bank(struct mtk_thermal *mt, int num,
 				  u32 apmixed_phys_base, u32 auxadc_phys_base,
 				  int ctrl_id)
@@ -960,7 +1051,17 @@ static int mtk_thermal_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, mt);
 
 	tzdev = devm_thermal_zone_of_sensor_register(&pdev->dev, 0, mt,
-						     &mtk_thermal_ops);
+							&mtk_thermal_ops);
+        tzdev = devm_thermal_zone_of_sensor_register(&pdev->dev, 1, mt,
+							&mtk_thermal_zone1_ops);
+	tzdev = devm_thermal_zone_of_sensor_register(&pdev->dev, 2, mt,
+							&mtk_thermal_zone2_ops);
+	tzdev = devm_thermal_zone_of_sensor_register(&pdev->dev, 3, mt,
+							&mtk_thermal_zone3_ops);
+	tzdev = devm_thermal_zone_of_sensor_register(&pdev->dev, 4, mt,
+							&mtk_thermal_zone4_ops);
+	tzdev = devm_thermal_zone_of_sensor_register(&pdev->dev, 5, mt,
+							&mtk_thermal_zone5_ops);
 	if (IS_ERR(tzdev)) {
 		ret = PTR_ERR(tzdev);
 		goto err_disable_clk_peri_therm;
diff --git a/sound/soc/codecs/max98357a.c b/sound/soc/codecs/max98357a.c
index 9aac1fda94c8..cfecbdaa5853 100644
--- a/sound/soc/codecs/max98357a.c
+++ b/sound/soc/codecs/max98357a.c
@@ -69,12 +69,54 @@ static int max98357a_daiops_trigger(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+static const char * const ext_spk_text[] = {
+	"Off", "On"
+};
+
+static const struct soc_enum ext_spk_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0,
+		ARRAY_SIZE(ext_spk_text), ext_spk_text);
+
+
+static const struct snd_kcontrol_new ext_spk_mux =
+	SOC_DAPM_ENUM("Ext Spk Switch Mux", ext_spk_enum);
+
+
+static int max98357a_enable_spk_pa(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *cmpnt = snd_soc_dapm_to_component(w->dapm);
+	struct max98357a_priv *max98357a = snd_soc_component_get_drvdata(cmpnt);
+
+	if (!max98357a->sdmode)
+		return 0;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		queue_delayed_work(system_power_efficient_wq,
+				&max98357a->enable_sdmode_work,
+				msecs_to_jiffies(max98357a->sdmode_delay));
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		cancel_delayed_work(&max98357a->enable_sdmode_work);
+		gpiod_set_value(max98357a->sdmode, 0);
+		break;
+	}
+	return 0;
+}
+
 static const struct snd_soc_dapm_widget max98357a_dapm_widgets[] = {
 	SND_SOC_DAPM_OUTPUT("Speaker"),
+	SND_SOC_DAPM_SPK("Spk PA", max98357a_enable_spk_pa),
+	SND_SOC_DAPM_MUX("Spk PA Switch", SND_SOC_NOPM, 0, 0,
+			&ext_spk_mux),
 };
 
 static const struct snd_soc_dapm_route max98357a_dapm_routes[] = {
 	{"Speaker", NULL, "HiFi Playback"},
+	{"Speaker", NULL, "Spk PA"},
+	{"Spk PA", NULL, "Spk PA Switch"},
+	{"Spk PA Switch", "On", "HiFi Playback1"},
 };
 
 static int max98357a_component_probe(struct snd_soc_component *component)
@@ -119,23 +161,43 @@ static const struct snd_soc_dai_ops max98357a_dai_ops = {
 	.trigger	= max98357a_daiops_trigger,
 };
 
-static struct snd_soc_dai_driver max98357a_dai_driver = {
-	.name = "HiFi",
-	.playback = {
-		.stream_name	= "HiFi Playback",
-		.formats	= SNDRV_PCM_FMTBIT_S16 |
-					SNDRV_PCM_FMTBIT_S24 |
-					SNDRV_PCM_FMTBIT_S32,
-		.rates		= SNDRV_PCM_RATE_8000 |
-					SNDRV_PCM_RATE_16000 |
-					SNDRV_PCM_RATE_48000 |
-					SNDRV_PCM_RATE_96000,
-		.rate_min	= 8000,
-		.rate_max	= 96000,
-		.channels_min	= 1,
-		.channels_max	= 2,
+static struct snd_soc_dai_driver max98357a_dai_driver[] = {
+	{
+		.name = "HiFi",
+		.playback = {
+			.stream_name	= "HiFi Playback",
+			.formats	= SNDRV_PCM_FMTBIT_S16 |
+						SNDRV_PCM_FMTBIT_S24 |
+						SNDRV_PCM_FMTBIT_S32,
+			.rates		= SNDRV_PCM_RATE_8000 |
+						SNDRV_PCM_RATE_16000 |
+						SNDRV_PCM_RATE_48000 |
+						SNDRV_PCM_RATE_96000,
+			.rate_min	= 8000,
+			.rate_max	= 96000,
+			.channels_min	= 1,
+			.channels_max	= 2,
+		},
+		.ops    = &max98357a_dai_ops,
+	},
+	{
+		.name = "max98357a-hifi",
+		.playback = {
+			.stream_name	= "HiFi Playback1",
+			.formats	= SNDRV_PCM_FMTBIT_S16 |
+						SNDRV_PCM_FMTBIT_S24 |
+						SNDRV_PCM_FMTBIT_S32,
+			.rates		= SNDRV_PCM_RATE_8000 |
+						SNDRV_PCM_RATE_16000 |
+						SNDRV_PCM_RATE_48000 |
+						SNDRV_PCM_RATE_96000,
+			.rate_min	= 8000,
+			.rate_max	= 96000,
+			.channels_min	= 1,
+			.channels_max	= 2,
+		},
+		.ops    = NULL,
 	},
-	.ops    = &max98357a_dai_ops,
 };
 
 static int max98357a_platform_probe(struct platform_device *pdev)
@@ -161,7 +223,7 @@ static int max98357a_platform_probe(struct platform_device *pdev)
 
 	return devm_snd_soc_register_component(&pdev->dev,
 			&max98357a_component_driver,
-			&max98357a_dai_driver, 1);
+			max98357a_dai_driver, ARRAY_SIZE(max98357a_dai_driver));
 }
 
 static int max98357a_platform_remove(struct platform_device *pdev)
diff --git a/sound/soc/mediatek/mt8183/mt8183-da7219-max98357.c b/sound/soc/mediatek/mt8183/mt8183-da7219-max98357.c
old mode 100644
new mode 100755
index 1e7e8aed8707..c25ed84e2117
--- a/sound/soc/mediatek/mt8183/mt8183-da7219-max98357.c
+++ b/sound/soc/mediatek/mt8183/mt8183-da7219-max98357.c
@@ -34,7 +34,7 @@ static struct snd_soc_dai_link_component
 mt8183_da7219_max98357_external_codecs[] = {
 	{
 		.name = "max98357a",
-		.dai_name = "HiFi",
+		.dai_name = "max98357a-hifi",
 	},
 	{
 		.name = "da7219.5-001a",
