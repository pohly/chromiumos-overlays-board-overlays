From 3e7c663e28a1c30297264b4ab2d9985579848b63 Mon Sep 17 00:00:00 2001
From: Aditya Kali <adityakali@google.com>
Date: Mon, 13 Aug 2018 12:31:33 -0700
Subject: [PATCH 11/22] CHROMIUM: x86/speculation/l1tf: Add l1tf detection and
 mitigation check

This is simplified version of "x86/speculation/l1tf: Add sysfs reporting
for l1tf" (commit 17dbca119312b4e8173d4e25ff64262119fcef38 upstream) by
Andi Kleen <ak@linux.intel.com>.
This patch adds the X86_FEATURE_L1TF_PTEINV and X86_BUG_L1TF bits. All
CPUs are assumed to be affected by X86_BUG_L1TF.
This drops the sysfs reporting part from the original patch.
---
 arch/x86/include/asm/cpufeature.h |  3 +++
 arch/x86/include/asm/processor.h  |  5 +++++
 arch/x86/kernel/cpu/bugs.c        | 35 +++++++++++++++++++++++++++++++
 arch/x86/kernel/cpu/common.c      |  4 ++++
 4 files changed, 47 insertions(+)

diff --git a/arch/x86/include/asm/cpufeature.h b/arch/x86/include/asm/cpufeature.h
index 34c4106230f1..7a603b6619a9 100644
--- a/arch/x86/include/asm/cpufeature.h
+++ b/arch/x86/include/asm/cpufeature.h
@@ -200,6 +200,8 @@
 #define X86_FEATURE_HWP_PKG_REQ ( 7*32+14) /* Intel HWP_PKG_REQ */
 #define X86_FEATURE_INTEL_PT	( 7*32+15) /* Intel Processor Trace */
 
+#define X86_FEATURE_L1TF_PTEINV	( 7*32+29) /* "" L1TF workaround PTE inversion */
+
 /* Because the ALTERNATIVE scheme is for members of the X86_FEATURE club... */
 #define X86_FEATURE_KAISER	( 7*32+31) /* CONFIG_PAGE_TABLE_ISOLATION w/o nokaiser */
 
@@ -277,6 +279,7 @@
 #define X86_BUG_FXSAVE_LEAK	X86_BUG(6) /* FXSAVE leaks FOP/FIP/FOP */
 #define X86_BUG_CLFLUSH_MONITOR	X86_BUG(7) /* AAI65, CLFLUSH required before MONITOR */
 #define X86_BUG_SYSRET_SS_ATTRS	X86_BUG(8) /* SYSRET doesn't fix up SS attrs */
+#define X86_BUG_L1TF		X86_BUG(18) /* CPU is affected by L1 Terminal Fault */
 
 #if defined(__KERNEL__) && !defined(__ASSEMBLY__)
 
diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
index 0f8e88e82039..0949ff949bb4 100644
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -173,6 +173,11 @@ extern const struct seq_operations cpuinfo_op;
 
 extern void cpu_detect(struct cpuinfo_x86 *c);
 
+static inline unsigned long l1tf_pfn_limit(void)
+{
+	return BIT(boot_cpu_data.x86_phys_bits - 1 - PAGE_SHIFT) - 1;
+}
+
 extern void early_cpu_init(void);
 extern void identify_boot_cpu(void);
 extern void identify_secondary_cpu(struct cpuinfo_x86 *);
diff --git a/arch/x86/kernel/cpu/bugs.c b/arch/x86/kernel/cpu/bugs.c
index 0b6124315441..6af353ba845d 100644
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@ -16,6 +16,10 @@
 #include <asm/msr.h>
 #include <asm/paravirt.h>
 #include <asm/alternative.h>
+#include <asm/pgtable.h>
+#include <asm/e820.h>
+
+static void __init l1tf_select_mitigation(void);
 
 void __init check_bugs(void)
 {
@@ -33,6 +37,8 @@ void __init check_bugs(void)
 	print_cpu_info(&boot_cpu_data);
 #endif
 
+	l1tf_select_mitigation();
+
 	/*
 	 * Check whether we are able to run this kernel safely on SMP.
 	 *
@@ -49,3 +55,32 @@ void __init check_bugs(void)
 
 	fpu__init_check_bugs();
 }
+
+#undef pr_fmt
+#define pr_fmt(fmt)     "L1TF: " fmt
+static void __init l1tf_select_mitigation(void)
+{
+	u64 half_pa;
+
+	if (!boot_cpu_has_bug(X86_BUG_L1TF))
+		return;
+
+#if CONFIG_PGTABLE_LEVELS == 2
+	pr_warn("Kernel not compiled for PAE. No mitigation for L1TF\n");
+	return;
+#endif
+
+	/*
+	 * This is extremely unlikely to happen because almost all
+	 * systems have far more MAX_PA/2 than RAM can be fit into
+	 * DIMM slots.
+	 */
+	half_pa = (u64)l1tf_pfn_limit() << PAGE_SHIFT;
+	if (e820_any_mapped(half_pa, ULLONG_MAX - half_pa, E820_RAM)) {
+		pr_warn("System has more than MAX_PA/2 memory. L1TF mitigation not effective.\n");
+		return;
+	}
+
+	setup_force_cpu_cap(X86_FEATURE_L1TF_PTEINV);
+}
+#undef pr_fmt
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index 0199dd6368a3..9735ec99ca45 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -831,6 +831,10 @@ static void __init early_identify_cpu(struct cpuinfo_x86 *c)
 	}
 
 	setup_force_cpu_cap(X86_FEATURE_ALWAYS);
+
+	/* Assume all CPUs are affected. */
+	setup_force_cpu_bug(X86_BUG_L1TF);
+
 	fpu__init_system(c);
 }
 
-- 
2.18.0.597.ga71716f1ad-goog

