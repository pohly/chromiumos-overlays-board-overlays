diff --git a/Documentation/devicetree/bindings/devfreq/devfreq-cpufreq-map.txt b/Documentation/devicetree/bindings/devfreq/devfreq-cpufreq-map.txt
new file mode 100644
index 000000000000..982a30bcfc86
--- /dev/null
+++ b/Documentation/devicetree/bindings/devfreq/devfreq-cpufreq-map.txt
@@ -0,0 +1,53 @@
+Devfreq CPUfreq governor
+
+devfreq-cpufreq-map is a parent device that contains one or more child devices.
+Each child device provides CPU frequency to device frequency mapping for a
+specific device. Examples of devices that could use this are: DDR, cache and
+CCI.
+
+Parent device name shall be "devfreq-cpufreq-map".
+
+Required child device properties:
+- cpu-to-dev-map, or cpu-to-dev-map-<X>:
+			A list of tuples where each tuple consists of a
+			CPU frequency (KHz) and the corresponding device
+			frequency. CPU frequencies not listed in the table
+			will use the device frequency that corresponds to the
+			next rounded up CPU frequency.
+			Use "cpu-to-dev-map" if all CPUs in the system should
+			share same mapping.
+			Use cpu-to-dev-map-<cpuid> to describe different
+			mappings for different CPUs. The property should be
+			listed only for the first CPU if multiple CPUs are
+			synchronous.
+- target-dev:		Phandle to device that this mapping applies to.
+
+Example:
+	devfreq-cpufreq-map {
+		cpubw-cpufreq {
+			target-dev = <&cpubw>;
+			cpu-to-dev-map =
+				<  300000  1144000 >,
+				<  422400  2288000 >,
+				<  652800  3051000 >,
+				<  883200  5996000 >,
+				< 1190400  8056000 >,
+				< 1497600 10101000 >,
+				< 1728000 12145000 >,
+				< 2649600 16250000 >;
+		};
+
+		cache-cpufreq {
+			target-dev = <&cache>;
+			cpu-to-dev-map =
+				<  300000  300000 >,
+				<  422400  422400 >,
+				<  652800  499200 >,
+				<  883200  576000 >,
+				<  960000  960000 >,
+				< 1497600 1036800 >,
+				< 1574400 1574400 >,
+				< 1728000 1651200 >,
+				< 2649600 1728000 >;
+		};
+	};
diff --git a/Documentation/devicetree/bindings/display/bridge/ite,it6505.txt b/Documentation/devicetree/bindings/display/bridge/ite,it6505.txt
new file mode 100644
index 000000000000..c3506ac4c980
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/bridge/ite,it6505.txt
@@ -0,0 +1,30 @@
+iTE it6505 DP bridge bindings
+
+Required properties:
+        - compatible: "ite,it6505"
+        - reg: i2c address of the bridge
+        - ovdd-supply: I/O voltage
+        - pwr18-supply: Core voltage
+        - interrupts: interrupt specifier of INT pin
+        - reset-gpios: gpio specifier of RESET pin
+
+Example:
+	it6505dptx: it6505dptx@5c {
+                compatible = "ite,it6505";
+                status = "okay";
+                interrupt-parent = <&pio>;
+                interrupts = <152 IRQ_TYPE_EDGE_RISING 152 0>;
+                reg = <0x5c>;
+                pinctrl-names = "default";
+                pinctrl-0 = <&it6505_pins>;
+                ovdd-supply = <&mt6358_vsim1_reg>;
+                pwr18-supply = <&it6505_pp18_reg>;
+                reset-gpios = <&pio 179 1>;
+                hpd-gpios = <&pio 9 0>;
+                extcon = <&usbc_extcon>;
+                port {
+                        it6505_in: endpoint {
+                                remote-endpoint = <&dpi_out>;
+                        };
+                };
+        };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,disp.txt b/Documentation/devicetree/bindings/display/mediatek/mediatek,disp.txt
index 5467470c7b8a..bc8e30c20c64 100644
--- a/Documentation/devicetree/bindings/display/mediatek/mediatek,disp.txt
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,disp.txt
@@ -59,8 +59,6 @@ Required properties (DMA function blocks):
 	"mediatek,<chip>-disp-rdma"
 	"mediatek,<chip>-disp-wdma"
   the supported chips are mt2701 and mt8173.
-- larb: Should contain a phandle pointing to the local arbiter device as defined
-  in Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.txt
 - iommus: Should point to the respective IOMMU block with master port as
   argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
   for details.
@@ -87,7 +85,6 @@ ovl0: ovl@1400c000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_OVL0>;
 	iommus = <&iommu M4U_PORT_DISP_OVL0>;
-	mediatek,larb = <&larb0>;
 };
 
 ovl1: ovl@1400d000 {
@@ -97,7 +94,6 @@ ovl1: ovl@1400d000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_OVL1>;
 	iommus = <&iommu M4U_PORT_DISP_OVL1>;
-	mediatek,larb = <&larb4>;
 };
 
 rdma0: rdma@1400e000 {
@@ -107,7 +103,6 @@ rdma0: rdma@1400e000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_RDMA0>;
 	iommus = <&iommu M4U_PORT_DISP_RDMA0>;
-	mediatek,larb = <&larb0>;
 };
 
 rdma1: rdma@1400f000 {
@@ -117,7 +112,6 @@ rdma1: rdma@1400f000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_RDMA1>;
 	iommus = <&iommu M4U_PORT_DISP_RDMA1>;
-	mediatek,larb = <&larb4>;
 };
 
 rdma2: rdma@14010000 {
@@ -127,7 +121,6 @@ rdma2: rdma@14010000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_RDMA2>;
 	iommus = <&iommu M4U_PORT_DISP_RDMA2>;
-	mediatek,larb = <&larb4>;
 };
 
 wdma0: wdma@14011000 {
@@ -137,7 +130,6 @@ wdma0: wdma@14011000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_WDMA0>;
 	iommus = <&iommu M4U_PORT_DISP_WDMA0>;
-	mediatek,larb = <&larb0>;
 };
 
 wdma1: wdma@14012000 {
@@ -147,7 +139,6 @@ wdma1: wdma@14012000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_WDMA1>;
 	iommus = <&iommu M4U_PORT_DISP_WDMA1>;
-	mediatek,larb = <&larb4>;
 };
 
 color0: color@14013000 {
diff --git a/Documentation/devicetree/bindings/display/panel/auo,kd101n80-45na.txt b/Documentation/devicetree/bindings/display/panel/auo,kd101n80-45na.txt
new file mode 100644
index 000000000000..994c2a13f942
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/panel/auo,kd101n80-45na.txt
@@ -0,0 +1,34 @@
+AUO Corporation 10.1" WUXGA TFT LCD panel
+
+Required properties:
+- compatible: should be "auo,kd101n80-45na"
+- reg: the virtual channel number of a DSI peripheral
+- enable-gpios: a GPIO spec for the enable pin
+- pp1800-supply: core voltage supply
+- avdd-supply: phandle of the regulator that provides positive voltage
+- avee-supply: phandle of the regulator that provides negative voltage
+- backlight: phandle of the backlight device attached to the panel
+
+The device node can contain one 'port' child node with one child
+'endpoint' node, according to the bindings defined in
+media/video-interfaces.txt. This node should describe panel's video bus.
+
+Example:
+&dsi {
+	...
+	panel@0 {
+		compatible = "auo,kd101n80-45na";
+		reg = <0>;
+		enable-gpios = <&pio 45 0>;
+		avdd-supply = <&ppvarn_lcd>;
+		avee-supply = <&ppvarp_lcd>;
+		pp1800-supply = <&pp1800_lcd>;
+		backlight = <&backlight_lcd0>;
+		status = "okay";
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
diff --git a/Documentation/devicetree/bindings/display/panel/boe,tv101wum-nl6.txt b/Documentation/devicetree/bindings/display/panel/boe,tv101wum-nl6.txt
new file mode 100644
index 000000000000..bd44af636390
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/panel/boe,tv101wum-nl6.txt
@@ -0,0 +1,34 @@
+Boe Corporation 10.1" WUXGA TFT LCD panel
+
+Required properties:
+- compatible: should be "boe,tv101wum-nl6"
+- reg: the virtual channel number of a DSI peripheral
+- enable-gpios: a GPIO spec for the enable pin
+- pp1800-supply: core voltage supply
+- avdd-supply: phandle of the regulator that provides positive voltage
+- avee-supply: phandle of the regulator that provides negative voltage
+- backlight: phandle of the backlight device attached to the panel
+
+The device node can contain one 'port' child node with one child
+'endpoint' node, according to the bindings defined in
+media/video-interfaces.txt. This node should describe panel's video bus.
+
+Example:
+&dsi {
+	...
+	panel@0 {
+		compatible = "boe,tv101wum-nl6";
+		reg = <0>;
+		enable-gpios = <&pio 45 0>;
+		avdd-supply = <&ppvarn_lcd>;
+		avee-supply = <&ppvarp_lcd>;
+		pp1800-supply = <&pp1800_lcd>;
+		backlight = <&backlight_lcd0>;
+		status = "okay";
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
diff --git a/Documentation/devicetree/bindings/media/mediatek-jpeg-decoder.txt b/Documentation/devicetree/bindings/media/mediatek-jpeg-decoder.txt
index 3813947b4d4f..c9f89132830c 100644
--- a/Documentation/devicetree/bindings/media/mediatek-jpeg-decoder.txt
+++ b/Documentation/devicetree/bindings/media/mediatek-jpeg-decoder.txt
@@ -14,9 +14,6 @@ Required properties:
 - clock-names: must contain "jpgdec-smi" and "jpgdec".
 - power-domains: a phandle to the power domain, see
   Documentation/devicetree/bindings/power/power_domain.txt for details.
-- mediatek,larb: must contain the local arbiters in the current Socs, see
-  Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.txt
-  for details.
 - iommus: should point to the respective IOMMU block with master port as
   argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
   for details.
@@ -31,7 +28,6 @@ Example:
 		clock-names = "jpgdec-smi",
 			      "jpgdec";
 		power-domains = <&scpsys MT2701_POWER_DOMAIN_ISP>;
-		mediatek,larb = <&larb2>;
 		iommus = <&iommu MT2701_M4U_PORT_JPGDEC_WDMA>,
 			 <&iommu MT2701_M4U_PORT_JPGDEC_BSDMA>;
 	};
diff --git a/Documentation/devicetree/bindings/media/mediatek-mdp.txt b/Documentation/devicetree/bindings/media/mediatek-mdp.txt
index 0d03e3ae2be2..df69c5a06250 100644
--- a/Documentation/devicetree/bindings/media/mediatek-mdp.txt
+++ b/Documentation/devicetree/bindings/media/mediatek-mdp.txt
@@ -27,9 +27,6 @@ Required properties (DMA function blocks, child node):
 - iommus: should point to the respective IOMMU block with master port as
   argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
   for details.
-- mediatek,larb: must contain the local arbiters in the current Socs, see
-  Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.txt
-  for details.
 
 Example:
 	mdp_rdma0: rdma@14001000 {
@@ -40,7 +37,6 @@ Example:
 			 <&mmsys CLK_MM_MUTEX_32K>;
 		power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 		iommus = <&iommu M4U_PORT_MDP_RDMA0>;
-		mediatek,larb = <&larb0>;
 		mediatek,vpu = <&vpu>;
 	};
 
@@ -51,7 +47,6 @@ Example:
 			 <&mmsys CLK_MM_MUTEX_32K>;
 		power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 		iommus = <&iommu M4U_PORT_MDP_RDMA1>;
-		mediatek,larb = <&larb4>;
 	};
 
 	mdp_rsz0: rsz@14003000 {
@@ -81,7 +76,6 @@ Example:
 		clocks = <&mmsys CLK_MM_MDP_WDMA>;
 		power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 		iommus = <&iommu M4U_PORT_MDP_WDMA>;
-		mediatek,larb = <&larb0>;
 	};
 
 	mdp_wrot0: wrot@14007000 {
@@ -90,7 +84,6 @@ Example:
 		clocks = <&mmsys CLK_MM_MDP_WROT0>;
 		power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 		iommus = <&iommu M4U_PORT_MDP_WROT0>;
-		mediatek,larb = <&larb0>;
 	};
 
 	mdp_wrot1: wrot@14008000 {
@@ -99,5 +92,4 @@ Example:
 		clocks = <&mmsys CLK_MM_MDP_WROT1>;
 		power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 		iommus = <&iommu M4U_PORT_MDP_WROT1>;
-		mediatek,larb = <&larb4>;
 	};
diff --git a/Documentation/devicetree/bindings/media/mediatek-vcodec.txt b/Documentation/devicetree/bindings/media/mediatek-vcodec.txt
index b6b5dde6abd8..5c9ee6af3cfa 100644
--- a/Documentation/devicetree/bindings/media/mediatek-vcodec.txt
+++ b/Documentation/devicetree/bindings/media/mediatek-vcodec.txt
@@ -9,7 +9,6 @@ Required properties:
 - reg : Physical base address of the video codec registers and length of
   memory mapped region.
 - interrupts : interrupt number to the cpu.
-- mediatek,larb : must contain the local arbiters in the current Socs.
 - clocks : list of clock specifiers, corresponding to entries in
   the clock-names property.
 - clock-names: encoder must contain "venc_sel_src", "venc_sel",,
@@ -39,7 +38,6 @@ vcodec_dec: vcodec@16000000 {
           <0 0x16027800 0 0x800>,   /*VP8_VL*/
           <0 0x16028400 0 0x400>;   /*VP9_VD*/
     interrupts = <GIC_SPI 204 IRQ_TYPE_LEVEL_LOW>;
-    mediatek,larb = <&larb1>;
     iommus = <&iommu M4U_PORT_HW_VDEC_MC_EXT>,
              <&iommu M4U_PORT_HW_VDEC_PP_EXT>,
              <&iommu M4U_PORT_HW_VDEC_AVC_MV_EXT>,
@@ -83,8 +81,6 @@ vcodec_dec: vcodec@16000000 {
           <0 0x19002000 0 0x1000>;    /*VENC_LT_SYS*/
     interrupts = <GIC_SPI 198 IRQ_TYPE_LEVEL_LOW>,
 		 <GIC_SPI 202 IRQ_TYPE_LEVEL_LOW>;
-    mediatek,larb = <&larb3>,
-		    <&larb5>;
     iommus = <&iommu M4U_PORT_VENC_RCPU>,
              <&iommu M4U_PORT_VENC_REC>,
              <&iommu M4U_PORT_VENC_BSDMA>,
diff --git a/Documentation/devicetree/bindings/memory-controllers/mediatek,emi.txt b/Documentation/devicetree/bindings/memory-controllers/mediatek,emi.txt
new file mode 100644
index 000000000000..a19e3b39ba66
--- /dev/null
+++ b/Documentation/devicetree/bindings/memory-controllers/mediatek,emi.txt
@@ -0,0 +1,19 @@
+EMI (External Memory Interface)
+
+Required properties:
+- compatible : must be one of :
+	"mediatek,mt8183-emi"
+- reg : the register and size of the EMI block.
+- interrupts : includes MPU, CGM, ELM.
+
+Example:
+	emi@10219000 {
+	compatible = "mediatek,mt8183-emi";
+	reg = <0 0x10219000 0 0x1000>, /* CEN EMI */
+		  <0 0x10226000 0 0x1000>, /* EMI MPU */
+		  <0 0x1022d000 0 0x1000>, /* CHA EMI */
+		  <0 0x10235000 0 0x1000>; /* CHB EMI */
+	interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_LOW>, /* MPU */
+			 <GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>, /* CGM */
+			 <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>; /* ELM */
+};
diff --git a/Documentation/devicetree/bindings/vendor-prefixes.txt b/Documentation/devicetree/bindings/vendor-prefixes.txt
index 2c3fc512e746..c088646f3f1e 100644
--- a/Documentation/devicetree/bindings/vendor-prefixes.txt
+++ b/Documentation/devicetree/bindings/vendor-prefixes.txt
@@ -184,6 +184,7 @@ iom	Iomega Corporation
 isee	ISEE 2007 S.L.
 isil	Intersil
 issi	Integrated Silicon Solutions Inc.
+ite	iTE Tech. Inc.
 itead	ITEAD Intelligent Systems Co.Ltd
 iwave  iWave Systems Technologies Pvt. Ltd.
 jdi	Japan Display Inc.
diff --git a/Makefile b/Makefile
index 05db073654cb..e7b2f552aca3 100644
--- a/Makefile
+++ b/Makefile
@@ -1,3 +1,4 @@
+# kukui ToT!
 # SPDX-License-Identifier: GPL-2.0
 VERSION = 4
 PATCHLEVEL = 19
diff --git a/README b/README
index 2c927ccbd970..768caa3970ef 100644
--- a/README
+++ b/README
@@ -1,3 +1,4 @@
+MTK TOT
 Linux kernel
 ============
 
diff --git a/arch/arm64/boot/dts/mediatek/Makefile b/arch/arm64/boot/dts/mediatek/Makefile
index 3a55c454b65d..ac7e79064ad1 100644
--- a/arch/arm64/boot/dts/mediatek/Makefile
+++ b/arch/arm64/boot/dts/mediatek/Makefile
@@ -8,5 +8,9 @@ dtb-$(CONFIG_ARCH_MEDIATEK) += mt7622-rfb1.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt7622-bananapi-bpi-r64.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8173-evb.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-evb.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-krane-rev3-sku16.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-krane-rev3-sku176.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-krane-rev4-sku16.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-krane-rev4-sku176.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-kukui-rev1.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-kukui-rev2.dtb
diff --git a/arch/arm64/boot/dts/mediatek/mt6358.dtsi b/arch/arm64/boot/dts/mediatek/mt6358.dtsi
index a7e655c42a54..a049ac2e39f7 100644
--- a/arch/arm64/boot/dts/mediatek/mt6358.dtsi
+++ b/arch/arm64/boot/dts/mediatek/mt6358.dtsi
@@ -114,8 +114,8 @@
 
 			mt6358_vsim1_reg: ldo_vsim1 {
 				regulator-name = "vsim1";
-				regulator-min-microvolt = <1700000>;
-				regulator-max-microvolt = <3100000>;
+				regulator-min-microvolt = <2700000>;
+				regulator-max-microvolt = <2700000>;
 				regulator-enable-ramp-delay = <540>;
 			};
 
@@ -349,8 +349,8 @@
 
 			mt6358_vsim2_reg: ldo_vsim2 {
 				regulator-name = "vsim2";
-				regulator-min-microvolt = <1700000>;
-				regulator-max-microvolt = <3100000>;
+				regulator-min-microvolt = <2700000>;
+				regulator-max-microvolt = <2700000>;
 				regulator-enable-ramp-delay = <540>;
 			};
 		};
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-krane-rev3-sku16.dts b/arch/arm64/boot/dts/mediatek/mt8183-krane-rev3-sku16.dts
new file mode 100644
index 000000000000..cb4a1264d06b
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-krane-rev3-sku16.dts
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ */
+
+/dts-v1/;
+#include "mt8183-krane.dtsi"
+
+/ {
+	model = "MediaTek krane rev3 sku16 board";
+	compatible = "google,krane-rev3-sku16", "google,krane-rev3",
+		"google,krane-sku16", "google,krane",
+		"google,kukui", "mediatek,mt8183";
+};
+
+#include "mt8183-krane-sku16.dtsi"
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-krane-rev3-sku176.dts b/arch/arm64/boot/dts/mediatek/mt8183-krane-rev3-sku176.dts
new file mode 100644
index 000000000000..e49769610d35
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-krane-rev3-sku176.dts
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ */
+
+/dts-v1/;
+#include "mt8183-krane.dtsi"
+
+/ {
+	model = "MediaTek krane rev3 sku176 board";
+	/*
+	 * Strapping on rev3 display is wrong, and appears as 0 instead of 176,
+	 * so match both here.
+	 */
+	compatible = "google,krane-rev3-sku0", "google,krane-rev3-sku176",
+		"google,krane-rev3",
+		"google,krane-sku0", "google,krane-sku176",
+		"google,krane", "google,kukui", "mediatek,mt8183";
+};
+
+#include "mt8183-krane-sku176.dtsi"
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-krane-rev4-sku16.dts b/arch/arm64/boot/dts/mediatek/mt8183-krane-rev4-sku16.dts
new file mode 100644
index 000000000000..341a9cf7cadb
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-krane-rev4-sku16.dts
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ */
+
+/dts-v1/;
+#include "mt8183-krane.dtsi"
+
+/ {
+	model = "MediaTek krane rev4 sku16 board";
+	compatible = "google,krane-rev4-sku16", "google,krane-rev4",
+		"google,krane-sku16", "google,krane",
+		"google,kukui", "mediatek,mt8183";
+};
+
+#include "mt8183-krane-sku16.dtsi"
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-krane-rev4-sku176.dts b/arch/arm64/boot/dts/mediatek/mt8183-krane-rev4-sku176.dts
new file mode 100644
index 000000000000..8a8b3a410ea4
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-krane-rev4-sku176.dts
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ */
+
+/dts-v1/;
+#include "mt8183-krane.dtsi"
+
+/ {
+	model = "MediaTek krane rev4 sku176 board";
+	/*
+	 * Strapping on rev4 display is wrong, and appears as 0 instead of 176,
+	 * so match both here.
+	 */
+	compatible = "google,krane-rev4-sku0", "google,krane-rev4-sku176",
+		"google,krane-rev4",
+		"google,krane-sku0", "google,krane-sku176",
+		"google,krane", "google,kukui", "mediatek,mt8183";
+};
+
+#include "mt8183-krane-sku176.dtsi"
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-krane-sku16.dtsi b/arch/arm64/boot/dts/mediatek/mt8183-krane-sku16.dtsi
new file mode 100644
index 000000000000..71b1b6af4cae
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-krane-sku16.dtsi
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ *
+ * Device-tree fragment for krane sku16 (boe panel).
+ */
+
+&panel {
+	status = "okay";
+	compatible = "boe,tv101wum-nl6";
+	reg = <0>;
+	enable-gpios = <&pio 45 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&panel_pins_default>;
+	avdd-supply = <&ppvarn_lcd>;
+	avee-supply = <&ppvarp_lcd>;
+	pp1800-supply = <&pp1800_lcd>;
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-krane-sku176.dtsi b/arch/arm64/boot/dts/mediatek/mt8183-krane-sku176.dtsi
new file mode 100644
index 000000000000..7c20e7c2bab6
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-krane-sku176.dtsi
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ *
+ * Device-tree fragment for krane sku176 (AUO panel).
+ */
+
+&panel {
+	status = "okay";
+	compatible = "auo,kd101n80-45na";
+	reg = <0>;
+	enable-gpios = <&pio 45 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&panel_pins_default>;
+	avdd-supply = <&ppvarn_lcd>;
+	avee-supply = <&ppvarp_lcd>;
+	pp1800-supply = <&pp1800_lcd>;
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-krane.dtsi b/arch/arm64/boot/dts/mediatek/mt8183-krane.dtsi
new file mode 100644
index 000000000000..71a12420e781
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8183-krane.dtsi
@@ -0,0 +1,305 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Google LLC
+ */
+
+/dts-v1/;
+#include "mt8183-kukui.dtsi"
+
+/ {
+	ppvarn_lcd: ppvarn-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "ppvarn_lcd";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ppvarn_lcd_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 66 GPIO_ACTIVE_HIGH>;
+	};
+
+	ppvarp_lcd: ppvarp-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "ppvarp_lcd";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ppvarp_lcd_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 166 GPIO_ACTIVE_HIGH>;
+	};
+
+	pp1800_lcd: pp1800-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "pp1800_lcd";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pp1800_lcm_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 36 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&i2c0 {
+	status = "okay";
+
+	touchscreen4: touchscreen@5d {
+		compatible = "hid-over-i2c";
+		reg = <0x5d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&open_touch>;
+
+		interrupt-parent = <&pio>;
+		interrupts = <155 IRQ_TYPE_EDGE_FALLING>;
+
+		post-power-on-delay-ms = <10>;
+		hid-descr-addr = <0x0001>;
+	};
+};
+
+&pio {
+	/* 192 lines */
+	gpio-line-names =
+		"SPI_AP_EC_CS_L",
+		"SPI_AP_EC_MOSI",
+		"SPI_AP_EC_CLK",
+		"I2S3_DO",
+		"USB_PD_INT_ODL",
+		"",
+		"",
+		"",
+		"",
+		"IT6505_HPD_L",
+		"I2S3_TDM_D3",
+		"SOC_I2C6_1V8_SCL",
+		"SOC_I2C6_1V8_SDA",
+		"DPI_D0",
+		"DPI_D1",
+		"DPI_D2",
+		"DPI_D3",
+		"DPI_D4",
+		"DPI_D5",
+		"DPI_D6",
+		"DPI_D7",
+		"DPI_D8",
+		"DPI_D9",
+		"DPI_D10",
+		"DPI_D11",
+		"DPI_HSYNC",
+		"DPI_VSYNC",
+		"DPI_DE",
+		"DPI_CK",
+		"AP_MSDC1_CLK",
+		"AP_MSDC1_DAT3",
+		"AP_MSDC1_CMD",
+		"AP_MSDC1_DAT0",
+		"AP_MSDC1_DAT2",
+		"AP_MSDC1_DAT1",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"OTG_EN",
+		"DRVBUS",
+		"DISP_PWM",
+		"DSI_TE",
+		"LCM_RST_1V8",
+		"AP_CTS_WIFI_RTS",
+		"AP_RTS_WIFI_CTS",
+		"SOC_I2C5_1V8_SCL",
+		"SOC_I2C5_1V8_SDA",
+		"SOC_I2C3_1V8_SCL",
+		"SOC_I2C3_1V8_SDA",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"SOC_I2C1_1V8_SDA",
+		"SOC_I2C0_1V8_SDA",
+		"SOC_I2C0_1V8_SCL",
+		"SOC_I2C1_1V8_SCL",
+		"AP_SPI_H1_MISO",
+		"AP_SPI_H1_CS_L",
+		"AP_SPI_H1_MOSI",
+		"AP_SPI_H1_CLK",
+		"I2S5_BCK",
+		"I2S5_LRCK",
+		"I2S5_DO",
+		"BOOTBLOCK_EN_L",
+		"MT8183_KPCOL0",
+		"SPI_AP_EC_MISO",
+		"UART_DBG_TX_AP_RX",
+		"UART_AP_TX_DBG_RX",
+		"I2S2_MCK",
+		"I2S2_BCK",
+		"CLK_5M_WCAM",
+		"CLK_2M_UCAM",
+		"I2S2_LRCK",
+		"I2S2_DI",
+		"SOC_I2C2_1V8_SCL",
+		"SOC_I2C2_1V8_SDA",
+		"SOC_I2C4_1V8_SCL",
+		"SOC_I2C4_1V8_SDA",
+		"",
+		"SCL8",
+		"SDA8",
+		"FCAM_PWDN_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"I2S_PMIC",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		/*
+		 * AP_FLASH_WP_L is crossystem ABI. Rev1 schematics
+		 * call it BIOS_FLASH_WP_R_L.
+		 */
+		"AP_FLASH_WP_L",
+		"EC_AP_INT_ODL",
+		"IT6505_INT_ODL",
+		"H1_INT_OD_L",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"AP_SPI_FLASH_MISO",
+		"AP_SPI_FLASH_CS_L",
+		"AP_SPI_FLASH_MOSI",
+		"AP_SPI_FLASH_CLK",
+		"DA7219_IRQ",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"";
+
+	ppvarp_lcd_en: ppvarp-lcd-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO66__FUNC_GPIO66>;
+			output-low;
+		};
+	};
+
+	ppvarn_lcd_en: ppvarn-lcd-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO166__FUNC_GPIO166>;
+			output-low;
+		};
+	};
+
+	pp1800_lcm_en: pp1800-lcd-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO36__FUNC_GPIO36>;
+			output-low;
+		};
+	};
+
+	open_touch: open_touch {
+		irq_pin {
+			pinmux = <PINMUX_GPIO155__FUNC_GPIO155>;
+			input-enable;
+			bias-pull-up;
+		};
+
+		rst_pin {
+			pinmux = <PINMUX_GPIO156__FUNC_GPIO156>;
+
+			/*
+			 * The pen driver doesn't currently support  driving
+			 * this reset line.  By specifying output-high here
+			 * we're relying on the fact that this pin has a default
+			 * pulldown at boot (which makes sure the pen was in
+			 * reset if it was powered) and then we set it high here
+			 * to take it out of reset.  Better would be if the pen
+			 * driver could control this and we could remove
+			 * "output-high" here.
+			 */
+			output-high;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev1.dts b/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev1.dts
index 0f78005f705c..96e101d6b346 100644
--- a/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev1.dts
+++ b/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev1.dts
@@ -225,6 +225,10 @@
 	};
 };
 
+&it6505dptx {
+	ovdd-supply = <&mt6358_vsim1_reg>;
+};
+
 &i2c0 {
 	status = "okay";
 
@@ -251,3 +255,11 @@
 			 <PINMUX_GPIO12__FUNC_TP_UTXD1_AO>;
 	};
 };
+
+&sound {
+	mediatek,headset-codec = <&ts3a227e>;
+};
+
+&ts3a227e {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev2.dts b/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev2.dts
index f950c87b1672..ba0ffaf330d4 100644
--- a/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev2.dts
+++ b/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev2.dts
@@ -4,6 +4,7 @@
  */
 
 /dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
 #include "mt8183-kukui.dtsi"
 
 / {
@@ -24,6 +25,72 @@
 			wakeup-source;
 		};
 	};
+
+	pp1200_mipibrdg: pp1200-mipibrdg {
+		compatible = "regulator-fixed";
+		regulator-name = "pp1200_mipibrdg";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pp1200_mipibrdg_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 54 GPIO_ACTIVE_HIGH>;
+	};
+
+	pp1800_lcd: pp1800-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "pp1800_lcd";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pp1800_lcm_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 36 GPIO_ACTIVE_HIGH>;
+	};
+
+	pp3300_lcd: pp3300-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "pp3300_lcd";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pp3300_lcm_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 35 GPIO_ACTIVE_HIGH>;
+	};
+
+	ppvarn_lcd: ppvarn-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "ppvarn_lcd";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ppvarn_lcd_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 66 GPIO_ACTIVE_HIGH>;
+	};
+
+	ppvarp_lcd: ppvarp-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "ppvarp_lcd";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ppvarp_lcd_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 166 GPIO_ACTIVE_HIGH>;
+	};
+
+	vddio_mipibrdg: vddio-mipibrdg {
+		compatible = "regulator-fixed";
+		regulator-name = "vddio_mipibrdg";
+		pinctrl-names = "default";
+		pinctrl-0 = <&vddio_mipibrdg_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 37 GPIO_ACTIVE_HIGH>;
+	};
 };
 
 &i2c0 {
@@ -52,6 +119,36 @@
 	};
 };
 
+&panel {
+	compatible = "innolux,p097pfg_ssd2858";
+	reg = <0>;
+	enable-gpios = <&pio 45 0 &pio 73 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&panel_pins_default>;
+	/delete-property/ power-supply;
+	avdd-supply = <&ppvarp_lcd>;
+	avee-supply = <&ppvarn_lcd>;
+	pp1800-supply = <&pp1800_lcd>;
+	pp3300-supply = <&pp3300_lcd>;
+	pp1200-bridge-supply = <&pp1200_mipibrdg>;
+	vddio-bridge-supply = <&vddio_mipibrdg>;
+	backlight = <&backlight_lcd0>;
+	status = "okay";
+	port {
+		panel_in: endpoint {
+			remote-endpoint = <&dsi_out>;
+		};
+	};
+};
+
+&panel_pins_default {
+	bridge_reset {
+		pinmux = <PINMUX_GPIO73__FUNC_GPIO73>;
+		output-low;
+		bias-pull-up;
+	};
+};
+
 &pio {
 	/* 192 lines */
 	gpio-line-names =
@@ -285,6 +382,41 @@
 		};
 	};
 
+	pp1200_mipibrdg_en: pp1200-mipibrdg-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO54__FUNC_GPIO54>;
+			output-low;
+		};
+	};
+
+	pp1800_lcm_en: pp1800-lcd-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO36__FUNC_GPIO36>;
+			output-low;
+		};
+	};
+
+	pp3300_lcm_en: pp3300-lcd-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO35__FUNC_GPIO35>;
+			output-low;
+		};
+	};
+
+	ppvarp_lcd_en: ppvarp-lcd-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO66__FUNC_GPIO66>;
+			output-low;
+		};
+	};
+
+	ppvarn_lcd_en: ppvarn-lcd-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO166__FUNC_GPIO166>;
+			output-low;
+		};
+	};
+
 	touch_default: touchdefault {
 		pin_irq {
 			pinmux = <PINMUX_GPIO155__FUNC_GPIO155>;
@@ -297,9 +429,24 @@
 			output-low;
 		};
 	};
+
+	vddio_mipibrdg_en: vddio_mipibrdg_en {
+		pins1 {
+			pinmux = <PINMUX_GPIO37__FUNC_GPIO37>;
+			output-low;
+		};
+	};
 };
 
 &scp_pins {
 	/* EINT pins are used for other purpose on rev2. */
 	/delete-node/ pins_eint;
 };
+
+&sound {
+	mediatek,headset-codec = <&ts3a227e>;
+};
+
+&ts3a227e {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-kukui.dtsi b/arch/arm64/boot/dts/mediatek/mt8183-kukui.dtsi
index 6e8549859067..c031a21cf778 100644
--- a/arch/arm64/boot/dts/mediatek/mt8183-kukui.dtsi
+++ b/arch/arm64/boot/dts/mediatek/mt8183-kukui.dtsi
@@ -41,6 +41,15 @@
 		clock-output-names = "clk32k";
 	};
 
+	it6505_pp18_reg: regulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "it6505_pp18";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		gpio = <&pio 178 0>;
+		enable-active-high;
+	};
+
 	lcd_pp3300: regulator@1 {
 		compatible = "regulator-fixed";
 		regulator-name = "lcd_pp3300";
@@ -114,7 +123,6 @@
 	sound: mt8183-mt6358-ts3a227e-max98357a {
 		compatible = "mediatek,mt8183_mt6358_ts3a227_max98357";
 		mediatek,platform = <&afe>;
-		mediatek,headset-codec = <&ts3a227e>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&aud_pins>;
 		status = "okay";
@@ -135,6 +143,10 @@
 	i2s0-share = "I2S5";
 };
 
+&auxadc {
+	status = "okay";
+};
+
 &cci {
 	proc-supply = <&mt6358_vproc12_reg>;
 };
@@ -171,6 +183,18 @@
 	proc-supply = <&mt6358_vproc11_reg>;
 };
 
+&dpi0 {
+	pinctrl-names = "default", "dpimode";
+	pinctrl-0 = <&dpi_pin_default>;
+	pinctrl-1 = <&dpi_pin_func>;
+	status = "okay";
+	port {
+		dpi_out: endpoint {
+			remote-endpoint = <&it6505_in>;
+		};
+	};
+};
+
 &dsi0 {
 	status = "okay";
 	#address-cells = <1>;
@@ -246,6 +270,28 @@
 	pinctrl-0 = <&i2c3_pins>;
 	status = "okay";
 	clock-frequency = <100000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	it6505dptx: it6505dptx@5c {
+		compatible = "ite,it6505";
+		status = "okay";
+		interrupt-parent = <&pio>;
+		interrupts = <152 IRQ_TYPE_EDGE_RISING 152 0>;
+		reg = <0x5c>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&it6505_pins>;
+		ovdd-supply = <&mt6358_vsim2_reg>;
+		pwr18-supply = <&it6505_pp18_reg>;
+		reset-gpios = <&pio 179 1>;
+		hpd-gpios = <&pio 9 0>;
+		extcon = <&usbc_extcon>;
+		port {
+			it6505_in: endpoint {
+				remote-endpoint = <&dpi_out>;
+			};
+		};
+	};
 };
 
 &i2c4 {
@@ -270,6 +316,7 @@
 		reg = <0x3b>;
 		interrupt-parent = <&pio>;
 		interrupts = <157 IRQ_TYPE_LEVEL_LOW>;
+		status = "disabled";
 	};
 };
 
@@ -380,6 +427,51 @@
 		};
 	};
 
+	dpi_pin_default: dpi_pin_default {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO13__FUNC_GPIO13>,
+				<PINMUX_GPIO14__FUNC_GPIO14>,
+				<PINMUX_GPIO15__FUNC_GPIO15>,
+				<PINMUX_GPIO16__FUNC_GPIO16>,
+				<PINMUX_GPIO17__FUNC_GPIO17>,
+				<PINMUX_GPIO18__FUNC_GPIO18>,
+				<PINMUX_GPIO19__FUNC_GPIO19>,
+				<PINMUX_GPIO20__FUNC_GPIO20>,
+				<PINMUX_GPIO21__FUNC_GPIO21>,
+				<PINMUX_GPIO22__FUNC_GPIO22>,
+				<PINMUX_GPIO23__FUNC_GPIO23>,
+				<PINMUX_GPIO24__FUNC_GPIO24>,
+				<PINMUX_GPIO25__FUNC_GPIO25>,
+				<PINMUX_GPIO26__FUNC_GPIO26>,
+				<PINMUX_GPIO27__FUNC_GPIO27>,
+				<PINMUX_GPIO28__FUNC_GPIO28>;
+				drive-strength = <MTK_DRIVE_6mA>;
+				output-low;
+		};
+	};
+
+	dpi_pin_func: dpi_pin_func {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO13__FUNC_DBPI_D0>,
+				<PINMUX_GPIO14__FUNC_DBPI_D1>,
+				<PINMUX_GPIO15__FUNC_DBPI_D2>,
+				<PINMUX_GPIO16__FUNC_DBPI_D3>,
+				<PINMUX_GPIO17__FUNC_DBPI_D4>,
+				<PINMUX_GPIO18__FUNC_DBPI_D5>,
+				<PINMUX_GPIO19__FUNC_DBPI_D6>,
+				<PINMUX_GPIO20__FUNC_DBPI_D7>,
+				<PINMUX_GPIO21__FUNC_DBPI_D8>,
+				<PINMUX_GPIO22__FUNC_DBPI_D9>,
+				<PINMUX_GPIO23__FUNC_DBPI_D10>,
+				<PINMUX_GPIO24__FUNC_DBPI_D11>,
+				<PINMUX_GPIO25__FUNC_DBPI_HSYNC>,
+				<PINMUX_GPIO26__FUNC_DBPI_VSYNC>,
+				<PINMUX_GPIO27__FUNC_DBPI_DE>,
+				<PINMUX_GPIO28__FUNC_DBPI_CK>;
+				drive-strength = <MTK_DRIVE_6mA>;
+		};
+	};
+
 	ec_ap_int_odl: ec_ap_int_odl {
 		pins1 {
 			pinmux = <PINMUX_GPIO151__FUNC_GPIO151>;
@@ -465,6 +557,22 @@
 		};
 	};
 
+	it6505_pins: it6505_pins {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO178__FUNC_GPIO178>,
+					<PINMUX_GPIO179__FUNC_GPIO179>;
+			output-low;
+			bias-pull-up;
+		};
+
+		pins_cmd_dat1 {
+			pinmux = <PINMUX_GPIO9__FUNC_GPIO9>,
+					<PINMUX_GPIO152__FUNC_GPIO152>;
+			input-enable;
+			bias-pull-up;
+		};
+	};
+
 	mmc0_pins_default: mmc0default {
 		pins_cmd_dat {
 			pinmux = <PINMUX_GPIO123__FUNC_MSDC0_DAT0>,
@@ -786,6 +894,12 @@
 			#address-cells = <1>;
 			#size-cells = <0>;
 		};
+
+		usbc_extcon: extcon@0 {
+			compatible = "google,extcon-usbc-cros-ec";
+			google,usb-port-id = <0>;
+			#extcon-cells = <0>;
+		};
 	};
 };
 
@@ -829,7 +943,8 @@
 };
 
 &ssusb {
-	dr_mode = "host";
+	maximum-speed = "high-speed";
+	enable-manual-drd;
 	vusb33-supply = <&mt6358_vusb_reg>;
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/mediatek/mt8183.dtsi b/arch/arm64/boot/dts/mediatek/mt8183.dtsi
index 1e791d585ad0..517d0b1a9de6 100644
--- a/arch/arm64/boot/dts/mediatek/mt8183.dtsi
+++ b/arch/arm64/boot/dts/mediatek/mt8183.dtsi
@@ -115,67 +115,67 @@
 		opp-shared;
 		opp00 {
 			opp-hz = /bits/ 64 <793000000>;
-			opp-microvolt = <650000>;
+			opp-microvolt = <700000>;
 		};
 		opp01 {
 			opp-hz = /bits/ 64 <910000000>;
-			opp-microvolt = <675000>;
+			opp-microvolt = <725000>;
 		};
 		opp02 {
 			opp-hz = /bits/ 64 <1014000000>;
-			opp-microvolt = <700000>;
+			opp-microvolt = <750000>;
 		};
 		opp03 {
 			opp-hz = /bits/ 64 <1131000000>;
-			opp-microvolt = <725000>;
+			opp-microvolt = <775000>;
 		};
 		opp04 {
 			opp-hz = /bits/ 64 <1248000000>;
-			opp-microvolt = <750000>;
+			opp-microvolt = <800000>;
 		};
 		opp05 {
 			opp-hz = /bits/ 64 <1326000000>;
-			opp-microvolt = <775000>;
+			opp-microvolt = <825000>;
 		};
 		opp06 {
 			opp-hz = /bits/ 64 <1417000000>;
-			opp-microvolt = <800000>;
+			opp-microvolt = <850000>;
 		};
 		opp07 {
 			opp-hz = /bits/ 64 <1508000000>;
-			opp-microvolt = <825000>;
+			opp-microvolt = <875000>;
 		};
 		opp08 {
 			opp-hz = /bits/ 64 <1586000000>;
-			opp-microvolt = <850000>;
+			opp-microvolt = <900000>;
 		};
 		opp09 {
 			opp-hz = /bits/ 64 <1625000000>;
-			opp-microvolt = <862500>;
+			opp-microvolt = <912500>;
 		};
 		opp10 {
 			opp-hz = /bits/ 64 <1677000000>;
-			opp-microvolt = <881250>;
+			opp-microvolt = <931250>;
 		};
 		opp11 {
 			opp-hz = /bits/ 64 <1716000000>;
-			opp-microvolt = <900000>;
+			opp-microvolt = <950000>;
 		};
 		opp12 {
 			opp-hz = /bits/ 64 <1781000000>;
-			opp-microvolt = <925000>;
+			opp-microvolt = <975000>;
 		};
 		opp13 {
 			opp-hz = /bits/ 64 <1846000000>;
-			opp-microvolt = <950000>;
+			opp-microvolt = <1000000>;
 		};
 		opp14 {
 			opp-hz = /bits/ 64 <1924000000>;
-			opp-microvolt = <975000>;
+			opp-microvolt = <1025000>;
 		};
 		opp15 {
 			opp-hz = /bits/ 64 <1989000000>;
-			opp-microvolt = <1000000>;
+			opp-microvolt = <1050000>;
 		};
 	};
 
@@ -255,6 +255,29 @@
 		operating-points-v2 = <&cci_opp>;
 	};
 
+	devfreq-cpufreq-map {
+		cci-cpufreq {
+			target-dev = <&cci>;
+			cpu-to-dev-map =
+				< 793000  273000000 >,
+				< 910000  403000000 >,
+				< 1014000  463000000 >,
+				< 1131000  546000000 >,
+				< 1248000  624000000 >,
+				< 1326000  689000000 >,
+				< 1417000  767000000 >,
+				< 1508000  871000000 >,
+				< 1586000  923000000 >,
+				< 1625000  962000000 >,
+				< 1677000  1027000000 >,
+				< 1716000  1092000000 >,
+				< 1781000  1144000000 >,
+				< 1846000  1196000000 >,
+				< 1924000  1196000000 >,
+				< 1989000  1196000000 >;
+		};
+	};
+
 	cpus {
 		#address-cells = <1>;
 		#size-cells = <0>;
@@ -467,6 +490,48 @@
 			     <GIC_PPI 10 IRQ_TYPE_LEVEL_LOW 0>;
 	};
 
+
+	tboard_thermistor: thermal-sensor {
+		compatible = "generic-adc-thermal";
+		#thermal-sensor-cells = <0>;
+		io-channels = <&auxadc 1>;
+		io-channel-names = "sensor-channel";
+		temperature-lookup-table = <    (-40000) 4833
+						(-35000) 4798
+						(-30000) 4754
+						(-25000) 4694
+						(-20000) 4615
+						(-15000) 4517
+						(-10000) 4391
+						(-5000) 4241
+						0 4063
+						5000 3856
+						10000 3621
+						15000 3364
+						20000 3091
+						25000 2810
+						30000 2526
+						35000 2247
+						40000 1982
+						45000 1734
+						50000 1507
+						55000 1305
+						60000 1122
+						65000 964
+						70000 827
+						75000 710
+						80000 606
+						85000 519
+						90000 445
+						95000 382
+						100000 330
+						105000 284
+						110000 846
+						115000 213
+						120000 183
+						125000 161>;
+	};
+
 	soc {
 		#address-cells = <2>;
 		#size-cells = <2>;
@@ -532,6 +597,13 @@
 			#reset-cells = <1>;
 		};
 
+		pericfg: power-controller@10003000 {
+			compatible = "mediatek,mt8183-pericfg", "syscon";
+			reg = <0 0x10003000 0 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
 		pio: pinctrl@10005000 {
 			compatible = "mediatek,mt8183-pinctrl";
 			reg = <0 0x10005000 0 0x1000>,
@@ -652,6 +724,17 @@
 			#iommu-cells = <1>;
 		};
 
+		emi@10219000 {
+			compatible = "mediatek,mt8183-emi";
+			reg = <0 0x10219000 0 0x1000>, /* CEN EMI */
+				  <0 0x10226000 0 0x1000>, /* EMI MPU */
+				  <0 0x1022d000 0 0x1000>, /* CHA EMI */
+			      <0 0x10235000 0 0x1000>; /* CHB EMI */
+			interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_LOW>, /* MPU */
+						 <GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>, /* CGM */
+						 <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>; /* ELM */
+		};
+
 		gce: gce@10238000 {
 			compatible = "mediatek,mt8183-gce";
 			reg = <0 0x10238000 0 0x4000>;
@@ -681,6 +764,8 @@
 			clocks = <&infracfg CLK_INFRA_AUXADC>;
 			clock-names = "main";
 			#io-channel-cells = <1>;
+			nvmem-cells = <&auxadc_calibration>;
+			nvmem-cell-names = "calibration-data";
 			status = "disabled";
 		};
 
@@ -908,6 +993,13 @@
 				trips {};
 				cooling-maps {};
 			};
+
+	                Tboard {
+				polling-delay = <1000>; /* milliseconds */
+				polling-delay-passive = <0>; /* milliseconds */
+				thermal-sensors = <&tboard_thermistor>;
+	                };
+
 		};
 
 		pwm0: pwm@1100e000 {
@@ -1125,6 +1217,8 @@
 			clocks = <&infracfg CLK_INFRA_UNIPRO_SCK>,
 				 <&infracfg CLK_INFRA_USB>;
 			clock-names = "sys_ck", "ref_ck";
+			wakeup-source;
+			mediatek,syscon-wakeup = <&pericfg 0x400 1>;
 			#address-cells = <2>;
 			#size-cells = <2>;
 			ranges;
@@ -1281,6 +1375,9 @@
 			thermal_calibration: calib@180 {
 				reg = <0x180 0xc>;
 			};
+			auxadc_calibration: auxadccali@1b4 {
+				reg = <0x1b4 0x4>;
+			};
 		};
 
 		u3phy: usb-phy@11f40000 {
@@ -1295,6 +1392,7 @@
 				clocks = <&clk26m>;
 				clock-names = "ref";
 				#phy-cells = <1>;
+				mediatek,eye-vrt = <1>;
 				status = "okay";
 			};
 
@@ -1496,7 +1594,6 @@
 			power-domains = <&scpsys MT8183_POWER_DOMAIN_DISP>;
 			clocks = <&mmsys CLK_MM_DISP_OVL0>;
 			iommus = <&iommu M4U_PORT_DISP_OVL0>;
-			mediatek,larb = <&larb0>;
 		};
 
 		ovl_2l0: ovl@14009000 {
@@ -1506,7 +1603,6 @@
 			power-domains = <&scpsys MT8183_POWER_DOMAIN_DISP>;
 			clocks = <&mmsys CLK_MM_DISP_OVL0_2L>;
 			iommus = <&iommu M4U_PORT_DISP_2L_OVL0_LARB0>;
-			mediatek,larb = <&larb0>;
 		};
 
 		ovl_2l1: ovl@1400a000 {
@@ -1516,7 +1612,6 @@
 			power-domains = <&scpsys MT8183_POWER_DOMAIN_DISP>;
 			clocks = <&mmsys CLK_MM_DISP_OVL1_2L>;
 			iommus = <&iommu M4U_PORT_DISP_2L_OVL1_LARB0>;
-			mediatek,larb = <&larb0>;
 		};
 
 		rdma0: rdma@1400b000 {
@@ -1526,7 +1621,6 @@
 			power-domains = <&scpsys MT8183_POWER_DOMAIN_DISP>;
 			clocks = <&mmsys CLK_MM_DISP_RDMA0>;
 			iommus = <&iommu M4U_PORT_DISP_RDMA0>;
-			mediatek,larb = <&larb0>;
 		};
 
 		rdma1: rdma@1400c000 {
@@ -1536,7 +1630,6 @@
 			power-domains = <&scpsys MT8183_POWER_DOMAIN_DISP>;
 			clocks = <&mmsys CLK_MM_DISP_RDMA1>;
 			iommus = <&iommu M4U_PORT_DISP_RDMA1>;
-			mediatek,larb = <&larb0>;
 		};
 
 		color0: color@1400e000 {
@@ -1596,6 +1689,17 @@
 			phy-names = "dphy";
 		};
 
+		dpi0: dpi@14015000 {
+			compatible = "mediatek,mt8183-dpi";
+			reg = <0 0x14015000 0 0x1000>;
+			interrupts = <GIC_SPI 237 IRQ_TYPE_LEVEL_LOW>;
+			power-domains = <&scpsys MT8183_POWER_DOMAIN_DISP>;
+			clocks = <&mmsys CLK_MM_DPI_IF>,
+				 <&mmsys CLK_MM_DPI_MM>,
+				 <&apmixedsys CLK_APMIXED_TVDPLL>;
+			clock-names = "pixel", "engine", "pll";
+		};
+
 		mutex: mutex@14016000 {
 			compatible = "mediatek,mt8183-disp-mutex";
 			reg = <0 0x14016000 0 0x1000>;
diff --git a/chromeos/config/arm64/chromiumos-arm64.flavour.config b/chromeos/config/arm64/chromiumos-arm64.flavour.config
index 13f7bd27b0bf..14df7facbb99 100644
--- a/chromeos/config/arm64/chromiumos-arm64.flavour.config
+++ b/chromeos/config/arm64/chromiumos-arm64.flavour.config
@@ -40,6 +40,7 @@ CONFIG_DRM_ANALOGIX_ANX78XX=y
 CONFIG_DRM_MEDIATEK=y
 CONFIG_DRM_MEDIATEK_HDMI=y
 # CONFIG_DRM_MSM_HDMI_HDCP is not set
+CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=y
 CONFIG_DRM_PANEL_INNOLUX_P079ZCA=y
 CONFIG_DRM_TI_SN65DSI86=y
 CONFIG_DRM_VIRTIO_GPU=y
@@ -63,6 +64,7 @@ CONFIG_I2C_RK3X=y
 CONFIG_INTERCONNECT=y
 CONFIG_INTERCONNECT_QCOM=y
 CONFIG_INTERCONNECT_QCOM_SDM845=y
+CONFIG_MEDIATEK_MT6577_AUXADC=y
 CONFIG_MEDIATEK_WATCHDOG=y
 CONFIG_MFD_PALMAS=y
 CONFIG_MFD_RK808=y
@@ -75,6 +77,7 @@ CONFIG_MSM_GCC_8916=y
 CONFIG_MTD_MT81xx_NOR=y
 CONFIG_MTK_CMDQ=y
 CONFIG_MTK_EFUSE=y
+CONFIG_MTK_EMI_MBW=y
 CONFIG_MTK_IOMMU=y
 CONFIG_MTK_PMIC_WRAP=y
 CONFIG_MTK_SCP=m
@@ -184,8 +187,10 @@ CONFIG_SPI_QCOM_QSPI=y
 CONFIG_SPI_ROCKCHIP=y
 CONFIG_SPMI=y
 CONFIG_TOUCHSCREEN_MELFAS_MIP4=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_SERIAL=y
 CONFIG_USB_MTU3=y
-CONFIG_USB_MTU3_HOST=y
 CONFIG_VIDEO_MEDIATEK_MDP=y
 CONFIG_VIDEO_MEDIATEK_VCODEC=y
 CONFIG_VIRTIO_BLK=y
@@ -193,3 +198,6 @@ CONFIG_VIRTIO_CONSOLE=y
 CONFIG_VIRTIO_INPUT=y
 CONFIG_VIRTIO_MMIO=y
 CONFIG_VIRTIO_NET=y
+
+CONFIG_GENERIC_ADC_THERMAL=y
+
diff --git a/chromeos/config/arm64/chromiumos-mediatek.flavour.config b/chromeos/config/arm64/chromiumos-mediatek.flavour.config
index e02669621c75..543e5e071074 100644
--- a/chromeos/config/arm64/chromiumos-mediatek.flavour.config
+++ b/chromeos/config/arm64/chromiumos-mediatek.flavour.config
@@ -25,10 +25,13 @@ CONFIG_COMMON_CLK_MT8183_MMSYS=y
 CONFIG_COMMON_CLK_MT8183_VDECSYS=y
 CONFIG_COMMON_CLK_MT8183_VENCSYS=y
 CONFIG_CROS_EC_RPMSG=m
+CONFIG_DEVFREQ_GOV_CPUFREQ_MAP=y
 CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
 CONFIG_DRM_ANALOGIX_ANX78XX=y
+CONFIG_DRM_ITE_IT6505=y
 CONFIG_DRM_MEDIATEK=y
 CONFIG_DRM_MEDIATEK_HDMI=y
+CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=y
 CONFIG_DRM_PANEL_INNOLUX_P079ZCA=y
 # CONFIG_EFI is not set
 CONFIG_ENERGY_MODEL=y
@@ -39,6 +42,7 @@ CONFIG_MALI_DMA_FENCE=y
 CONFIG_MALI_EXPERT=y
 CONFIG_MALI_MIDGARD=y
 CONFIG_MALI_PLATFORM_NAME="mediatek"
+CONFIG_MEDIATEK_MT6577_AUXADC=y
 CONFIG_MEDIATEK_WATCHDOG=y
 CONFIG_MEDIA_CONTROLLER=y
 CONFIG_MEDIA_CONTROLLER_REQUEST_API=y
@@ -46,6 +50,7 @@ CONFIG_MMC_MTK=y
 CONFIG_MTD_MT81xx_NOR=y
 CONFIG_MTK_CMDQ=y
 CONFIG_MTK_EFUSE=y
+CONFIG_MTK_EMI_MBW=y
 CONFIG_MTK_IOMMU=y
 CONFIG_MTK_PMIC_WRAP=y
 CONFIG_MTK_SCP=m
@@ -77,7 +82,12 @@ CONFIG_STAGING_MEDIA=y
 CONFIG_TCG_CR50_I2C=y
 CONFIG_TMPFS=y
 CONFIG_TOUCHSCREEN_MELFAS_MIP4=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_SERIAL=y
 CONFIG_USB_MTU3=y
-CONFIG_USB_MTU3_HOST=y
 CONFIG_VIDEO_MEDIATEK_MDP=y
 CONFIG_VIDEO_MEDIATEK_VCODEC=y
+
+CONFIG_GENERIC_ADC_THERMAL=y
+
diff --git a/drivers/clk/mediatek/Makefile b/drivers/clk/mediatek/Makefile
index 3dc1b9f15ea2..5df0e476e94d 100644
--- a/drivers/clk/mediatek/Makefile
+++ b/drivers/clk/mediatek/Makefile
@@ -44,3 +44,5 @@ obj-$(CONFIG_COMMON_CLK_MT8183_MFGCFG) += clk-mt8183-mfgcfg.o
 obj-$(CONFIG_COMMON_CLK_MT8183_MMSYS) += clk-mt8183-mm.o
 obj-$(CONFIG_COMMON_CLK_MT8183_VDECSYS) += clk-mt8183-vdec.o
 obj-$(CONFIG_COMMON_CLK_MT8183_VENCSYS) += clk-mt8183-venc.o
+obj-$(CONFIG_COMMON_CLK_MT8183) += clkdbg.o clkdbg-mt8183.o
+obj-$(CONFIG_COMMON_CLK_MT8183) += clkchk.o clkchk-mt8183.o
diff --git a/drivers/clk/mediatek/clk-mt8183.c b/drivers/clk/mediatek/clk-mt8183.c
index e749f40660a2..de22ba0b372a 100644
--- a/drivers/clk/mediatek/clk-mt8183.c
+++ b/drivers/clk/mediatek/clk-mt8183.c
@@ -1001,6 +1001,25 @@ static const struct mtk_gate infra_clks[] = {
 		"msdc50_0_sel", 24),
 };
 
+static const struct mtk_gate_regs peri_cg_regs = {
+	.set_ofs = 0x20c,
+	.clr_ofs = 0x20c,
+	.sta_ofs = 0x20c,
+};
+
+#define GATE_PERI(_id, _name, _parent, _shift) {        \
+	.id = _id,                              \
+	.name = _name,                          \
+	.parent_name = _parent,                 \
+	.regs = &peri_cg_regs,                  \
+	.shift = _shift,                        \
+	.ops = &mtk_clk_gate_ops_no_setclr_inv, \
+}
+
+static const struct mtk_gate peri_clks[] = {
+	GATE_PERI(CLK_PERIAXI, "periaxi", "axi_sel", 31),
+};
+
 static const struct mtk_gate_regs apmixed_cg_regs = {
 	.set_ofs = 0x20,
 	.clr_ofs = 0x20,
@@ -1224,6 +1243,25 @@ static int clk_mt8183_infra_probe(struct platform_device *pdev)
 	return r;
 }
 
+static int clk_mt8183_peri_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+
+	clk_data = mtk_alloc_clk_data(CLK_PERI_NR_CLK);
+
+	mtk_clk_register_gates(node, peri_clks, ARRAY_SIZE(peri_clks),
+		clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+	if (r)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	return r;
+}
+
 static int clk_mt8183_mcu_probe(struct platform_device *pdev)
 {
 	struct clk_onecell_data *clk_data;
@@ -1254,6 +1292,9 @@ static const struct of_device_id of_match_clk_mt8183[] = {
 		.compatible = "mediatek,mt8183-infracfg",
 		.data = clk_mt8183_infra_probe,
 	}, {
+		.compatible = "mediatek,mt8183-pericfg",
+		.data = clk_mt8183_peri_probe,
+	},  {
 		.compatible = "mediatek,mt8183-mcucfg",
 		.data = clk_mt8183_mcu_probe,
 	}, {
diff --git a/drivers/clk/mediatek/clkchk-mt8183.c b/drivers/clk/mediatek/clkchk-mt8183.c
new file mode 100644
index 000000000000..c7b081fbc44b
--- /dev/null
+++ b/drivers/clk/mediatek/clkchk-mt8183.c
@@ -0,0 +1,387 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2018 MediaTek Inc.
+// Author: Weiyi Lu <weiyi.lu@mediatek.com>
+
+#include <linux/module.h>
+#include "clkchk.h"
+
+static const char * const off_pll_names[] = {
+	"univ2pll",
+	"msdcpll",
+	"mmpll",
+	"mfgpll",
+	"tvdpll",
+	"apll1",
+	"apll2",
+	NULL
+};
+
+static const char * const all_clk_names[] = {
+	"univ2pll",
+	"msdcpll",
+	"mmpll",
+	"mfgpll",
+	"tvdpll",
+	"apll1",
+	"apll2",
+	"apmixed_ssusb26m",
+	"apmixed_mipic026m",
+	"apmixed_mdpll26m",
+	"apmixed_mmsys26m",
+	"apmixed_ufs26m",
+	"apmixed_mipic126m",
+	"apmixed_mempll26m",
+	"apmixed_lvpll26m",
+	"apmixed_mipid026m",
+	"apmixed_mipid126m",
+	"syspll_d3",
+	"syspll_d5",
+	"syspll_d2_d2",
+	"syspll_d2_d4",
+	"syspll_d2_d16",
+	"syspll_d3_d2",
+	"syspll_d3_d4",
+	"syspll_d3_d8",
+	"syspll_d5_d2",
+	"syspll_d5_d4",
+	"syspll_d7_d2",
+	"syspll_d7_d4",
+	"univpll_ck",
+	"univpll_d2",
+	"univpll_d3",
+	"univpll_d5",
+	"univpll_d7",
+	"univpll_d2_d2",
+	"univpll_d2_d4",
+	"univpll_d2_d8",
+	"univpll_d3_d2",
+	"univpll_d3_d4",
+	"univpll_d3_d8",
+	"univpll_d5_d2",
+	"univpll_d5_d4",
+	"univpll_d5_d8",
+	"apll1_ck",
+	"apll1_d2",
+	"apll1_d4",
+	"apll1_d8",
+	"apll2_ck",
+	"apll2_d2",
+	"apll2_d4",
+	"apll2_d8",
+	"tvdpll_ck",
+	"tvdpll_d2",
+	"tvdpll_d4",
+	"tvdpll_d8",
+	"tvdpll_d16",
+	"msdcpll_ck",
+	"msdcpll_d2",
+	"msdcpll_d4",
+	"msdcpll_d8",
+	"msdcpll_d16",
+	"ad_osc_ck",
+	"osc_d2",
+	"osc_d4",
+	"osc_d8",
+	"osc_d16",
+	"csw_f26m_ck_d2",
+	"mfgpll_ck",
+	"univ_192m_ck",
+	"univ_192m_d2",
+	"univ_192m_d4",
+	"univ_192m_d8",
+	"univ_192m_d16",
+	"univ_192m_d32",
+	"mmpll_ck",
+	"mmpll_d4",
+	"mmpll_d4_d2",
+	"mmpll_d4_d4",
+	"mmpll_d5",
+	"mmpll_d5_d2",
+	"mmpll_d5_d4",
+	"mmpll_d6",
+	"mmpll_d7",
+	"osc",
+	"univpll_192m",
+	"apll_i2s0_sel",
+	"apll_i2s1_sel",
+	"apll_i2s2_sel",
+	"apll_i2s3_sel",
+	"apll_i2s4_sel",
+	"apll_i2s5_sel",
+	"apll12_div0",
+	"apll12_div1",
+	"apll12_div2",
+	"apll12_div3",
+	"apll12_div4",
+	"apll12_divb",
+	"univpll",
+	"armpll_div_pll2",
+	"mm_sel",
+	"cam_sel",
+	"mfg_sel",
+	"camtg_sel",
+	"spi_sel",
+	"msdc50_hclk_sel",
+	"msdc50_0_sel",
+	"msdc30_1_sel",
+	"msdc30_2_sel",
+	"audio_sel",
+	"aud_intbus_sel",
+	"fpwrap_ulposc_sel",
+	"scp_sel",
+	"atb_sel",
+	"sspm_sel",
+	"dpi0_sel",
+	"scam_sel",
+	"aud_1_sel",
+	"aud_2_sel",
+	"disppwm_sel",
+	"ssusb_top_xhci_sel",
+	"usb_top_sel",
+	"i2c_sel",
+	"f52m_mfg_sel",
+	"seninf_sel",
+	"dxcc_sel",
+	"camtg2_sel",
+	"aud_eng1_sel",
+	"aud_eng2_sel",
+	"faes_ufsfde_sel",
+	"fufs_sel",
+	"img_sel",
+	"dsp_sel",
+	"dsp1_sel",
+	"dsp2_sel",
+	"ipu_if_sel",
+	"camtg3_sel",
+	"camtg4_sel",
+	"mcu_mp0_sel",
+	"mcu_mp2_sel",
+	"mcu_bus_sel",
+	"infra_pmic_tmr",
+	"infra_pmic_md",
+	"infra_pmic_conn",
+	"infra_scp",
+	"infra_sej",
+	"infra_apxgpt",
+	"infra_icusb",
+	"infra_gce",
+	"infra_therm",
+	"infra_i2c0",
+	"infra_i2c1",
+	"infra_i2c2",
+	"infra_i2c3",
+	"infra_pwm_hclk",
+	"infra_pwm1",
+	"infra_pwm2",
+	"infra_pwm3",
+	"infra_pwm4",
+	"infra_pwm",
+	"infra_uart1",
+	"infra_uart2",
+	"infra_uart3",
+	"infra_gce_26m",
+	"infra_cqdma_fpc",
+	"infra_btif",
+	"infra_spi0",
+	"infra_msdc0",
+	"infra_msdc1",
+	"infra_msdc2",
+	"infra_msdc0_sck",
+	"infra_dvfsrc",
+	"infra_gcpu",
+	"infra_trng",
+	"infra_auxadc",
+	"infra_cpum",
+	"infra_ccif1_ap",
+	"infra_ccif1_md",
+	"infra_auxadc_md",
+	"infra_msdc1_sck",
+	"infra_msdc2_sck",
+	"infra_apdma",
+	"infra_xiu",
+	"infra_device_apc",
+	"infra_ccif_ap",
+	"infra_debugsys",
+	"infra_audio",
+	"infra_ccif_md",
+	"infra_dxcc_sec_core",
+	"infra_dxcc_ao",
+	"infra_dramc_f26m",
+	"infra_irtx",
+	"infra_disppwm",
+	"infra_cldma_bclk",
+	"infra_audio_26m_bclk",
+	"infra_spi1",
+	"infra_i2c4",
+	"infra_md_tmp_share",
+	"infra_spi2",
+	"infra_spi3",
+	"infra_unipro_sck",
+	"infra_unipro_tick",
+	"infra_ufs_mp_sap_bck",
+	"infra_md32_bclk",
+	"infra_sspm",
+	"infra_unipro_mbist",
+	"infra_sspm_bus_hclk",
+	"infra_i2c5",
+	"infra_i2c5_arbiter",
+	"infra_i2c5_imm",
+	"infra_i2c1_arbiter",
+	"infra_i2c1_imm",
+	"infra_i2c2_arbiter",
+	"infra_i2c2_imm",
+	"infra_spi4",
+	"infra_spi5",
+	"infra_cqdma",
+	"infra_ufs",
+	"infra_aes_ufsfde",
+	"infra_ufs_tick",
+	"infra_msdc0_self",
+	"infra_msdc1_self",
+	"infra_msdc2_self",
+	"infra_sspm_26m_self",
+	"infra_sspm_32k_self",
+	"infra_ufs_axi",
+	"infra_i2c6",
+	"infra_ap_msdc0",
+	"infra_md_msdc0",
+	"infra_usb",
+	"infra_devmpu_bclk",
+	"infra_ccif2_ap",
+	"infra_ccif2_md",
+	"infra_ccif3_ap",
+	"infra_ccif3_md",
+	"infra_sej_f13m",
+	"infra_aes_bclk",
+	"infra_i2c7",
+	"infra_i2c8",
+	"infra_fbist2fpc",
+	"aud_tml",
+	"aud_dac_predis",
+	"aud_dac",
+	"aud_adc",
+	"aud_apll_tuner",
+	"aud_apll2_tuner",
+	"aud_24m",
+	"aud_22m",
+	"aud_afe",
+	"aud_i2s4",
+	"aud_i2s3",
+	"aud_i2s2",
+	"aud_i2s1",
+	"aud_pdn_adda6_adc",
+	"aud_tdm",
+	"mfg_bg3d",
+	"mm_smi_common",
+	"mm_smi_larb0",
+	"mm_smi_larb1",
+	"mm_gals_comm0",
+	"mm_gals_comm1",
+	"mm_gals_ccu2mm",
+	"mm_gals_ipu12mm",
+	"mm_gals_img2mm",
+	"mm_gals_cam2mm",
+	"mm_gals_ipu2mm",
+	"mm_mdp_dl_txck",
+	"mm_ipu_dl_txck",
+	"mm_mdp_rdma0",
+	"mm_mdp_rdma1",
+	"mm_mdp_rsz0",
+	"mm_mdp_rsz1",
+	"mm_mdp_tdshp",
+	"mm_mdp_wrot0",
+	"mm_fake_eng",
+	"mm_disp_ovl0",
+	"mm_disp_ovl0_2l",
+	"mm_disp_ovl1_2l",
+	"mm_disp_rdma0",
+	"mm_disp_rdma1",
+	"mm_disp_wdma0",
+	"mm_disp_color0",
+	"mm_disp_ccorr0",
+	"mm_disp_aal0",
+	"mm_disp_gamma0",
+	"mm_disp_dither0",
+	"mm_disp_split",
+	"mm_dsi0_mm",
+	"mm_dsi0_if",
+	"mm_dpi_mm",
+	"mm_dpi_if",
+	"mm_fake_eng2",
+	"mm_mdp_dl_rx",
+	"mm_ipu_dl_rx",
+	"mm_26m",
+	"mm_mmsys_r2y",
+	"mm_disp_rsz",
+	"mm_mdp_wdma0",
+	"mm_mdp_aal",
+	"mm_mdp_ccorr",
+	"mm_dbi_mm",
+	"mm_dbi_if",
+	"vdec_vdec",
+	"vdec_larb1",
+	"venc_larb",
+	"venc_venc",
+	"venc_jpgenc",
+	"img_owe",
+	"img_wpe_b",
+	"img_wpe_a",
+	"img_mfb",
+	"img_rsc",
+	"img_dpe",
+	"img_fdvt",
+	"img_dip",
+	"img_larb2",
+	"img_larb5",
+	"cam_larb6",
+	"cam_dfp_vad",
+	"cam_cam",
+	"cam_camtg",
+	"cam_seninf",
+	"cam_camsv0",
+	"cam_camsv1",
+	"cam_camsv2",
+	"cam_ccu",
+	"cam_larb3",
+	"ipu_conn_ipu",
+	"ipu_conn_ahb",
+	"ipu_conn_axi",
+	"ipu_conn_isp",
+	"ipu_conn_cam_adl",
+	"ipu_conn_img_adl",
+	"ipu_conn_dap_rx",
+	"ipu_conn_apb2axi",
+	"ipu_conn_apb2ahb",
+	"ipu_conn_ipu_cab1to2",
+	"ipu_conn_ipu1_cab1to2",
+	"ipu_conn_ipu2_cab1to2",
+	"ipu_conn_cab3to3",
+	"ipu_conn_cab2to1",
+	"ipu_conn_cab3to1_slice",
+	"ipu_adl_cabgen",
+	"ipu_core0_jtag",
+	"ipu_core0_axi",
+	"ipu_core0_ipu",
+	"ipu_core1_jtag",
+	"ipu_core1_axi",
+	"ipu_core1_ipu",
+	/* end */
+	NULL
+};
+
+static const char * const compatible[] = {"mediatek,mt8183", NULL};
+
+static struct clkchk_cfg_t cfg = {
+	.aee_excp_on_fail = false,
+	.warn_on_fail = true,
+	.compatible = compatible,
+	.off_pll_names = off_pll_names,
+	.all_clk_names = all_clk_names,
+};
+
+static int __init clkchk_platform_init(void)
+{
+	return clkchk_init(&cfg);
+}
+subsys_initcall(clkchk_platform_init);
diff --git a/drivers/clk/mediatek/clkchk.c b/drivers/clk/mediatek/clkchk.c
new file mode 100644
index 000000000000..d50110a0d538
--- /dev/null
+++ b/drivers/clk/mediatek/clkchk.c
@@ -0,0 +1,188 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2018 MediaTek Inc.
+// Author: Weiyi Lu <weiyi.lu@mediatek.com>
+
+#define pr_fmt(fmt) "[clkchk] " fmt
+
+#include <linux/clk-provider.h>
+#include <linux/syscore_ops.h>
+#include "clkchk.h"
+
+#define AEE_EXCP_CHECK_PLL_FAIL	0
+#define CLKDBG_CCF_API_4_4	1
+#define MAX_PLLS		32
+
+#if AEE_EXCP_CHECK_PLL_FAIL
+#include <mt-plat/aee.h>
+#endif
+
+#if !CLKDBG_CCF_API_4_4
+
+/* backward compatible */
+
+static const char *clk_hw_get_name(const struct clk_hw *hw)
+{
+	return __clk_get_name(hw->clk);
+}
+
+static bool clk_hw_is_prepared(const struct clk_hw *hw)
+{
+	return __clk_is_prepared(hw->clk);
+}
+
+static bool clk_hw_is_enabled(const struct clk_hw *hw)
+{
+	return __clk_is_enabled(hw->clk);
+}
+
+static unsigned long clk_hw_get_rate(const struct clk_hw *hw)
+{
+	return __clk_get_rate(hw->clk);
+}
+
+static struct clk_hw *clk_hw_get_parent(const struct clk_hw *hw)
+{
+	return __clk_get_hw(clk_get_parent(hw->clk));
+}
+
+#endif /* !CLKDBG_CCF_API_4_4 */
+
+static struct clkchk_cfg_t *clkchk_cfg;
+
+static const char *ccf_state(struct clk_hw *hw)
+{
+	if (__clk_get_enable_count(hw->clk))
+		return "enabled";
+
+	if (clk_hw_is_prepared(hw))
+		return "prepared";
+
+	return "disabled";
+}
+
+static void print_enabled_clks(void)
+{
+	const char * const *cn = clkchk_cfg->all_clk_names;
+
+	pr_warn("enabled clks:\n");
+
+	for (; *cn != NULL; cn++) {
+		struct clk *c = __clk_lookup(*cn);
+		struct clk_hw *c_hw = __clk_get_hw(c);
+		struct clk_hw *p_hw;
+
+		if (IS_ERR_OR_NULL(c) || c_hw == NULL)
+			continue;
+
+		p_hw = clk_hw_get_parent(c_hw);
+
+		if (p_hw == NULL)
+			continue;
+
+		if (!clk_hw_is_prepared(c_hw) &&
+			__clk_get_enable_count(c) <= 0U)
+			continue;
+
+		pr_warn("[%-17s: %8s, %3d, %3d, %10ld, %17s]\n",
+			clk_hw_get_name(c_hw),
+			ccf_state(c_hw),
+			clk_hw_is_prepared(c_hw),
+			__clk_get_enable_count(c),
+			clk_hw_get_rate(c_hw),
+			p_hw != NULL ? clk_hw_get_name(p_hw) : "- ");
+	}
+}
+
+static void check_pll_off(void)
+{
+	static struct clk *off_plls[MAX_PLLS];
+
+	struct clk **c;
+	int invalid = 0;
+	char buf[128] = {0};
+	int n = 0;
+
+	if (off_plls[0] == NULL) {
+		const char * const *pn = clkchk_cfg->off_pll_names;
+		struct clk **end = off_plls + MAX_PLLS - 1;
+
+		for (c = off_plls; *pn != NULL && c < end; pn++, c++)
+			*c = __clk_lookup(*pn);
+	}
+
+	for (c = off_plls; *c != NULL; c++) {
+		struct clk_hw *c_hw = __clk_get_hw(*c);
+
+		if (c_hw == NULL)
+			continue;
+
+		if (!clk_hw_is_prepared(c_hw) && !clk_hw_is_enabled(c_hw))
+			continue;
+
+		n += snprintf(buf + n, sizeof(buf) - (size_t)n, "%s ",
+				clk_hw_get_name(c_hw));
+
+		invalid++;
+	}
+
+	if (invalid == 0)
+		return;
+
+	/* invalid. output debug info */
+
+	pr_warn("unexpected unclosed PLL: %s\n", buf);
+	print_enabled_clks();
+
+#if AEE_EXCP_CHECK_PLL_FAIL
+	if (clkchk_cfg->aee_excp_on_fail)
+		aee_kernel_exception("clkchk", "unclosed PLL: %s\n", buf);
+#endif
+
+	if (clkchk_cfg->warn_on_fail)
+		WARN_ON(true);
+}
+
+static int clkchk_syscore_suspend(void)
+{
+	check_pll_off();
+
+	return 0;
+}
+
+static void clkchk_syscore_resume(void)
+{
+}
+
+static struct syscore_ops clkchk_syscore_ops = {
+	.suspend = clkchk_syscore_suspend,
+	.resume = clkchk_syscore_resume,
+};
+
+int clkchk_init(struct clkchk_cfg_t *cfg)
+{
+	const char * const *c;
+	bool match = false;
+
+	if (cfg == NULL || cfg->compatible == NULL
+		|| cfg->all_clk_names == NULL || cfg->off_pll_names == NULL) {
+		pr_warn("Invalid clkchk_cfg.\n");
+		return -EINVAL;
+	}
+
+	clkchk_cfg = cfg;
+
+	for (c = cfg->compatible; *c != NULL; c++) {
+		if (of_machine_is_compatible(*c) != 0) {
+			match = true;
+			break;
+		}
+	}
+
+	if (!match)
+		return -ENODEV;
+
+	register_syscore_ops(&clkchk_syscore_ops);
+
+	return 0;
+}
diff --git a/drivers/clk/mediatek/clkchk.h b/drivers/clk/mediatek/clkchk.h
new file mode 100644
index 000000000000..d99e1acb6477
--- /dev/null
+++ b/drivers/clk/mediatek/clkchk.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
+ */
+
+#include <stdbool.h>
+#include <stddef.h>
+
+struct clkchk_cfg_t {
+	bool aee_excp_on_fail;
+	bool warn_on_fail;
+	const char * const *compatible;
+	const char * const *off_pll_names;
+	const char * const *all_clk_names;
+};
+
+int clkchk_init(struct clkchk_cfg_t *cfg);
diff --git a/drivers/clk/mediatek/clkdbg-mt8183.c b/drivers/clk/mediatek/clkdbg-mt8183.c
new file mode 100644
index 000000000000..7b82ef2bce81
--- /dev/null
+++ b/drivers/clk/mediatek/clkdbg-mt8183.c
@@ -0,0 +1,865 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2018 MediaTek Inc.
+// Author: Weiyi Lu <weiyi.lu@mediatek.com>
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+
+#include "clkdbg.h"
+
+#define DUMP_INIT_STATE		0
+
+/*
+ * clkdbg dump_regs
+ */
+
+enum {
+	topckgen,
+	infracfg,
+	scpsys,
+	apmixedsys,
+	audiosys,
+	mfgsys,
+	mmsys,
+	imgsys,
+	camsys,
+	vencsys,
+};
+
+#define REGBASE_V(_phys, _id_name) { .phys = _phys, .name = #_id_name }
+
+/*
+ * checkpatch.pl ERROR:COMPLEX_MACRO
+ *
+ * #define REGBASE(_phys, _id_name) [_id_name] = REGBASE_V(_phys, _id_name)
+ */
+
+static struct regbase rb[] = {
+	[topckgen] = REGBASE_V(0x10000000, topckgen),
+	[infracfg] = REGBASE_V(0x10001000, infracfg),
+	[scpsys]   = REGBASE_V(0x10006000, scpsys),
+	[apmixedsys]  = REGBASE_V(0x1000c000, apmixedsys),
+	[audiosys]    = REGBASE_V(0x11220000, audiosys),
+	[mfgsys]   = REGBASE_V(0x13000000, mfgsys),
+	[mmsys]    = REGBASE_V(0x14000000, mmsys),
+	[imgsys]   = REGBASE_V(0x15020000, imgsys),
+	[camsys]   = REGBASE_V(0x1a000000, camsys),
+	[vencsys]  = REGBASE_V(0x17000000, vencsys),
+};
+
+#define REGNAME(_base, _ofs, _name)	\
+	{ .base = &rb[_base], .ofs = _ofs, .name = #_name }
+
+static struct regname rn[] = {
+	REGNAME(topckgen,  0x040, CLK_CFG_0),
+	REGNAME(topckgen,  0x050, CLK_CFG_1),
+	REGNAME(topckgen,  0x060, CLK_CFG_2),
+	REGNAME(topckgen,  0x070, CLK_CFG_3),
+	REGNAME(topckgen,  0x080, CLK_CFG_4),
+	REGNAME(topckgen,  0x090, CLK_CFG_5),
+	REGNAME(topckgen,  0x0a0, CLK_CFG_6),
+	REGNAME(topckgen,  0x0b0, CLK_CFG_7),
+	REGNAME(topckgen,  0x0c0, CLK_CFG_8),
+	REGNAME(topckgen,  0x0d0, CLK_CFG_9),
+	REGNAME(topckgen,  0x0e0, CLK_CFG_10),
+	REGNAME(audiosys,  0x000, AUDIO_TOP_CON0),
+	REGNAME(audiosys,  0x004, AUDIO_TOP_CON1),
+	REGNAME(camsys,  0x000, CAMSYS_CG),
+	REGNAME(imgsys,  0x000, IMG_CG),
+	REGNAME(infracfg,  0x090, MODULE_SW_CG_0),
+	REGNAME(infracfg,  0x094, MODULE_SW_CG_1),
+	REGNAME(infracfg,  0x0ac, MODULE_SW_CG_2),
+	REGNAME(infracfg,  0x0c8, MODULE_SW_CG_3),
+	REGNAME(mfgsys,  0x000, MFG_CG),
+	REGNAME(mmsys,	0x100, MMSYS_CG_CON0),
+	REGNAME(mmsys,	0x110, MMSYS_CG_CON1),
+	REGNAME(vencsys,  0x000, VENCSYS_CG),
+	REGNAME(apmixedsys,  0x200, ARMPLL_LL_CON0),
+	REGNAME(apmixedsys,  0x204, ARMPLL_LL_CON1),
+	REGNAME(apmixedsys,  0x20C, ARMPLL_LL_PWR_CON0),
+	REGNAME(apmixedsys,  0x210, ARMPLL_L_CON0),
+	REGNAME(apmixedsys,  0x214, ARMPLL_L_CON1),
+	REGNAME(apmixedsys,  0x21C, ARMPLL_L_PWR_CON0),
+	REGNAME(apmixedsys,  0x220, MAINPLL_CON0),
+	REGNAME(apmixedsys,  0x224, MAINPLL_CON1),
+	REGNAME(apmixedsys,  0x22C, MAINPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x230, UNIVPLL_CON0),
+	REGNAME(apmixedsys,  0x234, UNIVPLL_CON1),
+	REGNAME(apmixedsys,  0x23C, UNIVPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x240, MFGPLL_CON0),
+	REGNAME(apmixedsys,  0x244, MFGPLL_CON1),
+	REGNAME(apmixedsys,  0x24C, MFGPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x250, MSDCPLL_CON0),
+	REGNAME(apmixedsys,  0x254, MSDCPLL_CON1),
+	REGNAME(apmixedsys,  0x25C, MSDCPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x260, TVDPLL_CON0),
+	REGNAME(apmixedsys,  0x264, TVDPLL_CON1),
+	REGNAME(apmixedsys,  0x26C, TVDPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x270, MMPLL_CON0),
+	REGNAME(apmixedsys,  0x274, MMPLL_CON1),
+	REGNAME(apmixedsys,  0x27C, MMPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x280, MPLL_CON0),
+	REGNAME(apmixedsys,  0x284, MPLL_CON1),
+	REGNAME(apmixedsys,  0x28C, MPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x290, CCIPLL_CON0),
+	REGNAME(apmixedsys,  0x294, CCIPLL_CON1),
+	REGNAME(apmixedsys,  0x29C, CCIPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x2A0, APLL1_CON0),
+	REGNAME(apmixedsys,  0x2A4, APLL1_CON1),
+	REGNAME(apmixedsys,  0x2B0, APLL1_PWR_CON0),
+	REGNAME(apmixedsys,  0x2B4, APLL2_CON0),
+	REGNAME(apmixedsys,  0x2B8, APLL2_CON1),
+	REGNAME(apmixedsys,  0x2C4, APLL2_PWR_CON0),
+	REGNAME(scpsys,  0x0180, PWR_STATUS),
+	REGNAME(scpsys,  0x0184, PWR_STATUS_2ND),
+	REGNAME(scpsys,  0x0334, MFG_ASYNC_PWR_CON),
+	REGNAME(scpsys,  0x0338, MFG_PWR_CON),
+	REGNAME(scpsys,  0x033C, MFG_CORE0_PWR_CON),
+	REGNAME(scpsys,  0x0340, MFG_CORE1_PWR_CON),
+	REGNAME(scpsys,  0x0320, MD1_PWR_CON),
+	REGNAME(scpsys,  0x032C, CONN_PWR_CON),
+	REGNAME(scpsys,  0x0314, AUD_PWR_CON),
+	REGNAME(scpsys,  0x030C, DIS_PWR_CON),
+	REGNAME(scpsys,  0x0344, CAM_PWR_CON),
+	REGNAME(scpsys,  0x0308, ISP_PWR_CON),
+	REGNAME(scpsys,  0x0304, VEN_PWR_CON),
+	{}
+};
+
+static const struct regname *get_all_regnames(void)
+{
+	return rn;
+}
+
+static void __init init_regbase(void)
+{
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(rb); i++)
+		rb[i].virt = ioremap(rb[i].phys, PAGE_SIZE);
+}
+
+/*
+ * clkdbg fmeter
+ */
+
+#include <linux/delay.h>
+
+#define clk_readl(addr)		readl(addr)
+#define clk_writel(addr, val)	\
+	do { writel(val, addr); wmb(); } while (0) /* sync write */
+
+#define FMCLK(_t, _i, _n) { .type = _t, .id = _i, .name = _n }
+
+static const struct fmeter_clk fclks[] = {
+	FMCLK(CKGEN,  1, "hd_faxi_ck"),
+	FMCLK(CKGEN,  2, "hf_fmm_ck"),
+	FMCLK(CKGEN,  3, "hf_fimg_ck"),
+	FMCLK(CKGEN,  4, "hf_fcam_ck"),
+	FMCLK(CKGEN,  5, "hf_fdsp_ck"),
+	FMCLK(CKGEN,  6, "hf_fdsp1_ck"),
+	FMCLK(CKGEN,  7, "hf_fdsp2_ck"),
+	FMCLK(CKGEN,  8, "hf_fipu_if_ck"),
+	FMCLK(CKGEN,  9, "hf_fmfg_ck"),
+	FMCLK(CKGEN,  10, "f52m_mfg_ck"),
+	FMCLK(CKGEN,  11, "f_fcamtg_ck"),
+	FMCLK(CKGEN,  12, "f_fcamtg2_ck"),
+	FMCLK(CKGEN,  13, "f_fcamtg3_ck"),
+	FMCLK(CKGEN,  14, "f_fcamtg4_ck"),
+	FMCLK(CKGEN,  15, "f_fuart_ck"),
+	FMCLK(CKGEN,  16, "hf_fspi_ck"),
+	FMCLK(CKGEN,  17, "hf_fmsdc50_0_hclk_ck"),
+	FMCLK(CKGEN,  18, "hf_fmsdc50_0_ck"),
+	FMCLK(CKGEN,  19, "hf_fmsdc30_1_ck"),
+	FMCLK(CKGEN,  20, "hf_fmsdc30_2_ck"),
+	FMCLK(CKGEN,  21, "hf_faudio_ck"),
+	FMCLK(CKGEN,  22, "hf_faud_intbus_ck"),
+	FMCLK(CKGEN,  23, "hf_fpmicspi_ck"),
+	FMCLK(CKGEN,  24, "f_fpwrap_ulposc_ck"),
+	FMCLK(CKGEN,  25, "hf_fatb_ck"),
+	FMCLK(CKGEN,  26, "hf_fsspm_ck"),
+	FMCLK(CKGEN,  27, "hf_fdpi0_ck"),
+	FMCLK(CKGEN,  28, "hf_fscam_ck"),
+	FMCLK(CKGEN,  29, "f_fdisp_pwm_ck"),
+	FMCLK(CKGEN,  30, "f_fusb_top_ck"),
+	FMCLK(CKGEN,  31, "f_fssusb_xhci_ck"),
+	FMCLK(CKGEN,  32, "hg_fspm_ck"),
+	FMCLK(CKGEN,  33, "f_fi2c_ck"),
+	FMCLK(CKGEN,  34, "hf_fscp_ck"),
+	FMCLK(CKGEN,  35, "f_fseninf_ck"),
+	FMCLK(CKGEN,  36, "f_fdxcc_ck"),
+	FMCLK(CKGEN,  37, "hf_faud_engin1_ck"),
+	FMCLK(CKGEN,  38, "hf_faud_engin2_ck"),
+	FMCLK(CKGEN,  39, "hf_faes_ufsfde_ck"),
+	FMCLK(CKGEN,  40, "hf_fufs_ck"),
+	FMCLK(CKGEN,  41, "hf_faud_1_ck"),
+	FMCLK(CKGEN,  42, "hf_faud_2_ck"),
+	FMCLK(CKGEN,  49, "hf_fref_mm_ck"),
+	FMCLK(CKGEN,  50, "hf_fref_cam_ck"),
+	FMCLK(CKGEN,  51, "hf_hddrphycfg_ck"),
+	FMCLK(CKGEN,  52, "f_ufs_mp_sap_cfg_ck"),
+	FMCLK(CKGEN,  53, "f_ufs_tick1us_ck"),
+	FMCLK(CKGEN,  54, "hd_faxi_east_ck"),
+	FMCLK(CKGEN,  55, "hd_faxi_west_ck"),
+	FMCLK(CKGEN,  56, "hd_faxi_north_ck"),
+	FMCLK(CKGEN,  57, "hd_faxi_south_ck"),
+	FMCLK(CKGEN,  58, "hg_fmipicfg_tx_ck"),
+	FMCLK(CKGEN,  59, "fmem_ck_bfe_dcm_ch0"),
+	FMCLK(CKGEN,  60, "fmem_ck_aft_dcm_ch0"),
+	FMCLK(CKGEN,  61, "fmem_ck_bfe_dcm_ch1"),
+	FMCLK(CKGEN,  62, "fmem_ck_aft_dcm_ch1"),
+	FMCLK(CKGEN,  63, "dramc_pll104m_ck"),
+	FMCLK(ABIST,  1, "AD_WBG_DIG_CK_832M"),
+	FMCLK(ABIST,  2, "AD_WBG_DIG_CK_960M"),
+	FMCLK(ABIST,  3, "UFS_MP_CLK2FREQ"),
+	FMCLK(ABIST,  4, "AD_CSI0A_CDPHY_DELAYCAL_CK"),
+	FMCLK(ABIST,  5, "AD_CSI0B_CDPHY_DELAYCAL_CK"),
+	FMCLK(ABIST,  6, "AD_CSI1A_DPHY_DELAYCAL_CK"),
+	FMCLK(ABIST,  7, "AD_CSI1B_DPHY_DELAYCAL_CK"),
+	FMCLK(ABIST,  8, "AD_CSI2A_DPHY_DELAYCAL_CK"),
+	FMCLK(ABIST,  9, "AD_CSI2B_DPHY_DELAYCAL_CK"),
+	FMCLK(ABIST,  10, "AD_MDBPIPLL_CK"),
+	FMCLK(ABIST,  11, "AD_MDBRPPLL_CK"),
+	FMCLK(ABIST,  12, "AD_MDMCUPLL_CK"),
+	FMCLK(ABIST,  13, "AD_MDTXPLL_CK"),
+	FMCLK(ABIST,  14, "AD_MDVDSPPLL_CK"),
+	FMCLK(ABIST,  16, "AD_MDPLL_FS26M_CK"),
+	FMCLK(ABIST,  20, "AD_ARMPLL_L_CK"),
+	FMCLK(ABIST,  22, "AD_ARMPLL_LL_CK"),
+	FMCLK(ABIST,  23, "AD_MAINPLL_1092M_CK"),
+	FMCLK(ABIST,  24, "AD_UNIVPLL_1248M_CK"),
+	FMCLK(ABIST,  25, "AD_MFGPLL_CK"),
+	FMCLK(ABIST,  26, "AD_MSDCPLL_CK"),
+	FMCLK(ABIST,  27, "AD_MMPLL_CK"),
+	FMCLK(ABIST,  28, "AD_APLL1_CK"),
+	FMCLK(ABIST,  29, "AD_APLL2_CK"),
+	FMCLK(ABIST,  30, "AD_APPLLGP_TST_CK"),
+	FMCLK(ABIST,  32, "AD_UNIV_192M_CK"),
+	FMCLK(ABIST,  34, "AD_TVDPLL_CK"),
+	FMCLK(ABIST,  35, "AD_DSI0_MPPLL_TST_CK"),
+	FMCLK(ABIST,  36, "AD_DSI0_LNTC_DSICLK"),
+	FMCLK(ABIST,  37, "AD_OSC_CK_2"),
+	FMCLK(ABIST,  38, "AD_OSC_CK"),
+	FMCLK(ABIST,  39, "rtc32k_ck_i"),
+	FMCLK(ABIST,  40, "mcusys_arm_clk_out_all"),
+	FMCLK(ABIST,  41, "AD_OSC_SYNC_CK"),
+	FMCLK(ABIST,  42, "AD_OSC_SYNC_CK_2"),
+	FMCLK(ABIST,  43, "msdc01_in_ck"),
+	FMCLK(ABIST,  44, "msdc02_in_ck"),
+	FMCLK(ABIST,  45, "msdc11_in_ck"),
+	FMCLK(ABIST,  46, "msdc12_in_ck"),
+	FMCLK(ABIST,  49, "AD_CCIPLL_CK"),
+	FMCLK(ABIST,  50, "AD_MPLL_208M_CK"),
+	FMCLK(ABIST,  51, "AD_WBG_DIG_CK_CK_416M"),
+	FMCLK(ABIST,  52, "AD_WBG_B_DIG_CK_64M"),
+	FMCLK(ABIST,  53, "AD_WBG_W_DIG_CK_160M"),
+	FMCLK(ABIST,  55, "DA_UNIV_48M_DIV_CK"),
+	FMCLK(ABIST,  57, "DA_MPLL_52M_DIV_CK"),
+	FMCLK(ABIST,  60, "ckmon1_ck"),
+	FMCLK(ABIST,  61, "ckmon2_ck"),
+	FMCLK(ABIST,  62, "ckmon3_ck"),
+	FMCLK(ABIST,  63, "ckmon4_ck"),
+	{}
+};
+
+#define CLK_MISC_CFG_0	(rb[topckgen].virt + 0x104)
+#define CLK_DBG_CFG		(rb[topckgen].virt + 0x10C)
+#define CLK26CALI_0		(rb[topckgen].virt + 0x220)
+#define CLK26CALI_1		(rb[topckgen].virt + 0x224)
+
+static unsigned int mt_get_ckgen_freq(unsigned int ID)
+{
+	int output = 0, i = 0;
+	unsigned int temp, clk_dbg_cfg, clk_misc_cfg_0;
+
+	clk_dbg_cfg = clk_readl(CLK_DBG_CFG);
+	clk_writel(CLK_DBG_CFG, (clk_dbg_cfg & 0xFFFFC0FC)|(ID << 8)|(0x1));
+
+	clk_misc_cfg_0 = clk_readl(CLK_MISC_CFG_0);
+	clk_writel(CLK_MISC_CFG_0, (clk_misc_cfg_0 & 0x00FFFFFF));
+
+	clk_writel(CLK26CALI_0, 0x1000);
+	clk_writel(CLK26CALI_0, 0x1010);
+
+	while (clk_readl(CLK26CALI_0) & 0x10) {
+		mdelay(10);
+		i++;
+		if (i > 10)
+			break;
+	}
+
+	temp = clk_readl(CLK26CALI_1) & 0xFFFF;
+
+	output = (temp * 26000) / 1024;
+
+	clk_writel(CLK_DBG_CFG, clk_dbg_cfg);
+	clk_writel(CLK_MISC_CFG_0, clk_misc_cfg_0);
+
+	if (i > 10)
+		return 0;
+	else
+		return output;
+
+}
+
+static unsigned int mt_get_abist_freq(unsigned int ID)
+{
+	int output = 0, i = 0;
+	unsigned int temp, clk_dbg_cfg, clk_misc_cfg_0;
+
+	clk_dbg_cfg = clk_readl(CLK_DBG_CFG);
+	clk_writel(CLK_DBG_CFG, (clk_dbg_cfg & 0xFFC0FFFC)|(ID << 16));
+
+	clk_misc_cfg_0 = clk_readl(CLK_MISC_CFG_0);
+	clk_writel(CLK_MISC_CFG_0, (clk_misc_cfg_0 & 0x00FFFFFF) | (1 << 24));
+
+	clk_writel(CLK26CALI_0, 0x1000);
+	clk_writel(CLK26CALI_0, 0x1010);
+
+	while (clk_readl(CLK26CALI_0) & 0x10) {
+		mdelay(10);
+		i++;
+		if (i > 10)
+			break;
+	}
+
+	temp = clk_readl(CLK26CALI_1) & 0xFFFF;
+
+	output = (temp * 26000) / 1024;
+
+	clk_writel(CLK_DBG_CFG, clk_dbg_cfg);
+	clk_writel(CLK_MISC_CFG_0, clk_misc_cfg_0);
+
+	if (i > 10)
+		return 0;
+	else
+		return (output * 2);
+}
+
+static u32 fmeter_freq_op(const struct fmeter_clk *fclk)
+{
+	if (fclk->type == ABIST)
+		return mt_get_abist_freq(fclk->id);
+	else if (fclk->type == CKGEN)
+		return mt_get_ckgen_freq(fclk->id);
+	return 0;
+}
+
+static const struct fmeter_clk *get_all_fmeter_clks(void)
+{
+	return fclks;
+}
+
+/*
+ * clkdbg dump_state
+ */
+
+static const char * const *get_all_clk_names(void)
+{
+	static const char * const clks[] = {
+		"armpll_ll",
+		"armpll_l",
+		"ccipll",
+		"mainpll",
+		"univ2pll",
+		"msdcpll",
+		"mmpll",
+		"mfgpll",
+		"tvdpll",
+		"apll1",
+		"apll2",
+		"apmixed_ssusb26m",
+		"apmixed_appll26m",
+		"apmixed_mipic026m",
+		"apmixed_mdpll26m",
+		"apmixed_mmsys26m",
+		"apmixed_ufs26m",
+		"apmixed_mipic126m",
+		"apmixed_mempll26m",
+		"apmixed_lvpll26m",
+		"apmixed_mipid026m",
+		"apmixed_mipid126m",
+		"syspll_ck",
+		"syspll_d2",
+		"syspll_d3",
+		"syspll_d5",
+		"syspll_d7",
+		"syspll_d2_d2",
+		"syspll_d2_d4",
+		"syspll_d2_d8",
+		"syspll_d2_d16",
+		"syspll_d3_d2",
+		"syspll_d3_d4",
+		"syspll_d3_d8",
+		"syspll_d5_d2",
+		"syspll_d5_d4",
+		"syspll_d7_d2",
+		"syspll_d7_d4",
+		"univpll_ck",
+		"univpll_d2",
+		"univpll_d3",
+		"univpll_d5",
+		"univpll_d7",
+		"univpll_d2_d2",
+		"univpll_d2_d4",
+		"univpll_d2_d8",
+		"univpll_d3_d2",
+		"univpll_d3_d4",
+		"univpll_d3_d8",
+		"univpll_d5_d2",
+		"univpll_d5_d4",
+		"univpll_d5_d8",
+		"apll1_ck",
+		"apll1_d2",
+		"apll1_d4",
+		"apll1_d8",
+		"apll2_ck",
+		"apll2_d2",
+		"apll2_d4",
+		"apll2_d8",
+		"tvdpll_ck",
+		"tvdpll_d2",
+		"tvdpll_d4",
+		"tvdpll_d8",
+		"tvdpll_d16",
+		"msdcpll_ck",
+		"msdcpll_d2",
+		"msdcpll_d4",
+		"msdcpll_d8",
+		"msdcpll_d16",
+		"ad_osc_ck",
+		"osc_d2",
+		"osc_d4",
+		"osc_d8",
+		"osc_d16",
+		"csw_f26m_ck_d2",
+		"mfgpll_ck",
+		"univ_192m_ck",
+		"univ_192m_d2",
+		"univ_192m_d4",
+		"univ_192m_d8",
+		"univ_192m_d16",
+		"univ_192m_d32",
+		"mmpll_ck",
+		"mmpll_d4",
+		"mmpll_d4_d2",
+		"mmpll_d4_d4",
+		"mmpll_d5",
+		"mmpll_d5_d2",
+		"mmpll_d5_d4",
+		"mmpll_d6",
+		"mmpll_d7",
+		"f_f26m_ck",
+		"clk13m",
+		"osc",
+		"univpll_192m",
+		"apll_i2s0_sel",
+		"apll_i2s1_sel",
+		"apll_i2s2_sel",
+		"apll_i2s3_sel",
+		"apll_i2s4_sel",
+		"apll_i2s5_sel",
+		"apll12_div0",
+		"apll12_div1",
+		"apll12_div2",
+		"apll12_div3",
+		"apll12_div4",
+		"apll12_divb",
+		"univpll",
+		"armpll_div_pll1",
+		"armpll_div_pll2",
+		"axi_sel",
+		"mm_sel",
+		"cam_sel",
+		"mfg_sel",
+		"camtg_sel",
+		"uart_sel",
+		"spi_sel",
+		"msdc50_hclk_sel",
+		"msdc50_0_sel",
+		"msdc30_1_sel",
+		"msdc30_2_sel",
+		"audio_sel",
+		"aud_intbus_sel",
+		"fpwrap_ulposc_sel",
+		"scp_sel",
+		"atb_sel",
+		"sspm_sel",
+		"dpi0_sel",
+		"scam_sel",
+		"aud_1_sel",
+		"aud_2_sel",
+		"disppwm_sel",
+		"ssusb_top_xhci_sel",
+		"usb_top_sel",
+		"spm_sel",
+		"i2c_sel",
+		"f52m_mfg_sel",
+		"seninf_sel",
+		"dxcc_sel",
+		"camtg2_sel",
+		"aud_eng1_sel",
+		"aud_eng2_sel",
+		"faes_ufsfde_sel",
+		"fufs_sel",
+		"img_sel",
+		"dsp_sel",
+		"dsp1_sel",
+		"dsp2_sel",
+		"ipu_if_sel",
+		"camtg3_sel",
+		"camtg4_sel",
+		"pmicspi_sel",
+		"mcu_mp0_sel",
+		"mcu_mp2_sel",
+		"mcu_bus_sel",
+		"infra_pmic_tmr",
+		"infra_pmic_ap",
+		"infra_pmic_md",
+		"infra_pmic_conn",
+		"infra_scp",
+		"infra_sej",
+		"infra_apxgpt",
+		"infra_icusb",
+		"infra_gce",
+		"infra_therm",
+		"infra_i2c0",
+		"infra_i2c1",
+		"infra_i2c2",
+		"infra_i2c3",
+		"infra_pwm_hclk",
+		"infra_pwm1",
+		"infra_pwm2",
+		"infra_pwm3",
+		"infra_pwm4",
+		"infra_pwm",
+		"infra_uart0",
+		"infra_uart1",
+		"infra_uart2",
+		"infra_uart3",
+		"infra_gce_26m",
+		"infra_cqdma_fpc",
+		"infra_btif",
+		"infra_spi0",
+		"infra_msdc0",
+		"infra_msdc1",
+		"infra_msdc2",
+		"infra_msdc0_sck",
+		"infra_dvfsrc",
+		"infra_gcpu",
+		"infra_trng",
+		"infra_auxadc",
+		"infra_cpum",
+		"infra_ccif1_ap",
+		"infra_ccif1_md",
+		"infra_auxadc_md",
+		"infra_msdc1_sck",
+		"infra_msdc2_sck",
+		"infra_apdma",
+		"infra_xiu",
+		"infra_device_apc",
+		"infra_ccif_ap",
+		"infra_debugsys",
+		"infra_audio",
+		"infra_ccif_md",
+		"infra_dxcc_sec_core",
+		"infra_dxcc_ao",
+		"infra_dramc_f26m",
+		"infra_irtx",
+		"infra_disppwm",
+		"infra_cldma_bclk",
+		"infra_audio_26m_bclk",
+		"infra_spi1",
+		"infra_i2c4",
+		"infra_md_tmp_share",
+		"infra_spi2",
+		"infra_spi3",
+		"infra_unipro_sck",
+		"infra_unipro_tick",
+		"infra_ufs_mp_sap_bck",
+		"infra_md32_bclk",
+		"infra_sspm",
+		"infra_unipro_mbist",
+		"infra_sspm_bus_hclk",
+		"infra_i2c5",
+		"infra_i2c5_arbiter",
+		"infra_i2c5_imm",
+		"infra_i2c1_arbiter",
+		"infra_i2c1_imm",
+		"infra_i2c2_arbiter",
+		"infra_i2c2_imm",
+		"infra_spi4",
+		"infra_spi5",
+		"infra_cqdma",
+		"infra_ufs",
+		"infra_aes_ufsfde",
+		"infra_ufs_tick",
+		"infra_msdc0_self",
+		"infra_msdc1_self",
+		"infra_msdc2_self",
+		"infra_sspm_26m_self",
+		"infra_sspm_32k_self",
+		"infra_ufs_axi",
+		"infra_i2c6",
+		"infra_ap_msdc0",
+		"infra_md_msdc0",
+		"infra_usb",
+		"infra_devmpu_bclk",
+		"infra_ccif2_ap",
+		"infra_ccif2_md",
+		"infra_ccif3_ap",
+		"infra_ccif3_md",
+		"infra_sej_f13m",
+		"infra_aes_bclk",
+		"infra_i2c7",
+		"infra_i2c8",
+		"infra_fbist2fpc",
+		"aud_tml",
+		"aud_dac_predis",
+		"aud_dac",
+		"aud_adc",
+		"aud_apll_tuner",
+		"aud_apll2_tuner",
+		"aud_24m",
+		"aud_22m",
+		"aud_afe",
+		"aud_i2s4",
+		"aud_i2s3",
+		"aud_i2s2",
+		"aud_i2s1",
+		"aud_pdn_adda6_adc",
+		"aud_tdm",
+		"mfg_bg3d",
+		"mm_smi_common",
+		"mm_smi_larb0",
+		"mm_smi_larb1",
+		"mm_gals_comm0",
+		"mm_gals_comm1",
+		"mm_gals_ccu2mm",
+		"mm_gals_ipu12mm",
+		"mm_gals_img2mm",
+		"mm_gals_cam2mm",
+		"mm_gals_ipu2mm",
+		"mm_mdp_dl_txck",
+		"mm_ipu_dl_txck",
+		"mm_mdp_rdma0",
+		"mm_mdp_rdma1",
+		"mm_mdp_rsz0",
+		"mm_mdp_rsz1",
+		"mm_mdp_tdshp",
+		"mm_mdp_wrot0",
+		"mm_fake_eng",
+		"mm_disp_ovl0",
+		"mm_disp_ovl0_2l",
+		"mm_disp_ovl1_2l",
+		"mm_disp_rdma0",
+		"mm_disp_rdma1",
+		"mm_disp_wdma0",
+		"mm_disp_color0",
+		"mm_disp_ccorr0",
+		"mm_disp_aal0",
+		"mm_disp_gamma0",
+		"mm_disp_dither0",
+		"mm_disp_split",
+		"mm_dsi0_mm",
+		"mm_dsi0_if",
+		"mm_dpi_mm",
+		"mm_dpi_if",
+		"mm_fake_eng2",
+		"mm_mdp_dl_rx",
+		"mm_ipu_dl_rx",
+		"mm_26m",
+		"mm_mmsys_r2y",
+		"mm_disp_rsz",
+		"mm_mdp_wdma0",
+		"mm_mdp_aal",
+		"mm_mdp_ccorr",
+		"mm_dbi_mm",
+		"mm_dbi_if",
+		"vdec_vdec",
+		"vdec_larb1",
+		"venc_larb",
+		"venc_venc",
+		"venc_jpgenc",
+		"img_owe",
+		"img_wpe_b",
+		"img_wpe_a",
+		"img_mfb",
+		"img_rsc",
+		"img_dpe",
+		"img_fdvt",
+		"img_dip",
+		"img_larb2",
+		"img_larb5",
+		"cam_larb6",
+		"cam_dfp_vad",
+		"cam_cam",
+		"cam_camtg",
+		"cam_seninf",
+		"cam_camsv0",
+		"cam_camsv1",
+		"cam_camsv2",
+		"cam_ccu",
+		"cam_larb3",
+		"ipu_conn_ipu",
+		"ipu_conn_ahb",
+		"ipu_conn_axi",
+		"ipu_conn_isp",
+		"ipu_conn_cam_adl",
+		"ipu_conn_img_adl",
+		"ipu_conn_dap_rx",
+		"ipu_conn_apb2axi",
+		"ipu_conn_apb2ahb",
+		"ipu_conn_ipu_cab1to2",
+		"ipu_conn_ipu1_cab1to2",
+		"ipu_conn_ipu2_cab1to2",
+		"ipu_conn_cab3to3",
+		"ipu_conn_cab2to1",
+		"ipu_conn_cab3to1_slice",
+		"ipu_adl_cabgen",
+		"ipu_core0_jtag",
+		"ipu_core0_axi",
+		"ipu_core0_ipu",
+		"ipu_core1_jtag",
+		"ipu_core1_axi",
+		"ipu_core1_ipu",
+		/* end */
+		NULL
+	};
+
+	return clks;
+}
+
+/*
+ * clkdbg pwr_status
+ */
+
+static const char * const *get_pwr_names(void)
+{
+	static const char * const pwr_names[] = {
+		[0]  = "MD1",
+		[1]  = "CONN",
+		[2]  = "DDRPHY",
+		[3]  = "DISP",
+		[4]  = "MFG",
+		[5]  = "ISP",
+		[6]  = "INFRA",
+		[7]  = "MFG_CORE0",
+		[8]  = "MP0_CPUTOP",
+		[9]  = "MP0_CPU0",
+		[10] = "MP0_CPU1",
+		[11] = "MP0_CPU2",
+		[12] = "MP0_CPU3",
+		[13] = "",
+		[14] = "",
+		[15] = "",
+		[16] = "",
+		[17] = "",
+		[18] = "",
+		[19] = "",
+		[20] = "MFG_CORE1",
+		[21] = "VENC",
+		[22] = "MFG_2D",
+		[23] = "MFG_ASYNC",
+		[24] = "AUDIO",
+		[25] = "CAM",
+		[26] = "VPU_TOP",
+		[27] = "VPU_CORE0",
+		[28] = "VPU_CORE1",
+		[29] = "VPU_CORE2",
+		[30] = "",
+		[31] = "VDEC",
+	};
+
+	return pwr_names;
+}
+
+u32 get_spm_pwr_status(void)
+{
+	static void __iomem *scpsys_base, *pwr_sta, *pwr_sta_2nd;
+
+	if (scpsys_base == NULL || pwr_sta == NULL || pwr_sta_2nd == NULL) {
+		scpsys_base = ioremap(0x10006000, PAGE_SIZE);
+		pwr_sta = scpsys_base + 0x180;
+		pwr_sta_2nd = scpsys_base + 0x184;
+	}
+
+	return clk_readl(pwr_sta) & clk_readl(pwr_sta_2nd);
+}
+
+/*
+ * clkdbg dump_clks
+ */
+
+static void setup_provider_clk(struct provider_clk *pvdck)
+{
+	static const struct {
+		const char *pvdname;
+		u32 pwr_mask;
+	} pvd_pwr_mask[] = {
+		{"mmsys", BIT(3)},
+		{"imgsys", BIT(5)},
+		{"camsys", BIT(25)},
+		{"ipu_conn", BIT(26)},
+		{"ipu_core0", BIT(27)},
+		{"ipu_core1", BIT(28)},
+		{"audiosys", BIT(24)},
+		{"mfgcfg", BIT(22)},
+	};
+
+	size_t i;
+	const char *pvdname = pvdck->provider_name;
+
+	if (pvdname == NULL)
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(pvd_pwr_mask); i++) {
+		if (strcmp(pvdname, pvd_pwr_mask[i].pvdname) == 0) {
+			pvdck->pwr_mask = pvd_pwr_mask[i].pwr_mask;
+			return;
+		}
+	}
+}
+
+/*
+ * init functions
+ */
+
+static struct clkdbg_ops clkdbg_mt8183_ops = {
+	.get_all_fmeter_clks = get_all_fmeter_clks,
+	.fmeter_freq = fmeter_freq_op,
+	.get_all_regnames = get_all_regnames,
+	.get_all_clk_names = get_all_clk_names,
+	.get_pwr_names = get_pwr_names,
+	.setup_provider_clk = setup_provider_clk,
+	.get_spm_pwr_status = get_spm_pwr_status,
+};
+
+static void __init init_custom_cmds(void)
+{
+	static const struct cmd_fn cmds[] = {
+		{}
+	};
+
+	set_custom_cmds(cmds);
+}
+
+static int __init clkdbg_mt8183_init(void)
+{
+	if (of_machine_is_compatible("mediatek,mt8183") == 0)
+		return -ENODEV;
+
+	init_regbase();
+
+	init_custom_cmds();
+	set_clkdbg_ops(&clkdbg_mt8183_ops);
+
+#if DUMP_INIT_STATE
+	print_regs();
+	print_fmeter_all();
+#endif /* DUMP_INIT_STATE */
+
+	return 0;
+}
+device_initcall(clkdbg_mt8183_init);
diff --git a/drivers/clk/mediatek/clkdbg.c b/drivers/clk/mediatek/clkdbg.c
new file mode 100644
index 000000000000..8c9f67968160
--- /dev/null
+++ b/drivers/clk/mediatek/clkdbg.c
@@ -0,0 +1,2242 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2018 MediaTek Inc.
+// Author: Weiyi Lu <weiyi.lu@mediatek.com>
+
+#define pr_fmt(fmt) "[clkdbg] " fmt
+
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/pm_domain.h>
+#include <linux/pm_runtime.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include "clkdbg.h"
+
+#if defined(CONFIG_PM_DEBUG)
+#define CLKDBG_PM_DOMAIN	1
+#else
+#define CLKDBG_PM_DOMAIN	0
+#endif
+#define CLKDBG_PM_DOMAIN_API_4_9	1
+#define CLKDBG_CCF_API_4_4	1
+#define CLKDBG_HACK_CLK		0
+#define CLKDBG_HACK_CLK_CORE	1
+#define CLKDBG_DROP_GENPD_AS_IN_PARAM	1
+
+#if !CLKDBG_CCF_API_4_4
+
+/* backward compatible */
+
+static const char *clk_hw_get_name(const struct clk_hw *hw)
+{
+	return __clk_get_name(hw->clk);
+}
+
+static bool clk_hw_is_prepared(const struct clk_hw *hw)
+{
+	return __clk_is_prepared(hw->clk);
+}
+
+static bool clk_hw_is_enabled(const struct clk_hw *hw)
+{
+	return __clk_is_enabled(hw->clk);
+}
+
+static unsigned long clk_hw_get_rate(const struct clk_hw *hw)
+{
+	return __clk_get_rate(hw->clk);
+}
+
+static unsigned int clk_hw_get_num_parents(const struct clk_hw *hw)
+{
+	return __clk_get_num_parents(hw->clk);
+}
+
+static struct clk_hw *clk_hw_get_parent_by_index(const struct clk_hw *hw,
+					  unsigned int index)
+{
+	return __clk_get_hw(clk_get_parent_by_index(hw->clk, index));
+}
+
+#endif /* !CLKDBG_CCF_API_4_4 */
+
+#if CLKDBG_HACK_CLK
+
+#include <linux/clk-private.h>
+
+static bool clk_hw_is_on(struct clk_hw *hw)
+{
+	const struct clk_ops *ops = hw->clk->ops;
+
+	if (ops->is_enabled)
+		return clk_hw_is_enabled(hw);
+	else if (ops->is_prepared)
+		return clk_hw_is_prepared(hw);
+	return clk_hw_is_enabled(hw) || clk_hw_is_prepared(hw);
+}
+
+#elif CLKDBG_HACK_CLK_CORE
+
+struct clk_core {
+	const char		*name;
+	const struct clk_ops	*ops;
+	struct clk_hw		*hw;
+};
+
+static bool clk_hw_is_on(struct clk_hw *hw)
+{
+	const struct clk_ops *ops = hw->core->ops;
+
+	if (ops->is_enabled)
+		return clk_hw_is_enabled(hw);
+	else if (ops->is_prepared)
+		return clk_hw_is_prepared(hw);
+	return clk_hw_is_enabled(hw) || clk_hw_is_prepared(hw);
+}
+
+#else
+
+static bool clk_hw_is_on(struct clk_hw *hw)
+{
+	return __clk_get_enable_count(hw->clk) || clk_hw_is_prepared(hw);
+}
+
+#endif /* !CLKDBG_HACK_CLK && !CLKDBG_HACK_CLK_CORE */
+
+static const struct clkdbg_ops *clkdbg_ops;
+
+void set_clkdbg_ops(const struct clkdbg_ops *ops)
+{
+	clkdbg_ops = ops;
+}
+
+static const struct fmeter_clk *get_all_fmeter_clks(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->get_all_fmeter_clks  == NULL)
+		return NULL;
+
+	return clkdbg_ops->get_all_fmeter_clks();
+}
+
+static void *prepare_fmeter(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->prepare_fmeter == NULL)
+		return NULL;
+
+	return clkdbg_ops->prepare_fmeter();
+}
+
+static void unprepare_fmeter(void *data)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->unprepare_fmeter == NULL)
+		return;
+
+	clkdbg_ops->unprepare_fmeter(data);
+}
+
+static u32 fmeter_freq(const struct fmeter_clk *fclk)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->fmeter_freq == NULL)
+		return 0;
+
+	return clkdbg_ops->fmeter_freq(fclk);
+}
+
+static const struct regname *get_all_regnames(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->get_all_regnames == NULL)
+		return NULL;
+
+	return clkdbg_ops->get_all_regnames();
+}
+
+static const char * const *get_all_clk_names(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->get_all_clk_names == NULL)
+		return NULL;
+
+	return clkdbg_ops->get_all_clk_names();
+}
+
+static const char * const *get_pwr_names(void)
+{
+	static const char * const default_pwr_names[] = {
+		[0]  = "(MD)",
+		[1]  = "(CONN)",
+		[2]  = "(DDRPHY)",
+		[3]  = "(DISP)",
+		[4]  = "(MFG)",
+		[5]  = "(ISP)",
+		[6]  = "(INFRA)",
+		[7]  = "(VDEC)",
+		[8]  = "(CPU, CA7_CPUTOP)",
+		[9]  = "(FC3, CA7_CPU0, CPUTOP)",
+		[10] = "(FC2, CA7_CPU1, CPU3)",
+		[11] = "(FC1, CA7_CPU2, CPU2)",
+		[12] = "(FC0, CA7_CPU3, CPU1)",
+		[13] = "(MCUSYS, CA7_DBG, CPU0)",
+		[14] = "(MCUSYS, VEN, BDP)",
+		[15] = "(CA15_CPUTOP, ETH, MCUSYS)",
+		[16] = "(CA15_CPU0, HIF)",
+		[17] = "(CA15_CPU1, CA15-CX0, INFRA_MISC)",
+		[18] = "(CA15_CPU2, CA15-CX1)",
+		[19] = "(CA15_CPU3, CA15-CPU0)",
+		[20] = "(VEN2, MJC, CA15-CPU1)",
+		[21] = "(VEN, CA15-CPUTOP)",
+		[22] = "(MFG_2D)",
+		[23] = "(MFG_ASYNC, DBG)",
+		[24] = "(AUDIO, MFG_2D)",
+		[25] = "(USB, VCORE_PDN, MFG_ASYNC)",
+		[26] = "(ARMPLL_DIV, CPUTOP_SRM_SLPB)",
+		[27] = "(MD2, CPUTOP_SRM_PDN)",
+		[28] = "(CPU3_SRM_PDN)",
+		[29] = "(CPU2_SRM_PDN)",
+		[30] = "(CPU1_SRM_PDN)",
+		[31] = "(CPU0_SRM_PDN)",
+	};
+
+	if (clkdbg_ops == NULL || clkdbg_ops->get_pwr_names == NULL)
+		return default_pwr_names;
+
+	return clkdbg_ops->get_pwr_names();
+}
+
+static void setup_provider_clk(struct provider_clk *pvdck)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->setup_provider_clk == NULL)
+		return;
+
+	clkdbg_ops->setup_provider_clk(pvdck);
+}
+
+static bool is_valid_reg(void __iomem *addr)
+{
+#ifdef CONFIG_64BIT
+	return ((u64)addr & 0xf0000000) != 0UL ||
+			(((u64)addr >> 32U) & 0xf0000000) != 0UL;
+#else
+	return ((u32)addr & 0xf0000000) != 0U;
+#endif
+}
+
+enum clkdbg_opt {
+	CLKDBG_EN_SUSPEND_SAVE_1,
+	CLKDBG_EN_SUSPEND_SAVE_2,
+	CLKDBG_EN_SUSPEND_SAVE_3,
+	CLKDBG_EN_LOG_SAVE_POINTS,
+};
+
+static u32 clkdbg_flags;
+
+static void set_clkdbg_flag(enum clkdbg_opt opt)
+{
+	clkdbg_flags |= BIT(opt);
+}
+
+static void clr_clkdbg_flag(enum clkdbg_opt opt)
+{
+	clkdbg_flags &= ~BIT(opt);
+}
+
+static bool has_clkdbg_flag(enum clkdbg_opt opt)
+{
+	return (clkdbg_flags & BIT(opt)) != 0U;
+}
+
+typedef void (*fn_fclk_freq_proc)(const struct fmeter_clk *fclk,
+					u32 freq, void *data);
+
+static void proc_all_fclk_freq(fn_fclk_freq_proc proc, void *data)
+{
+	void *fmeter_data;
+	const struct fmeter_clk *fclk;
+
+	fclk = get_all_fmeter_clks();
+
+	if (fclk == NULL || proc == NULL)
+		return;
+
+	fmeter_data = prepare_fmeter();
+
+	for (; fclk->type != FT_NULL; fclk++) {
+		u32 freq;
+
+		freq = fmeter_freq(fclk);
+		proc(fclk, freq, data);
+	}
+
+	unprepare_fmeter(fmeter_data);
+}
+
+static void print_fclk_freq(const struct fmeter_clk *fclk, u32 freq, void *data)
+{
+	pr_info("%2d: %-29s: %u\n", fclk->id, fclk->name, freq);
+}
+
+void print_fmeter_all(void)
+{
+	proc_all_fclk_freq(print_fclk_freq, NULL);
+}
+
+static void seq_print_fclk_freq(const struct fmeter_clk *fclk,
+				u32 freq, void *data)
+{
+	struct seq_file *s = data;
+
+	seq_printf(s, "%2d: %-29s: %u\n", fclk->id, fclk->name, freq);
+}
+
+static int seq_print_fmeter_all(struct seq_file *s, void *v)
+{
+	proc_all_fclk_freq(seq_print_fclk_freq, s);
+
+	return 0;
+}
+
+typedef void (*fn_regname_proc)(const struct regname *rn, void *data);
+
+static void proc_all_regname(fn_regname_proc proc, void *data)
+{
+	const struct regname *rn = get_all_regnames();
+
+	if (rn == NULL)
+		return;
+
+	for (; rn->base != NULL; rn++)
+		proc(rn, data);
+}
+
+static void print_reg(const struct regname *rn, void *data)
+{
+	if (!is_valid_reg(ADDR(rn)))
+		return;
+
+	pr_info("%-21s: [0x%08x][0x%p] = 0x%08x\n",
+			rn->name, PHYSADDR(rn), ADDR(rn), clk_readl(ADDR(rn)));
+}
+
+void print_regs(void)
+{
+	proc_all_regname(print_reg, NULL);
+}
+
+static void seq_print_reg(const struct regname *rn, void *data)
+{
+	struct seq_file *s = data;
+
+	if (!is_valid_reg(ADDR(rn)))
+		return;
+
+	seq_printf(s, "%-21s: [0x%08x][0x%p] = 0x%08x\n",
+		rn->name, PHYSADDR(rn), ADDR(rn), clk_readl(ADDR(rn)));
+}
+
+static int seq_print_regs(struct seq_file *s, void *v)
+{
+	proc_all_regname(seq_print_reg, s);
+
+	return 0;
+}
+
+static void print_reg2(const struct regname *rn, void *data)
+{
+	if (!is_valid_reg(ADDR(rn)))
+		return;
+
+	pr_info("%-21s: [0x%08x][0x%p] = 0x%08x\n",
+		rn->name, PHYSADDR(rn), ADDR(rn), clk_readl(ADDR(rn)));
+
+	msleep(20);
+}
+
+static int clkdbg_dump_regs2(struct seq_file *s, void *v)
+{
+	proc_all_regname(print_reg2, s);
+
+	return 0;
+}
+
+static u32 read_spm_pwr_status(void)
+{
+	static void __iomem *scpsys_base, *pwr_sta, *pwr_sta_2nd;
+
+	if (clkdbg_ops == NULL || clkdbg_ops->get_spm_pwr_status  == NULL) {
+		if (scpsys_base == NULL ||
+		    pwr_sta == NULL || pwr_sta_2nd == NULL) {
+			scpsys_base = ioremap(0x10006000, PAGE_SIZE);
+			pwr_sta = scpsys_base + 0x60c;
+			pwr_sta_2nd = scpsys_base + 0x610;
+		}
+
+		return clk_readl(pwr_sta) & clk_readl(pwr_sta_2nd);
+	} else
+		return clkdbg_ops->get_spm_pwr_status();
+}
+
+static bool clk_hw_pwr_is_on(struct clk_hw *c_hw,
+			u32 spm_pwr_status, u32 pwr_mask)
+{
+	if ((spm_pwr_status & pwr_mask) != pwr_mask)
+		return false;
+
+	return clk_hw_is_on(c_hw);
+}
+
+static bool pvdck_pwr_is_on(struct provider_clk *pvdck, u32 spm_pwr_status)
+{
+	struct clk *c = pvdck->ck;
+	struct clk_hw *c_hw = __clk_get_hw(c);
+
+	return clk_hw_pwr_is_on(c_hw, spm_pwr_status, pvdck->pwr_mask);
+}
+
+static bool pvdck_is_on(struct provider_clk *pvdck)
+{
+	u32 spm_pwr_status = 0;
+
+	if (pvdck->pwr_mask != 0U)
+		spm_pwr_status = read_spm_pwr_status();
+
+	return pvdck_pwr_is_on(pvdck, spm_pwr_status);
+}
+
+static const char *ccf_state(struct clk_hw *hw)
+{
+	if (__clk_get_enable_count(hw->clk))
+		return "enabled";
+
+	if (clk_hw_is_prepared(hw))
+		return "prepared";
+
+	return "disabled";
+}
+
+static void dump_clk_state(const char *clkname, struct seq_file *s)
+{
+	struct clk *c = __clk_lookup(clkname);
+	struct clk *p = IS_ERR_OR_NULL(c) ? NULL : clk_get_parent(c);
+	struct clk_hw *c_hw = __clk_get_hw(c);
+	struct clk_hw *p_hw = __clk_get_hw(p);
+
+	if (IS_ERR_OR_NULL(c)) {
+		seq_printf(s, "[%17s: NULL]\n", clkname);
+		return;
+	}
+
+	seq_printf(s, "[%-17s: %8s, %3d, %3d, %10ld, %17s]\n",
+		clk_hw_get_name(c_hw),
+		ccf_state(c_hw),
+		clk_hw_is_prepared(c_hw),
+		__clk_get_enable_count(c),
+		clk_hw_get_rate(c_hw),
+		p != NULL ? clk_hw_get_name(p_hw) : "- ");
+}
+
+static int clkdbg_dump_state_all(struct seq_file *s, void *v)
+{
+	const char * const *ckn = get_all_clk_names();
+
+	if (ckn == NULL)
+		return 0;
+
+	for (; *ckn != NULL; ckn++)
+		dump_clk_state(*ckn, s);
+
+	return 0;
+}
+
+static const char *get_provider_name(struct device_node *node, u32 *cells)
+{
+	const char *name;
+	const char *p;
+	u32 cc;
+
+	if (of_property_read_u32(node, "#clock-cells", &cc) != 0)
+		cc = 0;
+
+	if (cells != NULL)
+		*cells = cc;
+
+	if (cc == 0U) {
+		if (of_property_read_string(node,
+				"clock-output-names", &name) < 0)
+			name = node->name;
+
+		return name;
+	}
+
+	if (of_property_read_string(node, "compatible", &name) < 0)
+		name = node->name;
+
+	p = strchr(name, (int)'-');
+
+	if (p != NULL)
+		return p + 1;
+	else
+		return name;
+}
+
+struct provider_clk *get_all_provider_clks(void)
+{
+	static struct provider_clk provider_clks[512];
+	struct device_node *node = NULL;
+	int n = 0;
+
+	if (provider_clks[0].ck != NULL)
+		return provider_clks;
+
+	do {
+		const char *node_name;
+		u32 cells;
+
+		node = of_find_node_with_property(node, "#clock-cells");
+
+		if (node == NULL)
+			break;
+
+		node_name = get_provider_name(node, &cells);
+
+		if (cells == 0U) {
+			struct clk *ck = __clk_lookup(node_name);
+
+			if (IS_ERR_OR_NULL(ck))
+				continue;
+
+			provider_clks[n].ck = ck;
+			setup_provider_clk(&provider_clks[n]);
+			++n;
+		} else {
+			unsigned int i;
+
+			for (i = 0; i < 256; i++) {
+				struct of_phandle_args pa;
+				struct clk *ck;
+
+				pa.np = node;
+				pa.args[0] = i;
+				pa.args_count = 1;
+				ck = of_clk_get_from_provider(&pa);
+
+				if (PTR_ERR(ck) == -EINVAL)
+					break;
+				else if (IS_ERR_OR_NULL(ck))
+					continue;
+
+				provider_clks[n].ck = ck;
+				provider_clks[n].idx = i;
+				provider_clks[n].provider_name = node_name;
+				setup_provider_clk(&provider_clks[n]);
+				++n;
+			}
+		}
+	} while (node != NULL);
+
+	return provider_clks;
+}
+
+static void dump_provider_clk(struct provider_clk *pvdck, struct seq_file *s)
+{
+	struct clk *c = pvdck->ck;
+	struct clk *p = IS_ERR_OR_NULL(c) ? NULL : clk_get_parent(c);
+	struct clk_hw *c_hw = __clk_get_hw(c);
+	struct clk_hw *p_hw = __clk_get_hw(p);
+
+	seq_printf(s, "[%10s: %-17s: %3s, %3d, %3d, %10ld, %17s]\n",
+		pvdck->provider_name != NULL ? pvdck->provider_name : "/ ",
+		clk_hw_get_name(c_hw),
+		pvdck_is_on(pvdck) ? "ON" : "off",
+		clk_hw_is_prepared(c_hw),
+		__clk_get_enable_count(c),
+		clk_hw_get_rate(c_hw),
+		p != NULL ? clk_hw_get_name(p_hw) : "- ");
+}
+
+static int clkdbg_dump_provider_clks(struct seq_file *s, void *v)
+{
+	struct provider_clk *pvdck = get_all_provider_clks();
+
+	for (; pvdck->ck != NULL; pvdck++)
+		dump_provider_clk(pvdck, s);
+
+	return 0;
+}
+
+static void dump_provider_mux(struct provider_clk *pvdck, struct seq_file *s)
+{
+	unsigned int i;
+	struct clk *c = pvdck->ck;
+	struct clk_hw *c_hw = __clk_get_hw(c);
+	unsigned int np = clk_hw_get_num_parents(c_hw);
+
+	if (np <= 1U)
+		return;
+
+	dump_provider_clk(pvdck, s);
+
+	for (i = 0; i < np; i++) {
+		struct clk_hw *p_hw = clk_hw_get_parent_by_index(c_hw, i);
+
+		if (IS_ERR_OR_NULL(p_hw))
+			continue;
+
+		seq_printf(s, "\t\t\t(%2d: %-17s: %8s, %10ld)\n",
+			i,
+			clk_hw_get_name(p_hw),
+			ccf_state(p_hw),
+			clk_hw_get_rate(p_hw));
+	}
+}
+
+static int clkdbg_dump_muxes(struct seq_file *s, void *v)
+{
+	struct provider_clk *pvdck = get_all_provider_clks();
+
+	for (; pvdck->ck != NULL; pvdck++)
+		dump_provider_mux(pvdck, s);
+
+	return 0;
+}
+
+static void show_pwr_status(u32 spm_pwr_status)
+{
+	unsigned int i;
+	const char * const *pwr_name = get_pwr_names();
+
+	pr_info("SPM_PWR_STATUS: 0x%08x\n\n", spm_pwr_status);
+
+	for (i = 0; i < 32; i++) {
+		const char *st = (spm_pwr_status & BIT(i)) != 0U ? "ON" : "off";
+
+		pr_info("[%2d]: %3s: %s\n", i, st, pwr_name[i]);
+		mdelay(20);
+	}
+}
+
+static int dump_pwr_status(u32 spm_pwr_status, struct seq_file *s)
+{
+	unsigned int i;
+	const char * const *pwr_name = get_pwr_names();
+
+	seq_printf(s, "SPM_PWR_STATUS: 0x%08x\n\n", spm_pwr_status);
+
+	for (i = 0; i < 32; i++) {
+		const char *st = (spm_pwr_status & BIT(i)) != 0U ? "ON" : "off";
+
+		seq_printf(s, "[%2d]: %3s: %s\n", i, st, pwr_name[i]);
+	}
+
+	return 0;
+}
+
+static int clkdbg_pwr_status(struct seq_file *s, void *v)
+{
+	return dump_pwr_status(read_spm_pwr_status(), s);
+}
+
+static char last_cmd[128] = "null";
+
+const char *get_last_cmd(void)
+{
+	return last_cmd;
+}
+
+static int clkop_int_ckname(int (*clkop)(struct clk *clk),
+			const char *clkop_name, const char *clk_name,
+			struct clk *ck, struct seq_file *s)
+{
+	struct clk *clk;
+
+	if (!IS_ERR_OR_NULL(ck)) {
+		clk = ck;
+	} else {
+		clk = __clk_lookup(clk_name);
+		if (IS_ERR_OR_NULL(clk)) {
+			seq_printf(s, "clk_lookup(%s): 0x%p\n", clk_name, clk);
+			return PTR_ERR(clk);
+		}
+	}
+
+	return clkop(clk);
+}
+
+static int clkdbg_clkop_int_ckname(int (*clkop)(struct clk *clk),
+			const char *clkop_name, struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *clk_name;
+	int r = 0;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	clk_name = strsep(&c, " ");
+
+	if (clk_name == NULL)
+		return 0;
+
+	if (strcmp(clk_name, "all") == 0) {
+		struct provider_clk *pvdck = get_all_provider_clks();
+
+		for (; pvdck->ck != NULL; pvdck++) {
+			r |= clkop_int_ckname(clkop, clkop_name, NULL,
+						pvdck->ck, s);
+		}
+
+		seq_printf(s, "%s(%s): %d\n", clkop_name, clk_name, r);
+
+		return r;
+	}
+
+	r = clkop_int_ckname(clkop, clkop_name, clk_name, NULL, s);
+	seq_printf(s, "%s(%s): %d\n", clkop_name, clk_name, r);
+
+	return r;
+}
+
+static void clkop_void_ckname(void (*clkop)(struct clk *clk),
+			const char *clkop_name, const char *clk_name,
+			struct clk *ck, struct seq_file *s)
+{
+	struct clk *clk;
+
+	if (!IS_ERR_OR_NULL(ck)) {
+		clk = ck;
+	} else {
+		clk = __clk_lookup(clk_name);
+		if (IS_ERR_OR_NULL(clk)) {
+			seq_printf(s, "clk_lookup(%s): 0x%p\n", clk_name, clk);
+			return;
+		}
+	}
+
+	clkop(clk);
+}
+
+static int clkdbg_clkop_void_ckname(void (*clkop)(struct clk *clk),
+			const char *clkop_name, struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *clk_name;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	clk_name = strsep(&c, " ");
+
+	if (clk_name == NULL)
+		return 0;
+
+	if (strcmp(clk_name, "all") == 0) {
+		struct provider_clk *pvdck = get_all_provider_clks();
+
+		for (; pvdck->ck != NULL; pvdck++) {
+			clkop_void_ckname(clkop, clkop_name, NULL,
+						pvdck->ck, s);
+		}
+
+		seq_printf(s, "%s(%s)\n", clkop_name, clk_name);
+
+		return 0;
+	}
+
+	clkop_void_ckname(clkop, clkop_name, clk_name, NULL, s);
+	seq_printf(s, "%s(%s)\n", clkop_name, clk_name);
+
+	return 0;
+}
+
+static int clkdbg_prepare(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_int_ckname(clk_prepare,
+					"clk_prepare", s, v);
+}
+
+static int clkdbg_unprepare(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_void_ckname(clk_unprepare,
+					"clk_unprepare", s, v);
+}
+
+static int clkdbg_enable(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_int_ckname(clk_enable,
+					"clk_enable", s, v);
+}
+
+static int clkdbg_disable(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_void_ckname(clk_disable,
+					"clk_disable", s, v);
+}
+
+static int clkdbg_prepare_enable(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_int_ckname(clk_prepare_enable,
+					"clk_prepare_enable", s, v);
+}
+
+static int clkdbg_disable_unprepare(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_void_ckname(clk_disable_unprepare,
+					"clk_disable_unprepare", s, v);
+}
+
+void prepare_enable_provider(const char *pvd)
+{
+	bool allpvd = (pvd == NULL || strcmp(pvd, "all") == 0);
+	struct provider_clk *pvdck = get_all_provider_clks();
+
+	for (; pvdck->ck != NULL; pvdck++) {
+		if (allpvd || (pvdck->provider_name != NULL &&
+				strcmp(pvd, pvdck->provider_name) == 0)) {
+			int r = clk_prepare_enable(pvdck->ck);
+
+			if (r != 0)
+				pr_info("clk_prepare_enable(): %d\n", r);
+		}
+	}
+}
+
+void disable_unprepare_provider(const char *pvd)
+{
+	bool allpvd = (pvd == NULL || strcmp(pvd, "all") == 0);
+	struct provider_clk *pvdck = get_all_provider_clks();
+
+	for (; pvdck->ck != NULL; pvdck++) {
+		if (allpvd || (pvdck->provider_name != NULL &&
+				strcmp(pvd, pvdck->provider_name) == 0))
+			clk_disable_unprepare(pvdck->ck);
+	}
+}
+
+static void clkpvdop(void (*pvdop)(const char *), const char *clkpvdop_name,
+			struct seq_file *s)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *pvd_name;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	pvd_name = strsep(&c, " ");
+
+	if (pvd_name == NULL)
+		return;
+
+	pvdop(pvd_name);
+	seq_printf(s, "%s(%s)\n", clkpvdop_name, pvd_name);
+}
+
+static int clkdbg_prepare_enable_provider(struct seq_file *s, void *v)
+{
+	clkpvdop(prepare_enable_provider, "prepare_enable_provider", s);
+	return 0;
+}
+
+static int clkdbg_disable_unprepare_provider(struct seq_file *s, void *v)
+{
+	clkpvdop(disable_unprepare_provider, "disable_unprepare_provider", s);
+	return 0;
+}
+
+static int clkdbg_set_parent(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *clk_name;
+	char *parent_name;
+	struct clk *clk;
+	struct clk *parent;
+	int r;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	clk_name = strsep(&c, " ");
+	parent_name = strsep(&c, " ");
+
+	if (clk_name == NULL || parent_name == NULL)
+		return 0;
+
+	seq_printf(s, "clk_set_parent(%s, %s): ", clk_name, parent_name);
+
+	clk = __clk_lookup(clk_name);
+	if (IS_ERR_OR_NULL(clk)) {
+		seq_printf(s, "__clk_lookup(): 0x%p\n", clk);
+		return PTR_ERR(clk);
+	}
+
+	parent = __clk_lookup(parent_name);
+	if (IS_ERR_OR_NULL(parent)) {
+		seq_printf(s, "__clk_lookup(): 0x%p\n", parent);
+		return PTR_ERR(parent);
+	}
+
+	r = clk_prepare_enable(clk);
+	if (r != 0) {
+		seq_printf(s, "clk_prepare_enable(): %d\n", r);
+		return r;
+	}
+
+	r = clk_set_parent(clk, parent);
+	seq_printf(s, "%d\n", r);
+
+	clk_disable_unprepare(clk);
+
+	return r;
+}
+
+static int clkdbg_set_rate(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *clk_name;
+	char *rate_str;
+	struct clk *clk;
+	unsigned long rate;
+	int r;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	clk_name = strsep(&c, " ");
+	rate_str = strsep(&c, " ");
+
+	if (clk_name == NULL || rate_str == NULL)
+		return 0;
+
+	r = kstrtoul(rate_str, 0, &rate);
+
+	seq_printf(s, "clk_set_rate(%s, %lu): %d: ", clk_name, rate, r);
+
+	clk = __clk_lookup(clk_name);
+	if (IS_ERR_OR_NULL(clk)) {
+		seq_printf(s, "__clk_lookup(): 0x%p\n", clk);
+		return PTR_ERR(clk);
+	}
+
+	r = clk_set_rate(clk, rate);
+	seq_printf(s, "%d\n", r);
+
+	return r;
+}
+
+static void *reg_from_str(const char *str)
+{
+	static phys_addr_t phys;
+	static void __iomem *virt;
+
+	if (sizeof(void *) == sizeof(unsigned long)) {
+		unsigned long v;
+
+		if (kstrtoul(str, 0, &v) == 0U) {
+			if ((0xf0000000 & v) < 0x20000000) {
+				if (virt != NULL && v > phys
+						&& v < phys + PAGE_SIZE)
+					return virt + v - phys;
+
+				if (virt != NULL)
+					iounmap(virt);
+
+				phys = v & ~(PAGE_SIZE - 1U);
+				virt = ioremap(phys, PAGE_SIZE);
+
+				return virt + v - phys;
+			}
+
+			return (void *)((uintptr_t)v);
+		}
+	} else if (sizeof(void *) == sizeof(unsigned long long)) {
+		unsigned long long v;
+
+		if (kstrtoull(str, 0, &v) == 0) {
+			if ((0xfffffffff0000000ULL & v) < 0x20000000) {
+				if (virt && v > phys && v < phys + PAGE_SIZE)
+					return virt + v - phys;
+
+				if (virt != NULL)
+					iounmap(virt);
+
+				phys = v & ~(PAGE_SIZE - 1);
+				virt = ioremap(phys, PAGE_SIZE);
+
+				return virt + v - phys;
+			}
+
+			return (void *)((uintptr_t)v);
+		}
+	} else {
+		pr_warn("unexpected pointer size: sizeof(void *): %zu\n",
+			sizeof(void *));
+	}
+
+	pr_warn("%s(): parsing error: %s\n", __func__, str);
+
+	return NULL;
+}
+
+static int parse_reg_val_from_cmd(void __iomem **preg, unsigned long *pval)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *reg_str;
+	char *val_str;
+	int r = 0;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	reg_str = strsep(&c, " ");
+	val_str = strsep(&c, " ");
+
+	if (preg != NULL && reg_str != NULL) {
+		*preg = reg_from_str(reg_str);
+		if (*preg != NULL)
+			r++;
+	}
+
+	if (pval != NULL && val_str != NULL && kstrtoul(val_str, 0, pval) == 0)
+		r++;
+
+	return r;
+}
+
+static int clkdbg_reg_read(struct seq_file *s, void *v)
+{
+	void __iomem *reg;
+	unsigned long val;
+
+	if (parse_reg_val_from_cmd(&reg, NULL) != 1)
+		return 0;
+
+	seq_printf(s, "readl(0x%p): ", reg);
+
+	val = clk_readl(reg);
+	seq_printf(s, "0x%08x\n", (u32)val);
+
+	return 0;
+}
+
+static int clkdbg_reg_write(struct seq_file *s, void *v)
+{
+	void __iomem *reg;
+	unsigned long val;
+
+	if (parse_reg_val_from_cmd(&reg, &val) != 2)
+		return 0;
+
+	seq_printf(s, "writel(0x%p, 0x%08x): ", reg, (u32)val);
+
+	clk_writel(reg, val);
+	val = clk_readl(reg);
+	seq_printf(s, "0x%08x\n", (u32)val);
+
+	return 0;
+}
+
+static int clkdbg_reg_set(struct seq_file *s, void *v)
+{
+	void __iomem *reg;
+	unsigned long val;
+
+	if (parse_reg_val_from_cmd(&reg, &val) != 2)
+		return 0;
+
+	seq_printf(s, "writel(0x%p, 0x%08x): ", reg, (u32)val);
+
+	clk_setl(reg, val);
+	val = clk_readl(reg);
+	seq_printf(s, "0x%08x\n", (u32)val);
+
+	return 0;
+}
+
+static int clkdbg_reg_clr(struct seq_file *s, void *v)
+{
+	void __iomem *reg;
+	unsigned long val;
+
+	if (parse_reg_val_from_cmd(&reg, &val) != 2)
+		return 0;
+
+	seq_printf(s, "writel(0x%p, 0x%08x): ", reg, (u32)val);
+
+	clk_clrl(reg, val);
+	val = clk_readl(reg);
+	seq_printf(s, "0x%08x\n", (u32)val);
+
+	return 0;
+}
+
+static int parse_val_from_cmd(unsigned long *pval)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *val_str;
+	int r = 0;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	val_str = strsep(&c, " ");
+
+	if (pval != NULL && val_str != NULL && kstrtoul(val_str, 0, pval) == 0)
+		r++;
+
+	return r;
+}
+
+static int clkdbg_show_flags(struct seq_file *s, void *v)
+{
+	static const char * const clkdbg_opt_name[] = {
+		"CLKDBG_EN_SUSPEND_SAVE_1",
+		"CLKDBG_EN_SUSPEND_SAVE_2",
+		"CLKDBG_EN_SUSPEND_SAVE_3",
+		"CLKDBG_EN_LOG_SAVE_POINTS",
+	};
+
+	size_t i;
+
+	seq_printf(s, "clkdbg_flags: 0x%08x\n", clkdbg_flags);
+
+	for (i = 0; i < ARRAY_SIZE(clkdbg_opt_name); i++) {
+		const char *onff =
+			has_clkdbg_flag((enum clkdbg_opt)i) ? "ON" : "off";
+
+		seq_printf(s, "[%2zd]: %3s: %s\n", i, onff, clkdbg_opt_name[i]);
+	}
+
+	return 0;
+}
+
+static int clkdbg_set_flag(struct seq_file *s, void *v)
+{
+	unsigned long val;
+
+	if (parse_val_from_cmd(&val) != 1)
+		return 0;
+
+	set_clkdbg_flag((enum clkdbg_opt)val);
+
+	seq_printf(s, "clkdbg_flags: 0x%08x\n", clkdbg_flags);
+
+	return 0;
+}
+
+static int clkdbg_clr_flag(struct seq_file *s, void *v)
+{
+	unsigned long val;
+
+	if (parse_val_from_cmd(&val) != 1)
+		return 0;
+
+	clr_clkdbg_flag((enum clkdbg_opt)val);
+
+	seq_printf(s, "clkdbg_flags: 0x%08x\n", clkdbg_flags);
+
+	return 0;
+}
+
+#if CLKDBG_PM_DOMAIN
+
+/*
+ * pm_domain support
+ */
+
+static struct generic_pm_domain **get_all_genpd(void)
+{
+	static struct generic_pm_domain *pds[20];
+	static int num_pds;
+	const size_t maxpd = ARRAY_SIZE(pds);
+	struct device_node *node;
+#if CLKDBG_PM_DOMAIN_API_4_9
+	struct platform_device *pdev;
+	int r;
+#endif
+
+	if (num_pds != 0)
+		goto out;
+
+	node = of_find_node_with_property(NULL, "#power-domain-cells");
+
+	if (node == NULL)
+		return NULL;
+
+#if CLKDBG_PM_DOMAIN_API_4_9
+	pdev = platform_device_alloc("traverse", 0);
+#endif
+
+	for (num_pds = 0; num_pds < maxpd; num_pds++) {
+		struct of_phandle_args pa;
+
+		pa.np = node;
+		pa.args[0] = num_pds;
+		pa.args_count = 1;
+
+#if CLKDBG_PM_DOMAIN_API_4_9
+		r = of_genpd_add_device(&pa, &pdev->dev);
+		if (r == -EINVAL)
+			continue;
+		else if (r != 0)
+			pr_warn("%s(): of_genpd_add_device(%d)\n", __func__, r);
+		pds[num_pds] = pd_to_genpd(pdev->dev.pm_domain);
+#if CLKDBG_DROP_GENPD_AS_IN_PARAM
+		r = pm_genpd_remove_device(&pdev->dev);
+#else
+		r = pm_genpd_remove_device(pds[num_pds], &pdev->dev);
+#endif
+		if (r != 0)
+			pr_warn("%s(): pm_genpd_remove_device(%d)\n",
+					__func__, r);
+#else
+		pds[num_pds] = of_genpd_get_from_provider(&pa);
+#endif
+
+		if (IS_ERR(pds[num_pds])) {
+			pds[num_pds] = NULL;
+			break;
+		}
+	}
+
+#if CLKDBG_PM_DOMAIN_API_4_9
+	platform_device_put(pdev);
+#endif
+
+out:
+	return pds;
+}
+
+static struct platform_device *pdev_from_name(const char *name)
+{
+	struct generic_pm_domain **pds = get_all_genpd();
+
+	for (; *pds != NULL; pds++) {
+		struct pm_domain_data *pdd;
+		struct generic_pm_domain *pd = *pds;
+
+		if (IS_ERR_OR_NULL(pd))
+			continue;
+
+		list_for_each_entry(pdd, &pd->dev_list, list_node) {
+			struct device *dev = pdd->dev;
+			struct platform_device *pdev = to_platform_device(dev);
+
+			if (strcmp(name, pdev->name) == 0)
+				return pdev;
+		}
+	}
+
+	return NULL;
+}
+
+static struct generic_pm_domain *genpd_from_name(const char *name)
+{
+	struct generic_pm_domain **pds = get_all_genpd();
+
+	for (; *pds != NULL; pds++) {
+		struct generic_pm_domain *pd = *pds;
+
+		if (IS_ERR_OR_NULL(pd))
+			continue;
+
+		if (strcmp(name, pd->name) == 0)
+			return pd;
+	}
+
+	return NULL;
+}
+
+struct genpd_dev_state {
+	struct device *dev;
+	bool active;
+	atomic_t usage_count;
+	unsigned int disable_depth;
+	enum rpm_status runtime_status;
+};
+
+struct genpd_state {
+	struct generic_pm_domain *pd;
+	enum gpd_status status;
+	struct genpd_dev_state *dev_state;
+	int num_dev_state;
+};
+
+static void save_all_genpd_state(struct genpd_state *genpd_states,
+				struct genpd_dev_state *genpd_dev_states)
+{
+	struct genpd_state *pdst = genpd_states;
+	struct genpd_dev_state *devst = genpd_dev_states;
+	struct generic_pm_domain **pds = get_all_genpd();
+
+	for (; *pds != NULL; pds++) {
+		struct pm_domain_data *pdd;
+		struct generic_pm_domain *pd = *pds;
+
+		if (IS_ERR_OR_NULL(pd))
+			continue;
+
+		pdst->pd = pd;
+		pdst->status = pd->status;
+		pdst->dev_state = devst;
+		pdst->num_dev_state = 0;
+
+		list_for_each_entry(pdd, &pd->dev_list, list_node) {
+			struct device *d = pdd->dev;
+
+			devst->dev = d;
+			devst->active = pm_runtime_active(d);
+			devst->usage_count = d->power.usage_count;
+			devst->disable_depth = d->power.disable_depth;
+			devst->runtime_status = d->power.runtime_status;
+
+			devst++;
+			pdst->num_dev_state++;
+		}
+
+		pdst++;
+	}
+
+	pdst->pd = NULL;
+	devst->dev = NULL;
+}
+
+static void show_genpd_state(struct genpd_state *pdst)
+{
+	static const char * const gpd_status_name[] = {
+		"ACTIVE",
+		"POWER_OFF",
+	};
+
+	static const char * const prm_status_name[] = {
+		"active",
+		"resuming",
+		"suspended",
+		"suspending",
+	};
+
+	pr_info("domain_on [pmd_name  status]\n");
+	pr_info("\tdev_on (dev_name usage_count, disable, status)\n");
+	pr_info("------------------------------------------------------\n");
+
+	for (; pdst->pd != NULL; pdst++) {
+		int i;
+		struct generic_pm_domain *pd = pdst->pd;
+
+		if (IS_ERR_OR_NULL(pd)) {
+			pr_info("pd: 0x%p\n", pd);
+			continue;
+		}
+
+		pr_info("%c [%-9s %11s]\n",
+			(pdst->status == GPD_STATE_ACTIVE) ? '+' : '-',
+			pd->name, gpd_status_name[pdst->status]);
+
+		for (i = 0; i < pdst->num_dev_state; i++) {
+			struct genpd_dev_state *devst = &pdst->dev_state[i];
+			struct device *dev = devst->dev;
+			struct platform_device *pdev = to_platform_device(dev);
+
+			pr_info("\t%c (%-19s %3d, %d, %10s)\n",
+				devst->active ? '+' : '-',
+				pdev->name,
+				atomic_read(&dev->power.usage_count),
+				devst->disable_depth,
+				prm_status_name[devst->runtime_status]);
+			mdelay(20);
+		}
+	}
+}
+
+static void dump_genpd_state(struct genpd_state *pdst, struct seq_file *s)
+{
+	static const char * const gpd_status_name[] = {
+		"ACTIVE",
+		"POWER_OFF",
+	};
+
+	static const char * const prm_status_name[] = {
+		"active",
+		"resuming",
+		"suspended",
+		"suspending",
+	};
+
+	seq_puts(s, "domain_on [pmd_name  status]\n");
+	seq_puts(s, "\tdev_on (dev_name usage_count, disable, status)\n");
+	seq_puts(s, "------------------------------------------------------\n");
+
+	for (; pdst->pd != NULL; pdst++) {
+		int i;
+		struct generic_pm_domain *pd = pdst->pd;
+
+		if (IS_ERR_OR_NULL(pd)) {
+			seq_printf(s, "pd: 0x%p\n", pd);
+			continue;
+		}
+
+		seq_printf(s, "%c [%-9s %11s]\n",
+			(pdst->status == GPD_STATE_ACTIVE) ? '+' : '-',
+			pd->name, gpd_status_name[pdst->status]);
+
+		for (i = 0; i < pdst->num_dev_state; i++) {
+			struct genpd_dev_state *devst = &pdst->dev_state[i];
+			struct device *dev = devst->dev;
+			struct platform_device *pdev = to_platform_device(dev);
+
+			seq_printf(s, "\t%c (%-19s %3d, %d, %10s)\n",
+				devst->active ? '+' : '-',
+				pdev->name,
+				atomic_read(&dev->power.usage_count),
+				devst->disable_depth,
+				prm_status_name[devst->runtime_status]);
+		}
+	}
+}
+
+static void seq_print_all_genpd(struct seq_file *s)
+{
+	static struct genpd_dev_state devst[100];
+	static struct genpd_state pdst[20];
+
+	save_all_genpd_state(pdst, devst);
+	dump_genpd_state(pdst, s);
+}
+
+static int clkdbg_dump_genpd(struct seq_file *s, void *v)
+{
+	seq_print_all_genpd(s);
+
+	return 0;
+}
+
+static int clkdbg_pm_runtime_enable(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *dev_name;
+	struct platform_device *pdev;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	dev_name = strsep(&c, " ");
+
+	if (dev_name == NULL)
+		return 0;
+
+	seq_printf(s, "pm_runtime_enable(%s): ", dev_name);
+
+	pdev = pdev_from_name(dev_name);
+	if (pdev != NULL) {
+		pm_runtime_enable(&pdev->dev);
+		seq_puts(s, "\n");
+	} else {
+		seq_puts(s, "NULL\n");
+	}
+
+	return 0;
+}
+
+static int clkdbg_pm_runtime_disable(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *dev_name;
+	struct platform_device *pdev;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	dev_name = strsep(&c, " ");
+
+	if (dev_name == NULL)
+		return 0;
+
+	seq_printf(s, "pm_runtime_disable(%s): ", dev_name);
+
+	pdev = pdev_from_name(dev_name);
+	if (pdev != NULL) {
+		pm_runtime_disable(&pdev->dev);
+		seq_puts(s, "\n");
+	} else {
+		seq_puts(s, "NULL\n");
+	}
+
+	return 0;
+}
+
+static int clkdbg_pm_runtime_get_sync(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *dev_name;
+	struct platform_device *pdev;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	dev_name = strsep(&c, " ");
+
+	if (dev_name == NULL)
+		return 0;
+
+	seq_printf(s, "pm_runtime_get_sync(%s): ", dev_name);
+
+	pdev = pdev_from_name(dev_name);
+	if (pdev != NULL) {
+		int r = pm_runtime_get_sync(&pdev->dev);
+
+		seq_printf(s, "%d\n", r);
+	} else {
+		seq_puts(s, "NULL\n");
+	}
+
+	return 0;
+}
+
+static int clkdbg_pm_runtime_put_sync(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *dev_name;
+	struct platform_device *pdev;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	dev_name = strsep(&c, " ");
+
+	if (dev_name == NULL)
+		return 0;
+
+	seq_printf(s, "pm_runtime_put_sync(%s): ", dev_name);
+
+	pdev = pdev_from_name(dev_name);
+	if (pdev != NULL) {
+		int r = pm_runtime_put_sync(&pdev->dev);
+
+		seq_printf(s, "%d\n", r);
+	} else {
+		seq_puts(s, "NULL\n");
+	}
+
+	return 0;
+}
+
+static int genpd_op(const char *gpd_op_name, struct seq_file *s)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *pd_name;
+	struct generic_pm_domain *genpd;
+	int gpd_op_id;
+	int (*gpd_op)(struct generic_pm_domain *genpd);
+	int r = 0;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	pd_name = strsep(&c, " ");
+
+	if (pd_name == NULL)
+		return 0;
+
+	if (strcmp(gpd_op_name, "power_on") == 0)
+		gpd_op_id = 1;
+	else
+		gpd_op_id = 0;
+
+	if (strcmp(pd_name, "all") == 0) {
+		struct generic_pm_domain **pds = get_all_genpd();
+
+		for (; *pds != NULL; pds++) {
+			genpd = *pds;
+
+			if (IS_ERR_OR_NULL(genpd))
+				continue;
+
+			gpd_op = (gpd_op_id == 1) ?
+					genpd->power_on : genpd->power_off;
+			r |= gpd_op(genpd);
+		}
+
+		seq_printf(s, "%s(%s): %d\n", gpd_op_name, pd_name, r);
+
+		return 0;
+	}
+
+	genpd = genpd_from_name(pd_name);
+	if (genpd != NULL) {
+		gpd_op = (gpd_op_id == 1) ? genpd->power_on : genpd->power_off;
+		r = gpd_op(genpd);
+
+		seq_printf(s, "%s(%s): %d\n", gpd_op_name, pd_name, r);
+	} else {
+		seq_printf(s, "genpd_from_name(%s): NULL\n", pd_name);
+	}
+
+	return 0;
+}
+
+static int clkdbg_pwr_on(struct seq_file *s, void *v)
+{
+	return genpd_op("power_on", s);
+}
+
+static int clkdbg_pwr_off(struct seq_file *s, void *v)
+{
+	return genpd_op("power_off", s);
+}
+
+/*
+ * clkdbg reg_pdrv/runeg_pdrv support
+ */
+
+static int clkdbg_probe(struct platform_device *pdev)
+{
+	int r;
+
+	pm_runtime_enable(&pdev->dev);
+	r = pm_runtime_get_sync(&pdev->dev);
+	if (r != 0)
+		pr_warn("%s(): pm_runtime_get_sync(%d)\n", __func__, r);
+
+	return r;
+}
+
+static int clkdbg_remove(struct platform_device *pdev)
+{
+	int r;
+
+	r = pm_runtime_put_sync(&pdev->dev);
+	if (r != 0)
+		pr_warn("%s(): pm_runtime_put_sync(%d)\n", __func__, r);
+	pm_runtime_disable(&pdev->dev);
+
+	return r;
+}
+
+struct pdev_drv {
+	struct platform_driver pdrv;
+	struct platform_device *pdev;
+	struct generic_pm_domain *genpd;
+};
+
+#define PDEV_DRV(_name) {				\
+	.pdrv = {					\
+		.probe		= clkdbg_probe,		\
+		.remove		= clkdbg_remove,	\
+		.driver		= {			\
+			.name	= _name,		\
+		},					\
+	},						\
+}
+
+static struct pdev_drv pderv[] = {
+	PDEV_DRV("clkdbg-pd0"),
+	PDEV_DRV("clkdbg-pd1"),
+	PDEV_DRV("clkdbg-pd2"),
+	PDEV_DRV("clkdbg-pd3"),
+	PDEV_DRV("clkdbg-pd4"),
+	PDEV_DRV("clkdbg-pd5"),
+	PDEV_DRV("clkdbg-pd6"),
+	PDEV_DRV("clkdbg-pd7"),
+	PDEV_DRV("clkdbg-pd8"),
+	PDEV_DRV("clkdbg-pd9"),
+	PDEV_DRV("clkdbg-pd10"),
+	PDEV_DRV("clkdbg-pd11"),
+	PDEV_DRV("clkdbg-pd12"),
+	PDEV_DRV("clkdbg-pd13"),
+	PDEV_DRV("clkdbg-pd14"),
+	PDEV_DRV("clkdbg-pd15"),
+};
+
+static void reg_pdev_drv(const char *pdname, struct seq_file *s)
+{
+	size_t i;
+	struct generic_pm_domain **pds = get_all_genpd();
+	bool allpd = (pdname == NULL || strcmp(pdname, "all") == 0);
+	int r;
+
+	for (i = 0; i < ARRAY_SIZE(pderv) && *pds != NULL; i++, pds++) {
+		const char *name = pderv[i].pdrv.driver.name;
+		struct generic_pm_domain *pd = *pds;
+
+		if (IS_ERR_OR_NULL(pd) || pderv[i].genpd != NULL)
+			continue;
+
+		if (!allpd && strcmp(pdname, pd->name) != 0)
+			continue;
+
+		pderv[i].genpd = pd;
+
+		pderv[i].pdev = platform_device_alloc(name, 0);
+		r = platform_device_add(pderv[i].pdev);
+		if (r != 0 && s != NULL)
+			seq_printf(s, "%s(): platform_device_add(%d)\n",
+						__func__, r);
+
+		r = pm_genpd_add_device(pd, &pderv[i].pdev->dev);
+		if (r != 0 && s != NULL)
+			seq_printf(s, "%s(): pm_genpd_add_device(%d)\n",
+						__func__, r);
+		r = platform_driver_register(&pderv[i].pdrv);
+		if (r != 0 && s != NULL)
+			seq_printf(s, "%s(): platform_driver_register(%d)\n",
+						__func__, r);
+
+		if (s != NULL)
+			seq_printf(s, "%s --> %s\n", name, pd->name);
+	}
+}
+
+static void unreg_pdev_drv(const char *pdname, struct seq_file *s)
+{
+	ssize_t i;
+	bool allpd = (pdname == NULL || strcmp(pdname, "all") == 0);
+	int r;
+
+	for (i = ARRAY_SIZE(pderv) - 1L; i >= 0L; i--) {
+		const char *name = pderv[i].pdrv.driver.name;
+		struct generic_pm_domain *pd = pderv[i].genpd;
+
+		if (IS_ERR_OR_NULL(pd))
+			continue;
+
+		if (!allpd && strcmp(pdname, pd->name) != 0)
+			continue;
+
+#if CLKDBG_DROP_GENPD_AS_IN_PARAM
+		r = pm_genpd_remove_device(&pderv[i].pdev->dev);
+#else
+		r = pm_genpd_remove_device(pd, &pderv[i].pdev->dev);
+#endif
+		if (r != 0 && s != NULL)
+			seq_printf(s, "%s(): pm_genpd_remove_device(%d)\n",
+						__func__, r);
+
+		platform_driver_unregister(&pderv[i].pdrv);
+		platform_device_unregister(pderv[i].pdev);
+
+		pderv[i].genpd = NULL;
+
+		if (s != NULL)
+			seq_printf(s, "%s -x- %s\n", name, pd->name);
+	}
+}
+
+static int clkdbg_reg_pdrv(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *pd_name;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	pd_name = strsep(&c, " ");
+
+	if (pd_name == NULL)
+		return 0;
+
+	reg_pdev_drv(pd_name, s);
+
+	return 0;
+}
+
+static int clkdbg_unreg_pdrv(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *pd_name;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	pd_name = strsep(&c, " ");
+
+	if (pd_name == NULL)
+		return 0;
+
+	unreg_pdev_drv(pd_name, s);
+
+	return 0;
+}
+
+#endif /* CLKDBG_PM_DOMAIN */
+
+void reg_pdrv(const char *pdname)
+{
+#if CLKDBG_PM_DOMAIN
+	reg_pdev_drv(pdname, NULL);
+#endif
+}
+
+void unreg_pdrv(const char *pdname)
+{
+#if CLKDBG_PM_DOMAIN
+	unreg_pdev_drv(pdname, NULL);
+#endif
+}
+
+/*
+ * Suspend / resume handler
+ */
+
+#include <linux/suspend.h>
+#include <linux/syscore_ops.h>
+
+struct provider_clk_state {
+	struct provider_clk *pvdck;
+	bool prepared;
+	bool enabled;
+	unsigned int enable_count;
+	unsigned long rate;
+	struct clk *parent;
+};
+
+struct save_point {
+	u32 spm_pwr_status;
+	struct provider_clk_state clks_states[512];
+#if CLKDBG_PM_DOMAIN
+	struct genpd_state genpd_states[20];
+	struct genpd_dev_state genpd_dev_states[100];
+#endif
+};
+
+static struct save_point save_point_1;
+static struct save_point save_point_2;
+static struct save_point save_point_3;
+
+static void save_pwr_status(u32 *spm_pwr_status)
+{
+	*spm_pwr_status = read_spm_pwr_status();
+}
+
+static void save_all_clks_state(struct provider_clk_state *clks_states,
+				u32 spm_pwr_status)
+{
+	struct provider_clk *pvdck = get_all_provider_clks();
+	struct provider_clk_state *st = clks_states;
+
+	for (; pvdck->ck != NULL; pvdck++, st++) {
+		struct clk *c = pvdck->ck;
+		struct clk_hw *c_hw = __clk_get_hw(c);
+
+		st->pvdck = pvdck;
+		st->prepared = clk_hw_is_prepared(c_hw);
+		st->enabled = clk_hw_pwr_is_on(c_hw, spm_pwr_status,
+							pvdck->pwr_mask);
+		st->enable_count = __clk_get_enable_count(c);
+		st->rate = clk_hw_get_rate(c_hw);
+		st->parent = IS_ERR_OR_NULL(c) ? NULL : clk_get_parent(c);
+	}
+}
+
+static void show_provider_clk_state(struct provider_clk_state *st)
+{
+	struct provider_clk *pvdck = st->pvdck;
+	struct clk_hw *c_hw = __clk_get_hw(pvdck->ck);
+
+	pr_info("[%10s: %-17s: %3s, %3d, %3d, %10ld, %17s]\n",
+		pvdck->provider_name != NULL ? pvdck->provider_name : "/ ",
+		clk_hw_get_name(c_hw),
+		st->enabled ? "ON" : "off",
+		st->prepared,
+		st->enable_count,
+		st->rate,
+		st->parent != NULL ?
+			clk_hw_get_name(__clk_get_hw(st->parent)) : "- ");
+	mdelay(20);
+}
+
+static void dump_provider_clk_state(struct provider_clk_state *st,
+					struct seq_file *s)
+{
+	struct provider_clk *pvdck = st->pvdck;
+	struct clk_hw *c_hw = __clk_get_hw(pvdck->ck);
+
+	seq_printf(s, "[%10s: %-17s: %3s, %3d, %3d, %10ld, %17s]\n",
+		pvdck->provider_name != NULL ? pvdck->provider_name : "/ ",
+		clk_hw_get_name(c_hw),
+		st->enabled ? "ON" : "off",
+		st->prepared,
+		st->enable_count,
+		st->rate,
+		st->parent != NULL ?
+			clk_hw_get_name(__clk_get_hw(st->parent)) : "- ");
+}
+
+static void show_save_point(struct save_point *sp)
+{
+	struct provider_clk_state *st = sp->clks_states;
+
+	for (; st->pvdck != NULL; st++)
+		show_provider_clk_state(st);
+
+	pr_info("\n");
+	show_pwr_status(sp->spm_pwr_status);
+
+#if CLKDBG_PM_DOMAIN
+	pr_info("\n");
+	show_genpd_state(sp->genpd_states);
+#endif
+}
+
+static void store_save_point(struct save_point *sp)
+{
+	save_pwr_status(&sp->spm_pwr_status);
+	save_all_clks_state(sp->clks_states, sp->spm_pwr_status);
+
+#if CLKDBG_PM_DOMAIN
+	save_all_genpd_state(sp->genpd_states, sp->genpd_dev_states);
+#endif
+
+	if (has_clkdbg_flag(CLKDBG_EN_LOG_SAVE_POINTS))
+		show_save_point(sp);
+}
+
+static void dump_save_point(struct save_point *sp, struct seq_file *s)
+{
+	struct provider_clk_state *st = sp->clks_states;
+
+	for (; st->pvdck != NULL; st++)
+		dump_provider_clk_state(st, s);
+
+	seq_puts(s, "\n");
+	dump_pwr_status(sp->spm_pwr_status, s);
+
+#if CLKDBG_PM_DOMAIN
+	seq_puts(s, "\n");
+	dump_genpd_state(sp->genpd_states, s);
+#endif
+}
+
+static int clkdbg_dump_suspend_clks_1(struct seq_file *s, void *v)
+{
+	dump_save_point(&save_point_1, s);
+	return 0;
+}
+
+static int clkdbg_dump_suspend_clks_2(struct seq_file *s, void *v)
+{
+	dump_save_point(&save_point_2, s);
+	return 0;
+}
+
+static int clkdbg_dump_suspend_clks_3(struct seq_file *s, void *v)
+{
+	dump_save_point(&save_point_3, s);
+	return 0;
+}
+
+static int clkdbg_dump_suspend_clks(struct seq_file *s, void *v)
+{
+	if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_3) &&
+			save_point_3.spm_pwr_status != 0U)
+		return clkdbg_dump_suspend_clks_3(s, v);
+	else if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_2) &&
+			save_point_2.spm_pwr_status != 0U)
+		return clkdbg_dump_suspend_clks_2(s, v);
+	else if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_1) &&
+			save_point_1.spm_pwr_status != 0U)
+		return clkdbg_dump_suspend_clks_1(s, v);
+
+	return 0;
+}
+
+static int clkdbg_pm_event_handler(struct notifier_block *nb,
+					unsigned long event, void *ptr)
+{
+	switch (event) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		/* suspend */
+		if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_1)) {
+			store_save_point(&save_point_1);
+			return NOTIFY_OK;
+		}
+
+		break;
+	case PM_POST_HIBERNATION:
+	case PM_POST_SUSPEND:
+		/* resume */
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block clkdbg_pm_notifier = {
+	.notifier_call = clkdbg_pm_event_handler,
+};
+
+static int clkdbg_syscore_suspend(void)
+{
+	if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_2))
+		store_save_point(&save_point_2);
+
+	return 0;
+}
+
+static void clkdbg_syscore_resume(void)
+{
+}
+
+static struct syscore_ops clkdbg_syscore_ops = {
+	.suspend = clkdbg_syscore_suspend,
+	.resume = clkdbg_syscore_resume,
+};
+
+static int __init clkdbg_pm_init(void)
+{
+	int r;
+
+	register_syscore_ops(&clkdbg_syscore_ops);
+	r = register_pm_notifier(&clkdbg_pm_notifier);
+	if (r != 0)
+		pr_warn("%s(): register_pm_notifier(%d)\n", __func__, r);
+
+	return r;
+}
+subsys_initcall(clkdbg_pm_init);
+
+static int clkdbg_suspend_ops_valid(suspend_state_t state)
+{
+	return state == PM_SUSPEND_MEM ? 1 : 0;
+}
+
+static int clkdbg_suspend_ops_begin(suspend_state_t state)
+{
+	return 0;
+}
+
+static int clkdbg_suspend_ops_prepare(void)
+{
+	return 0;
+}
+
+static int clkdbg_suspend_ops_enter(suspend_state_t state)
+{
+	if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_3))
+		store_save_point(&save_point_3);
+
+	return 0;
+}
+
+static void clkdbg_suspend_ops_finish(void)
+{
+}
+
+static void clkdbg_suspend_ops_end(void)
+{
+}
+
+static const struct platform_suspend_ops clkdbg_suspend_ops = {
+	.valid = clkdbg_suspend_ops_valid,
+	.begin = clkdbg_suspend_ops_begin,
+	.prepare = clkdbg_suspend_ops_prepare,
+	.enter = clkdbg_suspend_ops_enter,
+	.finish = clkdbg_suspend_ops_finish,
+	.end = clkdbg_suspend_ops_end,
+};
+
+static int clkdbg_suspend_set_ops(struct seq_file *s, void *v)
+{
+	suspend_set_ops(&clkdbg_suspend_ops);
+
+	return 0;
+}
+
+static const struct cmd_fn *custom_cmds;
+
+void set_custom_cmds(const struct cmd_fn *cmds)
+{
+	custom_cmds = cmds;
+}
+
+static int clkdbg_cmds(struct seq_file *s, void *v);
+
+static const struct cmd_fn common_cmds[] = {
+	CMDFN("dump_regs", seq_print_regs),
+	CMDFN("dump_regs2", clkdbg_dump_regs2),
+	CMDFN("dump_state", clkdbg_dump_state_all),
+	CMDFN("dump_clks", clkdbg_dump_provider_clks),
+	CMDFN("dump_muxes", clkdbg_dump_muxes),
+	CMDFN("fmeter", seq_print_fmeter_all),
+	CMDFN("pwr_status", clkdbg_pwr_status),
+	CMDFN("prepare", clkdbg_prepare),
+	CMDFN("unprepare", clkdbg_unprepare),
+	CMDFN("enable", clkdbg_enable),
+	CMDFN("disable", clkdbg_disable),
+	CMDFN("prepare_enable", clkdbg_prepare_enable),
+	CMDFN("disable_unprepare", clkdbg_disable_unprepare),
+	CMDFN("prepare_enable_provider", clkdbg_prepare_enable_provider),
+	CMDFN("disable_unprepare_provider", clkdbg_disable_unprepare_provider),
+	CMDFN("set_parent", clkdbg_set_parent),
+	CMDFN("set_rate", clkdbg_set_rate),
+	CMDFN("reg_read", clkdbg_reg_read),
+	CMDFN("reg_write", clkdbg_reg_write),
+	CMDFN("reg_set", clkdbg_reg_set),
+	CMDFN("reg_clr", clkdbg_reg_clr),
+	CMDFN("show_flags", clkdbg_show_flags),
+	CMDFN("set_flag", clkdbg_set_flag),
+	CMDFN("clr_flag", clkdbg_clr_flag),
+#if CLKDBG_PM_DOMAIN
+	CMDFN("dump_genpd", clkdbg_dump_genpd),
+	CMDFN("pm_runtime_enable", clkdbg_pm_runtime_enable),
+	CMDFN("pm_runtime_disable", clkdbg_pm_runtime_disable),
+	CMDFN("pm_runtime_get_sync", clkdbg_pm_runtime_get_sync),
+	CMDFN("pm_runtime_put_sync", clkdbg_pm_runtime_put_sync),
+	CMDFN("pwr_on", clkdbg_pwr_on),
+	CMDFN("pwr_off", clkdbg_pwr_off),
+	CMDFN("reg_pdrv", clkdbg_reg_pdrv),
+	CMDFN("unreg_pdrv", clkdbg_unreg_pdrv),
+#endif /* CLKDBG_PM_DOMAIN */
+	CMDFN("suspend_set_ops", clkdbg_suspend_set_ops),
+	CMDFN("dump_suspend_clks", clkdbg_dump_suspend_clks),
+	CMDFN("dump_suspend_clks_1", clkdbg_dump_suspend_clks_1),
+	CMDFN("dump_suspend_clks_2", clkdbg_dump_suspend_clks_2),
+	CMDFN("dump_suspend_clks_3", clkdbg_dump_suspend_clks_3),
+	CMDFN("cmds", clkdbg_cmds),
+	{}
+};
+
+static int clkdbg_cmds(struct seq_file *s, void *v)
+{
+	const struct cmd_fn *cf;
+
+	for (cf = common_cmds; cf->cmd != NULL; cf++)
+		seq_printf(s, "%s\n", cf->cmd);
+
+	for (cf = custom_cmds; cf != NULL && cf->cmd != NULL; cf++)
+		seq_printf(s, "%s\n", cf->cmd);
+
+	seq_puts(s, "\n");
+
+	return 0;
+}
+
+static int clkdbg_show(struct seq_file *s, void *v)
+{
+	const struct cmd_fn *cf;
+	char cmd[sizeof(last_cmd)];
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	for (cf = custom_cmds; cf != NULL && cf->cmd != NULL; cf++) {
+		char *c = cmd;
+		char *token = strsep(&c, " ");
+
+		if (strcmp(cf->cmd, token) == 0)
+			return cf->fn(s, v);
+	}
+
+	for (cf = common_cmds; cf->cmd != NULL; cf++) {
+		char *c = cmd;
+		char *token = strsep(&c, " ");
+
+		if (strcmp(cf->cmd, token) == 0)
+			return cf->fn(s, v);
+	}
+
+	return 0;
+}
+
+static int clkdbg_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clkdbg_show, NULL);
+}
+
+static ssize_t clkdbg_write(
+		struct file *file,
+		const char __user *buffer,
+		size_t count,
+		loff_t *data)
+{
+	size_t len = 0;
+
+	len = (count < (sizeof(last_cmd) - 1UL)) ?
+				count : (sizeof(last_cmd) - 1UL);
+	if (copy_from_user(last_cmd, buffer, len) != 0UL)
+		return 0;
+
+	last_cmd[len] = '\0';
+
+	if (last_cmd[len - 1UL] == '\n')
+		last_cmd[len - 1UL] = '\0';
+
+	return (ssize_t)len;
+}
+
+static const struct file_operations clkdbg_fops = {
+	.owner		= THIS_MODULE,
+	.open		= clkdbg_open,
+	.read		= seq_read,
+	.write		= clkdbg_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/*
+ * init functions
+ */
+
+static int __init clkdbg_debug_init(void)
+{
+	struct proc_dir_entry *entry;
+
+	entry = proc_create("clkdbg", 0644, NULL, &clkdbg_fops);
+	if (entry == 0)
+		return -ENOMEM;
+
+	set_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_3);
+
+	return 0;
+}
+module_init(clkdbg_debug_init);
diff --git a/drivers/clk/mediatek/clkdbg.h b/drivers/clk/mediatek/clkdbg.h
new file mode 100644
index 000000000000..b9cddf3445ff
--- /dev/null
+++ b/drivers/clk/mediatek/clkdbg.h
@@ -0,0 +1,83 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
+ */
+
+struct seq_file;
+
+#define clk_readl(addr)		readl(addr)
+#define clk_writel(addr, val)	\
+	do { writel(val, addr); wmb(); } while (0) /* sync write */
+#define clk_setl(addr, val)	clk_writel(addr, clk_readl(addr) | (val))
+#define clk_clrl(addr, val)	clk_writel(addr, clk_readl(addr) & ~(val))
+
+enum FMETER_TYPE {
+	FT_NULL,
+	ABIST,
+	CKGEN
+};
+
+struct fmeter_clk {
+	enum FMETER_TYPE type;
+	u32 id;
+	const char *name;
+};
+
+struct regbase {
+	u32 phys;
+	void __iomem *virt;
+	const char *name;
+};
+
+struct regname {
+	struct regbase *base;
+	u32 ofs;
+	const char *name;
+};
+
+#define ADDR(rn)	(rn->base->virt + rn->ofs)
+#define PHYSADDR(rn)	(rn->base->phys + rn->ofs)
+
+struct cmd_fn {
+	const char	*cmd;
+	int (*fn)(struct seq_file *s, void *v);
+};
+
+#define CMDFN(_cmd, _fn) {	\
+	.cmd = _cmd,		\
+	.fn = _fn,		\
+}
+
+struct provider_clk {
+	const char *provider_name;
+	u32 idx;
+	struct clk *ck;
+	u32 pwr_mask;
+};
+
+struct clkdbg_ops {
+	const struct fmeter_clk *(*get_all_fmeter_clks)(void);
+	void *(*prepare_fmeter)(void);
+	void (*unprepare_fmeter)(void *data);
+	u32 (*fmeter_freq)(const struct fmeter_clk *fclk);
+	const struct regname *(*get_all_regnames)(void);
+	const char * const *(*get_all_clk_names)(void);
+	const char * const *(*get_pwr_names)(void);
+	void (*setup_provider_clk)(struct provider_clk *pvdck);
+	u32 (*get_spm_pwr_status)(void);
+};
+
+void set_clkdbg_ops(const struct clkdbg_ops *ops);
+void set_custom_cmds(const struct cmd_fn *cmds);
+
+struct provider_clk *get_all_provider_clks(void);
+const char *get_last_cmd(void);
+
+void reg_pdrv(const char *pdname);
+void unreg_pdrv(const char *pdname);
+void prepare_enable_provider(const char *pvd);
+void disable_unprepare_provider(const char *pvd);
+
+void print_regs(void);
+void print_fmeter_all(void);
diff --git a/drivers/devfreq/Kconfig b/drivers/devfreq/Kconfig
index e178f1473136..6794e6093a47 100644
--- a/drivers/devfreq/Kconfig
+++ b/drivers/devfreq/Kconfig
@@ -73,6 +73,14 @@ config DEVFREQ_GOV_PASSIVE
 	  through sysfs entries. The passive governor recommends that
 	  devfreq device uses the OPP table to get the frequency/voltage.
 
+config DEVFREQ_GOV_CPUFREQ_MAP
+	tristate "CPUfreq Map"
+	depends on CPU_FREQ
+	help
+	  Chooses frequency based on the online CPUs' current frequency and a
+	  CPU frequency to device frequency mapping table(s). This governor
+	  can be useful for controlling devices such as DDR, cache, CCI, etc.
+
 comment "DEVFREQ Drivers"
 
 config ARM_EXYNOS_BUS_DEVFREQ
diff --git a/drivers/devfreq/Makefile b/drivers/devfreq/Makefile
index 71e7ac084db6..85d48f5744a0 100644
--- a/drivers/devfreq/Makefile
+++ b/drivers/devfreq/Makefile
@@ -6,6 +6,7 @@ obj-$(CONFIG_DEVFREQ_GOV_PERFORMANCE)	+= governor_performance.o
 obj-$(CONFIG_DEVFREQ_GOV_POWERSAVE)	+= governor_powersave.o
 obj-$(CONFIG_DEVFREQ_GOV_USERSPACE)	+= governor_userspace.o
 obj-$(CONFIG_DEVFREQ_GOV_PASSIVE)	+= governor_passive.o
+obj-$(CONFIG_DEVFREQ_GOV_CPUFREQ_MAP)	+= governor_cpufreq_map.o
 
 # DEVFREQ Drivers
 obj-$(CONFIG_ARM_EXYNOS_BUS_DEVFREQ)	+= exynos-bus.o
diff --git a/drivers/devfreq/governor_cpufreq_map.c b/drivers/devfreq/governor_cpufreq_map.c
new file mode 100644
index 000000000000..084a3ffb8f54
--- /dev/null
+++ b/drivers/devfreq/governor_cpufreq_map.c
@@ -0,0 +1,583 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2014-2015, 2018, The Linux Foundation. All rights reserved.
+ */
+
+#define pr_fmt(fmt) "dev-cpufreq-map: " fmt
+
+#include <linux/devfreq.h>
+#include <linux/cpu.h>
+#include <linux/cpufreq.h>
+#include <linux/cpumask.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/module.h>
+#include "governor.h"
+
+struct cpu_state {
+	unsigned int freq;
+	unsigned int min_freq;
+	unsigned int max_freq;
+	unsigned int first_cpu;
+};
+static struct cpu_state *state[NR_CPUS];
+static int cpufreq_cnt;
+
+struct freq_map {
+	unsigned int cpu_khz;
+	unsigned int target_freq;
+};
+
+struct devfreq_node {
+	struct devfreq *df;
+	void *orig_data;
+	struct device *dev;
+	struct device_node *of_node;
+	struct list_head list;
+	struct freq_map **map;
+	struct freq_map *common_map;
+};
+static LIST_HEAD(devfreq_list);
+static DEFINE_MUTEX(state_lock);
+static DEFINE_MUTEX(cpufreq_reg_lock);
+
+static void update_all_devfreqs(void)
+{
+	struct devfreq_node *node;
+
+	list_for_each_entry(node, &devfreq_list, list) {
+		struct devfreq *df = node->df;
+
+		if (!node->df)
+			continue;
+		mutex_lock(&df->lock);
+		update_devfreq(df);
+		mutex_unlock(&df->lock);
+
+	}
+}
+
+static struct devfreq_node *find_devfreq_node(struct device *dev)
+{
+	struct devfreq_node *node;
+
+	list_for_each_entry(node, &devfreq_list, list)
+		if (node->dev == dev || node->of_node == dev->of_node)
+			return node;
+
+	return NULL;
+}
+
+/* ==================== cpufreq part ==================== */
+static struct cpu_state *add_policy(struct cpufreq_policy *policy)
+{
+	struct cpu_state *new_state;
+	unsigned int cpu, first_cpu;
+
+	new_state = kzalloc(sizeof(struct cpu_state), GFP_KERNEL);
+	if (!new_state)
+		return NULL;
+
+	first_cpu = cpumask_first(policy->related_cpus);
+	new_state->first_cpu = first_cpu;
+	new_state->freq = policy->cur;
+	new_state->min_freq = policy->cpuinfo.min_freq;
+	new_state->max_freq = policy->cpuinfo.max_freq;
+
+	for_each_cpu(cpu, policy->related_cpus)
+		state[cpu] = new_state;
+
+	return new_state;
+}
+
+static int cpufreq_trans_notifier(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+	struct cpufreq_freqs *freq = data;
+	struct cpu_state *s;
+	struct cpufreq_policy *policy = NULL;
+
+	if (event != CPUFREQ_POSTCHANGE)
+		return 0;
+
+	mutex_lock(&state_lock);
+
+	s = state[freq->cpu];
+	if (!s) {
+		policy = cpufreq_cpu_get(freq->cpu);
+		if (policy) {
+			s = add_policy(policy);
+			cpufreq_cpu_put(policy);
+		}
+	}
+	if (!s)
+		goto out;
+
+	if (s->freq != freq->new || policy) {
+		s->freq = freq->new;
+		update_all_devfreqs();
+	}
+
+out:
+	mutex_unlock(&state_lock);
+	return 0;
+}
+
+static struct notifier_block cpufreq_trans_nb = {
+	.notifier_call = cpufreq_trans_notifier
+};
+
+static int register_cpufreq(void)
+{
+	int ret = 0;
+	unsigned int cpu;
+	struct cpufreq_policy *policy;
+
+	mutex_lock(&cpufreq_reg_lock);
+
+	if (cpufreq_cnt)
+		goto cnt_not_zero;
+
+	get_online_cpus();
+	ret = cpufreq_register_notifier(&cpufreq_trans_nb,
+				CPUFREQ_TRANSITION_NOTIFIER);
+	if (ret)
+		goto out;
+
+	for_each_online_cpu(cpu) {
+		policy = cpufreq_cpu_get(cpu);
+		if (policy) {
+			add_policy(policy);
+			cpufreq_cpu_put(policy);
+		}
+	}
+out:
+	put_online_cpus();
+cnt_not_zero:
+	if (!ret)
+		cpufreq_cnt++;
+	mutex_unlock(&cpufreq_reg_lock);
+	return ret;
+}
+
+static int unregister_cpufreq(void)
+{
+	int ret = 0;
+	int cpu;
+
+	mutex_lock(&cpufreq_reg_lock);
+
+	if (cpufreq_cnt > 1)
+		goto out;
+
+	cpufreq_unregister_notifier(&cpufreq_trans_nb,
+				CPUFREQ_TRANSITION_NOTIFIER);
+
+	for (cpu = ARRAY_SIZE(state) - 1; cpu >= 0; cpu--) {
+		if (!state[cpu])
+			continue;
+		if (state[cpu]->first_cpu == cpu)
+			kfree(state[cpu]);
+		state[cpu] = NULL;
+	}
+
+out:
+	cpufreq_cnt--;
+	mutex_unlock(&cpufreq_reg_lock);
+	return ret;
+}
+
+/* ==================== devfreq part ==================== */
+
+static unsigned int interpolate_freq(struct devfreq *df, unsigned int cpu)
+{
+	unsigned long *freq_table = df->profile->freq_table;
+	unsigned int cpu_min = state[cpu]->min_freq;
+	unsigned int cpu_max = state[cpu]->max_freq;
+	unsigned int cpu_freq = state[cpu]->freq;
+	unsigned int dev_min, dev_max, cpu_percent;
+
+	if (freq_table) {
+		dev_min = freq_table[0];
+		dev_max = freq_table[df->profile->max_state - 1];
+	} else {
+		if (df->max_freq <= df->min_freq)
+			return 0;
+		dev_min = df->min_freq;
+		dev_max = df->max_freq;
+	}
+
+	cpu_percent = ((cpu_freq - cpu_min) * 100) / (cpu_max - cpu_min);
+	return dev_min + mult_frac(dev_max - dev_min, cpu_percent, 100);
+}
+
+static unsigned int cpu_to_dev_freq(struct devfreq *df, unsigned int cpu)
+{
+	struct freq_map *map = NULL;
+	unsigned int cpu_khz = 0, freq;
+	struct devfreq_node *n = df->data;
+
+	if (!state[cpu] || state[cpu]->first_cpu != cpu) {
+		freq = 0;
+		goto out;
+	}
+
+	if (n->common_map)
+		map = n->common_map;
+	else if (n->map)
+		map = n->map[cpu];
+
+	cpu_khz = state[cpu]->freq;
+
+	if (!map) {
+		freq = interpolate_freq(df, cpu);
+		goto out;
+	}
+
+	while (map->cpu_khz && map->cpu_khz < cpu_khz)
+		map++;
+	if (!map->cpu_khz)
+		map--;
+	freq = map->target_freq;
+
+out:
+	dev_dbg(df->dev.parent, "CPU%u: %d -> dev: %u\n", cpu, cpu_khz, freq);
+	return freq;
+}
+
+static int devfreq_cpufreq_get_freq(struct devfreq *df,
+					unsigned long *freq)
+{
+	unsigned int cpu, tgt_freq = 0;
+	struct devfreq_node *node;
+
+	node = df->data;
+	if (!node) {
+		pr_err("Unable to find devfreq node!\n");
+		return -ENODEV;
+	}
+
+	for_each_possible_cpu(cpu)
+		tgt_freq = max(tgt_freq, cpu_to_dev_freq(df, cpu));
+
+	*freq = tgt_freq;
+	return 0;
+}
+
+static unsigned int show_table(char *buf, unsigned int len,
+				struct freq_map *map)
+{
+	unsigned int cnt = 0;
+
+	cnt += snprintf(buf + cnt, len - cnt, "CPU freq\tDevice freq\n");
+
+	while (map->cpu_khz && cnt < len) {
+		cnt += snprintf(buf + cnt, len - cnt, "%8u\t%11u\n",
+				map->cpu_khz, map->target_freq);
+		map++;
+	}
+	if (cnt < len)
+		cnt += snprintf(buf + cnt, len - cnt, "\n");
+
+	return cnt;
+}
+
+static ssize_t freq_map_show(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct devfreq *df = to_devfreq(dev);
+	struct devfreq_node *n = df->data;
+	struct freq_map *map;
+	unsigned int cnt = 0, cpu;
+
+	mutex_lock(&state_lock);
+	if (n->common_map) {
+		map = n->common_map;
+		cnt += snprintf(buf + cnt, PAGE_SIZE - cnt,
+				"Common table for all CPUs:\n");
+		cnt += show_table(buf + cnt, PAGE_SIZE - cnt, map);
+	} else if (n->map) {
+		for_each_possible_cpu(cpu) {
+			map = n->map[cpu];
+			if (!map)
+				continue;
+			cnt += snprintf(buf + cnt, PAGE_SIZE - cnt,
+					"CPU %u:\n", cpu);
+			if (cnt >= PAGE_SIZE)
+				break;
+			cnt += show_table(buf + cnt, PAGE_SIZE - cnt, map);
+			if (cnt >= PAGE_SIZE)
+				break;
+		}
+	} else {
+		cnt += snprintf(buf + cnt, PAGE_SIZE - cnt,
+				"Device freq interpolated based on CPU freq\n");
+	}
+	mutex_unlock(&state_lock);
+
+	return cnt;
+}
+
+static DEVICE_ATTR_RO(freq_map);
+static struct attribute *dev_attr[] = {
+	&dev_attr_freq_map.attr,
+	NULL,
+};
+
+static struct attribute_group dev_attr_group = {
+	.name = "cpufreq-map",
+	.attrs = dev_attr,
+};
+
+static int devfreq_cpufreq_gov_start(struct devfreq *devfreq)
+{
+	int ret = 0;
+	struct devfreq_node *node;
+	bool alloc = false;
+
+	ret = register_cpufreq();
+	if (ret)
+		return ret;
+
+	ret = sysfs_create_group(&devfreq->dev.kobj, &dev_attr_group);
+	if (ret) {
+		unregister_cpufreq();
+		return ret;
+	}
+
+	mutex_lock(&state_lock);
+
+	node = find_devfreq_node(devfreq->dev.parent);
+	if (node == NULL) {
+		node = kzalloc(sizeof(struct devfreq_node), GFP_KERNEL);
+		if (!node) {
+			ret = -ENOMEM;
+			goto alloc_fail;
+		}
+		alloc = true;
+		node->dev = devfreq->dev.parent;
+		list_add_tail(&node->list, &devfreq_list);
+	}
+	node->df = devfreq;
+	node->orig_data = devfreq->data;
+	devfreq->data = node;
+
+	mutex_lock(&devfreq->lock);
+	ret = update_devfreq(devfreq);
+	mutex_unlock(&devfreq->lock);
+	if (ret) {
+		pr_err("Freq update failed!\n");
+		goto update_fail;
+	}
+
+	mutex_unlock(&state_lock);
+	return 0;
+
+update_fail:
+	devfreq->data = node->orig_data;
+	if (alloc) {
+		list_del(&node->list);
+		kfree(node);
+	}
+alloc_fail:
+	mutex_unlock(&state_lock);
+	sysfs_remove_group(&devfreq->dev.kobj, &dev_attr_group);
+	unregister_cpufreq();
+	return ret;
+}
+
+static void devfreq_cpufreq_gov_stop(struct devfreq *devfreq)
+{
+	struct devfreq_node *node = devfreq->data;
+
+	mutex_lock(&state_lock);
+	devfreq->data = node->orig_data;
+	if (node->map || node->common_map) {
+		node->df = NULL;
+	} else {
+		list_del(&node->list);
+		kfree(node);
+	}
+	mutex_unlock(&state_lock);
+
+	sysfs_remove_group(&devfreq->dev.kobj, &dev_attr_group);
+	unregister_cpufreq();
+}
+
+static int devfreq_cpufreq_ev_handler(struct devfreq *devfreq,
+					unsigned int event, void *data)
+{
+	int ret;
+
+	switch (event) {
+	case DEVFREQ_GOV_START:
+
+		ret = devfreq_cpufreq_gov_start(devfreq);
+		if (ret) {
+			pr_err("Governor start failed!\n");
+			return ret;
+		}
+		pr_debug("Enabled CPUfreq-map governor\n");
+		break;
+
+	case DEVFREQ_GOV_STOP:
+
+		devfreq_cpufreq_gov_stop(devfreq);
+		pr_debug("Disabled dev CPUfreq-map governor\n");
+		break;
+	}
+
+	return 0;
+}
+
+static struct devfreq_governor devfreq_cpufreq = {
+	.name = "cpufreq-map",
+	.get_target_freq = devfreq_cpufreq_get_freq,
+	.event_handler = devfreq_cpufreq_ev_handler,
+};
+
+#define NUM_COLS	2
+static struct freq_map *read_tbl(struct device_node *of_node, char *prop_name)
+{
+	int len, nf, i, j;
+	u32 data;
+	struct freq_map *tbl;
+
+	if (!of_find_property(of_node, prop_name, &len))
+		return NULL;
+	len /= sizeof(data);
+
+	if (len % NUM_COLS || len == 0)
+		return NULL;
+	nf = len / NUM_COLS;
+
+	tbl = kzalloc((nf + 1) * sizeof(*tbl), GFP_KERNEL);
+	if (!tbl)
+		return NULL;
+
+	for (i = 0, j = 0; i < nf; i++, j += 2) {
+		of_property_read_u32_index(of_node, prop_name, j, &data);
+		tbl[i].cpu_khz = data;
+
+		of_property_read_u32_index(of_node, prop_name, j + 1, &data);
+		tbl[i].target_freq = data;
+	}
+	tbl[i].cpu_khz = 0;
+
+	return tbl;
+}
+
+#define PROP_TARGET "target-dev"
+#define PROP_TABLE "cpu-to-dev-map"
+static int add_table_from_of(struct device_node *of_node)
+{
+	struct device_node *target_of_node;
+	struct devfreq_node *node;
+	struct freq_map *common_tbl;
+	struct freq_map **tbl_list = NULL;
+	static char prop_name[] = PROP_TABLE "-999999";
+	int cpu, ret, cnt = 0, prop_sz = ARRAY_SIZE(prop_name);
+
+	target_of_node = of_parse_phandle(of_node, PROP_TARGET, 0);
+	if (!target_of_node)
+		return -EINVAL;
+
+	node = kzalloc(sizeof(struct devfreq_node), GFP_KERNEL);
+	if (!node)
+		return -ENOMEM;
+
+	common_tbl = read_tbl(of_node, PROP_TABLE);
+	if (!common_tbl) {
+		tbl_list = kzalloc(sizeof(*tbl_list) * NR_CPUS, GFP_KERNEL);
+		if (!tbl_list) {
+			ret = -ENOMEM;
+			goto err_list;
+		}
+
+		for_each_possible_cpu(cpu) {
+			ret = snprintf(prop_name, prop_sz, "%s-%d",
+					PROP_TABLE, cpu);
+			if (ret >= prop_sz) {
+				pr_warn("More CPUs than I can handle!\n");
+				pr_warn("Skipping rest of the tables!\n");
+				break;
+			}
+			tbl_list[cpu] = read_tbl(of_node, prop_name);
+			if (tbl_list[cpu])
+				cnt++;
+		}
+	}
+	if (!common_tbl && !cnt) {
+		ret = -EINVAL;
+		goto err_tbl;
+	}
+
+	mutex_lock(&state_lock);
+	node->of_node = target_of_node;
+	node->map = tbl_list;
+	node->common_map = common_tbl;
+	list_add_tail(&node->list, &devfreq_list);
+	mutex_unlock(&state_lock);
+
+	return 0;
+err_tbl:
+	kfree(tbl_list);
+err_list:
+	kfree(node);
+	return ret;
+}
+
+static int __init devfreq_cpufreq_init(void)
+{
+	int ret;
+	struct device_node *of_par, *of_child;
+
+	of_par = of_find_node_by_name(NULL, "devfreq-cpufreq-map");
+	if (of_par) {
+		for_each_child_of_node(of_par, of_child) {
+			ret = add_table_from_of(of_child);
+			if (ret)
+				pr_err("Parsing %s failed!\n", of_child->name);
+			else
+				pr_debug("Parsed %s.\n", of_child->name);
+		}
+		of_node_put(of_par);
+	} else {
+		pr_info("No tables parsed from DT.\n");
+	}
+
+	ret = devfreq_add_governor(&devfreq_cpufreq);
+	if (ret) {
+		pr_err("cpufreq-map governor add failed!\n");
+		return ret;
+	}
+
+	return 0;
+}
+subsys_initcall(devfreq_cpufreq_init);
+
+static void __exit devfreq_cpufreq_exit(void)
+{
+	int ret, cpu;
+	struct devfreq_node *node, *tmp;
+
+	ret = devfreq_remove_governor(&devfreq_cpufreq);
+	if (ret)
+		pr_err("cpufreq-map governor remove failed!\n");
+
+	mutex_lock(&state_lock);
+	list_for_each_entry_safe(node, tmp, &devfreq_list, list) {
+		kfree(node->common_map);
+		for_each_possible_cpu(cpu)
+			kfree(node->map[cpu]);
+		kfree(node->map);
+		list_del(&node->list);
+		kfree(node);
+	}
+	mutex_unlock(&state_lock);
+}
+module_exit(devfreq_cpufreq_exit);
+
+MODULE_DESCRIPTION("devfreq gov that sets dev freq based on current CPU freq");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/devfreq/mt8183-cci-devfreq.c b/drivers/devfreq/mt8183-cci-devfreq.c
index b5d8c1ff493f..a153adee033e 100644
--- a/drivers/devfreq/mt8183-cci-devfreq.c
+++ b/drivers/devfreq/mt8183-cci-devfreq.c
@@ -17,164 +17,7 @@
 struct cci_devfreq {
 	struct devfreq *devfreq;
 	struct regulator *proc_reg;
-	unsigned long proc_reg_uV;
 	struct clk *cci_clk;
-	unsigned long freq;
-	struct notifier_block nb;
-	struct notifier_block opp_nb;
-	int cci_min_freq;
-};
-
-static int cci_devfreq_regulator_notifier(struct notifier_block *nb,
-					  unsigned long val, void *data)
-{
-	int ret;
-	struct cci_devfreq *cci_df =
-		container_of(nb, struct cci_devfreq, nb);
-
-	/* deal with reduce frequency */
-	if (val & REGULATOR_EVENT_PRE_VOLTAGE_CHANGE) {
-		struct pre_voltage_change_data *pvc_data = data;
-
-		if (pvc_data->min_uV < pvc_data->old_uV) {
-			cci_df->proc_reg_uV =
-				(unsigned long)(pvc_data->min_uV);
-			mutex_lock(&cci_df->devfreq->lock);
-			ret = update_devfreq(cci_df->devfreq);
-			if (ret)
-				pr_err("Fail to reduce cci frequency: %d\n",
-				       ret);
-			mutex_unlock(&cci_df->devfreq->lock);
-		}
-	} else if ((val & REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE) &&
-	    ((unsigned long)data > cci_df->proc_reg_uV)) {
-		cci_df->proc_reg_uV = (unsigned long)data;
-		mutex_lock(&cci_df->devfreq->lock);
-		ret = update_devfreq(cci_df->devfreq);
-		if (ret)
-			pr_err("Fail to raise cci frequency back: %d\n", ret);
-		mutex_unlock(&cci_df->devfreq->lock);
-	} else if ((val & REGULATOR_EVENT_VOLTAGE_CHANGE) &&
-	    (cci_df->proc_reg_uV < (unsigned long)data)) {
-		/* deal with increase frequency */
-		cci_df->proc_reg_uV = (unsigned long)data;
-		mutex_lock(&cci_df->devfreq->lock);
-		ret = update_devfreq(cci_df->devfreq);
-		if (ret)
-			pr_err("Fail to raise cci frequency: %d\n", ret);
-		mutex_unlock(&cci_df->devfreq->lock);
-	}
-
-	return 0;
-}
-
-static int ccidevfreq_opp_notifier(struct notifier_block *nb,
-unsigned long event, void *data)
-{
-	int ret;
-	struct dev_pm_opp *opp = data;
-	struct cci_devfreq *cci_df = container_of(nb, struct cci_devfreq,
-						  opp_nb);
-	unsigned long	freq, volt, cur_volt;
-
-	if (event == OPP_EVENT_ADJUST_VOLTAGE) {
-		freq = dev_pm_opp_get_freq(opp);
-		/* current opp item is changed */
-		if (freq == cci_df->freq) {
-			volt = dev_pm_opp_get_voltage(opp);
-			cur_volt = regulator_get_voltage(cci_df->proc_reg);
-
-			if (volt > cur_volt) {
-				/* need reduce freq */
-				mutex_lock(&cci_df->devfreq->lock);
-				ret = update_devfreq(cci_df->devfreq);
-				if (ret)
-					pr_err("Fail to reduce cci frequency by opp notification: %d\n",
-					       ret);
-				mutex_unlock(&cci_df->devfreq->lock);
-			}
-		}
-
-		if (freq == cci_df->cci_min_freq) {
-			volt = dev_pm_opp_get_voltage(opp);
-			regulator_set_voltage(cci_df->proc_reg, volt, INT_MAX);
-		}
-	} else if (event == OPP_EVENT_DISABLE) {
-	}
-
-	return 0;
-}
-
-
-static int mtk_cci_governor_get_target(struct devfreq *devfreq,
-				       unsigned long *freq)
-{
-	struct cci_devfreq *cci_df;
-	struct dev_pm_opp *opp;
-	int ret;
-
-	cci_df = dev_get_drvdata(devfreq->dev.parent);
-
-	/* find available frequency */
-	opp = dev_pm_opp_find_freq_ceil_by_volt(devfreq->dev.parent,
-						cci_df->proc_reg_uV);
-	ret = PTR_ERR_OR_ZERO(opp);
-	if (ret) {
-		pr_err("%s[%d], cannot find opp with voltage=%lu: %d\n",
-		       __func__, __LINE__, cci_df->proc_reg_uV, ret);
-		return ret;
-	}
-	*freq = dev_pm_opp_get_freq(opp);
-
-	return 0;
-}
-
-static int mtk_cci_governor_event_handler(struct devfreq *devfreq,
-					  unsigned int event, void *data)
-{
-	int ret;
-	struct cci_devfreq *cci_df;
-	struct notifier_block *nb;
-	struct notifier_block *opp_nb;
-
-	cci_df = dev_get_drvdata(devfreq->dev.parent);
-	nb = &cci_df->nb;
-	opp_nb = &cci_df->opp_nb;
-
-	switch (event) {
-	case DEVFREQ_GOV_START:
-	case DEVFREQ_GOV_RESUME:
-		nb->notifier_call = cci_devfreq_regulator_notifier;
-		ret = regulator_register_notifier(cci_df->proc_reg,
-						  nb);
-		if (ret)
-			pr_err("%s: failed to add governor: %d\n", __func__,
-			       ret);
-		opp_nb->notifier_call = ccidevfreq_opp_notifier;
-		dev_pm_opp_register_notifier(devfreq->dev.parent, opp_nb);
-		break;
-
-	case DEVFREQ_GOV_STOP:
-	case DEVFREQ_GOV_SUSPEND:
-		ret = regulator_unregister_notifier(cci_df->proc_reg,
-						    nb);
-		if (ret)
-			pr_err("%s: failed to add governor: %d\n", __func__,
-			       ret);
-		break;
-
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static struct devfreq_governor mtk_cci_devfreq_governor = {
-	.name = "mtk_cci_vmon",
-	.get_target_freq = mtk_cci_governor_get_target,
-	.event_handler = mtk_cci_governor_event_handler,
-	.immutable = true
 };
 
 static int mtk_cci_devfreq_target(struct device *dev, unsigned long *freq,
@@ -193,8 +36,6 @@ static int mtk_cci_devfreq_target(struct device *dev, unsigned long *freq,
 		return ret;
 	}
 
-	cci_df->freq = *freq;
-
 	return 0;
 }
 
@@ -206,8 +47,6 @@ static int mtk_cci_devfreq_probe(struct platform_device *pdev)
 {
 	struct device *cci_dev = &pdev->dev;
 	struct cci_devfreq *cci_df;
-	unsigned long freq, volt;
-	struct dev_pm_opp *opp;
 	int ret;
 
 	cci_df = devm_kzalloc(cci_dev, sizeof(*cci_df), GFP_KERNEL);
@@ -237,19 +76,12 @@ static int mtk_cci_devfreq_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	/* set voltage lower bound */
-	freq = 1;
-	opp = dev_pm_opp_find_freq_ceil(cci_dev, &freq);
-	cci_df->cci_min_freq = dev_pm_opp_get_freq(opp);
-	volt = dev_pm_opp_get_voltage(opp);
-	dev_pm_opp_put(opp);
-
 	platform_set_drvdata(pdev, cci_df);
 
 	cci_df->devfreq = devm_devfreq_add_device(cci_dev,
-						  &cci_devfreq_profile,
-						  "mtk_cci_vmon",
-						  NULL);
+						&cci_devfreq_profile,
+						"cpufreq-map",
+						NULL);
 	if (IS_ERR(cci_df->devfreq)) {
 		ret = PTR_ERR(cci_df->devfreq);
 		dev_err(cci_dev, "cannot create cci devfreq device:%d\n", ret);
@@ -277,30 +109,12 @@ static struct platform_driver cci_devfreq_driver = {
 
 static int __init mtk_cci_devfreq_init(void)
 {
-	int ret;
-
-	ret = devfreq_add_governor(&mtk_cci_devfreq_governor);
-	if (ret) {
-		pr_err("%s: failed to add governor: %d\n", __func__, ret);
-		return ret;
-	}
-
-	ret = platform_driver_register(&cci_devfreq_driver);
-	if (ret)
-		devfreq_remove_governor(&mtk_cci_devfreq_governor);
-
-	return ret;
+	return platform_driver_register(&cci_devfreq_driver);
 }
 module_init(mtk_cci_devfreq_init)
 
 static void __exit mtk_cci_devfreq_exit(void)
 {
-	int ret;
-
-	ret = devfreq_remove_governor(&mtk_cci_devfreq_governor);
-	if (ret)
-		pr_err("%s: failed to remove governor: %d\n", __func__, ret);
-
 	platform_driver_unregister(&cci_devfreq_driver);
 }
 module_exit(mtk_cci_devfreq_exit)
diff --git a/drivers/gpu/drm/bridge/Kconfig b/drivers/gpu/drm/bridge/Kconfig
index 9c9c4df1a1cf..751c25f3cc9f 100644
--- a/drivers/gpu/drm/bridge/Kconfig
+++ b/drivers/gpu/drm/bridge/Kconfig
@@ -43,6 +43,13 @@ config DRM_DUMB_VGA_DAC
 	  Support for non-programmable RGB to VGA DAC bridges, such as ADI
 	  ADV7123, TI THS8134 and THS8135 or passive resistor ladder DACs.
 
+config DRM_ITE_IT6505
+	tristate "ITE IT6505 DP bridge"
+	depends on OF
+	select DRM_KMS_HELPER
+	help
+	  ITE IT6505 DP bridge chip driver.
+
 config DRM_LVDS_ENCODER
 	tristate "Transparent parallel to LVDS encoder support"
 	depends on OF
diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index 4934fcf5a6f8..f5abca593f71 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -2,6 +2,7 @@
 obj-$(CONFIG_DRM_ANALOGIX_ANX78XX) += analogix-anx78xx.o
 obj-$(CONFIG_DRM_CDNS_DSI) += cdns-dsi.o
 obj-$(CONFIG_DRM_DUMB_VGA_DAC) += dumb-vga-dac.o
+obj-$(CONFIG_DRM_ITE_IT6505) += ite-it6505.o
 obj-$(CONFIG_DRM_LVDS_ENCODER) += lvds-encoder.o
 obj-$(CONFIG_DRM_MEGACHIPS_STDPXXXX_GE_B850V3_FW) += megachips-stdpxxxx-ge-b850v3-fw.o
 obj-$(CONFIG_DRM_NXP_PTN3460) += nxp-ptn3460.o
diff --git a/drivers/gpu/drm/bridge/ite-it6505.c b/drivers/gpu/drm/bridge/ite-it6505.c
new file mode 100644
index 000000000000..8ffd0fc9dc0e
--- /dev/null
+++ b/drivers/gpu/drm/bridge/ite-it6505.c
@@ -0,0 +1,2612 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ */
+#include <linux/bits.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/extcon.h>
+#include <linux/fs.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/semaphore.h>
+#include <linux/types.h>
+
+#include <crypto/hash.h>
+#include <crypto/sha.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_dp_helper.h>
+#include <drm/drm_edid.h>
+
+#define AX 0
+#define BX 1
+#define AUDSEL I2S
+#define AUDTYPE LPCM
+#define AUDFS AUD48K
+#define AUDCH 2
+/* 0: Standard I2S;1: 32bit I2S */
+#define I2SINPUTFMT 1
+/* 0: Left-justified;1: Right-justified */
+#define I2SJUSTIFIED 0
+/* 0: Data delay 1T correspond to WS;1: No data delay correspond to WS */
+#define I2SDATADELAY 0
+/* 0: is left channel;1: is right channel */
+#define I2SWSCHANNEL 0
+/* 0: MSB shift first;1: LSB shift first */
+#define I2SDATASEQ 0
+
+#define LANESWAP 0
+#define LANE 4
+#define _HBR 1
+#define ENHFRAME 1
+#define ENSSC 1
+#define FLAGTRAINDOWN 100
+#define TRAINFAILCNT 5
+#define TRAINFAILHPD 3
+#define AUX_WAIT_TIMEOUT_MS 15
+#define PCLK_DELAY 1
+#define PCLK_INV 0
+#define EDIDRETRYTIME 5
+#define SHOWVIDEOTIMING 2
+#define PWROFFRETRYTIME 5
+
+/* AX or BX */
+#define CHIP_VERSION BX
+
+enum sys_status {
+	SYS_UNPLUG = 0,
+	SYS_HPD,
+	SYS_AUTOTRAIN,
+	SYS_WAIT,
+	SYS_TRAINFAIL,
+	SYS_ReHDCP,
+	SYS_PWRDN,
+	SYS_NOROP,
+	SYS_Unknown,
+};
+
+enum it6505_aud_sel {
+	I2S = 0,
+	SPDIF,
+};
+
+enum it6505_aud_fs {
+	AUD24K = 0x6,
+	AUD32K = 0x3,
+	AUD48K = 0x2,
+	AUD96K = 0xA,
+	AUD192K = 0xE,
+	AUD44P1K = 0x0,
+	AUD88P2K = 0x8,
+	AUD176P4K = 0xC,
+};
+
+enum it6505_aud_type {
+	LPCM = 0,
+	NLPCM,
+	DSS,
+	HBR,
+};
+
+enum aud_word_length {
+	AUD16BIT = 0,
+	AUD18BIT,
+	AUD20BIT,
+	AUD24BIT,
+};
+
+/* Audio Sample Word Length: AUD16BIT, AUD18BIT, AUD20BIT, AUD24BIT */
+#define AUDWORDLENGTH AUD24BIT
+
+struct it6505_platform_data {
+	struct regulator *pwr18;
+	struct regulator *ovdd;
+	struct gpio_desc *gpiod_hpd;
+	struct gpio_desc *gpiod_reset;
+};
+
+struct it6505_dp_port {
+	struct it6505 *it6505_dp;
+	struct notifier_block event_nb;
+	struct extcon_dev *extcon;
+	struct work_struct extcon_wq;
+};
+
+struct it6505 {
+	struct drm_dp_aux aux;
+	struct drm_bridge bridge;
+	struct i2c_client *client;
+	struct edid *edid;
+	struct drm_connector connector;
+	struct drm_dp_link link;
+	struct it6505_platform_data pdata;
+	struct mutex lock;
+	struct regmap *regmap;
+	struct it6505_dp_port *port;
+	struct drm_display_mode vid_info;
+	/* thread sequence control */
+	struct semaphore sem_notifier;
+
+	u8 dpcd[DP_RECEIVER_CAP_SIZE];
+	enum sys_status status;
+	u8 dumpdpcd[30];
+	bool hbr;
+	u8 lane;
+	u8 en_ssc;
+	bool en_hframe;
+	bool laneswap;
+
+	enum it6505_aud_sel aud_sel;
+	enum it6505_aud_fs aud_fs;
+	enum it6505_aud_type aud_type;
+	u8 aud_ch;
+	u8 i2s_input_fmt;
+	u8 i2s_justified;
+	u8 i2s_data_delay;
+	u8 i2s_ws_channel;
+	u8 i2s_data_seq;
+	u8 vidstable_done;
+	enum aud_word_length audwordlength;
+	unsigned int en_hdcp;
+	unsigned int en_pwronoff;
+	unsigned int en_audio;
+	u8 cntfsm;
+	u8 train_fail_hpd;
+	bool cp_capable;
+	unsigned int bstatus;
+	bool cp_done;
+	u8 downstream_repeater;
+	u8 am0[8];
+	u8 binfo[2];
+	u8 ksvlist[5 * 12];
+	u8 shainput[64];
+	u8 av[5][4];
+	u8 bv[5][4];
+	bool powered;
+	/* it6505 driver hold option */
+	unsigned int it6505_drv_hold;
+};
+
+static int it6505_poweron(struct it6505 *it6505);
+static int it6505_poweroff(struct it6505 *it6505);
+static void it6505_int_mask_off(struct it6505 *it6505);
+
+static const struct regmap_range it6505_bridge_volatile_ranges[] = {
+	{ .range_min = 0, .range_max = 0xFF },
+};
+
+static const struct regmap_access_table it6505_bridge_volatile_table = {
+	.yes_ranges = it6505_bridge_volatile_ranges,
+	.n_yes_ranges = ARRAY_SIZE(it6505_bridge_volatile_ranges),
+};
+
+static const struct regmap_config it6505_bridge_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.volatile_table = &it6505_bridge_volatile_table,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int dptxrd(struct it6505 *it6505, unsigned int reg_addr,
+		  unsigned int *value)
+{
+	int err;
+	struct device *dev = &it6505->client->dev;
+
+	err = regmap_read(it6505->regmap, reg_addr, value);
+	if (err < 0) {
+		DRM_DEV_ERROR(dev, "read failed reg[0x%x] err: %d", reg_addr,
+			      err);
+		return err;
+	}
+
+	return 0;
+}
+
+static void it6505_dump(struct it6505 *it6505)
+{
+	unsigned int value[16], i, j;
+	struct device *dev = &it6505->client->dev;
+
+	for (i = 0; i <= 0xff; i += 16) {
+		for (j = 0; j < 16; j++)
+			dptxrd(it6505, i + j, value + j);
+		DRM_DEV_DEBUG_DRIVER(dev, "[0x%02x] = %16ph", i, value);
+	}
+}
+
+static int dptxwr(struct it6505 *it6505, unsigned int reg_addr,
+		  unsigned int reg_val)
+{
+	int err;
+	struct device *dev = &it6505->client->dev;
+
+	err = regmap_write(it6505->regmap, reg_addr, reg_val);
+
+	if (err < 0) {
+		DRM_DEV_ERROR(dev, "write failed reg[0x%x] = 0x%x err = %d",
+			      reg_addr, reg_val, err);
+		return err;
+	}
+
+	return 0;
+}
+
+static int dptxset(struct it6505 *it6505, unsigned int reg, unsigned int mask,
+		   unsigned int value)
+{
+	int err;
+	struct device *dev = &it6505->client->dev;
+
+	err = regmap_update_bits(it6505->regmap, reg, mask, value);
+	if (err < 0) {
+		DRM_DEV_ERROR(
+			dev, "write reg[0x%x] = 0x%x mask = 0x%x failed err %d",
+			reg, value, mask, err);
+		return err;
+	}
+
+	return 0;
+}
+
+static inline struct it6505 *connector_to_it6505(struct drm_connector *c)
+{
+	return container_of(c, struct it6505, connector);
+}
+
+static inline struct it6505 *bridge_to_it6505(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct it6505, bridge);
+}
+
+static void it6505_init_fsm(struct it6505 *it6505)
+{
+	it6505->en_audio = 1;
+	it6505->aud_sel = AUDSEL;
+	it6505->aud_fs = AUDFS;
+	it6505->aud_ch = AUDCH;
+	it6505->aud_type = AUDTYPE;
+	it6505->i2s_input_fmt = I2SINPUTFMT;
+	it6505->i2s_justified = I2SJUSTIFIED;
+	it6505->i2s_data_delay = I2SDATADELAY;
+	it6505->i2s_ws_channel = I2SWSCHANNEL;
+	it6505->i2s_data_seq = I2SDATASEQ;
+	it6505->audwordlength = AUDWORDLENGTH;
+
+	it6505->status = SYS_Unknown;
+	it6505->hbr = _HBR;
+	it6505->lane = LANE;
+	it6505->en_ssc = ENSSC;
+	it6505->en_hframe = ENHFRAME;
+	it6505->en_hdcp = 1;
+	it6505->laneswap = LANESWAP;
+	it6505->vidstable_done = 0;
+}
+
+static void it6505_termination_on(struct it6505 *it6505)
+{
+#if (CHIP_VERSION == BX)
+	dptxset(it6505, 0x5D, 0x80, 0x00);
+	dptxset(it6505, 0x5E, 0x02, 0x02);
+#endif
+}
+
+static void it6505_termination_off(struct it6505 *it6505)
+{
+#if (CHIP_VERSION == BX)
+	dptxset(it6505, 0x5D, 0x80, 0x80);
+	dptxset(it6505, 0x5E, 0x02, 0x00);
+	dptxset(it6505, 0x5C, 0xF0, 0x00);
+#endif
+}
+
+static bool dptx_getsinkhpd(struct it6505 *it6505)
+{
+	unsigned int value;
+	int ret;
+
+	ret = dptxrd(it6505, 0x0D, &value);
+
+	if (ret < 0)
+		return false;
+
+	return (value & 2) == 2;
+}
+
+static void show_vid_info(struct it6505 *it6505)
+{
+	int hsync_pol, vsync_pol, interlaced;
+	int htotal, hdes, hdew, hfph, hsyncw;
+	int vtotal, vdes, vdew, vfph, vsyncw;
+	int rddata, rddata1, i;
+	int pclk, sum;
+
+	usleep_range(10000, 15000);
+	dptxwr(it6505, 0x0F, 0x00);
+	dptxrd(it6505, 0xa0, &rddata);
+	hsync_pol = rddata & BIT(0);
+	vsync_pol = (rddata & BIT(2)) >> 2;
+	interlaced = (rddata & BIT(4)) >> 4;
+
+	dptxrd(it6505, 0xa1, &rddata);
+	dptxrd(it6505, 0xa2, &rddata1);
+	htotal = ((rddata1 & 0x1F) << 8) + rddata;
+
+	dptxrd(it6505, 0xa3, &rddata);
+	dptxrd(it6505, 0xa4, &rddata1);
+
+	hdes = ((rddata1 & 0x1F) << 8) + rddata;
+
+	dptxrd(it6505, 0xa5, &rddata);
+	dptxrd(it6505, 0xa6, &rddata1);
+
+	hdew = ((rddata1 & 0x1F) << 8) + rddata;
+
+	dptxrd(it6505, 0xa7, &rddata);
+	dptxrd(it6505, 0xa8, &rddata1);
+
+	hfph = ((rddata1 & 0x1F) << 8) + rddata;
+
+	dptxrd(it6505, 0xa9, &rddata);
+	dptxrd(it6505, 0xaa, &rddata1);
+
+	hsyncw = ((rddata1 & 0x1F) << 8) + rddata;
+
+	dptxrd(it6505, 0xab, &rddata);
+	dptxrd(it6505, 0xac, &rddata1);
+	vtotal = ((rddata1 & 0x0F) << 8) + rddata;
+
+	dptxrd(it6505, 0xad, &rddata);
+	dptxrd(it6505, 0xae, &rddata1);
+	vdes = ((rddata1 & 0x0F) << 8) + rddata;
+
+	dptxrd(it6505, 0xaf, &rddata);
+	dptxrd(it6505, 0xb0, &rddata1);
+	vdew = ((rddata1 & 0x0F) << 8) + rddata;
+
+	dptxrd(it6505, 0xb1, &rddata);
+	dptxrd(it6505, 0xb2, &rddata1);
+	vfph = ((rddata1 & 0x0F) << 8) + rddata;
+
+	dptxrd(it6505, 0xb3, &rddata);
+	dptxrd(it6505, 0xb4, &rddata1);
+	vsyncw = ((rddata1 & 0x0F) << 8) + rddata;
+
+	sum = 0;
+	for (i = 0; i < 100; i++) {
+		dptxset(it6505, 0x12, 0x80, 0x80);
+		usleep_range(10000, 15000);
+		dptxset(it6505, 0x12, 0x80, 0x00);
+
+		dptxrd(it6505, 0x13, &rddata);
+		dptxrd(it6505, 0x14, &rddata1);
+		rddata = ((rddata1 & 0x0F) << 8) + rddata;
+
+		sum += rddata;
+	}
+
+	sum /= 100;
+	pclk = 13500 * 2048 / sum;
+	it6505->vid_info.clock = pclk;
+	it6505->vid_info.hdisplay = hdew;
+	it6505->vid_info.hsync_start = hdew + hfph;
+	it6505->vid_info.hsync_end = hdew + hfph + hsyncw;
+	it6505->vid_info.htotal = htotal;
+	it6505->vid_info.vdisplay = vdew;
+	it6505->vid_info.vsync_start = vdew + vfph;
+	it6505->vid_info.vsync_end = vdew + vfph + vsyncw;
+	it6505->vid_info.vtotal = vtotal;
+	it6505->vid_info.vrefresh = pclk / htotal / vtotal;
+
+	DRM_DEV_DEBUG_DRIVER(&it6505->client->dev, DRM_MODE_FMT,
+			     DRM_MODE_ARG(&it6505->vid_info));
+}
+
+static void dptx_sys_chg(struct it6505 *it6505, enum sys_status newstate)
+{
+	unsigned int i = 0;
+	struct device *dev = &it6505->client->dev;
+
+	if (newstate != SYS_UNPLUG) {
+		if (!dptx_getsinkhpd(it6505))
+			newstate = SYS_UNPLUG;
+	}
+
+	it6505->status = newstate;
+
+	switch (it6505->status) {
+	case SYS_UNPLUG:
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "sys_state is changing to SYS_UNPLUG!");
+		kfree(it6505->edid);
+		it6505->edid = NULL;
+		DRM_DEV_DEBUG_DRIVER(dev, "Free it6505 EDID memory");
+		it6505_int_mask_off(it6505);
+		it6505_termination_off(it6505);
+		break;
+	case SYS_HPD:
+		DRM_DEV_DEBUG_DRIVER(dev, "sys_state is changing to SYS_HPD!");
+		it6505_termination_on(it6505);
+		break;
+	case SYS_AUTOTRAIN:
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "sys_state is changing to SYS_AUTOTRAIN!");
+		break;
+	case SYS_WAIT:
+		DRM_DEV_DEBUG_DRIVER(dev, "sys_state is changing to SYS_WAIT!");
+		break;
+	case SYS_ReHDCP:
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "sys_state is changing to SYS_ReHDCP!");
+		break;
+	case SYS_NOROP:
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "sys_state is changing to SYS_NOROP!");
+		for (i = 0; i < SHOWVIDEOTIMING; i++)
+			show_vid_info(it6505);
+		break;
+	case SYS_TRAINFAIL:
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "sys_state is changing to SYS_TRAINFAIL!");
+		/* it6505 goes to idle */
+		break;
+	default:
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "sys_state is changing to SYS_UNKNOWN!");
+		break;
+	}
+}
+
+static bool it6505_aux_op_finished(struct it6505 *it6505)
+{
+	unsigned int value;
+	int err;
+
+	err = regmap_read(it6505->regmap, 0x2b, &value);
+	if (err < 0)
+		return false;
+
+	return (value & BIT(5)) == 0;
+}
+
+static int dptx_auxwait(struct it6505 *it6505)
+{
+	unsigned int status;
+	unsigned long timeout;
+	int err;
+	struct device *dev = &it6505->client->dev;
+
+	timeout = jiffies + msecs_to_jiffies(AUX_WAIT_TIMEOUT_MS) + 1;
+
+	while (!it6505_aux_op_finished(it6505)) {
+		if (time_after(jiffies, timeout)) {
+			DRM_DEV_ERROR(dev, "Timed out waiting AUX to finish");
+			return -ETIMEDOUT;
+		}
+		usleep_range(1000, 2000);
+	}
+
+	err = dptxrd(it6505, 0x9f, &status);
+	if (err < 0) {
+		DRM_DEV_ERROR(dev, "Failed to read AUX channel: %d", err);
+		return err;
+	}
+
+	if (status & 0x03) {
+		DRM_DEV_ERROR(dev, "Failed to wait for AUX (status: 0x%x)",
+			      status);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int dptx_aux_r_edid(struct it6505 *it6505, unsigned int nosegw,
+			   unsigned int block, unsigned int offset)
+{
+	unsigned int value, status;
+	int ret;
+	struct device *dev = &it6505->client->dev;
+
+	/* enable pc aux access */
+	dptxwr(it6505, 0x23, (nosegw << 6) + 0x03);
+	/* edid fifo clr */
+	dptxwr(it6505, 0x23, (nosegw << 6) + 0x82);
+	/* start address[7:0] */
+	dptxwr(it6505, 0x24, (block % 2) * 128 + offset);
+	/* start address[15:8] */
+	dptxwr(it6505, 0x25, block / 256);
+	/* writenum[3:0]+startadr[19:16] */
+	dptxwr(it6505, 0x26, 0xf0);
+	/* aux edid read fire */
+	dptxwr(it6505, 0x2b, 0x0b);
+	dptx_auxwait(it6505);
+
+	ret = dptxrd(it6505, 0x07, &value);
+	if (ret)
+		return ret;
+
+	if (value & BIT(0)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "aux channel request fail interrupt");
+
+		ret = dptxrd(it6505, 0x9f, &status);
+		if (ret) {
+			DRM_DEV_DEBUG_DRIVER(dev, "AUX channel failed: %d",
+					     ret);
+			return ret;
+		}
+
+		switch ((status & 0xc0) >> 6) {
+		case 0:
+			DRM_DEV_DEBUG_DRIVER(dev, "no error !!!");
+			return 0;
+		case 1:
+			DRM_DEV_DEBUG_DRIVER(
+				dev, "defer > 7 times status: 0x%x!", status);
+			return -ETIMEDOUT;
+
+		case 2:
+			DRM_DEV_DEBUG_DRIVER(dev, "Nack response status: 0x%x!",
+					     status);
+			return -ETIMEDOUT;
+
+		default:
+			DRM_DEV_DEBUG_DRIVER(dev, "timeout status: 0x%x!",
+					     status);
+			return -ETIMEDOUT;
+		}
+	}
+	return 0;
+}
+
+static int dptx_get_edidblock(struct it6505 *it6505, u8 *pedidbuff,
+			      unsigned int blockno, unsigned int *chk)
+{
+	ushort i;
+	unsigned int offset, value, reg0d;
+	struct device *dev = &it6505->client->dev;
+
+	if (pedidbuff == NULL)
+		return -ENOMEM;
+
+	dptxset(it6505, 0x05, 0x08, 0x08);
+	dptxset(it6505, 0x05, 0x08, 0x00);
+	DRM_DEV_DEBUG_DRIVER(dev, "blocknum = %d", blockno);
+	for (offset = 0; offset < 0x80; offset += 8) {
+		dptxrd(it6505, 0x0D, &reg0d);
+		if (!(reg0d & BIT(1))) {
+			dptx_sys_chg(it6505, SYS_UNPLUG);
+			return -ENXIO;
+		}
+		dptx_aux_r_edid(it6505, 1, blockno, offset);
+
+		for (i = 0; i < 8; i++) {
+			dptxrd(it6505, 0x2f, &value);
+			pedidbuff[offset + i] = value;
+		}
+		DRM_DEV_DEBUG_DRIVER(dev, "[0x%02x]: %8ph", offset,
+				     pedidbuff + offset);
+	}
+	/* disable pc aux access */
+	dptxwr(it6505, 0x23, 1 << 6);
+
+	*chk = 0;
+	for (i = 0; i < 0x80; i++)
+		*chk += pedidbuff[i];
+
+	*chk &= 0xff;
+
+	return 0;
+}
+
+static int it6505_get_extension_num(struct it6505 *it6505, u8 *block)
+{
+	unsigned int checksum = 0, retrytime = 0, reg0d;
+	int err;
+	u8 buff[EDID_LENGTH];
+	struct device *dev = &it6505->client->dev;
+
+	do {
+		dptxrd(it6505, 0x0D, &reg0d);
+		if (!(reg0d & BIT(1))) {
+			dptx_sys_chg(it6505, SYS_UNPLUG);
+			return -ENXIO;
+		}
+		err = dptx_get_edidblock(it6505, buff, 0, &checksum);
+		if (err < 0)
+			return err;
+		retrytime++;
+		DRM_DEV_DEBUG_DRIVER(dev, "read EDID %d time", retrytime);
+	} while (checksum != 0 && retrytime < EDIDRETRYTIME);
+
+	if (checksum)
+		return -EINVAL;
+	*block = buff[0x7e];
+	DRM_DEV_DEBUG_DRIVER(dev, "extension number: %d", *block);
+	return 0;
+}
+
+static struct edid *it6505_get_edid(struct it6505 *it6505)
+{
+	unsigned int checksum = 0, retrytime = 0;
+	unsigned int i, reg0d, total_size;
+	u8 block;
+	u8 *pedidbuff = kmalloc(EDID_LENGTH, GFP_KERNEL);
+	u8 *pedidbuff1;
+	struct device *dev = &it6505->client->dev;
+
+	if (!pedidbuff)
+		return NULL;
+
+	it6505_dump(it6505);
+	if (it6505_get_extension_num(it6505, &block) < 0)
+		return NULL;
+	/* dp does not have the hdmi tx four block test requirement */
+	if (block > 2)
+		block = 2;
+
+	total_size = (block + 1) * EDID_LENGTH;
+	if (total_size > EDID_LENGTH) {
+		pedidbuff1 = krealloc(pedidbuff, total_size, GFP_KERNEL);
+		if (!pedidbuff1) {
+			kfree(pedidbuff);
+			return NULL;
+		}
+		pedidbuff = pedidbuff1;
+	}
+
+	for (i = 0; i <= block; i++) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Read block 0x%x", i);
+		retrytime = 0;
+		do {
+			dptxrd(it6505, 0x0D, &reg0d);
+			if (!(reg0d & BIT(1))) {
+				dptx_sys_chg(it6505, SYS_UNPLUG);
+				kfree(pedidbuff);
+				return NULL;
+			}
+			if (dptx_get_edidblock(it6505,
+					       pedidbuff + i * EDID_LENGTH, i,
+					       &checksum) < 0)
+				return NULL;
+			DRM_DEV_DEBUG_DRIVER(dev, "%s in block %d %s!",
+					     checksum ? "Fake" : "True", i,
+					     checksum ? "and read again" : "");
+			retrytime++;
+			DRM_DEV_DEBUG_DRIVER(dev, "read EDID %d time",
+					     retrytime);
+		} while (checksum != 0 && retrytime < EDIDRETRYTIME);
+		if (checksum) {
+			kfree(pedidbuff);
+			return NULL;
+		}
+	}
+	return (struct edid *)pedidbuff;
+}
+
+static int it6505_get_modes(struct drm_connector *connector)
+{
+	struct it6505 *ctx = connector_to_it6505(connector);
+	int err, num_modes = 0;
+	unsigned int reg9f, reg0d;
+	struct device *dev = &ctx->client->dev;
+
+	err = it6505_poweron(ctx);
+	if (err) {
+		DRM_DEV_ERROR(dev, "power on fail");
+		goto unlock;
+	}
+	ctx->train_fail_hpd = TRAINFAILHPD;
+	if (ctx->edid)
+		return drm_add_edid_modes(connector, ctx->edid);
+	mutex_lock(&ctx->lock);
+	dptxrd(ctx, 0x0D, &reg0d);
+	if (reg0d & BIT(1))
+		dptx_sys_chg(ctx, SYS_HPD);
+	else
+		dptx_sys_chg(ctx, SYS_UNPLUG);
+
+	dptxrd(ctx, 0x9F, &reg9f);
+	DRM_DEV_DEBUG_DRIVER(dev, "Aux status reg9F = 0x%02x", reg9f);
+	ctx->edid = it6505_get_edid(ctx);
+	if (!ctx->edid) {
+		DRM_DEV_ERROR(dev, "Failed to read EDID");
+		goto unlock;
+	}
+
+	err = drm_connector_update_edid_property(connector, ctx->edid);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to update EDID property: %d", err);
+		goto unlock;
+	}
+
+	num_modes = drm_add_edid_modes(connector, ctx->edid);
+
+unlock:
+	mutex_unlock(&ctx->lock);
+
+	return num_modes;
+}
+
+static const struct drm_connector_helper_funcs it6505_connector_helper_funcs = {
+	.get_modes = it6505_get_modes,
+};
+
+static enum drm_connector_status it6505_detect(struct drm_connector *connector,
+					       bool force)
+{
+	struct it6505 *ctx = connector_to_it6505(connector);
+
+	if (gpiod_get_value(ctx->pdata.gpiod_hpd))
+		return connector_status_disconnected;
+
+	return connector_status_connected;
+}
+
+static const struct drm_connector_funcs it6505_connector_funcs = {
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.detect = it6505_detect,
+	.destroy = drm_connector_cleanup,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static ssize_t it6505_aux_transfer(struct drm_dp_aux *aux,
+				   struct drm_dp_aux_msg *msg)
+{
+	return 0;
+}
+
+static int it6505_extcon_notifier(struct notifier_block *self,
+				  unsigned long event, void *ptr)
+{
+	struct it6505_dp_port *port =
+		container_of(self, struct it6505_dp_port, event_nb);
+
+	schedule_work(&port->extcon_wq);
+	return NOTIFY_DONE;
+}
+
+static void it6505_extcon_work(struct work_struct *work)
+{
+	struct it6505_dp_port *port =
+		container_of(work, struct it6505_dp_port, extcon_wq);
+	struct it6505 *ctx = port->it6505_dp;
+	int reg06;
+	int state = extcon_get_state(port->extcon, EXTCON_DISP_DP);
+	unsigned int pwroffretry = 0;
+	struct device *dev = &ctx->client->dev;
+
+	if (dptxrd(ctx, 0x06, &reg06) < 0)
+		goto no_power;
+	if (!(reg06 & BIT(0))) {
+		DRM_DEV_DEBUG_DRIVER(dev, "no extcon event and return");
+		return;
+	}
+no_power:
+	down(&ctx->sem_notifier);
+	DRM_DEV_DEBUG_DRIVER(dev, "EXTCON_DISP_DP = %d", state);
+	if (state > 0) {
+		DRM_DEV_DEBUG_DRIVER(dev, "start to power on");
+		it6505_poweron(ctx);
+		drm_helper_hpd_irq_event(ctx->connector.dev);
+	} else {
+		drm_helper_hpd_irq_event(ctx->connector.dev);
+		if (ctx->en_pwronoff) {
+			DRM_DEV_DEBUG_DRIVER(dev, "start to power off");
+			while (it6505_poweroff(ctx) &&
+			       pwroffretry++ < PWROFFRETRYTIME) {
+				DRM_DEV_DEBUG_DRIVER(dev,
+						     "power off fail %d times",
+						     pwroffretry);
+			}
+			DRM_DEV_DEBUG_DRIVER(dev, "power off it6505 success!");
+		}
+	}
+	up(&ctx->sem_notifier);
+}
+
+static int it6505_use_notifier_module(struct it6505 *ctx)
+{
+	struct it6505_dp_port *port = ctx->port;
+	int ret;
+	struct device *dev = &ctx->client->dev;
+
+	port->event_nb.notifier_call = it6505_extcon_notifier;
+	INIT_WORK(&port->extcon_wq, it6505_extcon_work);
+	ret = devm_extcon_register_notifier(&ctx->client->dev, port->extcon,
+					    EXTCON_DISP_DP, &port->event_nb);
+	if (ret) {
+		DRM_DEV_ERROR(dev, "failed to register notifier for DP");
+		return ret;
+	}
+	return 0;
+}
+
+static int it6505_bridge_attach(struct drm_bridge *bridge)
+{
+	struct it6505 *ctx = bridge_to_it6505(bridge);
+	struct device *dev;
+	int err;
+
+	dev = &ctx->client->dev;
+	if (!bridge->encoder) {
+		DRM_DEV_ERROR(dev, "Parent encoder object not found");
+		return -ENODEV;
+	}
+
+	err = drm_connector_init(bridge->dev, &ctx->connector,
+				 &it6505_connector_funcs,
+				 DRM_MODE_CONNECTOR_DisplayPort);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to initialize connector: %d", err);
+		goto unregister_aux;
+	}
+
+	drm_connector_helper_add(&ctx->connector,
+				 &it6505_connector_helper_funcs);
+
+	err = drm_connector_register(&ctx->connector);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to register connector: %d", err);
+		goto unregister_aux;
+	}
+
+	ctx->connector.polled = DRM_CONNECTOR_POLL_HPD;
+
+	err = drm_connector_attach_encoder(&ctx->connector, bridge->encoder);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to link up connector to encoder: %d",
+			      err);
+		goto unregister_connector;
+	}
+
+	return 0;
+
+unregister_connector:
+	drm_connector_unregister(&ctx->connector);
+unregister_aux:
+	drm_dp_aux_unregister(&ctx->aux);
+	return err;
+}
+
+static void it6505_bridge_detach(struct drm_bridge *bridge)
+{
+	struct it6505 *ctx = bridge_to_it6505(bridge);
+	struct it6505_dp_port *port = ctx->port;
+
+	if (port) {
+		devm_extcon_unregister_notifier(&ctx->client->dev, port->extcon,
+						EXTCON_DISP_DP,
+						&port->event_nb);
+		flush_work(&port->extcon_wq);
+		ctx->port = NULL;
+	}
+	drm_connector_unregister(&ctx->connector);
+	drm_dp_aux_unregister(&ctx->aux);
+}
+
+static enum drm_mode_status
+it6505_bridge_mode_valid(struct drm_bridge *bridge,
+			 const struct drm_display_mode *mode)
+{
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+		return MODE_NO_INTERLACE;
+
+	/* Max 1200p at 5.4 Ghz, one lane */
+	if (mode->clock > 80000)
+		return MODE_CLOCK_HIGH;
+
+	return MODE_OK;
+}
+
+static int it6505_send_video_infoframe(struct it6505 *it6505,
+				       struct hdmi_avi_infoframe *frame)
+{
+	u8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];
+	int err;
+	struct device *dev = &it6505->client->dev;
+
+	err = hdmi_avi_infoframe_pack(frame, buffer, sizeof(buffer));
+	if (err < 0) {
+		DRM_DEV_ERROR(dev, "Failed to pack AVI infoframe: %d\n", err);
+		return err;
+	}
+
+	err = dptxset(it6505, 0xe8, 1, 0);
+	if (err)
+		return err;
+
+	err = regmap_bulk_write(it6505->regmap, 0xe9, buffer, frame->length);
+	if (err)
+		return err;
+
+	err = dptxset(it6505, 0xe8, 1, 1);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static void it6505_bridge_mode_set(struct drm_bridge *bridge,
+				   struct drm_display_mode *mode,
+				   struct drm_display_mode *adjusted_mode)
+{
+	struct it6505 *ctx = bridge_to_it6505(bridge);
+	struct hdmi_avi_infoframe frame;
+	int err;
+	struct device *dev = &ctx->client->dev;
+
+	mutex_lock(&ctx->lock);
+	err = drm_hdmi_avi_infoframe_from_display_mode(&frame, adjusted_mode,
+						       false);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to setup AVI infoframe: %d", err);
+		goto unlock;
+	}
+	ctx->vid_info.base.id = adjusted_mode->base.id;
+	strlcpy(ctx->vid_info.name, adjusted_mode->name, DRM_DISPLAY_MODE_LEN);
+	ctx->vid_info.type = adjusted_mode->type;
+	ctx->vid_info.flags = adjusted_mode->flags;
+	err = it6505_send_video_infoframe(ctx, &frame);
+	if (err)
+		DRM_DEV_ERROR(dev, "Failed to send AVI infoframe: %d", err);
+
+unlock:
+	mutex_unlock(&ctx->lock);
+}
+
+static void dptx_init(struct it6505 *it6505)
+{
+	dptxwr(it6505, 0x05, 0x3B);
+	usleep_range(1000, 2000);
+	dptxwr(it6505, 0x05, 0x1F);
+	usleep_range(1000, 1500);
+}
+
+static void it6505_int_mask_on(struct it6505 *it6505)
+{
+	dptxwr(it6505, 0x09, 0x1F);
+	dptxwr(it6505, 0x0A, 0x07);
+	dptxwr(it6505, 0x0B, 0x90);
+}
+
+static void it6505_int_mask_off(struct it6505 *it6505)
+{
+	dptxwr(it6505, 0x09, 0x00);
+	dptxwr(it6505, 0x0A, 0x00);
+	dptxwr(it6505, 0x0B, 0x00);
+}
+
+static void dptx_set_aud_fmt(struct it6505 *it6505, enum it6505_aud_sel audsel,
+			     unsigned int audch)
+{
+	unsigned int audsrc;
+	/* I2S MODE */
+	dptxwr(it6505, 0xB9,
+	       (it6505->audwordlength << 5) | (it6505->i2s_data_seq << 4) |
+		       (it6505->i2s_ws_channel << 3) |
+		       (it6505->i2s_data_delay << 2) |
+		       (it6505->i2s_justified << 1) | it6505->i2s_input_fmt);
+	if (audsel == SPDIF) {
+		dptxwr(it6505, 0xBA, 0x00);
+		/* 0x30 = 128*FS */
+		dptxset(it6505, 0x11, 0xF0, 0x30);
+	} else {
+		dptxwr(it6505, 0xBA, 0xe4);
+	}
+
+	dptxwr(it6505, 0xBB, 0x00);
+	dptxwr(it6505, 0xBC, 0x00);
+	audsrc = 1;
+
+	if (audch > 2)
+		audsrc |= 2;
+
+	if (audch > 4)
+		audsrc |= 4;
+
+	if (audch == 8)
+		audsrc |= 8;
+
+	audsrc |= audsel << 4;
+
+	dptxwr(it6505, 0xB8, audsrc);
+}
+
+static void dptx_set_aud_chsts(struct it6505 *it6505,
+			       enum it6505_aud_type audtype,
+			       enum it6505_aud_fs audfs)
+{
+	/* Channel Status */
+	dptxwr(it6505, 0xBF, audtype << 1);
+	dptxwr(it6505, 0xC0, 0x00);
+	dptxwr(it6505, 0xC1, 0x00);
+	dptxwr(it6505, 0xC2, audfs);
+	switch (it6505->audwordlength) {
+	case AUD16BIT:
+		dptxwr(it6505, 0xC3, ((~audfs) << 4) + 0x02);
+		break;
+
+	case AUD18BIT:
+		dptxwr(it6505, 0xC3, ((~audfs) << 4) + 0x04);
+		break;
+
+	case AUD20BIT:
+		dptxwr(it6505, 0xC3, ((~audfs) << 4) + 0x03);
+		break;
+
+	case AUD24BIT:
+		dptxwr(it6505, 0xC3, ((~audfs) << 4) + 0x0B);
+		break;
+	}
+}
+
+static void dptx_set_audio_infoframe(struct it6505 *it6505, unsigned int audch)
+{
+	struct device *dev = &it6505->client->dev;
+
+	dptxwr(it6505, 0xf7, audch - 1);
+
+	switch (audch) {
+	case 2:
+		dptxwr(it6505, 0xF9, 0x00);
+		break;
+	case 3:
+		dptxwr(it6505, 0xF9, 0x01);
+		break;
+	case 4:
+		dptxwr(it6505, 0xF9, 0x03);
+		break;
+	case 5:
+		dptxwr(it6505, 0xF9, 0x07);
+		break;
+	case 6:
+		dptxwr(it6505, 0xF9, 0x0B);
+		break;
+	case 7:
+		dptxwr(it6505, 0xF9, 0x0F);
+		break;
+	case 8:
+		dptxwr(it6505, 0xF9, 0x1F);
+		break;
+	default:
+		DRM_DEV_ERROR(dev, "audio channel number error: %u", audch);
+	}
+	/* Enable Audio InfoFrame */
+	dptxset(it6505, 0xE8, 0x22, 0x22);
+}
+
+static void it6505_set_audio(struct it6505 *it6505, enum it6505_aud_sel audsel,
+			     enum it6505_aud_type audtype,
+			     enum it6505_aud_fs audfs, unsigned int audch)
+{
+	/* Audio Clock Domain Reset */
+	dptxset(it6505, 0x05, 0x02, 0x02);
+	/* Audio mute */
+	dptxset(it6505, 0xD3, 0x20, 0x20);
+	/* Release Audio Clock Domain Reset */
+	dptxset(it6505, 0x05, 0x02, 0x00);
+
+	dptx_set_aud_chsts(it6505, audtype, audfs);
+	dptx_set_audio_infoframe(it6505, audch);
+	dptx_set_aud_fmt(it6505, audsel, audch);
+	/* Enable Enhanced Audio TimeStmp Mode */
+	dptxset(it6505, 0xD4, 0x04, 0x04);
+	/* Disable Full Audio Packet */
+	dptxset(it6505, 0xBB, 0x10, 0x00);
+
+	dptxwr(it6505, 0xDE, 0x00);
+	dptxwr(it6505, 0xDF, 0x80);
+	dptxwr(it6505, 0xE0, 0x00);
+	dptxset(it6505, 0xD3, 0x20, 0x00);
+
+	/* Clear Video M Error Interrupt */
+	dptxset(it6505, 0x08, 0x08, 0x08);
+	/* Clear Audio FIFO OverFlow Interrupt */
+	dptxset(it6505, 0x07, 0x04, 0x04);
+}
+
+/***************************************************************************
+ * DPCD Read and EDID
+ ***************************************************************************/
+
+static unsigned int dptx_dpcdrd(struct it6505 *it6505, unsigned long offset)
+{
+	unsigned int startadr0, startadr1, startadr2;
+
+	startadr0 = (unsigned int)((offset >> 0) & 0xFF);
+	startadr1 = (unsigned int)((offset >> 8) & 0xFF);
+	startadr2 = (unsigned int)((offset >> 16) & 0x0F);
+	/* Enable PC Aux Access */
+	dptxwr(it6505, 0x23, (0 << 6) + 0x02);
+	/* Start Address[7:0] */
+	dptxwr(it6505, 0x24, startadr0);
+	/* Start Address[15:8] */
+	dptxwr(it6505, 0x25, startadr1);
+	/* WriteNum[3:0]+StartAdr[19:16] */
+	dptxwr(it6505, 0x26, startadr2);
+	/* Aux Read Fire */
+	dptxwr(it6505, 0x2B, 0x00);
+	dptx_auxwait(it6505);
+	/* Disable PC Aux Access */
+	dptxwr(it6505, 0x23, (0 << 6) + 0x00);
+
+	dptxrd(it6505, 0x2C, &startadr0);
+
+	return startadr0;
+}
+
+static int dptx_dpcdwr(struct it6505 *it6505, unsigned long offset,
+		       unsigned long datain)
+{
+	unsigned int startadr0, startadr1, startadr2;
+
+	startadr0 = (unsigned int)(offset >> 0) & 0xFF;
+	startadr1 = (unsigned int)(offset >> 8) & 0xFF;
+	startadr2 = (unsigned int)(offset >> 16) & 0x0F;
+	/* Enable PC Aux Access */
+	dptxwr(it6505, 0x23, (1 << 6) + 0x02);
+	/* Start Address[7:0] */
+	dptxwr(it6505, 0x24, startadr0);
+	/* Start Address[15:8] */
+	dptxwr(it6505, 0x25, startadr1);
+	/* WriteNum[3:0]+StartAdr[19:16] */
+	dptxwr(it6505, 0x26, startadr2);
+	/* WriteData Byte 1 */
+	dptxwr(it6505, 0x27, datain);
+	/* Aux Write Fire */
+	dptxwr(it6505, 0x2B, 0x05);
+	dptx_auxwait(it6505);
+	/* Aux Read Fire */
+	dptxwr(it6505, 0x2B, 0x00);
+	dptx_auxwait(it6505);
+	/* Disable PC Aux Access */
+	dptxwr(it6505, 0x23, (1 << 6) + 0x00);
+
+	dptxrd(it6505, 0x2C, &startadr0);
+
+	if (startadr0 != datain)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void it6505_get_dpcd(struct it6505 *it6505)
+{
+	unsigned int offset = 0;
+	struct device *dev = &it6505->client->dev;
+
+	for (offset = 0; offset < 0x10; offset++)
+		it6505->dumpdpcd[offset] = dptx_dpcdrd(it6505, offset);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "DPCD[0x00] = %16ph", it6505->dumpdpcd);
+}
+
+static void it6505_parse_dpcd(struct it6505 *it6505)
+{
+	u8 max_lanes, dpcd_rev;
+	struct device *dev = &it6505->client->dev;
+
+	dpcd_rev = it6505->dumpdpcd[0];
+	DRM_DEV_DEBUG_DRIVER(dev, "#########DPCD Rev.: %d.%d###########",
+			     dpcd_rev >> 4, dpcd_rev & 0x0F);
+
+	switch (it6505->dumpdpcd[1]) {
+	case 0x06:
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Maximum Link Rate: 1.62Gbps per lane");
+		if (it6505->hbr) {
+			DRM_DEV_DEBUG_DRIVER(
+				dev, "Not support HBR Mode, will train LBR");
+			it6505->hbr = false;
+		} else {
+			DRM_DEV_DEBUG_DRIVER(dev, "Training LBR");
+		}
+		break;
+
+	case 0x0A:
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Maximum Link Rate: 2.7Gbps per lane");
+		if (!it6505->hbr) {
+			DRM_DEV_DEBUG_DRIVER(
+				dev, "Support HBR Mode, will train LBR");
+			it6505->hbr = false;
+		} else {
+			DRM_DEV_DEBUG_DRIVER(dev, "Training HBR");
+		}
+		break;
+
+	case 0x14:
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Maximum Link Rate: 2.7Gbps per lane");
+		break;
+
+	default:
+		DRM_DEV_ERROR(dev, "Unknown Maximum Link Rate: %u",
+			      it6505->dumpdpcd[1]);
+		break;
+	}
+
+	max_lanes = it6505->dumpdpcd[2] & 0x1F;
+	if (max_lanes == 1 || max_lanes == 2 || max_lanes == 4) {
+		DRM_DEV_DEBUG_DRIVER(
+			dev, "Maximum Lane Count: %u lane, it6505->lane = %u",
+			max_lanes, it6505->lane);
+		if (it6505->lane > max_lanes)
+			it6505->lane = max_lanes;
+		DRM_DEV_DEBUG_DRIVER(dev, "Training %u lane", it6505->lane);
+	} else {
+		DRM_DEV_ERROR(dev, "Maximum Lane Count Error: %u", max_lanes);
+	}
+
+	if (dpcd_rev >= 0x11 && it6505->dumpdpcd[2] & BIT(7)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Support Enhanced Framing Mode");
+	} else {
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Can not support Enhanced Framing Mode");
+		it6505->en_hframe = 0;
+	}
+
+	if (it6505->dumpdpcd[3] & BIT(0)) {
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Maximum Down-Spread: 0.5, support SSC!");
+	} else {
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Maximum Down-Spread: 0, No support SSC!");
+		it6505->en_ssc = 0;
+	}
+
+	if (dpcd_rev >= 0x11 && it6505->dumpdpcd[3] & BIT(6))
+		DRM_DEV_DEBUG_DRIVER(dev, "Support No AUX Training");
+	else
+		DRM_DEV_DEBUG_DRIVER(dev, "Can not support No AUX Training");
+
+	if (dptx_dpcdrd(it6505, 0x68028) & BIT(0)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Sink support HDCP!");
+		it6505->cp_capable = true;
+	} else {
+		DRM_DEV_DEBUG_DRIVER(dev, "Sink not support HDCP!");
+		it6505->cp_capable = false;
+		it6505->en_hdcp = 0;
+	}
+
+	if (dptx_dpcdrd(it6505, 0x68028) & BIT(1)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Downstream is repeater!!");
+		it6505->downstream_repeater = true;
+	} else {
+		DRM_DEV_DEBUG_DRIVER(dev, "Downstream is receiver!!");
+		it6505->downstream_repeater = false;
+	}
+}
+
+static void it6505_enable_hdcp(struct it6505 *it6505)
+{
+	int i;
+	u8 bksvs[5], c;
+	struct device *dev = &it6505->client->dev;
+
+	/* Disable CP_Desired */
+	dptxset(it6505, 0x38, 0x0B, 0x00);
+	dptxset(it6505, 0x05, 0x10, 0x10);
+
+	usleep_range(1000, 1500);
+	c = dptx_dpcdrd(it6505, 0x68028);
+	DRM_DEV_DEBUG_DRIVER(dev, "DPCD[0x68028]: 0x%x\n", c);
+	if (!c)
+		return;
+
+	dptxset(it6505, 0x05, 0x10, 0x00);
+	/* Disable CP_Desired */
+	dptxset(it6505, 0x38, 0x01, 0x00);
+	/* Use R0' 100ms waiting */
+	dptxset(it6505, 0x38, 0x08, 0x00);
+	/* clear the repeater List Chk Done and fail bit */
+	dptxset(it6505, 0x39, 0x30, 0x00);
+
+	for (i = 0; i < 5; i++)
+		bksvs[i] = dptx_dpcdrd(it6505, 0x68000 + i);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "Sink BKSV = %5ph", bksvs);
+
+	/* Select An Generator */
+	dptxset(it6505, 0x3A, 0x01, 0x01);
+	/* Enable An Generator */
+	dptxset(it6505, 0x3A, 0x02, 0x02);
+	/* delay1ms(10);*/
+	usleep_range(10000, 15000);
+	/* Stop An Generator */
+	dptxset(it6505, 0x3A, 0x02, 0x00);
+
+	dptxset(it6505, 0x38, 0x01, 0x01);
+	dptxset(it6505, 0x39, 0x01, 0x01);
+}
+
+static void it6505_lanespeed_setup(struct it6505 *it6505)
+{
+	if (!it6505->hbr) {
+		dptxset(it6505, 0x16, 0x01, 0x01);
+		dptxset(it6505, 0x5C, 0x02, 0x00);
+	} else {
+		dptxset(it6505, 0x16, 0x01, 0x00);
+		dptxset(it6505, 0x5C, 0x02, 0x02);
+	}
+}
+
+static void it6505_lane_swap(struct it6505 *it6505)
+{
+	int err;
+	union extcon_property_value property;
+	struct device *dev = &it6505->client->dev;
+
+	err = extcon_get_property(it6505->port->extcon, EXTCON_DISP_DP,
+				  EXTCON_PROP_USB_TYPEC_POLARITY, &property);
+	if (err) {
+		DRM_DEV_ERROR(dev, "get property fail!");
+		return;
+	}
+	it6505->laneswap = property.intval;
+
+	dptxset(it6505, 0x16, 0x08, it6505->laneswap ? 0x08 : 0x00);
+	dptxset(it6505, 0x16, 0x06, (it6505->lane - 1) << 1);
+	DRM_DEV_DEBUG_DRIVER(dev, "it6505->laneswap = 0x%x", it6505->laneswap);
+
+	if (it6505->laneswap) {
+		switch (it6505->lane) {
+		case 1:
+			dptxset(it6505, 0x5C, 0xF1, 0x81);
+			break;
+		case 2:
+			dptxset(it6505, 0x5C, 0xF1, 0xC1);
+			break;
+		default:
+			dptxset(it6505, 0x5C, 0xF1, 0xF1);
+			break;
+		}
+	} else {
+		switch (it6505->lane) {
+		case 1:
+			dptxset(it6505, 0x5C, 0xF1, 0x11);
+			break;
+		case 2:
+			dptxset(it6505, 0x5C, 0xF1, 0x31);
+			break;
+		default:
+			dptxset(it6505, 0x5C, 0xF1, 0xF1);
+			break;
+		}
+	}
+}
+
+static void it6505_lane_config(struct it6505 *it6505)
+{
+	it6505_lanespeed_setup(it6505);
+	it6505_lane_swap(it6505);
+}
+
+static void dptx_chgbank(struct it6505 *it6505, unsigned int bank_id)
+{
+	dptxset(it6505, 0x0F, 0x01, bank_id & BIT(0));
+}
+
+static void it6505_set_ssc(struct it6505 *it6505)
+{
+	struct device *dev = &it6505->client->dev;
+
+	dptxset(it6505, 0x16, 0x10, it6505->en_ssc << 4);
+	if (it6505->en_ssc) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Enable 27M 4463 PPM SSC");
+		dptx_chgbank(it6505, 1);
+		dptxwr(it6505, 0x88, 0x9e);
+		dptxwr(it6505, 0x89, 0x1c);
+		dptxwr(it6505, 0x8A, 0x42);
+		dptx_chgbank(it6505, 0);
+		dptxwr(it6505, 0x58, 0x07);
+		dptxwr(it6505, 0x59, 0x29);
+		dptxwr(it6505, 0x5A, 0x03);
+		/* Stamp Interrupt Step */
+		dptxset(it6505, 0xD4, 0x30, 0x10);
+		dptx_dpcdwr(it6505, 0x107, 0x10);
+	} else {
+		dptx_dpcdwr(it6505, 0x107, 0x00);
+		dptxset(it6505, 0xD4, 0x30, 0x00);
+	}
+}
+
+static void pclk_phase(struct it6505 *it6505)
+{
+	dptxset(it6505, 0x10, 0x03, PCLK_DELAY);
+	dptxset(it6505, 0x12, 0x10, PCLK_INV << 4);
+}
+
+static void afe_driving_setting(struct it6505 *it6505)
+{
+	dptxset(it6505, 0x0F, 0x01, 0x01);
+	dptxwr(it6505, 0x7E, 0x93);
+	dptxwr(it6505, 0x7F, 0x2A);
+	dptxwr(it6505, 0x81, 0x85);
+	dptxset(it6505, 0x0F, 0x01, 0x00);
+}
+
+static void dptx_output(struct it6505 *it6505, unsigned int hbr,
+			unsigned int lane, unsigned int laneswap,
+			unsigned int en_ssc, unsigned int en_hframe)
+{
+	dptxwr(it6505, 0x05, 0x13);
+	/* change bank 0 */
+	dptxset(it6505, 0x0F, 0x01, 0x00);
+	/* RegTxFFRst set */
+	dptxset(it6505, 0x61, 0x02, 0x02);
+	/* RegTxFFRst clear */
+	dptxset(it6505, 0x61, 0x02, 0x00);
+	dptxwr(it6505, 0x64, 0x10);
+	dptxwr(it6505, 0x65, 0x80);
+	dptxwr(it6505, 0x66, 0x10);
+	dptxwr(it6505, 0x67, 0x4F);
+	dptxwr(it6505, 0x68, 0x09);
+	dptxwr(it6505, 0x69, 0xBA);
+	dptxwr(it6505, 0x6A, 0x3B);
+	dptxwr(it6505, 0x6B, 0x4B);
+	dptxwr(it6505, 0x6C, 0x3E);
+	dptxwr(it6505, 0x6D, 0x4F);
+	dptxwr(it6505, 0x6E, 0x09);
+	dptxwr(it6505, 0x6F, 0x56);
+	dptxwr(it6505, 0x70, 0x0E);
+	dptxwr(it6505, 0x71, 0x00);
+	dptxwr(it6505, 0x72, 0x00);
+	dptxwr(it6505, 0x73, 0x4F);
+	dptxwr(it6505, 0x74, 0x09);
+	dptxwr(it6505, 0x75, 0x00);
+	dptxwr(it6505, 0x76, 0x00);
+	dptxwr(it6505, 0x77, 0xE7);
+	dptxwr(it6505, 0x78, 0x10);
+	dptxwr(it6505, 0xE8, 0x00);
+	dptxset(it6505, 0xCE, 0x70, 0x60);
+	dptxset(it6505, 0xD0, 0xC0, 0x80);
+	dptxwr(it6505, 0xCA, 0x4D);
+	dptxwr(it6505, 0xC9, 0xF5);
+	dptxwr(it6505, 0x5C, 0x02);
+
+	dptx_dpcdwr(it6505, 0x600, 0x01);
+	dptxset(it6505, 0x59, 0x01, 0x01);
+	dptxset(it6505, 0x5A, 0x05, 0x01);
+	dptxwr(it6505, 0x12, 0x01);
+	dptxwr(it6505, 0xCB, 0x17);
+	dptxwr(it6505, 0x11, 0x09);
+	dptxwr(it6505, 0x20, 0x28);
+	dptxset(it6505, 0x23, 0x30, 0x00);
+	dptxset(it6505, 0x3A, 0x04, 0x04);
+	dptxset(it6505, 0x15, 0x01, 0x01);
+	dptxwr(it6505, 0x0C, 0x08);
+
+	dptxset(it6505, 0x5F, 0x20, 0x00);
+	it6505_lane_config(it6505);
+
+	it6505_set_ssc(it6505);
+
+	if (en_hframe) {
+		dptxwr(it6505, 0xD3, 0x33);
+		dptx_dpcdwr(it6505, 0x101, 0x80);
+	} else {
+		dptxwr(it6505, 0xD3, 0x32);
+	}
+
+	dptxset(it6505, 0x15, 0x02, 0x02);
+	dptxset(it6505, 0x15, 0x02, 0x00);
+	dptxset(it6505, 0x05, 0x03, 0x02);
+	dptxset(it6505, 0x05, 0x03, 0x00);
+
+	/* reg60[2] = InDDR */
+	dptxwr(it6505, 0x60, 0x44);
+	/* M444B24 format */
+	dptxwr(it6505, 0x62, 0x01);
+	/* select RGB Bypass CSC */
+	dptxwr(it6505, 0x63, 0x00);
+
+	pclk_phase(it6505);
+	dptxset(it6505, 0x61, 0x01, 0x01);
+	dptxwr(it6505, 0x06, 0xFF);
+	dptxwr(it6505, 0x07, 0xFF);
+	dptxwr(it6505, 0x08, 0xFF);
+
+	dptxset(it6505, 0xd3, 0x30, 0x00);
+	dptxset(it6505, 0xd4, 0x41, 0x41);
+	dptxset(it6505, 0xe8, 0x11, 0x11);
+
+	afe_driving_setting(it6505);
+	dptxwr(it6505, 0x17, 0x04);
+	dptxwr(it6505, 0x17, 0x01);
+}
+
+static void dptx_process_sys_wait(struct it6505 *it6505)
+{
+	u8 dpcd1[0x09], dpcd2[0x18];
+	int i, reg0e, reg0d, len1, len2;
+	struct device *dev = &it6505->client->dev;
+
+	dptxrd(it6505, 0x0E, &reg0e);
+	len1 = ARRAY_SIZE(dpcd1);
+	len2 = ARRAY_SIZE(dpcd2);
+	DRM_DEV_DEBUG_DRIVER(dev,
+			     "SYS_WAIT state parse %d dpcd offset!",
+			     len1 + len2);
+
+	for (i = 0; i < len1; i++)
+		dpcd1[i] = dptx_dpcdrd(it6505, 0x100 + i);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd[0x100] = %*ph", len1, dpcd1);
+	for (i = 0; i < len2; i++)
+		dpcd2[i] = dptx_dpcdrd(it6505, 0x200 + i);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd[0x200] = %*ph", len2, dpcd2);
+	if (reg0e & BIT(4)) {
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Auto Link Training Success...");
+		DRM_DEV_DEBUG_DRIVER(dev, "Link State : 0x%x",
+				     reg0e & 0x1F);
+		if (it6505->en_audio) {
+			DRM_DEV_DEBUG_DRIVER(dev, "Enable audio!");
+			it6505_set_audio(it6505, it6505->aud_sel,
+					 it6505->aud_type,
+					 it6505->aud_fs,
+					 it6505->aud_ch);
+		}
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "it6505->VidStable_Done = %02x",
+				     it6505->vidstable_done);
+		if (it6505->cp_capable) {
+			DRM_DEV_DEBUG_DRIVER(dev, "Support HDCP");
+			if (it6505->en_hdcp) {
+				DRM_DEV_DEBUG_DRIVER(dev,
+						     "Enable HDCP");
+				dptx_sys_chg(it6505, SYS_ReHDCP);
+			} else {
+				DRM_DEV_DEBUG_DRIVER(dev,
+						     "Disable HDCP");
+				dptx_sys_chg(it6505, SYS_NOROP);
+			}
+		} else {
+			DRM_DEV_DEBUG_DRIVER(dev, "Not support HDCP");
+			dptx_sys_chg(it6505, SYS_NOROP);
+		}
+	} else {
+		dptxrd(it6505, 0x0D, &reg0d);
+		dptxrd(it6505, 0x0E, &reg0e);
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Auto Link Training fail step %d",
+				     it6505->cntfsm);
+		DRM_DEV_DEBUG_DRIVER(dev, "reg0E:0x%x, reg0D:0x%x",
+				     reg0e, reg0d);
+		if (it6505->cntfsm > 0) {
+			it6505->cntfsm--;
+			dptx_sys_chg(it6505, SYS_AUTOTRAIN);
+		} else {
+			DRM_DEV_DEBUG_DRIVER(
+				dev, "Auto Training Fail %d times",
+				TRAINFAILCNT);
+			DRM_DEV_DEBUG_DRIVER(dev,
+					     "Sys change to SYS_HPD");
+			dptx_dpcdwr(it6505, 0x102, 0x00);
+			if (it6505->train_fail_hpd > 0) {
+				it6505->train_fail_hpd--;
+				dptx_sys_chg(it6505, SYS_HPD);
+			} else {
+				dptx_sys_chg(it6505, SYS_TRAINFAIL);
+			}
+		}
+	}
+}
+
+static void dptx_sys_fsm(struct it6505 *it6505)
+{
+	unsigned int i;
+	int reg0e, reg0d, reg9f;
+	struct device *dev = &it6505->client->dev;
+	unsigned int ar0_low, ar0_high, br0_low, br0_high;
+
+	dptxrd(it6505, 0x0D, &reg0d);
+
+	if (it6505->status != SYS_UNPLUG && !(reg0d & BIT(1)))
+		dptx_sys_chg(it6505, SYS_UNPLUG);
+	DRM_DEV_DEBUG_DRIVER(dev, "state: %d", it6505->status);
+	switch (it6505->status) {
+	case SYS_UNPLUG:
+		break;
+
+	case SYS_HPD:
+		dptxrd(it6505, 0x9f, &reg9f);
+		DRM_DEV_DEBUG_DRIVER(dev, "Aux channel status reg9F=0x%02x",
+				     reg9f);
+		/* GETDPCD */
+		it6505_get_dpcd(it6505);
+		it6505_parse_dpcd(it6505);
+
+		/*
+		 * training fail TRAINFAILCNT times,
+		 * then change to HPD to restart
+		 */
+		it6505->cntfsm = TRAINFAILCNT;
+		DRM_DEV_DEBUG_DRIVER(dev, "will Train %s %d lanes",
+				     it6505->hbr ? "HBR" : "LBR", it6505->lane);
+		dptx_sys_chg(it6505, SYS_AUTOTRAIN);
+		break;
+
+	case SYS_AUTOTRAIN:
+		dptx_output(it6505, it6505->hbr, it6505->lane, it6505->laneswap,
+			    it6505->en_ssc, it6505->en_hframe);
+
+		/*
+		 * waiting for training down flag
+		 * because we don't know
+		 * how long this step will be completed
+		 * so use step 1ms to wait
+		 */
+		for (i = 0; i < FLAGTRAINDOWN; i++) {
+			usleep_range(1000, 2000);
+			dptxrd(it6505, 0x0E, &reg0e);
+			if (reg0e & BIT(4))
+				break;
+		}
+
+		dptx_sys_chg(it6505, SYS_WAIT);
+		break;
+
+	case SYS_WAIT:
+		dptx_process_sys_wait(it6505);
+		break;
+
+	case SYS_ReHDCP:
+		msleep(500);
+		dptxrd(it6505, 0x3B, &ar0_low);
+		dptxrd(it6505, 0x3C, &ar0_high);
+		dptxrd(it6505, 0x45, &br0_low);
+		dptxrd(it6505, 0x46, &br0_high);
+		DRM_DEV_DEBUG_DRIVER(dev, "Before EnableHDCP");
+		DRM_DEV_DEBUG_DRIVER(dev, "Ar0_low:%x, Ar0_high:%x", ar0_low,
+				     ar0_high);
+		DRM_DEV_DEBUG_DRIVER(dev, "Br0_low:%x, Br0_high:%x", br0_low,
+				     br0_high);
+		it6505_enable_hdcp(it6505);
+		msleep(200);
+		DRM_DEV_DEBUG_DRIVER(dev, "SYS_ReHDCP end");
+		break;
+
+	case SYS_NOROP:
+		break;
+
+	case SYS_TRAINFAIL:
+		break;
+
+	default:
+		DRM_DEV_ERROR(dev, "sys_state change to unknown_state: %d",
+			      it6505->status);
+		break;
+	}
+}
+
+static int it6505_poweron(struct it6505 *it6505)
+{
+	struct it6505_platform_data *pdata = &it6505->pdata;
+	int err = 0;
+	struct device *dev = &it6505->client->dev;
+
+	if (it6505->powered) {
+		DRM_DEV_DEBUG_DRIVER(dev, "it6505 already powered on");
+		return 0;
+	}
+
+	DRM_DEV_DEBUG_DRIVER(dev, "it6505 start to power on");
+
+	err = regulator_enable(pdata->pwr18);
+	DRM_DEV_DEBUG_DRIVER(dev, "%s to enable pwr18 regulator",
+			     err ? "Failed" : "Succeeded");
+	if (err)
+		return err;
+	/* time interval between IVDD and OVDD at least be 1ms */
+	usleep_range(1000, 2000);
+	err = regulator_enable(pdata->ovdd);
+	DRM_DEV_DEBUG_DRIVER(dev, "%s to enable ovdd regulator",
+			     err ? "Failed" : "Succeeded");
+	if (err) {
+		regulator_disable(pdata->pwr18);
+		return err;
+	}
+	/* time interval between OVDD and SYSRSTN at least be 10ms */
+	usleep_range(10000, 20000);
+	gpiod_set_value_cansleep(pdata->gpiod_reset, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(pdata->gpiod_reset, 1);
+	usleep_range(10000, 20000);
+
+	dptx_init(it6505);
+	it6505->powered = true;
+	return 0;
+}
+
+static int it6505_poweroff(struct it6505 *it6505)
+{
+	struct it6505_platform_data *pdata = &it6505->pdata;
+	int err = 0;
+	struct device *dev = &it6505->client->dev;
+
+	if (!(it6505->powered)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "power had been already off");
+		return 0;
+	}
+	gpiod_set_value_cansleep(pdata->gpiod_reset, 0);
+	err = regulator_disable(pdata->pwr18);
+	DRM_DEV_DEBUG_DRIVER(dev, "%s to disable pwr18 regulator",
+			     err ? "Failed" : "Succeeded");
+	if (err)
+		return err;
+	err = regulator_disable(pdata->ovdd);
+	DRM_DEV_DEBUG_DRIVER(dev, "%s to disable ovdd regulator",
+			     err ? "Failed" : "Succeeded");
+	if (err)
+		return err;
+
+	kfree(it6505->edid);
+	it6505->edid = NULL;
+	it6505->powered = false;
+	return 0;
+}
+
+static int sha1_digest(struct it6505 *it6505, u8 *sha1_input, unsigned int size,
+		       u8 *output_av)
+{
+	struct shash_desc *desc;
+	struct crypto_shash *tfm;
+	int err;
+	struct device *dev = &it6505->client->dev;
+
+	tfm = crypto_alloc_shash("sha1", 0, 0);
+	if (IS_ERR(tfm)) {
+		DRM_DEV_ERROR(dev, "crypto_alloc_shash sha1 failed");
+		return PTR_ERR(tfm);
+	}
+	desc = kzalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
+	if (!desc) {
+		crypto_free_shash(tfm);
+		return -ENOMEM;
+	}
+
+	desc->tfm = tfm;
+	err = crypto_shash_digest(desc, sha1_input, size, output_av);
+	if (err)
+		DRM_DEV_ERROR(dev, "crypto_shash_digest sha1 failed");
+
+	crypto_free_shash(tfm);
+	kfree(desc);
+	return err;
+}
+
+static int it6505_makeup_sha1_input(struct it6505 *it6505)
+{
+	int msgcnt = 0, i;
+	unsigned int value;
+	struct device *dev = &it6505->client->dev;
+
+	dptxset(it6505, 0x3A, 0x20, 0x20);
+	for (i = 0; i < 8; i++) {
+		dptxrd(it6505, 0x4C + i, &value);
+		it6505->am0[i] = value;
+	}
+	DRM_DEV_DEBUG_DRIVER(dev, "read am0 = %8ph", it6505->am0);
+	dptxset(it6505, 0x3A, 0x20, 0x00);
+
+	it6505->binfo[0] = dptx_dpcdrd(it6505, 0x6802A);
+	it6505->binfo[1] = dptx_dpcdrd(it6505, 0x6802B);
+	DRM_DEV_DEBUG_DRIVER(dev, "read Binfo!!");
+	DRM_DEV_DEBUG_DRIVER(dev, "Attached devices: %02x",
+			     it6505->binfo[0] & 0x7F);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "%s 127 devices are attached",
+			     (it6505->binfo[0] & BIT(7)) ? "over" : "under");
+	DRM_DEV_DEBUG_DRIVER(dev, "depth, attached levels: %02x",
+			     it6505->binfo[1] & 0x07);
+	DRM_DEV_DEBUG_DRIVER(dev, "%s than seven levels cascaded",
+			     (it6505->binfo[1] & BIT(3)) ? "more" : "less");
+
+	for (i = 0; i < (it6505->binfo[0] & 0x7F); i++) {
+		it6505->shainput[msgcnt] = it6505->ksvlist[msgcnt] =
+			dptx_dpcdrd(it6505, 0x6802C + (i % 3) * 5);
+		msgcnt++;
+		it6505->shainput[msgcnt] = it6505->ksvlist[msgcnt] =
+			dptx_dpcdrd(it6505, 0x6802D + (i % 3) * 5);
+		msgcnt++;
+		it6505->shainput[msgcnt] = it6505->ksvlist[msgcnt] =
+			dptx_dpcdrd(it6505, 0x6802E + (i % 3) * 5);
+		msgcnt++;
+		it6505->shainput[msgcnt] = it6505->ksvlist[msgcnt] =
+			dptx_dpcdrd(it6505, 0x6802F + (i % 3) * 5);
+		msgcnt++;
+		it6505->shainput[msgcnt] = it6505->ksvlist[msgcnt] =
+			dptx_dpcdrd(it6505, 0x68030 + (i % 3) * 5);
+		msgcnt++;
+
+		DRM_DEV_DEBUG_DRIVER(dev, "KSV List %d device : %5ph", i,
+				     it6505->ksvlist + i * 5);
+	}
+	it6505->shainput[msgcnt++] = it6505->binfo[0];
+	it6505->shainput[msgcnt++] = it6505->binfo[1];
+	for (i = 0; i < 8; i++)
+		it6505->shainput[msgcnt++] = it6505->am0[i];
+
+	DRM_DEV_DEBUG_DRIVER(dev, "SHA Message Count = %d", msgcnt);
+	return msgcnt;
+}
+
+static void it6505_check_sha1_result(struct it6505 *it6505)
+{
+	unsigned int i, shapass;
+	struct device *dev = &it6505->client->dev;
+
+	DRM_DEV_DEBUG_DRIVER(dev, "SHA calculate complete");
+	for (i = 0; i < 5; i++)
+		DRM_DEV_DEBUG_DRIVER(dev, "av %d: %4ph", i, it6505->av[i]);
+
+	shapass = 1;
+	for (i = 0; i < 5; i++) {
+		it6505->bv[i][0] = dptx_dpcdrd(it6505, 0x68017 + i * 4);
+		it6505->bv[i][1] = dptx_dpcdrd(it6505, 0x68016 + i * 4);
+		it6505->bv[i][2] = dptx_dpcdrd(it6505, 0x68015 + i * 4);
+		it6505->bv[i][3] = dptx_dpcdrd(it6505, 0x68014 + i * 4);
+		DRM_DEV_DEBUG_DRIVER(dev, "bv %d: %4ph", i, it6505->bv[i]);
+		if ((it6505->bv[i][0] != it6505->av[i][0]) ||
+		    (it6505->bv[i][1] != it6505->av[i][1]) ||
+		    (it6505->bv[i][2] != it6505->av[i][2]) ||
+		    (it6505->bv[i][3] != it6505->av[i][3])) {
+			shapass = 0;
+		}
+	}
+	if (shapass) {
+		DRM_DEV_DEBUG_DRIVER(dev, "SHA check result pass!");
+		dptxset(it6505, 0x39, BIT(4), BIT(4));
+	} else {
+		DRM_DEV_DEBUG_DRIVER(dev, "SHA check result fail");
+		dptxset(it6505, 0x39, BIT(5), BIT(5));
+	}
+}
+
+static void to_fsm_status(struct it6505 *it6505, enum sys_status status)
+{
+	while (it6505->status != status) {
+		dptx_sys_fsm(it6505);
+		if (it6505->status == SYS_UNPLUG)
+			return;
+	}
+}
+
+static void go_on_fsm(struct it6505 *it6505);
+
+static void hpd_irq(struct it6505 *it6505)
+{
+	unsigned int dpcd200, dpcd201, dpcd202, dpcd203;
+	unsigned int dpcd204, dpcd205, aux_busy_cnt, aux_busy, value, reg55;
+	int ret, len;
+	struct device *dev = &it6505->client->dev;
+
+	dpcd200 = dptx_dpcdrd(it6505, 0x200);
+	dpcd201 = dptx_dpcdrd(it6505, 0x201);
+	dpcd202 = dptx_dpcdrd(it6505, 0x202);
+	dpcd203 = dptx_dpcdrd(it6505, 0x203);
+	dpcd204 = dptx_dpcdrd(it6505, 0x204);
+	dpcd205 = dptx_dpcdrd(it6505, 0x205);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd200 = 0x%x", dpcd200);
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd201 = 0x%x", dpcd201);
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd202 = 0x%x", dpcd202);
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd203 = 0x%x", dpcd203);
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd204 = 0x%x", dpcd204);
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd205 = 0x%x", dpcd205);
+
+	if (dpcd201 & BIT(2)) {
+		ret = dptxrd(it6505, 0x38, &value);
+		it6505->bstatus = dptx_dpcdrd(it6505, 0x68029);
+		dptxrd(it6505, 0x55, &reg55);
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "reg0x55 = 0x%02x, reg0x68029 = 0x%02x",
+				     reg55, it6505->bstatus);
+		if (value & BIT(0) &&
+		    (!it6505->cp_done || it6505->bstatus & BIT(2))) {
+			DRM_DEV_DEBUG_DRIVER(
+				dev, "Trigger CP_IRQ to HDCP engine");
+			dptxset(it6505, 0x39, 0x02, 0x02);
+			aux_busy_cnt = 0;
+			do {
+				usleep_range(1000, 1500);
+				aux_busy_cnt++;
+				ret = dptxrd(it6505, 0x2B, &value);
+				aux_busy = (value & BIT(5)) >> 5;
+			} while (aux_busy == 1 && aux_busy_cnt < 20);
+
+			if (aux_busy) {
+				DRM_DEV_DEBUG_DRIVER(
+					dev, "AUX Busy Period!");
+			} else {
+				msleep(1000);
+				dptxrd(it6505, 0x55, &it6505->bstatus);
+				DRM_DEV_DEBUG_DRIVER(
+					dev,
+					"bstatus = %d", it6505->bstatus);
+			}
+		}
+		DRM_DEV_DEBUG_DRIVER(dev, "Receive CP_IRQ!");
+		it6505->bstatus = dptx_dpcdrd(it6505, 0x68029);
+		dptxrd(it6505, 0x55, &reg55);
+		DRM_DEV_DEBUG_DRIVER(dev, "Cause of the interrupt!");
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "reg0x68029 = 0x%02x, reg0x55 = 0x%02x",
+				     it6505->bstatus, reg55);
+
+		if (it6505->bstatus & BIT(0)) {
+			DRM_DEV_DEBUG_DRIVER(dev, "HDCP KSV list ready");
+			len = it6505_makeup_sha1_input(it6505);
+			sha1_digest(it6505, it6505->shainput, len,
+				    (u8 *)it6505->av);
+
+			it6505_check_sha1_result(it6505);
+		}
+		if (it6505->bstatus & BIT(1))
+			DRM_DEV_DEBUG_DRIVER(dev, "HDCP R0' ready");
+		if (it6505->bstatus & BIT(2)) {
+			DRM_DEV_DEBUG_DRIVER(
+				dev, "Link Integrity Fail, restart HDCP");
+			dptx_sys_chg(it6505, SYS_ReHDCP);
+		}
+	}
+
+	if ((dpcd204 & BIT(7)) == 0x80) {
+		if ((it6505->lane == 1 && (dpcd202 & BIT(2)) != 0x04) ||
+		    (it6505->lane == 2 && (dpcd202 & 0x44) != 0x44) ||
+		    (it6505->lane == 4 &&
+		     ((dpcd202 & 0x44) != 0x44 || (dpcd203 & 0x44) != 0x44)) ||
+		    (it6505->lane == 1 && (dpcd203 & BIT(6)) != 0x40) ||
+		    (it6505->lane == 2 && (dpcd203 & 0x44) != 0x44) ||
+		    (it6505->lane == 4 &&
+		     ((dpcd203 & 0x44) != 0x44 || (dpcd202 & 0x44) != 0x44)) ||
+		    (dpcd204 & BIT(0)) != 0x01) {
+			DRM_DEV_DEBUG_DRIVER(dev, "Link Re-Training");
+			dptxset(it6505, 0xD3, 0x30, 0x30);
+			dptxset(it6505, 0xE8, 0x33, 0x00);
+			msleep(500);
+			dptx_sys_chg(it6505, SYS_HPD);
+			go_on_fsm(it6505);
+		}
+	}
+}
+
+static void go_on_fsm(struct it6505 *it6505)
+{
+	struct device *dev = &it6505->client->dev;
+
+	if (it6505->cp_capable) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Support HDCP, cp_capable: %d",
+				     it6505->cp_capable);
+		if (it6505->en_hdcp) {
+			DRM_DEV_DEBUG_DRIVER(dev, "Enable HDCP");
+			to_fsm_status(it6505, SYS_ReHDCP);
+			dptx_sys_fsm(it6505);
+			if (it6505->downstream_repeater) {
+				DRM_DEV_DEBUG_DRIVER(dev, "Is repeater");
+				hpd_irq(it6505);
+			}
+		} else {
+			DRM_DEV_DEBUG_DRIVER(dev, "Disable HDCP");
+			to_fsm_status(it6505, SYS_NOROP);
+		}
+	} else {
+		DRM_DEV_DEBUG_DRIVER(dev, "Not support HDCP");
+		to_fsm_status(it6505, SYS_NOROP);
+	}
+}
+
+static void it6505_check_reg06(struct it6505 *it6505, unsigned int reg06)
+{
+	unsigned int rddata, err;
+	union extcon_property_value property;
+	struct device *dev = &it6505->client->dev;
+
+	if (reg06 & BIT(0)) {
+		/* hpd pin status change */
+		DRM_DEV_DEBUG_DRIVER(dev, "HPD Change Interrupt");
+		dptxrd(it6505, 0x0D, &rddata);
+		if (rddata & BIT(1)) {
+			err = extcon_get_property(
+				it6505->port->extcon, EXTCON_DISP_DP,
+				EXTCON_PROP_USB_TYPEC_POLARITY, &property);
+			if (err) {
+				DRM_DEV_DEBUG_DRIVER(dev, "get property fail");
+			}
+
+			it6505->laneswap = property.intval;
+			DRM_DEV_DEBUG_DRIVER(dev, "laneswap: %d",
+					     it6505->laneswap);
+			dptx_sys_chg(it6505, SYS_HPD);
+			dptx_sys_fsm(it6505);
+			go_on_fsm(it6505);
+		} else {
+			dptx_sys_chg(it6505, SYS_UNPLUG);
+		}
+	}
+
+	if (it6505->cp_capable) {
+		if (reg06 & BIT(3)) {
+			DRM_DEV_DEBUG_DRIVER(dev,
+					     "HDCP encryption Fail Interrupt");
+			DRM_DEV_DEBUG_DRIVER(dev, "HDCP retry");
+			it6505->cp_done = 0;
+			it6505->en_hdcp = 0;
+			dptx_sys_fsm(it6505);
+			if (it6505->downstream_repeater) {
+				DRM_DEV_DEBUG_DRIVER(dev, "Is repeater");
+				hpd_irq(it6505);
+			}
+		}
+
+		if (reg06 & BIT(4)) {
+			DRM_DEV_DEBUG_DRIVER(dev,
+					     "HDCP encryption Done Interrupt");
+			it6505->cp_done = 1;
+			it6505->en_hdcp = 1;
+			dptx_sys_chg(it6505, SYS_NOROP);
+		}
+	}
+
+	if (reg06 & BIT(1)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "HPD IRQ Interrupt");
+		hpd_irq(it6505);
+	}
+
+	if (reg06 & BIT(2)) {
+		dptxrd(it6505, 0x0D, &rddata);
+
+		if ((rddata & BIT(2)) >> 2) {
+			DRM_DEV_DEBUG_DRIVER(dev, "Video Stable On Interrupt");
+			it6505->vidstable_done = 1;
+		} else {
+			DRM_DEV_DEBUG_DRIVER(dev, "Video Stable Off Interrupt");
+			it6505->vidstable_done = 0;
+		}
+	}
+}
+
+static void it6505_check_reg07(struct it6505 *it6505, unsigned int reg07)
+{
+	struct device *dev = &it6505->client->dev;
+
+	if (it6505->status == SYS_UNPLUG)
+		return;
+	if (reg07 & BIT(0))
+		DRM_DEV_DEBUG_DRIVER(dev, "AUX PC Request Fail Interrupt");
+
+	if (reg07 & BIT(1)) {
+		unsigned int ar0_low, ar0_high, br0_low, br0_high;
+
+		DRM_DEV_DEBUG_DRIVER(dev, "HDCP event Interrupt");
+		it6505->bstatus = dptx_dpcdrd(it6505, 0x68029);
+		dptxrd(it6505, 0x3B, &ar0_low);
+		dptxrd(it6505, 0x3C, &ar0_high);
+		dptxrd(it6505, 0x45, &br0_low);
+		dptxrd(it6505, 0x46, &br0_high);
+		/*
+		 * Read Bstatus to determine what happened
+		 */
+		DRM_DEV_DEBUG_DRIVER(dev, "Bstatus reg0x68029: %02x",
+				     it6505->bstatus);
+		if (!(it6505->bstatus & BIT(0))) {
+			DRM_DEV_DEBUG_DRIVER(dev,
+					     "Ar0_low: %02x Ar0_high: %02x",
+					     ar0_low, ar0_high);
+			DRM_DEV_DEBUG_DRIVER(dev,
+					     "Br0_low: %02x Br0_high: %02x",
+					     br0_low, br0_high);
+		}
+	}
+	if (it6505->en_audio && (reg07 & BIT(2))) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Audio FIFO OverFlow Interrupt");
+		dptxset(it6505, 0xD3, 0x20, 0x20);
+		dptxset(it6505, 0xE8, 0x22, 0x00);
+		dptxset(it6505, 0xB8, 0x80, 0x80);
+		dptxset(it6505, 0xB8, 0x80, 0x00);
+		it6505_set_audio(it6505, it6505->aud_sel, it6505->aud_type,
+				 it6505->aud_fs, it6505->aud_ch);
+	}
+}
+
+static void it6505_check_reg08(struct it6505 *it6505, unsigned int reg08)
+{
+	struct device *dev = &it6505->client->dev;
+
+	if (it6505->status == SYS_UNPLUG)
+		return;
+	if (reg08 & BIT(4)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Link Training Fail Interrupt");
+		/* restart training */
+		dptx_sys_chg(it6505, SYS_AUTOTRAIN);
+		go_on_fsm(it6505);
+	}
+
+	if (reg08 & BIT(7)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "IO Latch FIFO OverFlow Interrupt");
+		dptxset(it6505, 0x61, 0x02, 0x02);
+		dptxset(it6505, 0x61, 0x02, 0x00);
+	}
+}
+
+static void it6505_dptx_irq(struct it6505 *it6505)
+{
+	unsigned int reg06, reg07, reg08, reg0d;
+	struct device *dev = &it6505->client->dev;
+
+	dptxrd(it6505, 0x06, &reg06);
+	dptxrd(it6505, 0x07, &reg07);
+	dptxrd(it6505, 0x08, &reg08);
+	dptxrd(it6505, 0x0D, &reg0d);
+
+	dptxwr(it6505, 0x06, reg06);
+	dptxwr(it6505, 0x07, reg07);
+	dptxwr(it6505, 0x08, reg08);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "reg06 = 0x%02x", reg06);
+	DRM_DEV_DEBUG_DRIVER(dev, "reg07 = 0x%02x", reg07);
+	DRM_DEV_DEBUG_DRIVER(dev, "reg08 = 0x%02x", reg08);
+	DRM_DEV_DEBUG_DRIVER(dev, "reg0d = 0x%02x", reg0d);
+
+	if (reg06 != 0)
+		it6505_check_reg06(it6505, reg06);
+
+	if (reg07 != 0)
+		it6505_check_reg07(it6505, reg07);
+
+	if (reg08 != 0)
+		it6505_check_reg08(it6505, reg08);
+}
+
+static void it6505_bridge_enable(struct drm_bridge *bridge)
+{
+	struct it6505 *ctx = bridge_to_it6505(bridge);
+
+	it6505_init_fsm(ctx);
+	it6505_int_mask_on(ctx);
+	dptx_sys_chg(ctx, SYS_HPD);
+}
+
+static const struct drm_bridge_funcs it6505_bridge_funcs = {
+	.attach = it6505_bridge_attach,
+	.detach = it6505_bridge_detach,
+	.mode_valid = it6505_bridge_mode_valid,
+	.mode_set = it6505_bridge_mode_set,
+	.enable = it6505_bridge_enable,
+};
+
+static void it6505_clear_int(struct it6505 *it6505)
+{
+	dptxwr(it6505, 0x06, 0xFF);
+	dptxwr(it6505, 0x07, 0xFF);
+	dptxwr(it6505, 0x08, 0xFF);
+}
+
+static irqreturn_t it6505_intp_threaded_handler(int unused, void *data)
+{
+	struct it6505 *ctx = data;
+	struct device *dev = &ctx->client->dev;
+
+	msleep(100);
+	down(&ctx->sem_notifier);
+
+	if (ctx->it6505_drv_hold)
+		it6505_clear_int(ctx);
+
+	if (ctx->it6505_drv_hold == 0 && ctx->powered) {
+		DRM_DEV_DEBUG_DRIVER(dev, "into it6505_dptx_irq");
+		it6505_dptx_irq(ctx);
+	}
+
+	up(&ctx->sem_notifier);
+	return IRQ_HANDLED;
+}
+
+static int it6505_init_pdata(struct it6505 *it6505)
+{
+	struct it6505_platform_data *pdata = &it6505->pdata;
+	struct device *dev = &it6505->client->dev;
+
+	/* 1.0V digital core power regulator  */
+	pdata->pwr18 = devm_regulator_get(dev, "pwr18");
+	if (IS_ERR(pdata->pwr18)) {
+		DRM_DEV_ERROR(dev, "pwr18 regulator not found");
+		return PTR_ERR(pdata->pwr18);
+	}
+
+	pdata->ovdd = devm_regulator_get(dev, "ovdd");
+	if (IS_ERR(pdata->ovdd)) {
+		DRM_DEV_ERROR(dev, "ovdd regulator not found");
+		return PTR_ERR(pdata->ovdd);
+	}
+
+	/* GPIO for HPD */
+	pdata->gpiod_hpd = devm_gpiod_get(dev, "hpd", GPIOD_IN);
+	if (IS_ERR(pdata->gpiod_hpd))
+		return PTR_ERR(pdata->gpiod_hpd);
+
+	/* GPIO for chip reset */
+	pdata->gpiod_reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+
+	return PTR_ERR_OR_ZERO(pdata->gpiod_reset);
+}
+
+static ssize_t drv_hold_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct it6505 *ctx = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", ctx->it6505_drv_hold);
+}
+
+static ssize_t drv_hold_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct it6505 *ctx = dev_get_drvdata(dev);
+
+	if (kstrtoint(buf, 10, &ctx->it6505_drv_hold) < 0)
+		return -EINVAL;
+	return count;
+}
+
+static ssize_t print_timing_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct it6505 *ctx = dev_get_drvdata(dev);
+	struct drm_display_mode *vid = &ctx->vid_info;
+	char *str = buf, *end = buf + PAGE_SIZE;
+
+	str += scnprintf(str, end - str, "---video timing---\n");
+	str += scnprintf(str, end - str, "PCLK:%d.%03dMHz\n", vid->clock / 1000,
+			 vid->clock % 1000);
+	str += scnprintf(str, end - str, "HTotal:%d\n", vid->htotal);
+	str += scnprintf(str, end - str, "HActive:%d\n", vid->hdisplay);
+	str += scnprintf(str, end - str, "HFrontPorch:%d\n",
+			 vid->hsync_start - vid->hdisplay);
+	str += scnprintf(str, end - str, "HSyncWidth:%d\n",
+			 vid->hsync_end - vid->hsync_start);
+	str += scnprintf(str, end - str, "HBackPorch:%d\n",
+			 vid->htotal - vid->hsync_end);
+	str += scnprintf(str, end - str, "VTotal:%d\n", vid->vtotal);
+	str += scnprintf(str, end - str, "VActive:%d\n", vid->vdisplay);
+	str += scnprintf(str, end - str, "VFrontPorch:%d\n",
+			 vid->vsync_start - vid->vdisplay);
+	str += scnprintf(str, end - str, "VSyncWidth:%d\n",
+			 vid->vsync_end - vid->vsync_start);
+	str += scnprintf(str, end - str, "VBackPorch:%d\n",
+			 vid->vtotal - vid->vsync_end);
+
+	return str - buf;
+}
+
+static ssize_t sha_debug_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	int i = 0;
+	char *str = buf, *end = buf + PAGE_SIZE;
+	struct it6505 *ctx = dev_get_drvdata(dev);
+
+	str += scnprintf(str, end - str, "sha input:\n");
+	for (i = 0; i < ARRAY_SIZE(ctx->shainput); i += 16)
+		str += scnprintf(str, end - str, "%16ph\n", ctx->shainput + i);
+
+	str += scnprintf(str, end - str, "av:\n");
+	for (i = 0; i < ARRAY_SIZE(ctx->av); i++)
+		str += scnprintf(str, end - str, "%4ph\n", ctx->av[i]);
+
+	str += scnprintf(str, end - str, "bv:\n");
+	for (i = 0; i < ARRAY_SIZE(ctx->bv); i++)
+		str += scnprintf(str, end - str, "%4ph\n", ctx->bv[i]);
+
+	return end - str;
+}
+
+static ssize_t en_hdcp_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct it6505 *ctx = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", ctx->en_hdcp);
+}
+
+static ssize_t en_hdcp_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct it6505 *ctx = dev_get_drvdata(dev);
+	unsigned int reg3f, hdcp;
+
+	if (!ctx->powered || ctx->status == SYS_UNPLUG) {
+		DRM_DEV_DEBUG_DRIVER(dev, "can not set en_hdcp");
+		return -EINVAL;
+	}
+	if (kstrtoint(buf, 10, &ctx->en_hdcp) < 0)
+		return -EINVAL;
+
+	if (ctx->en_hdcp) {
+		if (ctx->cp_capable) {
+			dptx_sys_chg(ctx, SYS_ReHDCP);
+			dptx_sys_fsm(ctx);
+		} else {
+			DRM_DEV_ERROR(dev, "sink not support HDCP");
+			ctx->en_hdcp = 0;
+		}
+	} else {
+		dptxset(ctx, 0x05, 0x10, 0x10);
+		dptxset(ctx, 0x05, 0x10, 0x00);
+		dptxrd(ctx, 0x3F, &reg3f);
+		hdcp = (reg3f & BIT(7)) >> 7;
+		DRM_DEV_DEBUG_DRIVER(dev, "%s to disable hdcp",
+				     hdcp ? "failed" : "succeeded");
+		if (hdcp)
+			ctx->en_hdcp = 1;
+	}
+	return count;
+}
+
+static ssize_t en_pwronoff_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct it6505 *ctx = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", ctx->en_pwronoff);
+}
+
+static ssize_t en_pwronoff_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct it6505 *ctx = dev_get_drvdata(dev);
+
+	if (kstrtoint(buf, 10, &ctx->en_pwronoff) < 0)
+		return -EINVAL;
+	return count;
+}
+
+static ssize_t en_audio_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct it6505 *ctx = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", ctx->en_audio);
+}
+
+static ssize_t en_audio_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct it6505 *ctx = dev_get_drvdata(dev);
+
+	if (!ctx->powered || ctx->status == SYS_UNPLUG) {
+		DRM_DEV_DEBUG_DRIVER(dev, "can not set en_audio");
+		return -EINVAL;
+	}
+	if (kstrtoint(buf, 10, &ctx->en_audio) < 0)
+		return -EINVAL;
+	if (ctx->en_audio) {
+		it6505_set_audio(ctx, ctx->aud_sel, ctx->aud_type, ctx->aud_fs,
+				 ctx->aud_ch);
+	} else {
+		dptxset(ctx, 0x05, 0x02, 0x02);
+		dptxset(ctx, 0x05, 0x02, 0x00);
+	}
+	DRM_DEV_DEBUG_DRIVER(dev, "%s audio",
+			     ctx->en_audio ? "Enable" : "Disable");
+	return count;
+}
+
+static ssize_t force_pwronoff_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct it6505 *ctx = dev_get_drvdata(dev);
+	int pwr;
+
+	if (kstrtoint(buf, 10, &pwr) < 0)
+		return -EINVAL;
+	if (pwr)
+		it6505_poweron(ctx);
+	else
+		it6505_poweroff(ctx);
+	return count;
+}
+
+static ssize_t pwr_status_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct it6505 *ctx = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", ctx->powered);
+}
+
+static DEVICE_ATTR_RO(print_timing);
+static DEVICE_ATTR_RO(pwr_status);
+static DEVICE_ATTR_RO(sha_debug);
+static DEVICE_ATTR_WO(force_pwronoff);
+static DEVICE_ATTR_RW(drv_hold);
+static DEVICE_ATTR_RW(en_hdcp);
+static DEVICE_ATTR_RW(en_pwronoff);
+static DEVICE_ATTR_RW(en_audio);
+
+static const struct attribute *it6505_attrs[] = {
+	&dev_attr_drv_hold.attr,
+	&dev_attr_print_timing.attr,
+	&dev_attr_sha_debug.attr,
+	&dev_attr_en_hdcp.attr,
+	&dev_attr_en_pwronoff.attr,
+	&dev_attr_en_audio.attr,
+	&dev_attr_force_pwronoff.attr,
+	&dev_attr_pwr_status.attr,
+	NULL,
+};
+
+static int it6505_i2c_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	struct it6505 *ctx;
+	struct it6505_platform_data *pdata;
+	struct device *dev = &client->dev;
+	struct extcon_dev *extcon;
+	struct it6505_dp_port *port;
+	int err = 0, hpd_irq, intp_irq;
+
+	ctx = devm_kzalloc(&client->dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	mutex_init(&ctx->lock);
+
+	pdata = &ctx->pdata;
+
+	ctx->bridge.of_node = client->dev.of_node;
+	ctx->client = client;
+	i2c_set_clientdata(client, ctx);
+
+	/* get extcon device from DTS */
+	extcon = extcon_get_edev_by_phandle(dev, 0);
+	if (PTR_ERR(extcon) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (IS_ERR(extcon)) {
+		DRM_DEV_ERROR(dev, "can not get extcon device!");
+		return -EINVAL;
+	}
+
+	port = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);
+	if (!port)
+		return -ENOMEM;
+	port->extcon = extcon;
+	port->it6505_dp = ctx;
+	ctx->port = port;
+	err = it6505_use_notifier_module(ctx);
+	if (err < 0)
+		return err;
+
+	err = it6505_init_pdata(ctx);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to initialize pdata: %d", err);
+		return err;
+	}
+
+	ctx->regmap =
+		devm_regmap_init_i2c(client, &it6505_bridge_regmap_config);
+	if (IS_ERR(ctx->regmap)) {
+		DRM_DEV_ERROR(dev, "regmap i2c init failed");
+		return PTR_ERR(ctx->regmap);
+	}
+
+	hpd_irq = gpiod_to_irq(pdata->gpiod_hpd);
+
+	if (hpd_irq < 0) {
+		DRM_DEV_ERROR(dev, "Failed to get HPD IRQ: %d", hpd_irq);
+		return -ENODEV;
+	}
+
+	intp_irq = client->irq;
+
+	if (!intp_irq) {
+		DRM_DEV_ERROR(dev, "Failed to get CABLE_DET and INTP IRQ");
+		return -ENODEV;
+	}
+
+	err = devm_request_threaded_irq(&client->dev, intp_irq, NULL,
+					it6505_intp_threaded_handler,
+					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					"it6505-intp", ctx);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to request INTP threaded IRQ: %d",
+			      err);
+		return err;
+	}
+
+	/* Register aux channel */
+	ctx->aux.name = "DP-AUX";
+	ctx->aux.dev = dev;
+	ctx->aux.transfer = it6505_aux_transfer;
+	err = drm_dp_aux_register(&ctx->aux);
+	if (err < 0) {
+		DRM_DEV_ERROR(dev, "Failed to register aux: %d", err);
+		return err;
+	}
+
+	/* thread sequence control */
+	sema_init(&ctx->sem_notifier, 1);
+	ctx->en_pwronoff = 1;
+	ctx->powered = 0;
+	ctx->it6505_drv_hold = 0;
+	err = sysfs_create_files(&client->dev.kobj, it6505_attrs);
+	if (err) {
+		drm_dp_aux_unregister(&ctx->aux);
+		return err;
+	}
+
+	ctx->bridge.funcs = &it6505_bridge_funcs;
+	drm_bridge_add(&ctx->bridge);
+	return 0;
+}
+
+static int it6505_remove(struct i2c_client *client)
+{
+	struct it6505 *ctx = i2c_get_clientdata(client);
+
+	drm_bridge_remove(&ctx->bridge);
+	sysfs_remove_files(&client->dev.kobj, it6505_attrs);
+	kfree(ctx->edid);
+	ctx->edid = NULL;
+	drm_connector_unregister(&ctx->connector);
+	drm_dp_aux_unregister(&ctx->aux);
+	return 0;
+}
+
+static const struct i2c_device_id it6505_id[] = {
+	{ "it6505", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, it6505_id);
+
+static const struct of_device_id it6505_of_match[] = {
+	{ .compatible = "ite,it6505" },
+	{ }
+};
+
+struct i2c_driver it6505_i2c_driver = {
+	.driver = {
+		.name = "it6505_dptx",
+		.owner = THIS_MODULE,
+		.of_match_table = it6505_of_match,
+	},
+	.probe = it6505_i2c_probe,
+	.remove = it6505_remove,
+	.id_table = it6505_id,
+};
+
+static int __init it6505_init(void)
+{
+	i2c_add_driver(&it6505_i2c_driver);
+	return 0;
+}
+
+static void __exit it6505_exit(void)
+{
+	i2c_del_driver(&it6505_i2c_driver);
+}
+
+module_init(it6505_init);
+module_exit(it6505_exit);
+
+MODULE_AUTHOR("Jitao Shi <jitao.shi@mediatek.com>");
+MODULE_DESCRIPTION("IT6505 DisplayPort Transmitter driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_crtc.c b/drivers/gpu/drm/mediatek/mtk_drm_crtc.c
index f70d33c8b495..60e101ca9d03 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_crtc.c
+++ b/drivers/gpu/drm/mediatek/mtk_drm_crtc.c
@@ -18,7 +18,6 @@
 #include <drm/drm_plane_helper.h>
 #include <linux/clk.h>
 #include <linux/pm_runtime.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_drm_drv.h"
 #include "mtk_drm_crtc.h"
@@ -396,20 +395,12 @@ static void mtk_drm_crtc_atomic_enable(struct drm_crtc *crtc,
 				       struct drm_crtc_state *old_state)
 {
 	struct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);
-	struct mtk_ddp_comp *comp = mtk_crtc->ddp_comp[0];
 	int ret;
 
 	DRM_DEBUG_DRIVER("%s %d\n", __func__, crtc->base.id);
 
-	ret = mtk_smi_larb_get(comp->larb_dev);
-	if (ret) {
-		DRM_ERROR("Failed to get larb: %d\n", ret);
-		return;
-	}
-
 	ret = mtk_crtc_ddp_hw_init(mtk_crtc);
 	if (ret) {
-		mtk_smi_larb_put(comp->larb_dev);
 		return;
 	}
 
@@ -421,7 +412,6 @@ static void mtk_drm_crtc_atomic_disable(struct drm_crtc *crtc,
 					struct drm_crtc_state *old_state)
 {
 	struct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);
-	struct mtk_ddp_comp *comp = mtk_crtc->ddp_comp[0];
 	int i;
 
 	DRM_DEBUG_DRIVER("%s %d\n", __func__, crtc->base.id);
@@ -444,7 +434,6 @@ static void mtk_drm_crtc_atomic_disable(struct drm_crtc *crtc,
 
 	drm_crtc_vblank_off(crtc);
 	mtk_crtc_ddp_hw_fini(mtk_crtc);
-	mtk_smi_larb_put(comp->larb_dev);
 
 	mtk_crtc->enabled = false;
 }
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c
index bb55d1dc8746..6a66373df6e9 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c
+++ b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c
@@ -351,8 +351,6 @@ int mtk_ddp_comp_init(struct device *dev, struct device_node *node,
 		      const struct mtk_ddp_comp_funcs *funcs)
 {
 	enum mtk_ddp_comp_type type;
-	struct device_node *larb_node;
-	struct platform_device *larb_pdev;
 
 	if (comp_id < 0 || comp_id >= DDP_COMPONENT_ID_MAX)
 		return -EINVAL;
@@ -382,31 +380,6 @@ int mtk_ddp_comp_init(struct device *dev, struct device_node *node,
 	if (IS_ERR(comp->clk))
 		return PTR_ERR(comp->clk);
 
-	/* Only DMA capable components need the LARB property */
-	comp->larb_dev = NULL;
-	if (type != MTK_DISP_OVL &&
-	    type != MTK_DISP_OVL_2L &&
-	    type != MTK_DISP_RDMA &&
-	    type != MTK_DISP_WDMA)
-		return 0;
-
-	larb_node = of_parse_phandle(node, "mediatek,larb", 0);
-	if (!larb_node) {
-		dev_err(dev,
-			"Missing mediadek,larb phandle in %pOF node\n", node);
-		return -EINVAL;
-	}
-
-	larb_pdev = of_find_device_by_node(larb_node);
-	if (!larb_pdev) {
-		dev_warn(dev, "Waiting for larb device %pOF\n", larb_node);
-		of_node_put(larb_node);
-		return -EPROBE_DEFER;
-	}
-	of_node_put(larb_node);
-
-	comp->larb_dev = &larb_pdev->dev;
-
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h
index 6bf46d1f39b4..9e7969bc755f 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h
+++ b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h
@@ -101,7 +101,6 @@ struct mtk_ddp_comp {
 	struct clk *clk;
 	void __iomem *regs;
 	int irq;
-	struct device *larb_dev;
 	enum mtk_ddp_comp_id id;
 	const struct mtk_ddp_comp_funcs *funcs;
 };
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 4aae4a7d9f71..3d4817d381e0 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -28,6 +28,15 @@ config DRM_PANEL_BOE_HIMAX8279D
 	  24 bit RGB per pixel. It provides a MIPI DSI interface to
 	  the host and has a built-in LED backlight.
 
+config DRM_PANEL_BOE_TV101WUM_NL6
+	tristate "BOE TV101WUM 1200x1920 panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to support for BOE TV101WUM WUXGA PANEL
+	  DSI Video Mode panel
+
 config DRM_PANEL_LVDS
 	tristate "Generic LVDS panel driver"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 7285539d8015..47e639a7f575 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_DRM_PANEL_ARM_VERSATILE) += panel-arm-versatile.o
 obj-$(CONFIG_DRM_PANEL_BOE_HIMAX8279D) += panel-boe-himax8279d.o
+obj-$(CONFIG_DRM_PANEL_BOE_TV101WUM_NL6) += panel-boe-tv101wum-nl6.o
 obj-$(CONFIG_DRM_PANEL_LVDS) += panel-lvds.o
 obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-simple.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_IL9322) += panel-ilitek-ili9322.o
diff --git a/drivers/gpu/drm/panel/panel-boe-tv101wum-nl6.c b/drivers/gpu/drm/panel/panel-boe-tv101wum-nl6.c
new file mode 100644
index 000000000000..91898794df74
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-boe-tv101wum-nl6.c
@@ -0,0 +1,755 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Jitao Shi <jitao.shi@mediatek.com>
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+
+#include <video/mipi_display.h>
+
+struct panel_desc {
+	const struct drm_display_mode *modes;
+	unsigned int bpc;
+
+	/**
+	 * @width: width (in millimeters) of the panel's active display area
+	 * @height: height (in millimeters) of the panel's active display area
+	 */
+	struct {
+		unsigned int width;
+		unsigned int height;
+	} size;
+
+	unsigned long mode_flags;
+	enum mipi_dsi_pixel_format format;
+	const struct panel_init_cmd *init_cmds;
+	unsigned int lanes;
+};
+
+struct boe_panel {
+	struct drm_panel base;
+	struct mipi_dsi_device *dsi;
+
+	const struct panel_desc *desc;
+
+	struct backlight_device *backlight;
+	struct regulator *pp1800;
+	struct regulator *avee;
+	struct regulator *avdd;
+	struct gpio_desc *enable_gpio;
+
+	bool prepared;
+	bool enabled;
+
+	const struct drm_display_mode *mode;
+};
+
+enum dsi_cmd_type {
+	INIT_DCS_CMD,
+	DELAY_CMD,
+};
+
+struct panel_init_cmd {
+	enum dsi_cmd_type type;
+	size_t len;
+	const char *data;
+};
+
+#define _INIT_DCS_CMD(...) { \
+	.type = INIT_DCS_CMD, \
+	.len = sizeof((char[]){__VA_ARGS__}), \
+	.data = (char[]){__VA_ARGS__} }
+
+#define _INIT_DELAY_CMD(...) { \
+	.type = DELAY_CMD,\
+	.len = sizeof((char[]){__VA_ARGS__}), \
+	.data = (char[]){__VA_ARGS__} }
+
+static const struct panel_init_cmd boe_init_cmd[] = {
+	_INIT_DELAY_CMD(24),
+	_INIT_DCS_CMD(0xB0, 0x05),
+	_INIT_DCS_CMD(0xB1, 0xE5),
+	_INIT_DCS_CMD(0xB3, 0x52),
+	_INIT_DCS_CMD(0xB0, 0x00),
+	_INIT_DCS_CMD(0xB3, 0x88),
+	_INIT_DCS_CMD(0xB0, 0x04),
+	_INIT_DCS_CMD(0xB8, 0x00),
+	_INIT_DCS_CMD(0xB0, 0x00),
+	_INIT_DCS_CMD(0xB6, 0x03),
+	_INIT_DCS_CMD(0xBA, 0x8B),
+	_INIT_DCS_CMD(0xBF, 0x1A),
+	_INIT_DCS_CMD(0xC0, 0x0F),
+	_INIT_DCS_CMD(0xC2, 0x0C),
+	_INIT_DCS_CMD(0xC3, 0x02),
+	_INIT_DCS_CMD(0xC4, 0x0C),
+	_INIT_DCS_CMD(0xC5, 0x02),
+	_INIT_DCS_CMD(0xB0, 0x01),
+	_INIT_DCS_CMD(0xE0, 0x26),
+	_INIT_DCS_CMD(0xE1, 0x26),
+	_INIT_DCS_CMD(0xDC, 0x00),
+	_INIT_DCS_CMD(0xDD, 0x00),
+	_INIT_DCS_CMD(0xCC, 0x26),
+	_INIT_DCS_CMD(0xCD, 0x26),
+	_INIT_DCS_CMD(0xC8, 0x00),
+	_INIT_DCS_CMD(0xC9, 0x00),
+	_INIT_DCS_CMD(0xD2, 0x03),
+	_INIT_DCS_CMD(0xD3, 0x03),
+	_INIT_DCS_CMD(0xE6, 0x04),
+	_INIT_DCS_CMD(0xE7, 0x04),
+	_INIT_DCS_CMD(0xC4, 0x09),
+	_INIT_DCS_CMD(0xC5, 0x09),
+	_INIT_DCS_CMD(0xD8, 0x0A),
+	_INIT_DCS_CMD(0xD9, 0x0A),
+	_INIT_DCS_CMD(0xC2, 0x0B),
+	_INIT_DCS_CMD(0xC3, 0x0B),
+	_INIT_DCS_CMD(0xD6, 0x0C),
+	_INIT_DCS_CMD(0xD7, 0x0C),
+	_INIT_DCS_CMD(0xC0, 0x05),
+	_INIT_DCS_CMD(0xC1, 0x05),
+	_INIT_DCS_CMD(0xD4, 0x06),
+	_INIT_DCS_CMD(0xD5, 0x06),
+	_INIT_DCS_CMD(0xCA, 0x07),
+	_INIT_DCS_CMD(0xCB, 0x07),
+	_INIT_DCS_CMD(0xDE, 0x08),
+	_INIT_DCS_CMD(0xDF, 0x08),
+	_INIT_DCS_CMD(0xB0, 0x02),
+	_INIT_DCS_CMD(0xC0, 0x00),
+	_INIT_DCS_CMD(0xC1, 0x0D),
+	_INIT_DCS_CMD(0xC2, 0x17),
+	_INIT_DCS_CMD(0xC3, 0x26),
+	_INIT_DCS_CMD(0xC4, 0x31),
+	_INIT_DCS_CMD(0xC5, 0x1C),
+	_INIT_DCS_CMD(0xC6, 0x2C),
+	_INIT_DCS_CMD(0xC7, 0x33),
+	_INIT_DCS_CMD(0xC8, 0x31),
+	_INIT_DCS_CMD(0xC9, 0x37),
+	_INIT_DCS_CMD(0xCA, 0x37),
+	_INIT_DCS_CMD(0xCB, 0x37),
+	_INIT_DCS_CMD(0xCC, 0x39),
+	_INIT_DCS_CMD(0xCD, 0x2E),
+	_INIT_DCS_CMD(0xCE, 0x2F),
+	_INIT_DCS_CMD(0xCF, 0x2F),
+	_INIT_DCS_CMD(0xD0, 0x07),
+	_INIT_DCS_CMD(0xD2, 0x00),
+	_INIT_DCS_CMD(0xD3, 0x0D),
+	_INIT_DCS_CMD(0xD4, 0x17),
+	_INIT_DCS_CMD(0xD5, 0x26),
+	_INIT_DCS_CMD(0xD6, 0x31),
+	_INIT_DCS_CMD(0xD7, 0x3F),
+	_INIT_DCS_CMD(0xD8, 0x3F),
+	_INIT_DCS_CMD(0xD9, 0x3F),
+	_INIT_DCS_CMD(0xDA, 0x3F),
+	_INIT_DCS_CMD(0xDB, 0x37),
+	_INIT_DCS_CMD(0xDC, 0x37),
+	_INIT_DCS_CMD(0xDD, 0x37),
+	_INIT_DCS_CMD(0xDE, 0x39),
+	_INIT_DCS_CMD(0xDF, 0x2E),
+	_INIT_DCS_CMD(0xE0, 0x2F),
+	_INIT_DCS_CMD(0xE1, 0x2F),
+	_INIT_DCS_CMD(0xE2, 0x07),
+	_INIT_DCS_CMD(0xB0, 0x03),
+	_INIT_DCS_CMD(0xC8, 0x0B),
+	_INIT_DCS_CMD(0xC9, 0x07),
+	_INIT_DCS_CMD(0xC3, 0x00),
+	_INIT_DCS_CMD(0xE7, 0x00),
+	_INIT_DCS_CMD(0xC5, 0x2A),
+	_INIT_DCS_CMD(0xDE, 0x2A),
+	_INIT_DCS_CMD(0xCA, 0x43),
+	_INIT_DCS_CMD(0xC9, 0x07),
+	_INIT_DCS_CMD(0xE4, 0xC0),
+	_INIT_DCS_CMD(0xE5, 0x0D),
+	_INIT_DCS_CMD(0xCB, 0x00),
+	_INIT_DCS_CMD(0xB0, 0x06),
+	_INIT_DCS_CMD(0xB8, 0xA5),
+	_INIT_DCS_CMD(0xC0, 0xA5),
+	_INIT_DCS_CMD(0xC7, 0x0F),
+	_INIT_DCS_CMD(0xD5, 0x32),
+	_INIT_DCS_CMD(0xB8, 0x00),
+	_INIT_DCS_CMD(0xC0, 0x00),
+	_INIT_DCS_CMD(0xBC, 0x00),
+	_INIT_DCS_CMD(0xB0, 0x07),
+	_INIT_DCS_CMD(0xB1, 0x00),
+	_INIT_DCS_CMD(0xB2, 0x02),
+	_INIT_DCS_CMD(0xB3, 0x0F),
+	_INIT_DCS_CMD(0xB4, 0x25),
+	_INIT_DCS_CMD(0xB5, 0x39),
+	_INIT_DCS_CMD(0xB6, 0x4E),
+	_INIT_DCS_CMD(0xB7, 0x72),
+	_INIT_DCS_CMD(0xB8, 0x97),
+	_INIT_DCS_CMD(0xB9, 0xDC),
+	_INIT_DCS_CMD(0xBA, 0x22),
+	_INIT_DCS_CMD(0xBB, 0xA4),
+	_INIT_DCS_CMD(0xBC, 0x2B),
+	_INIT_DCS_CMD(0xBD, 0x2F),
+	_INIT_DCS_CMD(0xBE, 0xA9),
+	_INIT_DCS_CMD(0xBF, 0x25),
+	_INIT_DCS_CMD(0xC0, 0x61),
+	_INIT_DCS_CMD(0xC1, 0x97),
+	_INIT_DCS_CMD(0xC2, 0xB2),
+	_INIT_DCS_CMD(0xC3, 0xCD),
+	_INIT_DCS_CMD(0xC4, 0xD9),
+	_INIT_DCS_CMD(0xC5, 0xE7),
+	_INIT_DCS_CMD(0xC6, 0xF4),
+	_INIT_DCS_CMD(0xC7, 0xFA),
+	_INIT_DCS_CMD(0xC8, 0xFC),
+	_INIT_DCS_CMD(0xC9, 0x00),
+	_INIT_DCS_CMD(0xCA, 0x00),
+	_INIT_DCS_CMD(0xCB, 0x16),
+	_INIT_DCS_CMD(0xCC, 0xAF),
+	_INIT_DCS_CMD(0xCD, 0xFF),
+	_INIT_DCS_CMD(0xCE, 0xFF),
+	_INIT_DCS_CMD(0xB0, 0x08),
+	_INIT_DCS_CMD(0xB1, 0x04),
+	_INIT_DCS_CMD(0xB2, 0x05),
+	_INIT_DCS_CMD(0xB3, 0x11),
+	_INIT_DCS_CMD(0xB4, 0x24),
+	_INIT_DCS_CMD(0xB5, 0x39),
+	_INIT_DCS_CMD(0xB6, 0x4F),
+	_INIT_DCS_CMD(0xB7, 0x72),
+	_INIT_DCS_CMD(0xB8, 0x98),
+	_INIT_DCS_CMD(0xB9, 0xDC),
+	_INIT_DCS_CMD(0xBA, 0x23),
+	_INIT_DCS_CMD(0xBB, 0xA6),
+	_INIT_DCS_CMD(0xBC, 0x2C),
+	_INIT_DCS_CMD(0xBD, 0x30),
+	_INIT_DCS_CMD(0xBE, 0xAA),
+	_INIT_DCS_CMD(0xBF, 0x26),
+	_INIT_DCS_CMD(0xC0, 0x62),
+	_INIT_DCS_CMD(0xC1, 0x9B),
+	_INIT_DCS_CMD(0xC2, 0xB5),
+	_INIT_DCS_CMD(0xC3, 0xCF),
+	_INIT_DCS_CMD(0xC4, 0xDB),
+	_INIT_DCS_CMD(0xC5, 0xE8),
+	_INIT_DCS_CMD(0xC6, 0xF5),
+	_INIT_DCS_CMD(0xC7, 0xFA),
+	_INIT_DCS_CMD(0xC8, 0xFC),
+	_INIT_DCS_CMD(0xC9, 0x00),
+	_INIT_DCS_CMD(0xCA, 0x00),
+	_INIT_DCS_CMD(0xCB, 0x16),
+	_INIT_DCS_CMD(0xCC, 0xAF),
+	_INIT_DCS_CMD(0xCD, 0xFF),
+	_INIT_DCS_CMD(0xCE, 0xFF),
+	_INIT_DCS_CMD(0xB0, 0x09),
+	_INIT_DCS_CMD(0xB1, 0x04),
+	_INIT_DCS_CMD(0xB2, 0x02),
+	_INIT_DCS_CMD(0xB3, 0x16),
+	_INIT_DCS_CMD(0xB4, 0x24),
+	_INIT_DCS_CMD(0xB5, 0x3B),
+	_INIT_DCS_CMD(0xB6, 0x4F),
+	_INIT_DCS_CMD(0xB7, 0x73),
+	_INIT_DCS_CMD(0xB8, 0x99),
+	_INIT_DCS_CMD(0xB9, 0xE0),
+	_INIT_DCS_CMD(0xBA, 0x26),
+	_INIT_DCS_CMD(0xBB, 0xAD),
+	_INIT_DCS_CMD(0xBC, 0x36),
+	_INIT_DCS_CMD(0xBD, 0x3A),
+	_INIT_DCS_CMD(0xBE, 0xAE),
+	_INIT_DCS_CMD(0xBF, 0x2A),
+	_INIT_DCS_CMD(0xC0, 0x66),
+	_INIT_DCS_CMD(0xC1, 0x9E),
+	_INIT_DCS_CMD(0xC2, 0xB8),
+	_INIT_DCS_CMD(0xC3, 0xD1),
+	_INIT_DCS_CMD(0xC4, 0xDD),
+	_INIT_DCS_CMD(0xC5, 0xE9),
+	_INIT_DCS_CMD(0xC6, 0xF6),
+	_INIT_DCS_CMD(0xC7, 0xFA),
+	_INIT_DCS_CMD(0xC8, 0xFC),
+	_INIT_DCS_CMD(0xC9, 0x00),
+	_INIT_DCS_CMD(0xCA, 0x00),
+	_INIT_DCS_CMD(0xCB, 0x16),
+	_INIT_DCS_CMD(0xCC, 0xAF),
+	_INIT_DCS_CMD(0xCD, 0xFF),
+	_INIT_DCS_CMD(0xCE, 0xFF),
+	_INIT_DCS_CMD(0xB0, 0x0A),
+	_INIT_DCS_CMD(0xB1, 0x00),
+	_INIT_DCS_CMD(0xB2, 0x02),
+	_INIT_DCS_CMD(0xB3, 0x0F),
+	_INIT_DCS_CMD(0xB4, 0x25),
+	_INIT_DCS_CMD(0xB5, 0x39),
+	_INIT_DCS_CMD(0xB6, 0x4E),
+	_INIT_DCS_CMD(0xB7, 0x72),
+	_INIT_DCS_CMD(0xB8, 0x97),
+	_INIT_DCS_CMD(0xB9, 0xDC),
+	_INIT_DCS_CMD(0xBA, 0x22),
+	_INIT_DCS_CMD(0xBB, 0xA4),
+	_INIT_DCS_CMD(0xBC, 0x2B),
+	_INIT_DCS_CMD(0xBD, 0x2F),
+	_INIT_DCS_CMD(0xBE, 0xA9),
+	_INIT_DCS_CMD(0xBF, 0x25),
+	_INIT_DCS_CMD(0xC0, 0x61),
+	_INIT_DCS_CMD(0xC1, 0x97),
+	_INIT_DCS_CMD(0xC2, 0xB2),
+	_INIT_DCS_CMD(0xC3, 0xCD),
+	_INIT_DCS_CMD(0xC4, 0xD9),
+	_INIT_DCS_CMD(0xC5, 0xE7),
+	_INIT_DCS_CMD(0xC6, 0xF4),
+	_INIT_DCS_CMD(0xC7, 0xFA),
+	_INIT_DCS_CMD(0xC8, 0xFC),
+	_INIT_DCS_CMD(0xC9, 0x00),
+	_INIT_DCS_CMD(0xCA, 0x00),
+	_INIT_DCS_CMD(0xCB, 0x16),
+	_INIT_DCS_CMD(0xCC, 0xAF),
+	_INIT_DCS_CMD(0xCD, 0xFF),
+	_INIT_DCS_CMD(0xCE, 0xFF),
+	_INIT_DCS_CMD(0xB0, 0x0B),
+	_INIT_DCS_CMD(0xB1, 0x04),
+	_INIT_DCS_CMD(0xB2, 0x05),
+	_INIT_DCS_CMD(0xB3, 0x11),
+	_INIT_DCS_CMD(0xB4, 0x24),
+	_INIT_DCS_CMD(0xB5, 0x39),
+	_INIT_DCS_CMD(0xB6, 0x4F),
+	_INIT_DCS_CMD(0xB7, 0x72),
+	_INIT_DCS_CMD(0xB8, 0x98),
+	_INIT_DCS_CMD(0xB9, 0xDC),
+	_INIT_DCS_CMD(0xBA, 0x23),
+	_INIT_DCS_CMD(0xBB, 0xA6),
+	_INIT_DCS_CMD(0xBC, 0x2C),
+	_INIT_DCS_CMD(0xBD, 0x30),
+	_INIT_DCS_CMD(0xBE, 0xAA),
+	_INIT_DCS_CMD(0xBF, 0x26),
+	_INIT_DCS_CMD(0xC0, 0x62),
+	_INIT_DCS_CMD(0xC1, 0x9B),
+	_INIT_DCS_CMD(0xC2, 0xB5),
+	_INIT_DCS_CMD(0xC3, 0xCF),
+	_INIT_DCS_CMD(0xC4, 0xDB),
+	_INIT_DCS_CMD(0xC5, 0xE8),
+	_INIT_DCS_CMD(0xC6, 0xF5),
+	_INIT_DCS_CMD(0xC7, 0xFA),
+	_INIT_DCS_CMD(0xC8, 0xFC),
+	_INIT_DCS_CMD(0xC9, 0x00),
+	_INIT_DCS_CMD(0xCA, 0x00),
+	_INIT_DCS_CMD(0xCB, 0x16),
+	_INIT_DCS_CMD(0xCC, 0xAF),
+	_INIT_DCS_CMD(0xCD, 0xFF),
+	_INIT_DCS_CMD(0xCE, 0xFF),
+	_INIT_DCS_CMD(0xB0, 0x0C),
+	_INIT_DCS_CMD(0xB1, 0x04),
+	_INIT_DCS_CMD(0xB2, 0x02),
+	_INIT_DCS_CMD(0xB3, 0x16),
+	_INIT_DCS_CMD(0xB4, 0x24),
+	_INIT_DCS_CMD(0xB5, 0x3B),
+	_INIT_DCS_CMD(0xB6, 0x4F),
+	_INIT_DCS_CMD(0xB7, 0x73),
+	_INIT_DCS_CMD(0xB8, 0x99),
+	_INIT_DCS_CMD(0xB9, 0xE0),
+	_INIT_DCS_CMD(0xBA, 0x26),
+	_INIT_DCS_CMD(0xBB, 0xAD),
+	_INIT_DCS_CMD(0xBC, 0x36),
+	_INIT_DCS_CMD(0xBD, 0x3A),
+	_INIT_DCS_CMD(0xBE, 0xAE),
+	_INIT_DCS_CMD(0xBF, 0x2A),
+	_INIT_DCS_CMD(0xC0, 0x66),
+	_INIT_DCS_CMD(0xC1, 0x9E),
+	_INIT_DCS_CMD(0xC2, 0xB8),
+	_INIT_DCS_CMD(0xC3, 0xD1),
+	_INIT_DCS_CMD(0xC4, 0xDD),
+	_INIT_DCS_CMD(0xC5, 0xE9),
+	_INIT_DCS_CMD(0xC6, 0xF6),
+	_INIT_DCS_CMD(0xC7, 0xFA),
+	_INIT_DCS_CMD(0xC8, 0xFC),
+	_INIT_DCS_CMD(0xC9, 0x00),
+	_INIT_DCS_CMD(0xCA, 0x00),
+	_INIT_DCS_CMD(0xCB, 0x16),
+	_INIT_DCS_CMD(0xCC, 0xAF),
+	_INIT_DCS_CMD(0xCD, 0xFF),
+	_INIT_DCS_CMD(0xCE, 0xFF),
+	_INIT_DCS_CMD(0xB0, 0x00),
+	_INIT_DCS_CMD(0xB3, 0x08),
+	_INIT_DCS_CMD(0xB0, 0x04),
+	_INIT_DCS_CMD(0xB8, 0x68),
+	_INIT_DELAY_CMD(150),
+	{},
+};
+
+static const struct panel_init_cmd auo_init_cmd[] = {
+	_INIT_DELAY_CMD(24),
+	_INIT_DCS_CMD(0x11),
+	_INIT_DELAY_CMD(120),
+	_INIT_DCS_CMD(0x29),
+	_INIT_DELAY_CMD(120),
+	{},
+};
+
+static inline struct boe_panel *to_boe_panel(struct drm_panel *panel)
+{
+	return container_of(panel, struct boe_panel, base);
+}
+
+static int boe_panel_init(struct boe_panel *boe)
+{
+	struct mipi_dsi_device *dsi = boe->dsi;
+	struct drm_panel *panel = &boe->base;
+	int err, i;
+
+	if (boe->desc->init_cmds) {
+		const struct panel_init_cmd *init_cmds = boe->desc->init_cmds;
+
+		for (i = 0; init_cmds[i].len != 0; i++) {
+			const struct panel_init_cmd *cmd = &init_cmds[i];
+
+			switch (cmd->type) {
+			case DELAY_CMD:
+				msleep(cmd->data[0]);
+				err = 0;
+				break;
+
+			case INIT_DCS_CMD:
+				err = mipi_dsi_dcs_write(dsi, cmd->data[0],
+							 cmd->len <= 1 ? NULL :
+							 &cmd->data[1],
+							 cmd->len - 1);
+				break;
+			}
+
+			if (err < 0) {
+				dev_err(panel->dev,
+					"failed to write command %u\n", i);
+				return err;
+			}
+		}
+	}
+	return 0;
+}
+
+static int boe_panel_off(struct boe_panel *boe)
+{
+	struct mipi_dsi_device *dsi = boe->dsi;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int boe_panel_disable(struct drm_panel *panel)
+{
+	struct boe_panel *boe = to_boe_panel(panel);
+
+	if (!boe->enabled)
+		return 0;
+
+	backlight_disable(boe->backlight);
+
+	boe->enabled = false;
+
+	return 0;
+}
+
+static int boe_panel_unprepare(struct drm_panel *panel)
+{
+	struct boe_panel *boe = to_boe_panel(panel);
+	int ret;
+
+	if (!boe->prepared)
+		return 0;
+
+	ret = boe_panel_off(boe);
+	if (ret < 0) {
+		dev_err(panel->dev, "failed to set panel off: %d\n", ret);
+		return ret;
+	}
+
+	msleep(150);
+	if (boe->enable_gpio)
+		gpiod_set_value(boe->enable_gpio, 0);
+	usleep_range(500, 1000);
+	regulator_disable(boe->avee);
+	regulator_disable(boe->avdd);
+	usleep_range(5000, 7000);
+	regulator_disable(boe->pp1800);
+
+	boe->prepared = false;
+
+	return 0;
+}
+
+static int boe_panel_prepare(struct drm_panel *panel)
+{
+	struct boe_panel *boe = to_boe_panel(panel);
+	int ret;
+
+	if (boe->prepared)
+		return 0;
+
+	if (boe->enable_gpio) {
+		gpiod_set_value(boe->enable_gpio, 0);
+		usleep_range(1000, 1500);
+	}
+
+	ret = regulator_enable(boe->pp1800);
+	if (ret < 0)
+		return ret;
+
+	usleep_range(3000, 5000);
+
+	ret = regulator_enable(boe->avdd);
+	if (ret < 0)
+		goto poweroff1v8;
+	ret = regulator_enable(boe->avee);
+	if (ret < 0)
+		goto poweroffavdd;
+
+	msleep(100);
+
+	if (boe->enable_gpio) {
+		gpiod_set_value(boe->enable_gpio, 1);
+		usleep_range(10000, 12000);
+	}
+
+	ret = boe_panel_init(boe);
+	if (ret < 0) {
+		dev_err(panel->dev, "failed to init panel: %d\n", ret);
+		goto poweroff;
+	}
+
+	boe->prepared = true;
+
+	return 0;
+
+poweroff:
+	regulator_disable(boe->avee);
+poweroffavdd:
+	regulator_disable(boe->avdd);
+poweroff1v8:
+	usleep_range(5000, 7000);
+	regulator_disable(boe->pp1800);
+	if (boe->enable_gpio)
+		gpiod_set_value(boe->enable_gpio, 0);
+	return ret;
+}
+
+static int boe_panel_enable(struct drm_panel *panel)
+{
+	struct boe_panel *boe = to_boe_panel(panel);
+	int ret;
+
+	if (boe->enabled)
+		return 0;
+
+	ret = backlight_enable(boe->backlight);
+	if (ret) {
+		dev_err(panel->dev, "Failed to enable backlight %d\n",
+			ret);
+		return ret;
+	}
+
+	boe->enabled = true;
+
+	return 0;
+}
+
+static const struct drm_display_mode boe_default_mode = {
+	.clock = 159425,
+	.hdisplay = 1200,
+	.hsync_start = 1200 + 100,
+	.hsync_end = 1200 + 100 + 40,
+	.htotal = 1200 + 100 + 40 + 24,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 10,
+	.vsync_end = 1920 + 10 + 14,
+	.vtotal = 1920 + 10 + 14 + 4,
+	.vrefresh = 60,
+	.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,
+};
+
+static const struct panel_desc boe_tv101wum_nl6_desc = {
+	.modes = &boe_default_mode,
+	.bpc = 8,
+	.size = {
+		.width = 135,
+		.height = 216,
+	},
+	.lanes = 4,
+	.format = MIPI_DSI_FMT_RGB888,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+		      MIPI_DSI_MODE_LPM,
+	.init_cmds = boe_init_cmd,
+};
+
+static const struct drm_display_mode auo_default_mode = {
+	.clock = 157000,
+	.hdisplay = 1200,
+	.hsync_start = 1200 + 80,
+	.hsync_end = 1200 + 80 + 24,
+	.htotal = 1200 + 80 + 24 + 36,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 16,
+	.vsync_end = 1920 + 16 + 4,
+	.vtotal = 1920 + 16 + 4 + 16,
+	.vrefresh = 60,
+	.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,
+};
+
+static const struct panel_desc auo_kd101n80_45na_desc = {
+	.modes = &auo_default_mode,
+	.bpc = 8,
+	.size = {
+		.width = 135,
+		.height = 216,
+	},
+	.lanes = 4,
+	.format = MIPI_DSI_FMT_RGB888,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+		      MIPI_DSI_MODE_LPM,
+	.init_cmds = auo_init_cmd,
+};
+
+static int boe_panel_get_modes(struct drm_panel *panel)
+{
+	struct boe_panel *boe = to_boe_panel(panel);
+	const struct drm_display_mode *m = boe->desc->modes;
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(panel->drm, m);
+	if (!mode) {
+		dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
+			m->hdisplay, m->vdisplay, m->vrefresh);
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	drm_mode_probed_add(panel->connector, mode);
+
+	panel->connector->display_info.width_mm = boe->desc->size.width;
+	panel->connector->display_info.height_mm = boe->desc->size.height;
+	panel->connector->display_info.bpc = boe->desc->bpc;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs boe_panel_funcs = {
+	.disable = boe_panel_disable,
+	.unprepare = boe_panel_unprepare,
+	.prepare = boe_panel_prepare,
+	.enable = boe_panel_enable,
+	.get_modes = boe_panel_get_modes,
+};
+
+static int boe_panel_add(struct boe_panel *boe)
+{
+	struct device *dev = &boe->dsi->dev;
+
+	boe->avdd = devm_regulator_get(dev, "avdd");
+	if (IS_ERR(boe->avdd))
+		return PTR_ERR(boe->avdd);
+
+	boe->avee = devm_regulator_get(dev, "avee");
+	if (IS_ERR(boe->avee))
+		return PTR_ERR(boe->avee);
+
+	boe->pp1800 = devm_regulator_get(dev, "pp1800");
+	if (IS_ERR(boe->pp1800))
+		return PTR_ERR(boe->pp1800);
+
+	boe->enable_gpio = devm_gpiod_get(dev, "enable", GPIOD_OUT_LOW);
+	if (IS_ERR(boe->enable_gpio)) {
+		dev_err(dev, "cannot get reset-gpios %ld\n",
+			PTR_ERR(boe->enable_gpio));
+		return PTR_ERR(boe->enable_gpio);
+	}
+
+	gpiod_set_value(boe->enable_gpio, 0);
+
+	boe->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(boe->backlight))
+		return PTR_ERR(boe->backlight);
+
+	drm_panel_init(&boe->base);
+	boe->base.funcs = &boe_panel_funcs;
+	boe->base.dev = &boe->dsi->dev;
+
+	return drm_panel_add(&boe->base);
+}
+
+static int boe_panel_probe(struct mipi_dsi_device *dsi)
+{
+	struct boe_panel *boe;
+	int ret;
+	const struct panel_desc *desc;
+
+	boe = devm_kzalloc(&dsi->dev, sizeof(*boe), GFP_KERNEL);
+	if (!boe)
+		return -ENOMEM;
+
+	desc = of_device_get_match_data(&dsi->dev);
+	dsi->lanes = desc->lanes;
+	dsi->format = desc->format;
+	dsi->mode_flags = desc->mode_flags;
+	boe->desc = desc;
+	boe->dsi = dsi;
+	ret = boe_panel_add(boe);
+	if (ret < 0)
+		return ret;
+
+	mipi_dsi_set_drvdata(dsi, boe);
+
+	return mipi_dsi_attach(dsi);
+}
+
+static int boe_panel_remove(struct mipi_dsi_device *dsi)
+{
+	struct boe_panel *boe = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = boe_panel_disable(&boe->base);
+	if (ret < 0)
+		dev_err(&dsi->dev, "failed to disable panel: %d\n", ret);
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "failed to detach from DSI host: %d\n", ret);
+
+	if (boe->base.dev)
+		drm_panel_remove(&boe->base);
+
+	return 0;
+}
+
+static void boe_panel_shutdown(struct mipi_dsi_device *dsi)
+{
+	struct boe_panel *boe = mipi_dsi_get_drvdata(dsi);
+
+	boe_panel_disable(&boe->base);
+}
+
+static const struct of_device_id boe_of_match[] = {
+	{ .compatible = "boe,tv101wum-nl6",
+	  .data = &boe_tv101wum_nl6_desc
+	},
+	{ .compatible = "auo,kd101n80-45na",
+	  .data = &auo_kd101n80_45na_desc
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, boe_of_match);
+
+static struct mipi_dsi_driver boe_panel_driver = {
+	.driver = {
+		.name = "panel-boe-tv101wum-nl6",
+		.of_match_table = boe_of_match,
+	},
+	.probe = boe_panel_probe,
+	.remove = boe_panel_remove,
+	.shutdown = boe_panel_shutdown,
+};
+module_mipi_dsi_driver(boe_panel_driver);
+
+MODULE_AUTHOR("Jitao Shi <jitao.shi@mediatek.com>");
+MODULE_DESCRIPTION("BOE tv101wum-nl6 1200x1920 video mode panel driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-innolux-p079zca.c b/drivers/gpu/drm/panel/panel-innolux-p079zca.c
index 88c7d035ace6..f52c892323c3 100644
--- a/drivers/gpu/drm/panel/panel-innolux-p079zca.c
+++ b/drivers/gpu/drm/panel/panel-innolux-p079zca.c
@@ -56,7 +56,7 @@ struct innolux_panel {
 	struct backlight_device *backlight;
 	struct regulator_bulk_data *supplies;
 	unsigned int num_supplies;
-	struct gpio_desc *enable_gpio;
+	struct gpio_desc *enable_gpio[2];
 
 	bool prepared;
 	bool enabled;
@@ -84,7 +84,7 @@ static int innolux_panel_disable(struct drm_panel *panel)
 static int innolux_panel_unprepare(struct drm_panel *panel)
 {
 	struct innolux_panel *innolux = to_innolux_panel(panel);
-	int err;
+	int err, i;
 
 	if (!innolux->prepared)
 		return 0;
@@ -104,7 +104,8 @@ static int innolux_panel_unprepare(struct drm_panel *panel)
 	if (innolux->desc->sleep_mode_delay)
 		msleep(innolux->desc->sleep_mode_delay);
 
-	gpiod_set_value_cansleep(innolux->enable_gpio, 0);
+	for (i = 0; i < ARRAY_SIZE(innolux->enable_gpio); i++)
+		gpiod_set_value_cansleep(innolux->enable_gpio[i], 0);
 
 	if (innolux->desc->power_down_delay)
 		msleep(innolux->desc->power_down_delay);
@@ -122,22 +123,28 @@ static int innolux_panel_unprepare(struct drm_panel *panel)
 static int innolux_panel_prepare(struct drm_panel *panel)
 {
 	struct innolux_panel *innolux = to_innolux_panel(panel);
-	int err;
+	int err, i;
 
 	if (innolux->prepared)
 		return 0;
 
-	gpiod_set_value_cansleep(innolux->enable_gpio, 0);
+	for (i = 0; i < ARRAY_SIZE(innolux->enable_gpio); i++)
+		gpiod_set_value_cansleep(innolux->enable_gpio[i], 0);
 
 	err = regulator_bulk_enable(innolux->desc->num_supplies,
 				    innolux->supplies);
 	if (err < 0)
 		return err;
 
-	/* p079zca: t2 (20ms), p097pfg: t4 (15ms) */
-	usleep_range(20000, 21000);
+	for (i = 0; i < ARRAY_SIZE(innolux->enable_gpio); i++) {
+		if (!innolux->enable_gpio[i])
+			break;
 
-	gpiod_set_value_cansleep(innolux->enable_gpio, 1);
+		/* p079zca: t2 (20ms), p097pfg: t4 (15ms); ssd2858: 20ms */
+		usleep_range(20000, 21000);
+
+		gpiod_set_value_cansleep(innolux->enable_gpio[i], 1);
+	}
 
 	/* p079zca: t4, p097pfg: t5 */
 	usleep_range(20000, 21000);
@@ -158,6 +165,18 @@ static int innolux_panel_prepare(struct drm_panel *panel)
 				goto poweroff;
 			}
 
+			/*
+			 * If the command list contains exit sleep mode or set
+			 * display on, wait the appropriate time (needed for
+			 * displays behind a bridge).
+			 */
+			/* T6: 120ms - 1000ms*/
+			if (cmd->data[0] == MIPI_DCS_EXIT_SLEEP_MODE)
+				msleep(120);
+			/* T7: 5ms */
+			if (cmd->data[0] == MIPI_DCS_SET_DISPLAY_ON)
+				usleep_range(5000, 6000);
+
 			/*
 			 * Included by random guessing, because without this
 			 * (or at least, some delay), the panel sometimes
@@ -197,7 +216,8 @@ static int innolux_panel_prepare(struct drm_panel *panel)
 	return 0;
 
 poweroff:
-	gpiod_set_value_cansleep(innolux->enable_gpio, 0);
+	for (i = 0; i < ARRAY_SIZE(innolux->enable_gpio); i++)
+		gpiod_set_value_cansleep(innolux->enable_gpio[i], 0);
 	regulator_bulk_disable(innolux->desc->num_supplies, innolux->supplies);
 
 	return err;
@@ -405,6 +425,90 @@ static const struct panel_desc innolux_p097pfg_panel_desc = {
 	.sleep_mode_delay = 100, /* T15 */
 };
 
+static const char * const innolux_p097pfg_ssd2858_supply_names[] = {
+	"avdd",
+	"avee",
+	"pp1800",
+	"pp3300",
+	"pp1200-bridge",
+	"vddio-bridge",
+};
+
+static const struct drm_display_mode innolux_p097pfg_ssd2858_mode = {
+	.clock = 211660,
+	.hdisplay = 1536,
+	.hsync_start = 1536 + 140,
+	.hsync_end = 1536 + 140 + 10,
+	.htotal = 1536 + 140 + 10 + 10,
+	.vdisplay = 2048,
+	.vsync_start = 2048 + 20,
+	.vsync_end = 2048 + 20 + 2,
+	.vtotal = 2048 + 20 + 2 + 10,
+	.vrefresh = 60,
+};
+
+static const struct panel_init_cmd innolux_p097pfg_ssd2858_init_cmds[] = {
+	/* SSD2858 config */
+	_INIT_CMD(0xff, 0x00),
+	/* LOCKCNT=0x1f4, MRX=0, POSTDIV=1 (/2), MULT=0x49
+	 * 27 Mhz => 985.5 Mhz */
+	_INIT_CMD(0x00, 0x08, 0x01, 0xf4, 0x01, 0x49),
+	/* MTXDIV=1, SYSDIV=3 (=> 4) */
+	_INIT_CMD(0x00, 0x0c, 0x00, 0x00, 0x00, 0x03),
+	/* MTXVPF=24bpp, MRXLS=4 lanes, MRXVB=bypass, MRXECC=1, MRXEOT=1
+	 * MRXEE=1 */
+	_INIT_CMD(0x00, 0x14, 0x0c, 0x3d, 0x80, 0x0f),
+	_INIT_CMD(0x00, 0x20, 0x15, 0x92, 0x56, 0x7d),
+	_INIT_CMD(0x00, 0x24, 0x00, 0x00, 0x30, 0x00),
+
+	_INIT_CMD(0x10, 0x08, 0x01, 0x20, 0x08, 0x45),
+	_INIT_CMD(0x10, 0x1c, 0x00, 0x00, 0x00, 0x00),
+	_INIT_CMD(0x20, 0x0c, 0x00, 0x00, 0x00, 0x04),
+	/* Pixel clock 985.5 Mhz * 0x49/0x4b = 959 Mhz */
+	_INIT_CMD(0x20, 0x10, 0x00, 0x4b, 0x00, 0x49),
+	_INIT_CMD(0x20, 0xa0, 0x00, 0x00, 0x00, 0x00),
+	/* EOT=1, LPE = 0, LSOUT=4 lanes, LPD=25 */
+	_INIT_CMD(0x60, 0x08, 0x00, 0xd9, 0x00, 0x08),
+	_INIT_CMD(0x60, 0x14, 0x01, 0x00, 0x01, 0x06),
+	/* DSI0 enable (default: probably not needed) */
+	_INIT_CMD(0x60, 0x80, 0x00, 0x00, 0x00, 0x0f),
+	/* DSI1 enable */
+	_INIT_CMD(0x60, 0xa0, 0x00, 0x00, 0x00, 0x0f),
+
+	/* HSA=0x18, VSA=0x02, HBP=0x50, VBP=0x0c */
+	_INIT_CMD(0x60, 0x0c, 0x0c, 0x50, 0x02, 0x18),
+	/* VACT= 0x800 (2048), VFP= 0x14, HFP=0x50 */
+	_INIT_CMD(0x60, 0x10, 0x08, 0x00, 0x14, 0x50),
+	/* HACT=0x300 (768) */
+	_INIT_CMD(0x60, 0x84, 0x00, 0x00, 0x03, 0x00),
+	_INIT_CMD(0x60, 0xa4, 0x00, 0x00, 0x03, 0x00),
+
+	/* Take panel out of sleep. */
+	_INIT_CMD(0xff, 0x01),
+	_INIT_CMD(0x11),
+	_INIT_CMD(0x29),
+	_INIT_CMD(0xff, 0x00),
+
+	{},
+};
+
+static const struct panel_desc innolux_p097pfg_ssd2858_panel_desc = {
+	.mode = &innolux_p097pfg_ssd2858_mode,
+	.bpc = 8,
+	.size = {
+		.width = 147,
+		.height = 196,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+		 MIPI_DSI_MODE_LPM,
+	.format = MIPI_DSI_FMT_RGB888,
+	.init_cmds = innolux_p097pfg_ssd2858_init_cmds,
+	.lanes = 4,
+	.supply_names = innolux_p097pfg_ssd2858_supply_names,
+	.num_supplies = ARRAY_SIZE(innolux_p097pfg_ssd2858_supply_names),
+	.sleep_mode_delay = 100, /* T15 */
+};
+
 static int innolux_panel_get_modes(struct drm_panel *panel)
 {
 	struct innolux_panel *innolux = to_innolux_panel(panel);
@@ -446,6 +550,9 @@ static const struct of_device_id innolux_of_match[] = {
 	{ .compatible = "innolux,p097pfg",
 	  .data = &innolux_p097pfg_panel_desc
 	},
+	{ .compatible = "innolux,p097pfg_ssd2858",
+	  .data = &innolux_p097pfg_ssd2858_panel_desc
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(of, innolux_of_match);
@@ -477,12 +584,14 @@ static int innolux_panel_add(struct mipi_dsi_device *dsi,
 	if (err < 0)
 		return err;
 
-	innolux->enable_gpio = devm_gpiod_get_optional(dev, "enable",
-						       GPIOD_OUT_HIGH);
-	if (IS_ERR(innolux->enable_gpio)) {
-		err = PTR_ERR(innolux->enable_gpio);
-		dev_dbg(dev, "failed to get enable gpio: %d\n", err);
-		innolux->enable_gpio = NULL;
+	for (i = 0; i < ARRAY_SIZE(innolux->enable_gpio); i++) {
+		innolux->enable_gpio[i] = devm_gpiod_get_index_optional(dev,
+						"enable", i, GPIOD_OUT_HIGH);
+		if (IS_ERR(innolux->enable_gpio[i])) {
+			err = PTR_ERR(innolux->enable_gpio[i]);
+			dev_err(dev, "failed to get enable gpio: %d\n", err);
+			innolux->enable_gpio[i] = NULL;
+		}
 	}
 
 	innolux->backlight = devm_of_find_backlight(dev);
diff --git a/drivers/iio/adc/mt6577_auxadc.c b/drivers/iio/adc/mt6577_auxadc.c
index 95d76abb64ec..ac2b01c601d9 100644
--- a/drivers/iio/adc/mt6577_auxadc.c
+++ b/drivers/iio/adc/mt6577_auxadc.c
@@ -17,12 +17,14 @@
 #include <linux/err.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/nvmem-consumer.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/iopoll.h>
 #include <linux/io.h>
 #include <linux/iio/iio.h>
+#include <linux/slab.h>
 
 /* Register definitions */
 #define MT6577_AUXADC_CON0                    0x00
@@ -42,6 +44,13 @@
 #define MT6577_AUXADC_POWER_READY_MS          1
 #define MT6577_AUXADC_SAMPLE_READY_US         25
 
+#define ADC_GE_A_SHIFT      10
+#define ADC_GE_A_MASK       (0x3ff << ADC_GE_A_SHIFT)
+#define ADC_OE_A_SHIFT      0
+#define ADC_OE_A_MASK       (0x3ff << ADC_OE_A_SHIFT)
+#define ADC_CALI_EN_A_SHIFT 20
+#define ADC_CALI_EN_A_MASK  (0x1 << ADC_CALI_EN_A_SHIFT)
+
 struct mt6577_auxadc_device {
 	void __iomem *reg_base;
 	struct clk *adc_clk;
@@ -74,6 +83,59 @@ static const struct iio_chan_spec mt6577_auxadc_iio_channels[] = {
 	MT6577_AUXADC_CHANNEL(15),
 };
 
+s32 cali_oe;
+s32 cali_ge;
+static u32 cali_ge_a;
+static u32 cali_oe_a;
+static u32 gain;
+
+static int mt_auxadc_update_cali(struct device *dev)
+{
+	struct nvmem_cell *cell;
+	u32 *buf;
+	size_t len;
+	int ret = 0;
+	cali_oe = 0;
+	cali_ge = 0;
+
+	cell = nvmem_cell_get(dev, "calibration-data");
+	if (IS_ERR(cell)) {
+		if (PTR_ERR(cell) == -EPROBE_DEFER)
+			return PTR_ERR(cell);
+		return 0;
+	}
+
+	buf = (u32 *)nvmem_cell_read(cell, &len);
+
+	nvmem_cell_put(cell);
+
+	if (IS_ERR(buf))
+		return PTR_ERR(buf);
+
+	if (len < sizeof(u32)) {
+		dev_warn(dev, "invalid calibration data\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (((buf[0] & ADC_CALI_EN_A_MASK) >> ADC_CALI_EN_A_SHIFT) != 0) {
+		cali_oe_a = (buf[0] & ADC_OE_A_MASK) >> ADC_OE_A_SHIFT;
+		cali_ge_a = ((buf[0] & ADC_GE_A_MASK) >> ADC_GE_A_SHIFT);
+
+		cali_ge = cali_ge_a - 512;
+		cali_oe = cali_oe_a - 512;
+		gain = 1 + cali_ge;
+	}  else {
+		dev_info(dev, "Device not calibrated, using default calibration values\n");
+	}
+	pr_err("xupo cali_oe=%d,cali_ge=%d\n", cali_oe,cali_ge);
+
+out:
+	kfree(buf);
+
+	return ret;
+}
+
 static inline void mt6577_auxadc_mod_reg(void __iomem *reg,
 					 u32 or_mask, u32 and_mask)
 {
@@ -221,7 +283,7 @@ static int mt6577_auxadc_probe(struct platform_device *pdev)
 	struct resource *res;
 	struct iio_dev *indio_dev;
 	int ret;
-
+	pr_err("xupo auxadc probe start\n");
 	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*adc_dev));
 	if (!indio_dev)
 		return -ENOMEM;
@@ -274,6 +336,10 @@ static int mt6577_auxadc_probe(struct platform_device *pdev)
 		goto err_power_off;
 	}
 
+	ret = mt_auxadc_update_cali(&pdev->dev);
+	if (ret)
+		return ret;
+pr_err("xupo audadc probe end\n");
 	return 0;
 
 err_power_off:
diff --git a/drivers/iommu/mtk_iommu.c b/drivers/iommu/mtk_iommu.c
index 803084c86124..43e420cdab6e 100644
--- a/drivers/iommu/mtk_iommu.c
+++ b/drivers/iommu/mtk_iommu.c
@@ -262,6 +262,7 @@ static void mtk_iommu_config(struct mtk_iommu_data *data,
 	struct mtk_smi_larb_iommu    *larb_mmu;
 	unsigned int                 larbid, portid;
 	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+	struct device_link *link;
 	int i;
 
 	for (i = 0; i < fwspec->num_ids; ++i) {
@@ -272,10 +273,20 @@ static void mtk_iommu_config(struct mtk_iommu_data *data,
 		dev_dbg(dev, "%s iommu port: %d\n",
 			enable ? "enable" : "disable", portid);
 
-		if (enable)
+		if (enable) {
 			larb_mmu->mmu |= MTK_SMI_MMU_EN(portid);
-		else
+			/* Link the consumer with the larb device(supplier) */
+			link = device_link_add(dev, larb_mmu->dev,
+					       DL_FLAG_PM_RUNTIME |
+					       DL_FLAG_AUTOREMOVE_CONSUMER);
+			if (!link) {
+				dev_err(dev, "Unable to link %s\n",
+					dev_name(larb_mmu->dev));
+				return;
+			}
+		} else {
 			larb_mmu->mmu &= ~MTK_SMI_MMU_EN(portid);
+		}
 	}
 }
 
@@ -662,7 +673,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 			id = i;
 
 		plarbdev = of_find_device_by_node(larbnode);
-		if (!plarbdev)
+		if (!plarbdev || !plarbdev->dev.driver)
 			return -EPROBE_DEFER;
 		data->smi_imu.larb_imu[id].dev = &plarbdev->dev;
 
@@ -696,7 +707,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 	return component_master_add_with_match(dev, &mtk_iommu_com_ops, match);
 }
 
-static int mtk_iommu_remove(struct platform_device *pdev)
+static void mtk_iommu_shutdown(struct platform_device *pdev)
 {
 	struct mtk_iommu_data *data = platform_get_drvdata(pdev);
 
@@ -709,12 +720,6 @@ static int mtk_iommu_remove(struct platform_device *pdev)
 	clk_disable_unprepare(data->bclk);
 	devm_free_irq(&pdev->dev, data->irq, data);
 	component_master_del(&pdev->dev, &mtk_iommu_com_ops);
-	return 0;
-}
-
-static void mtk_iommu_shutdown(struct platform_device *pdev)
-{
-	mtk_iommu_remove(pdev);
 }
 
 static int __maybe_unused mtk_iommu_suspend(struct device *dev)
@@ -797,7 +802,6 @@ static const struct of_device_id mtk_iommu_of_ids[] = {
 
 static struct platform_driver mtk_iommu_driver = {
 	.probe	= mtk_iommu_probe,
-	.remove	= mtk_iommu_remove,
 	.shutdown = mtk_iommu_shutdown,
 	.driver	= {
 		.name = "mtk-iommu",
@@ -805,16 +809,4 @@ static struct platform_driver mtk_iommu_driver = {
 		.pm = &mtk_iommu_pm_ops,
 	}
 };
-
-static int __init mtk_iommu_init(void)
-{
-	int ret;
-
-	ret = platform_driver_register(&mtk_iommu_driver);
-	if (ret != 0)
-		pr_err("Failed to register MTK IOMMU driver\n");
-
-	return ret;
-}
-
-subsys_initcall(mtk_iommu_init)
+builtin_platform_driver(mtk_iommu_driver);
diff --git a/drivers/iommu/mtk_iommu_v1.c b/drivers/iommu/mtk_iommu_v1.c
index d70bdf64ab71..832ea99f7a16 100644
--- a/drivers/iommu/mtk_iommu_v1.c
+++ b/drivers/iommu/mtk_iommu_v1.c
@@ -201,6 +201,7 @@ static void mtk_iommu_config(struct mtk_iommu_data *data,
 	struct mtk_smi_larb_iommu    *larb_mmu;
 	unsigned int                 larbid, portid;
 	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+	struct device_link *link;
 	int i;
 
 	for (i = 0; i < fwspec->num_ids; ++i) {
@@ -211,10 +212,19 @@ static void mtk_iommu_config(struct mtk_iommu_data *data,
 		dev_dbg(dev, "%s iommu port: %d\n",
 			enable ? "enable" : "disable", portid);
 
-		if (enable)
+		if (enable) {
 			larb_mmu->mmu |= MTK_SMI_MMU_EN(portid);
-		else
+			link = device_link_add(dev, larb_mmu->dev,
+					       DL_FLAG_PM_RUNTIME |
+					       DL_FLAG_AUTOREMOVE_CONSUMER);
+			if (!link) {
+				dev_err(dev, "Unable to link %s\n",
+					dev_name(larb_mmu->dev));
+				return;
+			}
+		} else {
 			larb_mmu->mmu &= ~MTK_SMI_MMU_EN(portid);
+		}
 	}
 }
 
@@ -601,7 +611,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 			plarbdev = of_platform_device_create(
 						larb_spec.np, NULL,
 						platform_bus_type.dev_root);
-			if (!plarbdev) {
+			if (!plarbdev || !plarbdev->dev.driver) {
 				of_node_put(larb_spec.np);
 				return -EPROBE_DEFER;
 			}
@@ -636,7 +646,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 	return component_master_add_with_match(dev, &mtk_iommu_com_ops, match);
 }
 
-static int mtk_iommu_remove(struct platform_device *pdev)
+static void mtk_iommu_shutdown(struct platform_device *pdev)
 {
 	struct mtk_iommu_data *data = platform_get_drvdata(pdev);
 
@@ -649,12 +659,6 @@ static int mtk_iommu_remove(struct platform_device *pdev)
 	clk_disable_unprepare(data->bclk);
 	devm_free_irq(&pdev->dev, data->irq, data);
 	component_master_del(&pdev->dev, &mtk_iommu_com_ops);
-	return 0;
-}
-
-static void mtk_iommu_shutdown(struct platform_device *pdev)
-{
-	mtk_iommu_remove(pdev);
 }
 
 static int __maybe_unused mtk_iommu_suspend(struct device *dev)
@@ -693,7 +697,6 @@ static const struct dev_pm_ops mtk_iommu_pm_ops = {
 
 static struct platform_driver mtk_iommu_driver = {
 	.probe	= mtk_iommu_probe,
-	.remove	= mtk_iommu_remove,
 	.shutdown = mtk_iommu_shutdown,
 	.driver	= {
 		.name = "mtk-iommu-v1",
@@ -701,9 +704,4 @@ static struct platform_driver mtk_iommu_driver = {
 		.pm = &mtk_iommu_pm_ops,
 	}
 };
-
-static int __init m4u_init(void)
-{
-	return platform_driver_register(&mtk_iommu_driver);
-}
-subsys_initcall(m4u_init);
+builtin_platform_driver(mtk_iommu_driver);
diff --git a/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c b/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c
index f761e4d8bf2a..2f375386e376 100644
--- a/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c
+++ b/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c
@@ -29,7 +29,6 @@
 #include <media/v4l2-ioctl.h>
 #include <media/videobuf2-core.h>
 #include <media/videobuf2-dma-contig.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_jpeg_hw.h"
 #include "mtk_jpeg_core.h"
@@ -901,11 +900,6 @@ static int mtk_jpeg_queue_init(void *priv, struct vb2_queue *src_vq,
 
 static void mtk_jpeg_clk_on(struct mtk_jpeg_dev *jpeg)
 {
-	int ret;
-
-	ret = mtk_smi_larb_get(jpeg->larb);
-	if (ret)
-		dev_err(jpeg->dev, "mtk_smi_larb_get larbvdec fail %d\n", ret);
 	clk_prepare_enable(jpeg->clk_jdec_smi);
 	clk_prepare_enable(jpeg->clk_jdec);
 }
@@ -914,7 +908,6 @@ static void mtk_jpeg_clk_off(struct mtk_jpeg_dev *jpeg)
 {
 	clk_disable_unprepare(jpeg->clk_jdec);
 	clk_disable_unprepare(jpeg->clk_jdec_smi);
-	mtk_smi_larb_put(jpeg->larb);
 }
 
 static irqreturn_t mtk_jpeg_dec_irq(int irq, void *priv)
@@ -1059,21 +1052,6 @@ static const struct v4l2_file_operations mtk_jpeg_fops = {
 
 static int mtk_jpeg_clk_init(struct mtk_jpeg_dev *jpeg)
 {
-	struct device_node *node;
-	struct platform_device *pdev;
-
-	node = of_parse_phandle(jpeg->dev->of_node, "mediatek,larb", 0);
-	if (!node)
-		return -EINVAL;
-	pdev = of_find_device_by_node(node);
-	if (WARN_ON(!pdev)) {
-		of_node_put(node);
-		return -EINVAL;
-	}
-	of_node_put(node);
-
-	jpeg->larb = &pdev->dev;
-
 	jpeg->clk_jdec = devm_clk_get(jpeg->dev, "jpgdec");
 	if (IS_ERR(jpeg->clk_jdec))
 		return PTR_ERR(jpeg->clk_jdec);
diff --git a/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.h b/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.h
index 1a6cdfd4ea70..e35fb79b4c74 100644
--- a/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.h
+++ b/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.h
@@ -55,7 +55,6 @@ enum mtk_jpeg_ctx_state {
  * @dec_reg_base:	JPEG registers mapping
  * @clk_jdec:		JPEG hw working clock
  * @clk_jdec_smi:	JPEG SMI bus clock
- * @larb:		SMI device
  */
 struct mtk_jpeg_dev {
 	struct mutex		lock;
@@ -69,7 +68,6 @@ struct mtk_jpeg_dev {
 	void __iomem		*dec_reg_base;
 	struct clk		*clk_jdec;
 	struct clk		*clk_jdec_smi;
-	struct device		*larb;
 };
 
 /**
diff --git a/drivers/media/platform/mtk-mdp/mtk_mdp_comp.c b/drivers/media/platform/mtk-mdp/mtk_mdp_comp.c
index 03aba03a24c8..4f7cbc4577de 100644
--- a/drivers/media/platform/mtk-mdp/mtk_mdp_comp.c
+++ b/drivers/media/platform/mtk-mdp/mtk_mdp_comp.c
@@ -17,7 +17,6 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_mdp_comp.h"
 
@@ -66,14 +65,6 @@ void mtk_mdp_comp_clock_on(struct device *dev, struct mtk_mdp_comp *comp)
 {
 	int i, err;
 
-	if (comp->larb_dev) {
-		err = mtk_smi_larb_get(comp->larb_dev);
-		if (err)
-			dev_err(dev,
-				"failed to get larb, err %d. type:%d id:%d\n",
-				err, comp->type, comp->id);
-	}
-
 	for (i = 0; i < ARRAY_SIZE(comp->clk); i++) {
 		if (IS_ERR(comp->clk[i]))
 			continue;
@@ -94,16 +85,11 @@ void mtk_mdp_comp_clock_off(struct device *dev, struct mtk_mdp_comp *comp)
 			continue;
 		clk_disable_unprepare(comp->clk[i]);
 	}
-
-	if (comp->larb_dev)
-		mtk_smi_larb_put(comp->larb_dev);
 }
 
 int mtk_mdp_comp_init(struct device *dev, struct device_node *node,
 		      struct mtk_mdp_comp *comp, enum mtk_mdp_comp_id comp_id)
 {
-	struct device_node *larb_node;
-	struct platform_device *larb_pdev;
 	int i;
 
 	if (comp_id < 0 || comp_id >= MTK_MDP_COMP_ID_MAX) {
@@ -124,30 +110,6 @@ int mtk_mdp_comp_init(struct device *dev, struct device_node *node,
 			break;
 	}
 
-	/* Only DMA capable components need the LARB property */
-	comp->larb_dev = NULL;
-	if (comp->type != MTK_MDP_RDMA &&
-	    comp->type != MTK_MDP_WDMA &&
-	    comp->type != MTK_MDP_WROT)
-		return 0;
-
-	larb_node = of_parse_phandle(node, "mediatek,larb", 0);
-	if (!larb_node) {
-		dev_err(dev,
-			"Missing mediadek,larb phandle in %pOF node\n", node);
-		return -EINVAL;
-	}
-
-	larb_pdev = of_find_device_by_node(larb_node);
-	if (!larb_pdev) {
-		dev_warn(dev, "Waiting for larb device %pOF\n", larb_node);
-		of_node_put(larb_node);
-		return -EPROBE_DEFER;
-	}
-	of_node_put(larb_node);
-
-	comp->larb_dev = &larb_pdev->dev;
-
 	return 0;
 }
 
diff --git a/drivers/media/platform/mtk-mdp/mtk_mdp_comp.h b/drivers/media/platform/mtk-mdp/mtk_mdp_comp.h
index 63b3983ef1a4..602d577f5dc2 100644
--- a/drivers/media/platform/mtk-mdp/mtk_mdp_comp.h
+++ b/drivers/media/platform/mtk-mdp/mtk_mdp_comp.h
@@ -47,7 +47,6 @@ enum mtk_mdp_comp_id {
  * @dev_node:	component device node
  * @clk:	clocks required for component
  * @regs:	Mapped address of component registers.
- * @larb_dev:	SMI device required for component
  * @type:	component type
  * @id:		component ID
  */
@@ -55,7 +54,6 @@ struct mtk_mdp_comp {
 	struct device_node	*dev_node;
 	struct clk		*clk[2];
 	void __iomem		*regs;
-	struct device		*larb_dev;
 	enum mtk_mdp_comp_type	type;
 	enum mtk_mdp_comp_id	id;
 };
diff --git a/drivers/media/platform/mtk-mdp/mtk_mdp_core.c b/drivers/media/platform/mtk-mdp/mtk_mdp_core.c
index bbb24fb95b95..adb098d761a7 100644
--- a/drivers/media/platform/mtk-mdp/mtk_mdp_core.c
+++ b/drivers/media/platform/mtk-mdp/mtk_mdp_core.c
@@ -25,7 +25,6 @@
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/workqueue.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_mdp_core.h"
 #include "mtk_mdp_m2m.h"
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.c
index 7884465afcd2..f5177901ba6e 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.c
@@ -16,7 +16,6 @@
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
 #include <linux/pm_runtime.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_vcodec_dec_pm.h"
 #include "mtk_vcodec_util.h"
@@ -24,7 +23,6 @@
 
 int mtk_vcodec_init_dec_pm(struct mtk_vcodec_dev *mtkdev)
 {
-	struct device_node *node;
 	struct platform_device *pdev;
 	struct mtk_vcodec_pm *pm;
 	struct mtk_vcodec_clk *dec_clk;
@@ -35,18 +33,7 @@ int mtk_vcodec_init_dec_pm(struct mtk_vcodec_dev *mtkdev)
 	pm = &mtkdev->pm;
 	pm->mtkdev = mtkdev;
 	dec_clk = &pm->vdec_clk;
-	node = of_parse_phandle(pdev->dev.of_node, "mediatek,larb", 0);
-	if (!node) {
-		mtk_v4l2_err("of_parse_phandle mediatek,larb fail!");
-		return -1;
-	}
 
-	pdev = of_find_device_by_node(node);
-	if (WARN_ON(!pdev)) {
-		of_node_put(node);
-		return -1;
-	}
-	pm->larbvdec = &pdev->dev;
 	pdev = mtkdev->plat_dev;
 	pm->dev = &pdev->dev;
 
@@ -122,11 +109,6 @@ void mtk_vcodec_dec_clock_on(struct mtk_vcodec_pm *pm)
 		}
 	}
 
-	ret = mtk_smi_larb_get(pm->larbvdec);
-	if (ret) {
-		mtk_v4l2_err("mtk_smi_larb_get larbvdec fail %d", ret);
-		goto error;
-	}
 	return;
 
 error:
@@ -139,7 +121,6 @@ void mtk_vcodec_dec_clock_off(struct mtk_vcodec_pm *pm)
 	struct mtk_vcodec_clk *dec_clk = &pm->vdec_clk;
 	int i = 0;
 
-	mtk_smi_larb_put(pm->larbvdec);
 	for (i = dec_clk->clk_num - 1; i >= 0; i--)
 		clk_disable_unprepare(dec_clk->clk_info[i].vcodec_clk);
 }
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_drv.h b/drivers/media/platform/mtk-vcodec/mtk_vcodec_drv.h
index 662a84b822af..cf56b07c4828 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_drv.h
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_drv.h
@@ -196,11 +196,8 @@ struct mtk_vcodec_clk {
  */
 struct mtk_vcodec_pm {
 	struct mtk_vcodec_clk	vdec_clk;
-	struct device	*larbvdec;
 
 	struct mtk_vcodec_clk	venc_clk;
-	struct device	*larbvenc;
-	struct device	*larbvenclt;
 	struct device	*dev;
 	struct mtk_vcodec_dev	*mtkdev;
 };
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc.c
index 50351adafc47..80d1c4ef8247 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc.c
@@ -16,7 +16,6 @@
 #include <media/v4l2-event.h>
 #include <media/v4l2-mem2mem.h>
 #include <media/videobuf2-dma-contig.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_vcodec_drv.h"
 #include "mtk_vcodec_enc.h"
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc_pm.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc_pm.c
index 39375b8ea27c..c3a1871d4739 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc_pm.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc_pm.c
@@ -16,7 +16,6 @@
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
 #include <linux/pm_runtime.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_vcodec_enc_pm.h"
 #include "mtk_vcodec_util.h"
@@ -25,7 +24,6 @@
 
 int mtk_vcodec_init_enc_pm(struct mtk_vcodec_dev *mtkdev)
 {
-	struct device_node *node;
 	struct platform_device *pdev;
 	struct mtk_vcodec_pm *pm;
 	struct mtk_vcodec_clk *enc_clk;
@@ -41,33 +39,6 @@ int mtk_vcodec_init_enc_pm(struct mtk_vcodec_dev *mtkdev)
 	dev = &pdev->dev;
 	enc_clk = &pm->venc_clk;
 
-	node = of_parse_phandle(dev->of_node, "mediatek,larb", 0);
-	if (!node) {
-		mtk_v4l2_err("no mediatek,larb found");
-		return -ENODEV;
-	}
-	pdev = of_find_device_by_node(node);
-	of_node_put(node);
-	if (!pdev) {
-		mtk_v4l2_err("no mediatek,larb device found");
-		return -ENODEV;
-	}
-	pm->larbvenc = &pdev->dev;
-
-	node = of_parse_phandle(dev->of_node, "mediatek,larb", 1);
-	if (!node) {
-		mtk_v4l2_err("no mediatek,larb found");
-		return -ENODEV;
-	}
-
-	pdev = of_find_device_by_node(node);
-	of_node_put(node);
-	if (!pdev) {
-		mtk_v4l2_err("no mediatek,larb device found");
-		return -ENODEV;
-	}
-
-	pm->larbvenclt = &pdev->dev;
 	pdev = mtkdev->plat_dev;
 	pm->dev = &pdev->dev;
 
@@ -123,21 +94,8 @@ void mtk_vcodec_enc_clock_on(struct mtk_vcodec_pm *pm)
 		}
 	}
 
-	ret = mtk_smi_larb_get(pm->larbvenc);
-	if (ret) {
-		mtk_v4l2_err("mtk_smi_larb_get larb3 fail %d", ret);
-		goto larbvencerr;
-	}
-	ret = mtk_smi_larb_get(pm->larbvenclt);
-	if (ret) {
-		mtk_v4l2_err("mtk_smi_larb_get larb4 fail %d", ret);
-		goto larbvenclterr;
-	}
 	return;
 
-larbvenclterr:
-	mtk_smi_larb_put(pm->larbvenc);
-larbvencerr:
 clkerr:
 	for (i -= 1; i >= 0; i--)
 		clk_disable_unprepare(enc_clk->clk_info[i].vcodec_clk);
@@ -148,8 +106,6 @@ void mtk_vcodec_enc_clock_off(struct mtk_vcodec_pm *pm)
 	struct mtk_vcodec_clk *enc_clk = &pm->venc_clk;
 	int i = 0;
 
-	mtk_smi_larb_put(pm->larbvenc);
-	mtk_smi_larb_put(pm->larbvenclt);
 	for (i = enc_clk->clk_num - 1; i >= 0; i--)
 		clk_disable_unprepare(enc_clk->clk_info[i].vcodec_clk);
 }
diff --git a/drivers/memory/Kconfig b/drivers/memory/Kconfig
index 63389f075f1d..4a291dabf2cc 100644
--- a/drivers/memory/Kconfig
+++ b/drivers/memory/Kconfig
@@ -129,6 +129,15 @@ config JZ4780_NEMC
 	  the Ingenic JZ4780. This controller is used to handle external
 	  memory devices such as NAND and SRAM.
 
+config MTK_EMI_MBW
+	bool "Mediatek EMI bandwidth driver"
+	depends on ARCH_MEDIATEK || COMPILE_TEST
+	help
+	  This driver is for MTK EMI control.
+	  If unsure, use N.
+	  This is the first time emi upstream.
+	  Only support emi bw statistics.
+
 config MTK_SMI
 	bool
 	depends on ARCH_MEDIATEK || COMPILE_TEST
diff --git a/drivers/memory/Makefile b/drivers/memory/Makefile
index a01ab3e22f94..82e3d862c24d 100644
--- a/drivers/memory/Makefile
+++ b/drivers/memory/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_FSL_CORENET_CF)	+= fsl-corenet-cf.o
 obj-$(CONFIG_FSL_IFC)		+= fsl_ifc.o
 obj-$(CONFIG_MVEBU_DEVBUS)	+= mvebu-devbus.o
 obj-$(CONFIG_JZ4780_NEMC)	+= jz4780-nemc.o
++obj-$(CONFIG_MTK_EMI_MBW)	+= mtk-emi.o
 obj-$(CONFIG_MTK_SMI)		+= mtk-smi.o
 obj-$(CONFIG_DA8XX_DDRCTL)	+= da8xx-ddrctl.o
 
diff --git a/drivers/memory/mtk-emi.c b/drivers/memory/mtk-emi.c
new file mode 100644
index 000000000000..5d00c05a8717
--- /dev/null
+++ b/drivers/memory/mtk-emi.c
@@ -0,0 +1,412 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2015-2016 MediaTek Inc.
+ * Author: Xi Chen <xixi.chen@mediatek.com>
+ */
+
+#include <linux/cdev.h>
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <soc/mediatek/emi.h>
+
+/* 67ms emi bw  */
+#define EMI_BW_ARRAY_SIZE	67
+
+#define MT8173_SMI_LARB_NR	6
+#define MT8167_SMI_LARB_NR	3
+#define MTK_SMI_LARB_NR_MAX	8
+#define MT8173_MMU_EN		0xf00
+#define MT8167_MMU_EN		0xfc0
+#define MT8167_LARB0_OFF	0
+#define MT8167_LARB1_OFF	8
+#define MT8167_LARB2_OFF	21
+
+/*****************************************************************************
+ *  Type Definitions
+ *****************************************************************************/
+enum DDRTYPE {
+	TYPE_LPDDR3 = 1,
+	TYPE_LPDDR4,
+	TYPE_LPDDR4X
+};
+
+enum {
+	EMI_BASE_IDX_EMI = 0,
+	EMI_BASE_IDX_EMI_CH0,
+	EMI_BASE_IDX_EMI_CH1,
+
+	NR_EMI_BASE_IDX,
+};
+
+struct emi_base_addr {
+	unsigned int phy_addr;
+	unsigned int remap_addr;
+};
+
+struct mtk_emi {
+	void __iomem *cen_emi_base;
+	void __iomem *chn_emi_base[MAX_CH];
+	void __iomem *emi_mpu_base;
+
+	struct emi_info_t emi_info;
+
+	struct timer_list emi_bw_timer;
+	struct timeval old_tv;
+
+	unsigned long long emi_bw_array[EMI_BW_ARRAY_SIZE];
+	int emi_bw_cur_idx;
+	int emi_bw_max_idx;
+};
+
+/* because timer can't pass argument, so add the global
+ * static struct device * for timer callback usage
+ */
+static struct device *emi_dev;
+
+unsigned long long emi_get_max_bw_in_last_array(struct device *dev,
+	unsigned long long arr[], unsigned int size)
+{
+	unsigned int i = 0;
+	unsigned long long max = arr[0];
+
+	while (i < size) {
+		if (arr[i] > max)
+			max = arr[i];
+		++i;
+	}
+	return max;
+}
+
+unsigned long long mtk_emi_get_max_bw(void)
+{
+	struct mtk_emi *emi;
+
+	if (!emi_dev)
+		return 0;
+
+	emi = dev_get_drvdata(emi_dev);
+	return emi_get_max_bw_in_last_array(emi_dev,
+		emi->emi_bw_array, ARRAY_SIZE(emi->emi_bw_array));
+}
+EXPORT_SYMBOL(mtk_emi_get_max_bw);
+
+void emi_update_bw_array(struct device *dev, unsigned int val)
+{
+	struct mtk_emi *emi = dev_get_drvdata(emi_dev);
+
+	if (emi->emi_bw_cur_idx == emi->emi_bw_max_idx) {
+		/* remove the first array element */
+		memmove(emi->emi_bw_array, emi->emi_bw_array + 1,
+			sizeof(unsigned long long) * (emi->emi_bw_max_idx - 1));
+		emi->emi_bw_array[emi->emi_bw_max_idx - 1] = val;
+	} else
+		emi->emi_bw_array[emi->emi_bw_cur_idx++] = val;
+}
+
+static void emi_dump_bw_array(struct device *dev)
+{
+	int i = 0;
+	const int unit = 10;
+	struct mtk_emi *emi = dev_get_drvdata(emi_dev);
+
+	while (i < emi->emi_bw_max_idx) {
+		if (i != 0 && i % unit == 0)
+			pr_info("\n");
+		pr_info("0x%x ", emi->emi_bw_array[i]);
+
+		++i;
+	}
+
+	pr_info("\n");
+}
+
+static void emi_counter_reset(struct device *dev)
+{
+	struct mtk_emi *emi = dev_get_drvdata(dev);
+
+	writel(EMI_BMEN_DEFAULT_VALUE, EMI_BMEN);
+	writel(EMI_MSEL_DEFAULT_VALUE, EMI_MSEL);
+	writel(EMI_MSEL2_DEFAULT_VALUE, EMI_MSEL2);
+	writel(EMI_BMEN2_DEFAULT_VALUE, EMI_BMEN2);
+	writel(EMI_BMRW0_DEFAULT_VALUE, EMI_BMRW0);
+}
+
+static void emi_counter_pause(struct device *dev)
+{
+	struct mtk_emi *emi = dev_get_drvdata(dev);
+	const unsigned int value = readl(EMI_BMEN);
+
+	/* BW monitor */
+	writel(value | BUS_MON_PAUSE, EMI_BMEN);
+}
+
+static void emi_counter_continue(struct device *dev)
+{
+	struct mtk_emi *emi = dev_get_drvdata(dev);
+	const unsigned int value = readl(EMI_BMEN);
+
+	/* BW monitor */
+	writel(value & (~BUS_MON_PAUSE), EMI_BMEN);
+}
+
+static void emi_counter_enable(struct device *dev, const unsigned int enable)
+{
+	unsigned int value, value_set;
+	struct mtk_emi *emi = dev_get_drvdata(dev);
+
+	value = readl(EMI_BMEN);
+	if (enable == 0) {	/* disable monitor circuit */
+		/*  bit3 =1	bit0 = 0-> clear */
+		value_set = (value) | (BUS_MON_IDLE);
+		writel(value_set, EMI_BMEN);
+
+		value_set = ((value) | (BUS_MON_IDLE)) & ~(BUS_MON_EN);
+		writel(value_set, EMI_BMEN);
+
+		value_set = ((value) & ~(BUS_MON_IDLE)) & ~(BUS_MON_EN);
+		writel(value_set, EMI_BMEN);
+	} else {		/* enable monitor circuit */
+		/*  bit3 =0	&   bit0=1 */
+		value_set = (value & ~(BUS_MON_IDLE));
+		writel(value_set, EMI_BMEN);
+
+		value_set = (value & ~(BUS_MON_IDLE)) | (BUS_MON_EN);
+		writel(value_set, EMI_BMEN);
+	}
+}
+
+/*****************************************************************************
+ *  APIs
+ *****************************************************************************/
+static void mtk_emi_mon_start(struct device *dev)
+{
+	emi_counter_enable(dev, 0);
+	emi_counter_reset(dev);
+	emi_counter_enable(dev, 1);
+}
+
+static void mtk_emi_mon_restart(struct device *dev)
+{
+	emi_counter_continue(dev);
+	emi_counter_enable(dev, 0);
+	emi_counter_reset(dev);
+	emi_counter_enable(dev, 1);
+}
+
+static void mtk_emi_mon_stop(struct device *dev)
+{
+	emi_counter_pause(dev);
+}
+
+static ssize_t emi_show_max_bw(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	unsigned long long var, bw_cpu;
+	unsigned int bw_gpu;
+	struct mtk_emi *emi = dev_get_drvdata(dev);
+
+	if (!dev) {
+		pr_warn("dev is null!!\n");
+		return 0;
+	}
+
+	var = mtk_emi_get_max_bw();
+	bw_gpu = readl(EMI_BWVL_4TH) & 0x7f;
+	bw_cpu = readl(EMI_WSCT3);
+
+	return scnprintf(buf, PAGE_SIZE,
+		"gpu_max_bw:%llu(0x%x) EMI_BWVL_4TH:0x%x, cpu:%llu(0x%x)\n",
+		var, var, bw_gpu, bw_cpu, bw_cpu);
+}
+
+DEVICE_ATTR(bw,  0440, emi_show_max_bw, NULL);
+
+static ssize_t emi_dump_bw(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	unsigned long long var;
+
+	if (!dev) {
+		pr_warn("dev is null!!\n");
+		return 0;
+	}
+
+	emi_dump_bw_array(dev);
+	var = mtk_emi_get_max_bw();
+
+	return scnprintf(buf, PAGE_SIZE,
+		"\temi_max_bw:%llu(0x%x)\n", var, var);
+}
+
+DEVICE_ATTR(dump_bw,  0440, emi_dump_bw, NULL);
+
+static int emi_bw_ms = 1;
+module_param_named(bw_ms, emi_bw_ms, int, 0664);
+
+static void emi_bw_timer_callback(struct timer_list *tm)
+{
+	struct timeval tv;
+	unsigned long long val, cur_max;
+	struct mtk_emi *emi = dev_get_drvdata(emi_dev);
+
+	do_gettimeofday(&tv);
+
+	/* pasue emi monitor for get WACT value*/
+	mtk_emi_mon_stop(emi_dev);
+
+	val = readl(EMI_WSCT4);	/* GPU BW */
+	val *= 8;
+
+	cur_max = mtk_emi_get_max_bw();
+	emi_update_bw_array(emi_dev, val);
+
+	/* set mew timer expires and restart emi monitor */
+	emi->old_tv = tv;
+	emi->emi_bw_timer.expires = jiffies + msecs_to_jiffies(emi_bw_ms);
+
+	add_timer(&(emi->emi_bw_timer));
+	mtk_emi_mon_restart(emi_dev);
+}
+
+static int emi_probe(struct platform_device *pdev)
+{
+	struct mtk_emi *emi;
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+	int i, ret;
+
+	emi = devm_kzalloc(dev, sizeof(*emi), GFP_KERNEL);
+	if (!emi)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	emi->cen_emi_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(emi->cen_emi_base)) {
+		pr_err("[EMI] unable to map cen_emi_base\n");
+		devm_kfree(dev, emi);
+		return -EINVAL;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	emi->emi_mpu_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(emi->emi_mpu_base)) {
+		pr_err("[EMI] unable to map emi_mpu_base\n");
+		devm_kfree(dev, emi);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < MAX_CH; i++) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 2 + i);
+		emi->chn_emi_base[i] = devm_ioremap_resource(dev, res);
+		if (IS_ERR(emi->chn_emi_base[i])) {
+			pr_err("[EMI] unable to map ch%d_emi_base\n", i);
+			devm_kfree(dev, emi);
+			return -EINVAL;
+		}
+	}
+
+	platform_set_drvdata(pdev, emi);
+
+	emi_dev = dev;
+	/* start emi bw monitor */
+	mtk_emi_mon_start(dev);
+
+	emi->emi_bw_max_idx = ARRAY_SIZE(emi->emi_bw_array);
+	/* setup timer */
+	timer_setup(&(emi->emi_bw_timer), NULL, 0);
+	do_gettimeofday(&(emi->old_tv));
+
+	emi->emi_bw_timer.function = emi_bw_timer_callback;
+	emi->emi_bw_timer.expires = jiffies + msecs_to_jiffies(1);
+	add_timer(&(emi->emi_bw_timer));
+
+	/* debug node */
+	ret = device_create_file(dev, &dev_attr_bw);
+	if (ret) {
+		dev_err(dev, "create bw file failed!\n");
+		goto err_create_attr_bw;
+	}
+	ret = device_create_file(dev, &dev_attr_dump_bw);
+	if (ret) {
+		dev_err(dev, "create dump_bw file failed!\n");
+		goto err_create_attr_dump_bw;
+	}
+
+	return 0;
+
+err_create_attr_dump_bw:
+	del_timer(&(emi->emi_bw_timer));
+	device_remove_file(dev, &dev_attr_bw);
+err_create_attr_bw:
+	devm_kfree(dev, emi);
+	return -ENOMEM;
+}
+
+static int emi_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_emi *emi = dev_get_drvdata(dev);
+
+	del_timer(&(emi->emi_bw_timer));
+	device_remove_file(dev, &dev_attr_dump_bw);
+	device_remove_file(dev, &dev_attr_bw);
+
+	devm_kfree(dev, emi);
+	return 0;
+}
+
+
+#ifdef CONFIG_OF
+static const struct of_device_id emi_of_ids[] = {
+	{.compatible = "mediatek,mt8183-emi",},
+	{}
+};
+#endif
+
+static struct platform_driver emi_bw_driver = {
+	.probe = emi_probe,
+	.remove = emi_remove,
+	.driver = {
+		.name = "emi_bw",
+		.owner = THIS_MODULE,
+		.pm = NULL,
+#ifdef CONFIG_OF
+		.of_match_table = emi_of_ids,
+#endif
+	},
+};
+
+
+static int __init emi_bw_init(void)
+{
+	int ret;
+
+	/* register EMI ctrl interface */
+	ret = platform_driver_register(&emi_bw_driver);
+	if (ret) {
+		pr_err("[EMI/BWL] fail to register emi_bw_driver\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit emi_bw_exit(void)
+{
+	platform_driver_unregister(&emi_bw_driver);
+}
+
+postcore_initcall(emi_bw_init);
+module_exit(emi_bw_exit);
+
diff --git a/drivers/memory/mtk-smi.c b/drivers/memory/mtk-smi.c
index 96883411cd29..a1dc34ba7332 100644
--- a/drivers/memory/mtk-smi.c
+++ b/drivers/memory/mtk-smi.c
@@ -123,20 +123,6 @@ static void mtk_smi_clk_disable(const struct mtk_smi *smi)
 	clk_disable_unprepare(smi->clk_apb);
 }
 
-int mtk_smi_larb_get(struct device *larbdev)
-{
-	int ret = pm_runtime_get_sync(larbdev);
-
-	return (ret < 0) ? ret : 0;
-}
-EXPORT_SYMBOL_GPL(mtk_smi_larb_get);
-
-void mtk_smi_larb_put(struct device *larbdev)
-{
-	pm_runtime_put_sync(larbdev);
-}
-EXPORT_SYMBOL_GPL(mtk_smi_larb_put);
-
 static int
 mtk_smi_larb_bind(struct device *dev, struct device *master, void *data)
 {
@@ -271,6 +257,7 @@ static int mtk_smi_larb_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct device_node *smi_node;
 	struct platform_device *smi_pdev;
+	struct device_link *link;
 
 	larb = devm_kzalloc(dev, sizeof(*larb), GFP_KERNEL);
 	if (!larb)
@@ -310,6 +297,12 @@ static int mtk_smi_larb_probe(struct platform_device *pdev)
 		if (!platform_get_drvdata(smi_pdev))
 			return -EPROBE_DEFER;
 		larb->smi_common_dev = &smi_pdev->dev;
+		link = device_link_add(dev, larb->smi_common_dev,
+				       DL_FLAG_PM_RUNTIME);
+		if (!link) {
+			dev_err(dev, "Unable to link smi-common dev\n");
+			return -ENODEV;
+		}
 	} else {
 		dev_err(dev, "Failed to get the smi_common device\n");
 		return -EINVAL;
@@ -333,17 +326,9 @@ static int __maybe_unused mtk_smi_larb_resume(struct device *dev)
 	const struct mtk_smi_larb_gen *larb_gen = larb->larb_gen;
 	int ret;
 
-	/* Power on smi-common. */
-	ret = pm_runtime_get_sync(larb->smi_common_dev);
-	if (ret < 0) {
-		dev_err(dev, "Failed to pm get for smi-common(%d).\n", ret);
-		return ret;
-	}
-
 	ret = mtk_smi_clk_enable(&larb->smi);
 	if (ret < 0) {
 		dev_err(dev, "Failed to enable clock(%d).\n", ret);
-		pm_runtime_put_sync(larb->smi_common_dev);
 		return ret;
 	}
 
@@ -358,7 +343,6 @@ static int __maybe_unused mtk_smi_larb_suspend(struct device *dev)
 	struct mtk_smi_larb *larb = dev_get_drvdata(dev);
 
 	mtk_smi_clk_disable(&larb->smi);
-	pm_runtime_put_sync(larb->smi_common_dev);
 	return 0;
 }
 
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index ce8398e6f2c0..c8f3fe701ea7 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -23,7 +23,7 @@ obj-$(CONFIG_MMC_SDHCI_F_SDH30)	+= sdhci_f_sdh30.o
 obj-$(CONFIG_MMC_SDHCI_SPEAR)	+= sdhci-spear.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
 obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
-obj-$(CONFIG_MMC_MTK)		+= mtk-sd.o
+obj-$(CONFIG_MMC_MTK)		+= mtk-sd.o mtk-sdio-proc.o
 obj-$(CONFIG_MMC_OMAP)		+= omap.o
 obj-$(CONFIG_MMC_OMAP_HS)	+= omap_hsmmc.o
 obj-$(CONFIG_MMC_ATMELMCI)	+= atmel-mci.o
diff --git a/drivers/mmc/host/mtk-sd.c b/drivers/mmc/host/mtk-sd.c
index 0de3749c9311..8aaa5d405987 100644
--- a/drivers/mmc/host/mtk-sd.c
+++ b/drivers/mmc/host/mtk-sd.c
@@ -39,6 +39,8 @@
 #include <linux/mmc/sdio.h>
 #include <linux/mmc/slot-gpio.h>
 
+#include "mtk-sdio-proc.h"
+
 #define MAX_BD_NUM          1024
 
 /*--------------------------------------------------------------------------*/
@@ -2234,6 +2236,9 @@ static int msdc_drv_probe(struct platform_device *pdev)
 	if (ret)
 		goto end;
 
+	if (host->mmc->caps & MMC_CAP_SDIO_IRQ)
+		sdio_proc_init(host->mmc);
+
 	return 0;
 end:
 	pm_runtime_disable(host->dev);
diff --git a/drivers/mmc/host/mtk-sdio-proc.c b/drivers/mmc/host/mtk-sdio-proc.c
new file mode 100644
index 000000000000..6f4c3cd96d42
--- /dev/null
+++ b/drivers/mmc/host/mtk-sdio-proc.c
@@ -0,0 +1,342 @@
+/*
+ * Copyright (c) 2014-2015 MediaTek Inc.
+ * Author: Chaotian.Jing <chaotian.jing@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "mtk-sdio-proc.h"
+
+static struct mmc_host *host;
+
+/**
+ * sdio_proc_show dispaly the common cccr and cis.
+ */
+static int sdio_proc_show(struct seq_file *m, void *v)
+{
+	struct mmc_card *card;
+	struct sdio_cccr cccr;
+
+	WARN_ON(!host);
+	card = host->card;
+	cccr = card->cccr;
+
+	seq_puts(m, "\n=========================================\n");
+	seq_puts(m, "common cccr:\n");
+	seq_printf(m, "sdio_vsn:%x, sd_vsn:%x, multi_block%x.\n"
+			"low_speed:%x, wide_bus:%x, hight_power:%x.\n"
+			"high_speed:%x, disable_cd:%x.\n",
+			cccr.sdio_vsn, cccr.sd_vsn, cccr.multi_block,
+			cccr.low_speed, cccr.wide_bus, cccr.high_power,
+			cccr.high_speed, cccr.disable_cd);
+
+	seq_puts(m, "common cis:\n");
+	seq_printf(m, "vendor: %x, device:%x, blksize:%x, max_dtr:%x\n",
+			card->cis.vendor, card->cis.device,
+			card->cis.blksize, card->cis.max_dtr);
+
+	seq_puts(m, "read cmd format:\n");
+	seq_puts(m, "echo 0 0xReg 0xfunction> /proc/sdio\n");
+	seq_puts(m, "write cmd format:\n");
+	seq_puts(m, "echo 1 0xReg 0xfunction 0xValue> /proc/sdio\n");
+	seq_puts(m, "setspeed cmd format:\n");
+	seq_puts(m, "echo 2 0xclkfrequency > /proc/sdio\n");
+	seq_puts(m, "tune cmd format:\n");
+	seq_puts(m, "echo 3 0xloop_cycles > /proc/sdio\n");
+	seq_puts(m, "multi read cmd format:\n");
+	seq_puts(m, "echo 4 0x13 0x0 > /proc/sdio\n");
+	seq_puts(m, "multi write cmd format:\n");
+	seq_puts(m, "echo 5 0x13 0x0 0xvalue > /proc/sdio\n");
+	seq_puts(m, "Notice:value is the read result!\n");
+	seq_puts(m, "=========================================\n");
+
+	return 0;
+}
+
+static int sdio_tuning(void)
+{
+	int err = 0;
+
+	err = mmc_send_tuning(host, MMC_SEND_TUNING_BLOCK, NULL);
+	if (err)
+		pr_err("tuning result is %d.\n", err);
+	return err;
+}
+
+/**
+ * sdio_proc_write - read/write sdio function register.
+ */
+static ssize_t sdio_proc_write(struct file *file, const char *buf,
+		size_t count, loff_t *f_pos)
+{
+	struct mmc_card *card;
+	struct sdio_func *func;
+	struct mmc_ios *ios;
+	char *cmd_buf;
+	unsigned int cmd, addr, fn, value, hqa_result;
+	unsigned char result;
+	int i = 0, ret;
+	unsigned long long count_r = 0, count_w = 0, total = 0;
+
+	WARN_ON(!host);
+	card = host->card;
+	ios = &host->ios;
+
+	cmd_buf = kzalloc((count + 1), GFP_KERNEL);
+	if (!cmd_buf)
+		return -ENOMEM;
+
+	func = kzalloc(sizeof(struct sdio_func), GFP_KERNEL);
+	if (!func)
+		return -ENOMEM;
+
+	ret = copy_from_user(cmd_buf, buf, count);
+	if (ret < 0) {
+		kfree(cmd_buf);
+		kfree(func);
+		return -EFAULT;
+	}
+
+	*(cmd_buf + count) = '\0';
+	ret = sscanf(cmd_buf, "%x %x %x %x",
+			&cmd, &addr, &fn, &value);
+	if (ret == 0) {
+		pr_err("please enter cmd.\n");
+		return ret;
+	}
+
+	if ((cmd == tune) || (cmd == speed))
+		fn = 0;
+
+	/* Judge whether request fn is over the max functions. */
+	if (fn > card->sdio_funcs) {
+		pr_err("the fn is over the max sdio funcs.\n");
+		return -EFAULT;
+	}
+
+	if (fn) {
+		/**
+		 * The test read/write api don't need more func
+		 * information. So we just use the card & func->num
+		 * to the new struct func.
+		 */
+		if (card->sdio_func[fn - 1]) {
+			func->card = card;
+			func->num = card->sdio_func[fn - 1]->num;
+			func->tuples = card->sdio_func[fn - 1]->tuples;
+			func->tmpbuf = card->sdio_func[fn - 1]->tmpbuf;
+			func->max_blksize = card->sdio_func[fn - 1]->max_blksize;
+			if ((cmd == hqa_read) || (cmd == hqa_write) || (cmd == burn))
+				func->cur_blksize = 8;
+			else
+				func->cur_blksize = 1;
+			func = card->sdio_func[fn - 1];
+		} else
+			pr_err("func %d is null,.\n", fn);
+	} else {
+		/**
+		  * function 0 should not need struct func.
+		  * but the api need the parameter, so we create
+		  * the a new func for function 0.
+		  */
+		func->card = card;
+		func->tuples = card->tuples;
+		func->num = 0;
+		func->max_blksize = 16;
+		if ((cmd == hqa_read) || (cmd == hqa_write) || (cmd == burn))
+			func->cur_blksize = 16;
+		else
+			func->cur_blksize = 1;
+
+		func->tmpbuf = kmalloc(func->cur_blksize, GFP_KERNEL);
+		if (!func->tmpbuf) {
+			kfree(func);
+			return -ENOMEM;
+		}
+		memset(func->tmpbuf, 0, func->cur_blksize);
+	}
+
+	sdio_claim_host(func);
+	pr_err("===========================================\n");
+
+	switch (cmd) {
+	case read:
+		pr_err("read addr:%x, fn:%d.\n", addr, fn);
+		ret = 0;
+		if (fn == 0)
+			result = sdio_f0_readb(func, addr, &ret);
+		else
+			result = sdio_readb(func, addr, &ret);
+
+		if (ret)
+			pr_err("Read f%d reg(%x) fail(%d).\n",
+					func->num, addr, ret);
+		else
+			pr_err("f%d reg(%x) is 0x%02x.\n",
+					func->num, addr, result);
+		break;
+	case write:
+		pr_err("write addr:%x, value:%x, fn %d.\n",
+				addr, (u8)value, fn);
+		ret = 0;
+		if (fn == 0)
+			/* (0xF0 - 0xFF) are permiited for func0 */
+			sdio_f0_writeb(func, (u8)value, addr, &ret);
+		else
+			sdio_writeb(func, (u8)value, addr, &ret);
+
+		if (ret)
+			pr_err("write f%d reg(%x) fail(%d).\n",
+					func->num, addr, ret);
+		else
+			pr_err("write f%d reg(%x) success(%d).\n",
+					func->num, addr, ret);
+
+		break;
+	case speed:
+		pr_err("set frequence:%x.\n", addr);
+
+		if (addr > 200000000)
+			addr = 200000000;
+		ios->clock = addr;
+		pr_err("%s: clock %uHz busmode %u powermode %u cs %u Vdd %u width %u timing %u\n",
+				mmc_hostname(host), ios->clock, ios->bus_mode,
+				ios->power_mode, ios->chip_select, ios->vdd,
+				ios->bus_width, ios->timing);
+
+		host->ops->set_ios(host, ios);
+		break;
+	case tune:
+		value = 0;
+		pr_err("read loop / 0x200:%x.\n", addr);
+
+		do {
+			result = sdio_tuning();
+			if (result)
+				value = value + 1;
+
+			i = i + 1;
+		} while (i < addr);
+
+		pr_err("send tuning cmd is result (%d).\n", value);
+		break;
+	case hqa_read:
+		pr_err("hqa_r addr:%x, fn %d\n", addr, fn);
+		i = 0;
+		hqa_result = 0;
+		do {
+			ret = 0;
+			hqa_result = sdio_readl(func, addr, &ret);
+			if (ret)
+				pr_err("Read f%d reg(%x) fail(%d).\n",
+						func->num, addr, ret);
+
+			i = i + 1;
+		} while (i < 0x10000);
+		pr_err("Read %d cycles success:f%d reg(%x) is 0x%02x.\n",
+				i, func->num, addr, hqa_result);
+		break;
+	case hqa_write:
+		pr_err("hqa_w addr:%x, value:%x, fn %d\n",
+				addr, value, fn);
+		i = 0;
+		hqa_result = 0;
+		do {
+			ret = 0;
+			sdio_writel(func, value, addr, &ret);
+			if (ret)
+				pr_err("write f%d reg(%x) fail(%d).\n",
+						func->num, addr, ret);
+
+			i = i + 1;
+		} while (i < 0x10000);
+		pr_err("write f%d reg(%x) success(%d).\n",
+				func->num, addr, ret);
+		break;
+	case burn:
+		do {
+			ret = 0;
+			addr = 0x13;
+			value = sdio_readl(func, addr, &ret);
+			if (ret)
+				pr_err("Read f%d reg(%x) fail(%d).\n",
+						func->num, addr, ret);
+			else {
+				pr_err("********read success********\n");
+				count_r = count_r + 1;
+			}
+			msleep(20);
+
+			ret = 0;
+			addr = 0x13;
+			func->cur_blksize = 4;
+			sdio_writel(func, value, addr, &ret);
+			if (ret)
+				pr_err("write f%d reg(%x) fail(%d).\n",
+						func->num, addr, ret);
+			else {
+				pr_err("********write success*******\n");
+				count_w = count_w + 1;
+			}
+			total = total + 1;
+			msleep(20);
+			pr_err("success read:%llx, write:%llx, total:%llx.\n",
+					count_r, count_w, total);
+		} while (1);
+		break;
+	default:
+		pr_err("cmd is not valid.\n");
+		break;
+	}
+
+	pr_err("\n===========================================\n");
+	sdio_release_host(func);
+
+	kfree(cmd_buf);
+	kfree(func);
+
+	return count;
+}
+
+/**
+ * open function show some stable information.
+ */
+static int sdio_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sdio_proc_show, inode->i_private);
+}
+
+/**
+  * sdio pre is our own function.
+  * seq or single pre is the kernel function.
+  */
+static const struct file_operations sdio_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = sdio_proc_open,
+	.release = single_release,
+	.write = sdio_proc_write,
+	.read = seq_read,
+	.llseek = seq_lseek,
+};
+
+int sdio_proc_init(struct mmc_host *host_init)
+{
+	struct proc_dir_entry *prEntry;
+
+	host = host_init;
+
+	prEntry = proc_create("sdio", 0660, NULL, &sdio_proc_fops);
+	if (prEntry)
+		pr_err("[%s]/proc/sdio_proc is created.\n", __func__);
+	else
+		pr_err("[%s]Create /proc/sdio_proc failed.\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/mmc/host/mtk-sdio-proc.h b/drivers/mmc/host/mtk-sdio-proc.h
new file mode 100644
index 000000000000..33659ba69be3
--- /dev/null
+++ b/drivers/mmc/host/mtk-sdio-proc.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2014-2015 MediaTek Inc.
+ * Author: Chaotian.Jing <chaotian.jing@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+#include <linux/mmc/host.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+
+int sdio_proc_init(struct mmc_host *host);
+
+enum {
+	read = 0,
+	write,
+	speed,
+	tune,
+	hqa_read,
+	hqa_write,
+	burn
+};
diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
index b91f2679945c..e728a5471bd7 100644
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -184,7 +184,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 			.board_size = QCA6174_BOARD_DATA_SZ,
 			.board_ext_size = QCA6174_BOARD_EXT_DATA_SZ,
 		},
-		.hw_ops = &qca6174_ops,
+		.hw_ops = &qca6174_sdio_ops,
 		.hw_clk = qca6174_clk,
 		.target_cpu_freq = 176000000,
 		.decap_align_bytes = 4,
diff --git a/drivers/net/wireless/ath/ath10k/htt_rx.c b/drivers/net/wireless/ath/ath10k/htt_rx.c
index 4a3892735ab8..4893928502af 100644
--- a/drivers/net/wireless/ath/ath10k/htt_rx.c
+++ b/drivers/net/wireless/ath/ath10k/htt_rx.c
@@ -1952,6 +1952,7 @@ static bool ath10k_htt_rx_proc_rx_ind_hl(struct ath10k_htt *htt,
 	int num_mpdu_ranges;
 	size_t tot_hdr_len;
 	struct ieee80211_channel *ch;
+	bool pn_invalid;
 
 	peer_id = __le16_to_cpu(rx->hdr.peer_id);
 
@@ -1959,7 +1960,7 @@ static bool ath10k_htt_rx_proc_rx_ind_hl(struct ath10k_htt *htt,
 	peer = ath10k_peer_find_by_id(ar, peer_id);
 	spin_unlock_bh(&ar->data_lock);
 	if (!peer)
-		ath10k_warn(ar, "Got RX ind from invalid peer: %u\n", peer_id);
+		ath10k_dbg(ar, ATH10K_DBG_HTT, "Got RX ind from invalid peer: %u\n", peer_id);
 
 	num_mpdu_ranges = MS(__le32_to_cpu(rx->hdr.info1),
 			     HTT_RX_INDICATION_INFO1_NUM_MPDU_RANGES);
@@ -1977,15 +1978,21 @@ static bool ath10k_htt_rx_proc_rx_ind_hl(struct ath10k_htt *htt,
 			    num_mpdu_ranges);
 
 	if (mpdu_ranges->mpdu_range_status !=
-	    HTT_RX_IND_MPDU_STATUS_OK) {
-		ath10k_warn(ar, "MPDU range status: %d\n",
+	    HTT_RX_IND_MPDU_STATUS_OK &&
+	    mpdu_ranges->mpdu_range_status !=
+	    HTT_RX_IND_MPDU_STATUS_TKIP_MIC_ERR) {
+		ath10k_dbg(ar, ATH10K_DBG_HTT, "MPDU range status: %d\n",
 			    mpdu_ranges->mpdu_range_status);
 		goto err;
 	}
 
-	if (check_pn_type == HTT_RX_PN_CHECK &&
-	    ath10k_htt_rx_pn_check_replay_hl(ar, peer, rx))
-		goto err;
+	if (check_pn_type == HTT_RX_PN_CHECK) {
+		spin_lock_bh(&ar->data_lock);
+		pn_invalid = ath10k_htt_rx_pn_check_replay_hl(ar, peer, rx);
+		spin_unlock_bh(&ar->data_lock);
+		if (pn_invalid)
+			goto err;
+	}
 
 	/* Strip off all headers before the MAC header before delivery to
 	 * mac80211
@@ -2047,6 +2054,9 @@ static bool ath10k_htt_rx_proc_rx_ind_hl(struct ath10k_htt *htt,
 		rx_status->flag &= ~RX_FLAG_IV_STRIPPED &
 				   ~RX_FLAG_MMIC_STRIPPED;
 
+	if (mpdu_ranges->mpdu_range_status == HTT_RX_IND_MPDU_STATUS_TKIP_MIC_ERR)
+		rx_status->flag |= RX_FLAG_MMIC_ERROR;
+
 	ieee80211_rx_ni(ar->hw, skb);
 
 	/* We have delivered the skb to the upper layers (mac80211) so we
diff --git a/drivers/net/wireless/ath/ath10k/hw.c b/drivers/net/wireless/ath/ath10k/hw.c
index 52845912a4b9..e8dd6a1e6e03 100644
--- a/drivers/net/wireless/ath/ath10k/hw.c
+++ b/drivers/net/wireless/ath/ath10k/hw.c
@@ -1130,4 +1130,8 @@ const struct ath10k_hw_ops qca6174_ops = {
 	.enable_pll_clk = ath10k_hw_qca6174_enable_pll_clock,
 };
 
+const struct ath10k_hw_ops qca6174_sdio_ops = {
+	.enable_pll_clk = ath10k_hw_qca6174_enable_pll_clock,
+};
+
 const struct ath10k_hw_ops wcn3990_ops = {};
diff --git a/drivers/net/wireless/ath/ath10k/hw.h b/drivers/net/wireless/ath/ath10k/hw.h
index 5c256d41cc82..3ff49d973ea4 100644
--- a/drivers/net/wireless/ath/ath10k/hw.h
+++ b/drivers/net/wireless/ath/ath10k/hw.h
@@ -162,6 +162,8 @@ enum qca9377_chip_id_rev {
 #define ATH10K_FW_UTF_FILE		"utf.bin"
 #define ATH10K_FW_UTF_API2_FILE		"utf-2.bin"
 
+#define ATH10K_FW_UTF_FILE_BASE		"utf"
+
 /* includes also the null byte */
 #define ATH10K_FIRMWARE_MAGIC               "QCA-ATH10K"
 #define ATH10K_BOARD_MAGIC                  "QCA-ATH10K-BOARD"
@@ -633,6 +635,7 @@ struct ath10k_hw_ops {
 extern const struct ath10k_hw_ops qca988x_ops;
 extern const struct ath10k_hw_ops qca99x0_ops;
 extern const struct ath10k_hw_ops qca6174_ops;
+extern const struct ath10k_hw_ops qca6174_sdio_ops;
 extern const struct ath10k_hw_ops wcn3990_ops;
 
 extern const struct ath10k_hw_clk_params qca6174_clk[];
@@ -1076,6 +1079,7 @@ ath10k_rx_desc_get_l3_pad_bytes(struct ath10k_hw_params *hw,
 #define MBOX_CPU_INT_STATUS_ENABLE_ADDRESS	0x00000819
 #define MBOX_CPU_INT_STATUS_ENABLE_BIT_LSB	0
 #define MBOX_CPU_INT_STATUS_ENABLE_BIT_MASK	0x000000ff
+#define MBOX_CPU_STATUS_ENABLE_ASSERT_MASK 0x00000001
 #define MBOX_ERROR_STATUS_ENABLE_ADDRESS	0x0000081a
 #define MBOX_ERROR_STATUS_ENABLE_RX_UNDERFLOW_LSB  1
 #define MBOX_ERROR_STATUS_ENABLE_RX_UNDERFLOW_MASK 0x00000002
diff --git a/drivers/net/wireless/ath/ath10k/sdio.c b/drivers/net/wireless/ath/ath10k/sdio.c
index 2ebe657be089..874d17dfcf0e 100644
--- a/drivers/net/wireless/ath/ath10k/sdio.c
+++ b/drivers/net/wireless/ath/ath10k/sdio.c
@@ -618,6 +618,10 @@ static int ath10k_sdio_mbox_rx_alloc(struct ath10k *ar,
 						    full_len,
 						    last_in_bundle,
 						    last_in_bundle);
+		if (ret) {
+			ath10k_warn(ar, "alloc_rx_pkt error %d\n", ret);
+			goto err;
+		}
 	}
 
 	ar_sdio->n_rx_pkts = i;
@@ -866,6 +870,10 @@ static int ath10k_sdio_mbox_proc_cpu_intr(struct ath10k *ar)
 
 out:
 	mutex_unlock(&irq_data->mtx);
+	if (cpu_int_status & MBOX_CPU_STATUS_ENABLE_ASSERT_MASK) {
+		ath10k_err(ar, "firmware crashed!\n");
+		queue_work(ar->workqueue, &ar->restart_work);
+	}
 	return ret;
 }
 
@@ -1510,8 +1518,10 @@ static int ath10k_sdio_hif_enable_intrs(struct ath10k *ar)
 	regs->int_status_en |=
 		FIELD_PREP(MBOX_INT_STATUS_ENABLE_MBOX_DATA_MASK, 1);
 
-	/* Set up the CPU Interrupt status Register */
-	regs->cpu_int_status_en = 0;
+	/* Set up the CPU Interrupt Status Register, enable CPU sourced interrupt #0
+	 * #0 is used for report assertion from target
+	 */
+	regs->cpu_int_status_en = FIELD_PREP(MBOX_CPU_STATUS_ENABLE_ASSERT_MASK, 1);
 
 	/* Set up the Error Interrupt status Register */
 	regs->err_int_status_en =
diff --git a/drivers/net/wireless/ath/ath10k/testmode.c b/drivers/net/wireless/ath/ath10k/testmode.c
index c24ee616833c..348d98be2c70 100644
--- a/drivers/net/wireless/ath/ath10k/testmode.c
+++ b/drivers/net/wireless/ath/ath10k/testmode.c
@@ -185,8 +185,23 @@ static int ath10k_tm_fetch_firmware(struct ath10k *ar)
 {
 	struct ath10k_fw_components *utf_mode_fw;
 	int ret;
+	char fw_name[100];
+	int fw_api2 = 2;
+
+	switch (ar->hif.bus) {
+	case ATH10K_BUS_SDIO:
+	case ATH10K_BUS_USB:
+		scnprintf(fw_name, sizeof(fw_name), "%s-%s-%d.bin",
+			  ATH10K_FW_UTF_FILE_BASE, ath10k_bus_str(ar->hif.bus),
+			  fw_api2);
+		break;
+	default:
+		scnprintf(fw_name, sizeof(fw_name), "%s-%d.bin",
+			  ATH10K_FW_UTF_FILE_BASE, fw_api2);
+		break;
+	}
 
-	ret = ath10k_core_fetch_firmware_api_n(ar, ATH10K_FW_UTF_API2_FILE,
+	ret = ath10k_core_fetch_firmware_api_n(ar, fw_name,
 					       &ar->testmode.utf_mode_fw.fw_file);
 	if (ret == 0) {
 		ath10k_dbg(ar, ATH10K_DBG_TESTMODE, "testmode using fw utf api 2");
diff --git a/drivers/thermal/mtk_thermal.c b/drivers/thermal/mtk_thermal.c
index 3d0115316bae..a17563c2cf47 100644
--- a/drivers/thermal/mtk_thermal.c
+++ b/drivers/thermal/mtk_thermal.c
@@ -46,6 +46,7 @@
 #define TEMP_MONIDET0		0x014
 #define TEMP_MONIDET1		0x018
 #define TEMP_MSRCTL0		0x038
+#define TEMP_MSRCTL1		0x03c
 #define TEMP_AHBPOLL		0x040
 #define TEMP_AHBTO		0x044
 #define TEMP_ADCPNP0		0x048
@@ -95,6 +96,9 @@
 #define TEMP_ADCVALIDMASK_VALID_HIGH		BIT(5)
 #define TEMP_ADCVALIDMASK_VALID_POS(bit)	(bit)
 
+#define TEMP_BUS_STA	(BIT(1) | BIT(8))
+#define TEMP_SENSING_POINTS_PAUSE	0x10E
+
 /* MT8173 thermal sensors */
 #define MT8173_TS1	0
 #define MT8173_TS2	1
@@ -266,6 +270,10 @@ struct mtk_thermal_data {
 struct mtk_thermal {
 	struct device *dev;
 	void __iomem *thermal_base;
+	void __iomem *apmixed_base;
+	void __iomem *auxadc_base;
+	u64 apmixed_phys_base;
+	u64 auxadc_phys_base;
 
 	struct clk *clk_peri_therm;
 	struct clk *clk_auxadc;
@@ -795,6 +803,52 @@ static void mtk_thermal_init_bank(struct mtk_thermal *mt, int num,
 	mtk_thermal_put_bank(bank);
 }
 
+static int mtk_thermal_disable_sensing(struct mtk_thermal *mt, int num)
+{
+	struct mtk_thermal_bank *bank = &mt->banks[num];
+	u32 val;
+	unsigned long timeout;
+	bool expired;
+	int ret = 0;
+
+	bank->id = num;
+	bank->mt = mt;
+
+	mtk_thermal_get_bank(bank);
+
+	/* wait until temperature measurement bus idle */
+	timeout = jiffies + HZ;
+	expired = false;
+	while (1) {
+		val = readl(mt->thermal_base + TEMP_MSRCTL1);
+		if ((val & TEMP_BUS_STA) == 0x0 ||
+		    (val & TEMP_BUS_STA) == TEMP_BUS_STA)
+			break;
+
+		if (expired) {
+			ret = -ETIMEDOUT;
+			goto out;
+		}
+
+		cpu_relax();
+
+		if (time_after(jiffies, timeout))
+			expired = true;
+	}
+
+	/* pause periodic temperature measurement for sensing points */
+	writel(val | TEMP_SENSING_POINTS_PAUSE,
+	       mt->thermal_base + TEMP_MSRCTL1);
+
+	/* disable periodic temperature meausrement on sensing points */
+	writel(0x0, mt->thermal_base + TEMP_MONCTL0);
+
+out:
+	mtk_thermal_put_bank(bank);
+
+	return ret;
+}
+
 static u64 of_get_phys_base(struct device_node *np)
 {
 	u64 size64;
@@ -917,7 +971,6 @@ static int mtk_thermal_probe(struct platform_device *pdev)
 	struct device_node *auxadc, *apmixedsys, *np = pdev->dev.of_node;
 	struct mtk_thermal *mt;
 	struct resource *res;
-	u64 auxadc_phys_base, apmixed_phys_base;
 	struct thermal_zone_device *tzdev;
 	struct mtk_thermal_zone *tz;
 
@@ -954,11 +1007,12 @@ static int mtk_thermal_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	auxadc_phys_base = of_get_phys_base(auxadc);
+	mt->auxadc_phys_base = of_get_phys_base(auxadc);
+	mt->auxadc_base = of_iomap(auxadc, 0);
 
 	of_node_put(auxadc);
 
-	if (auxadc_phys_base == OF_BAD_ADDR) {
+	if (mt->auxadc_phys_base == OF_BAD_ADDR) {
 		dev_err(&pdev->dev, "Can't get auxadc phys address\n");
 		return -EINVAL;
 	}
@@ -969,11 +1023,12 @@ static int mtk_thermal_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	apmixed_phys_base = of_get_phys_base(apmixedsys);
+	mt->apmixed_phys_base = of_get_phys_base(apmixedsys);
+	mt->apmixed_base = of_iomap(apmixedsys, 0);
 
 	of_node_put(apmixedsys);
 
-	if (apmixed_phys_base == OF_BAD_ADDR) {
+	if (mt->apmixed_phys_base == OF_BAD_ADDR) {
 		dev_err(&pdev->dev, "Can't get auxadc phys address\n");
 		return -EINVAL;
 	}
@@ -985,19 +1040,19 @@ static int mtk_thermal_probe(struct platform_device *pdev)
 	ret = clk_prepare_enable(mt->clk_auxadc);
 	if (ret) {
 		dev_err(&pdev->dev, "Can't enable auxadc clk: %d\n", ret);
-		return ret;
+		goto err_disable_clk_auxadc;
 	}
 
 	ret = clk_prepare_enable(mt->clk_peri_therm);
 	if (ret) {
 		dev_err(&pdev->dev, "Can't enable peri clk: %d\n", ret);
-		goto err_disable_clk_auxadc;
+		goto err_disable_clk_peri_therm;
 	}
 
 	for (ctrl_id = 0; ctrl_id < mt->conf->num_controller ; ctrl_id++)
 		for (i = 0; i < mt->conf->num_banks; i++)
-			mtk_thermal_init_bank(mt, i, apmixed_phys_base,
-					      auxadc_phys_base, ctrl_id);
+			mtk_thermal_init_bank(mt, i, mt->apmixed_phys_base,
+					      mt->auxadc_phys_base, ctrl_id);
 
 	platform_set_drvdata(pdev, mt);
 
@@ -1041,11 +1096,78 @@ static int mtk_thermal_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static int __maybe_unused mtk_thermal_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct mtk_thermal *mt = platform_get_drvdata(pdev);
+	int i, ret;
+
+	for (i = 0; i < mt->conf->num_banks; i++) {
+		ret = mtk_thermal_disable_sensing(mt, i);
+		if (ret)
+			goto out;
+	}
+
+	/* disable buffer */
+	writel(readl(mt->apmixed_base + APMIXED_SYS_TS_CON1) | 0x30,
+	       mt->apmixed_base + APMIXED_SYS_TS_CON1);
+
+	clk_disable_unprepare(mt->clk_peri_therm);
+	clk_disable_unprepare(mt->clk_auxadc);
+
+	return 0;
+
+out:
+	dev_err(&pdev->dev, "Failed to wait until bus idle\n");
+
+	return ret;
+}
+
+static int __maybe_unused mtk_thermal_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct mtk_thermal *mt = platform_get_drvdata(pdev);
+	int i, ret, ctrl_id;
+
+	ret = device_reset(&pdev->dev);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(mt->clk_auxadc);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't enable auxadc clk: %d\n", ret);
+		goto err_disable_clk_auxadc;
+	}
+
+	ret = clk_prepare_enable(mt->clk_peri_therm);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't enable peri clk: %d\n", ret);
+		goto err_disable_clk_peri_therm;
+	}
+
+	for (ctrl_id = 0; ctrl_id < mt->conf->num_controller ; ctrl_id++)
+		for (i = 0; i < mt->conf->num_banks; i++)
+			mtk_thermal_init_bank(mt, i, mt->apmixed_phys_base,
+					      mt->auxadc_phys_base, ctrl_id);
+	return 0;
+
+err_disable_clk_peri_therm:
+	clk_disable_unprepare(mt->clk_peri_therm);
+err_disable_clk_auxadc:
+	clk_disable_unprepare(mt->clk_auxadc);
+
+	return ret;
+}
+
+static SIMPLE_DEV_PM_OPS(mtk_thermal_pm_ops,
+			 mtk_thermal_suspend, mtk_thermal_resume);
+
 static struct platform_driver mtk_thermal_driver = {
 	.probe = mtk_thermal_probe,
 	.remove = mtk_thermal_remove,
 	.driver = {
 		.name = "mtk-thermal",
+		.pm = &mtk_thermal_pm_ops,
 		.of_match_table = mtk_thermal_of_match,
 	},
 };
diff --git a/drivers/tty/serial/8250/8250_mtk.c b/drivers/tty/serial/8250/8250_mtk.c
old mode 100644
new mode 100755
index 417c7c810df9..c201646f61b9
--- a/drivers/tty/serial/8250/8250_mtk.c
+++ b/drivers/tty/serial/8250/8250_mtk.c
@@ -31,6 +31,7 @@
 #define MTK_UART_RXTRI_AD	0x14	/* RX Trigger address */
 #define MTK_UART_FRACDIV_L	0x15	/* Fractional divider LSB address */
 #define MTK_UART_FRACDIV_M	0x16	/* Fractional divider MSB address */
+#define MTK_UART_DEBUG0		0x18
 #define MTK_UART_IER_XOFFI	0x20	/* Enable XOFF character interrupt */
 #define MTK_UART_IER_RTSI	0x40	/* Enable RTS Modem status interrupt */
 #define MTK_UART_IER_CTSI	0x80	/* Enable CTS Modem status interrupt */
@@ -395,9 +396,18 @@ mtk8250_set_termios(struct uart_port *port, struct ktermios *termios,
 static int __maybe_unused mtk8250_runtime_suspend(struct device *dev)
 {
 	struct mtk8250_data *data = dev_get_drvdata(dev);
+	struct uart_8250_port *up = serial8250_get_port(data->line);
 
-	clk_disable_unprepare(data->uart_clk);
-	clk_disable_unprepare(data->bus_clk);
+	/*wait until UART in idle status*/
+	while
+		(serial_in(up, MTK_UART_DEBUG0));
+
+	if (data->clk_count == 0U)
+		dev_dbg(dev, "%s clock count is 0\n", __func__);
+	else {
+		clk_disable_unprepare(data->bus_clk);
+		data->clk_count--;
+	}
 
 	return 0;
 }
@@ -407,16 +417,16 @@ static int __maybe_unused mtk8250_runtime_resume(struct device *dev)
 	struct mtk8250_data *data = dev_get_drvdata(dev);
 	int err;
 
-	err = clk_prepare_enable(data->uart_clk);
-	if (err) {
-		dev_warn(dev, "Can't enable clock\n");
-		return err;
-	}
-
-	err = clk_prepare_enable(data->bus_clk);
-	if (err) {
-		dev_warn(dev, "Can't enable bus clock\n");
-		return err;
+	if (data->clk_count > 0U)
+		dev_dbg(dev, "%s clock count is %d\n", __func__,
+			data->clk_count);
+	else {
+		err = clk_prepare_enable(data->bus_clk);
+		if (err) {
+			dev_warn(dev, "Can't enable bus clock\n");
+			return err;
+		}
+		data->clk_count++;
 	}
 
 	return 0;
@@ -426,12 +436,14 @@ static void
 mtk8250_do_pm(struct uart_port *port, unsigned int state, unsigned int old)
 {
 	if (!state)
-		pm_runtime_get_sync(port->dev);
+		if (!mtk8250_runtime_resume(port->dev))
+			pm_runtime_get_sync(port->dev);
 
 	serial8250_do_pm(port, state, old);
 
 	if (state)
-		pm_runtime_put_sync_suspend(port->dev);
+		if (!pm_runtime_put_sync_suspend(port->dev))
+			mtk8250_runtime_suspend(port->dev);
 }
 
 #ifdef CONFIG_SERIAL_8250_DMA
@@ -508,6 +520,8 @@ static int mtk8250_probe(struct platform_device *pdev)
 	if (!data)
 		return -ENOMEM;
 
+	data->clk_count = 0;
+
 	if (pdev->dev.of_node) {
 		err = mtk8250_probe_of(pdev, &uart.port, data);
 		if (err)
@@ -540,6 +554,7 @@ static int mtk8250_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, data);
 
+	pm_runtime_enable(&pdev->dev);
 	err = mtk8250_runtime_resume(&pdev->dev);
 	if (err)
 		return err;
@@ -548,9 +563,6 @@ static int mtk8250_probe(struct platform_device *pdev)
 	if (data->line < 0)
 		return data->line;
 
-	pm_runtime_set_active(&pdev->dev);
-	pm_runtime_enable(&pdev->dev);
-
 	return 0;
 }
 
@@ -561,11 +573,13 @@ static int mtk8250_remove(struct platform_device *pdev)
 	pm_runtime_get_sync(&pdev->dev);
 
 	serial8250_unregister_port(data->line);
-	mtk8250_runtime_suspend(&pdev->dev);
 
 	pm_runtime_disable(&pdev->dev);
 	pm_runtime_put_noidle(&pdev->dev);
 
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		mtk8250_runtime_suspend(&pdev->dev);
+
 	return 0;
 }
 
diff --git a/drivers/usb/mtu3/mtu3_core.c b/drivers/usb/mtu3/mtu3_core.c
index 48d10a61e271..542b67a6b5a6 100644
--- a/drivers/usb/mtu3/mtu3_core.c
+++ b/drivers/usb/mtu3/mtu3_core.c
@@ -94,6 +94,7 @@ static int mtu3_device_enable(struct mtu3 *mtu)
 {
 	void __iomem *ibase = mtu->ippc_base;
 	u32 check_clk = 0;
+	struct ssusb_mtk *ssusb = mtu->ssusb;
 
 	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);
 
@@ -107,7 +108,7 @@ static int mtu3_device_enable(struct mtu3 *mtu)
 		(SSUSB_U2_PORT_DIS | SSUSB_U2_PORT_PDN |
 		SSUSB_U2_PORT_HOST_SEL));
 
-	if (mtu->ssusb->dr_mode == USB_DR_MODE_OTG) {
+	if (mtu->ssusb->dr_mode == USB_DR_MODE_OTG && !ssusb->otg_switch.manual_drd_enabled) {
 		mtu3_setbits(ibase, SSUSB_U2_CTRL(0), SSUSB_U2_PORT_OTG_SEL);
 		if (mtu->is_u3_ip)
 			mtu3_setbits(ibase, SSUSB_U3_CTRL(0),
@@ -120,6 +121,7 @@ static int mtu3_device_enable(struct mtu3 *mtu)
 static void mtu3_device_disable(struct mtu3 *mtu)
 {
 	void __iomem *ibase = mtu->ippc_base;
+	struct ssusb_mtk *ssusb = mtu->ssusb;
 
 	if (mtu->is_u3_ip)
 		mtu3_setbits(ibase, SSUSB_U3_CTRL(0),
@@ -128,7 +130,7 @@ static void mtu3_device_disable(struct mtu3 *mtu)
 	mtu3_setbits(ibase, SSUSB_U2_CTRL(0),
 		SSUSB_U2_PORT_DIS | SSUSB_U2_PORT_PDN);
 
-	if (mtu->ssusb->dr_mode == USB_DR_MODE_OTG)
+	if (mtu->ssusb->dr_mode == USB_DR_MODE_OTG && !ssusb->otg_switch.manual_drd_enabled)
 		mtu3_clrbits(ibase, SSUSB_U2_CTRL(0), SSUSB_U2_PORT_OTG_SEL);
 
 	mtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);
@@ -183,6 +185,9 @@ static void mtu3_intr_enable(struct mtu3 *mtu)
 	value = SUSPEND_INTR | RESUME_INTR | RESET_INTR | LPM_RESUME_INTR;
 	mtu3_writel(mbase, U3D_COMMON_USB_INTR_ENABLE, value);
 
+	mtu3_clrbits(mbase, U3D_DEVICE_CONTROL, DC_SESSION);
+	mtu3_setbits(mbase, U3D_MISC_CTRL, VBUS_FRC_EN | VBUS_ON);
+
 	if (mtu->is_u3_ip) {
 		/* Enable U3 LTSSM interrupts */
 		value = HOT_RST_INTR | WARM_RST_INTR | VBUS_RISE_INTR |
@@ -759,7 +764,10 @@ static int mtu3_hw_init(struct mtu3 *mtu)
 	mtu->hw_version = mtu3_readl(mtu->ippc_base, U3D_SSUSB_HW_ID);
 
 	cap_dev = mtu3_readl(mtu->ippc_base, U3D_SSUSB_IP_DEV_CAP);
-	mtu->is_u3_ip = !!SSUSB_IP_DEV_U3_PORT_NUM(cap_dev);
+	if (mtu->max_speed <= USB_SPEED_HIGH)
+		mtu->is_u3_ip = 0;
+	else
+		mtu->is_u3_ip = !!SSUSB_IP_DEV_U3_PORT_NUM(cap_dev);
 
 	dev_info(mtu->dev, "IP version 0x%x(%s IP)\n", mtu->hw_version,
 		mtu->is_u3_ip ? "U3" : "U2");
diff --git a/drivers/usb/mtu3/mtu3_dr.c b/drivers/usb/mtu3/mtu3_dr.c
index ac60e9c8564e..7660d107e5bc 100644
--- a/drivers/usb/mtu3/mtu3_dr.c
+++ b/drivers/usb/mtu3/mtu3_dr.c
@@ -401,7 +401,7 @@ void ssusb_set_force_mode(struct ssusb_mtk *ssusb,
 		break;
 	case MTU3_DR_FORCE_HOST:
 		value |= SSUSB_U2_PORT_FORCE_IDDIG;
-		value &= ~SSUSB_U2_PORT_RG_IDDIG;
+		value &= ~(SSUSB_U2_PORT_RG_IDDIG | SSUSB_U2_PORT_OTG_SEL);
 		break;
 	case MTU3_DR_FORCE_NONE:
 		value &= ~(SSUSB_U2_PORT_FORCE_IDDIG | SSUSB_U2_PORT_RG_IDDIG);
diff --git a/drivers/usb/mtu3/mtu3_host.c b/drivers/usb/mtu3/mtu3_host.c
index c871b94f3e6f..6f9cf64fe7bb 100644
--- a/drivers/usb/mtu3/mtu3_host.c
+++ b/drivers/usb/mtu3/mtu3_host.c
@@ -29,6 +29,17 @@
 #define SSC_IP_SLEEP_EN	BIT(4)
 #define SSC_SPM_INT_EN		BIT(1)
 
+/* mt8183 etc */
+#define PERI_USB_WK_CTRL0		0x400
+#define SSUSB_INST_DP_CDDEBOUNCE	(0xf << 26)
+#define SSUSB_INST_DM_CDDEBOUNCE	(0xf << 22)
+#define SSUSB_INST_DP_CDEN		BIT(21)
+#define SSUSB_INST_DM_CDEN		BIT(20)
+#define SSUSB_INST_DP_SPM_RISE_ENABLE	BIT(19)
+#define SSUSB_INST_DP_SPM_FALL_ENABLE	BIT(18)
+#define SSUSB_INST_DM_SPM_RISE_ENABLE	BIT(17)
+#define SSUSB_INST_DM_SPM_FALL_ENABLE	BIT(16)
+
 enum ssusb_uwk_vers {
 	SSUSB_UWK_V1 = 1,
 	SSUSB_UWK_V2,
@@ -59,6 +70,22 @@ static void ssusb_wakeup_ip_sleep_set(struct ssusb_mtk *ssusb, bool enable)
 	regmap_update_bits(ssusb->uwk, reg, msk, val);
 }
 
+static void ssusb_wakeup_dm_set(struct ssusb_mtk *ssusb, bool enable)
+{
+	u32 tmp;
+
+	regmap_read(ssusb->uwk, PERI_USB_WK_CTRL0, &tmp);
+	if (enable) {
+		tmp |= SSUSB_INST_DM_SPM_RISE_ENABLE;
+		tmp |= SSUSB_INST_DM_CDDEBOUNCE;
+		tmp |= SSUSB_INST_DM_CDEN;
+	} else
+		tmp &= ~SSUSB_INST_DM_CDEN;
+
+	regmap_write(ssusb->uwk, PERI_USB_WK_CTRL0, tmp);
+	regmap_read(ssusb->uwk, PERI_USB_WK_CTRL0, &tmp);
+}
+
 int ssusb_wakeup_of_property_parse(struct ssusb_mtk *ssusb,
 				struct device_node *dn)
 {
@@ -87,8 +114,10 @@ int ssusb_wakeup_of_property_parse(struct ssusb_mtk *ssusb,
 
 void ssusb_wakeup_set(struct ssusb_mtk *ssusb, bool enable)
 {
-	if (ssusb->uwk_en)
+	if (ssusb->uwk_en) {
 		ssusb_wakeup_ip_sleep_set(ssusb, enable);
+		ssusb_wakeup_dm_set(ssusb, enable);
+	}
 }
 
 static void host_ports_num_get(struct ssusb_mtk *ssusb)
diff --git a/include/dt-bindings/clock/mt8183-clk.h b/include/dt-bindings/clock/mt8183-clk.h
index 0046506eb24c..bf133a5a8848 100644
--- a/include/dt-bindings/clock/mt8183-clk.h
+++ b/include/dt-bindings/clock/mt8183-clk.h
@@ -284,6 +284,10 @@
 #define CLK_INFRA_FBIST2FPC		100
 #define CLK_INFRA_NR_CLK		101
 
+/* PERICFG */
+#define CLK_PERIAXI                     0
+#define CLK_PERI_NR_CLK                 1
+
 /* MFGCFG */
 #define CLK_MFG_BG3D			0
 #define CLK_MFG_NR_CLK			1
diff --git a/include/soc/mediatek/emi.h b/include/soc/mediatek/emi.h
new file mode 100644
index 000000000000..83bdaeb6840b
--- /dev/null
+++ b/include/soc/mediatek/emi.h
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: GPL-2.0  */
+/*
+ * Copyright (c) 2015-2016 MediaTek Inc.
+ * Author: Xi Chen <xixi.chen@mediatek.com>
+ */
+
+#ifndef _MTK_EMI_H_
+#define _MTK_EMI_H_
+
+#define MAX_CH		2
+#define MAX_RK		2
+
+struct emi_info_t {
+	unsigned int dram_type;
+	unsigned int ch_num;
+	unsigned int rk_num;
+	unsigned int rank_size[MAX_RK];
+};
+
+/*****************************************************************************
+ *  Macro Definiations
+ *****************************************************************************/
+#define EMI_REG_BASE                (0x10219000)
+#define EMI_REG_BASE_MAPPED         (emi->cen_emi_base)
+
+#define EMI_MDCT                    (EMI_REG_BASE_MAPPED + 0x078)
+#define EMI_MDCT_2ND                (EMI_REG_BASE_MAPPED + 0x07C)
+
+#define EMI_ARBA                    (EMI_REG_BASE_MAPPED + 0x100)
+#define EMI_ARBB                    (EMI_REG_BASE_MAPPED + 0x108)
+#define EMI_ARBC                    (EMI_REG_BASE_MAPPED + 0x110)
+#define EMI_ARBD                    (EMI_REG_BASE_MAPPED + 0x118)
+#define EMI_ARBE                    (EMI_REG_BASE_MAPPED + 0x120)
+#define EMI_ARBF                    (EMI_REG_BASE_MAPPED + 0x128)
+#define EMI_ARBG                    (EMI_REG_BASE_MAPPED + 0x130)
+#define EMI_ARBH                    (EMI_REG_BASE_MAPPED + 0x138)
+
+#define EMI_BMEN                    (EMI_REG_BASE_MAPPED + 0x400)
+#define EMI_BCNT                    (EMI_REG_BASE_MAPPED + 0x408)
+#define EMI_TACT                    (EMI_REG_BASE_MAPPED + 0x410)
+#define EMI_TSCT                    (EMI_REG_BASE_MAPPED + 0x418)
+#define EMI_WACT                    (EMI_REG_BASE_MAPPED + 0x420)
+#define EMI_WSCT                    (EMI_REG_BASE_MAPPED + 0x428)
+#define EMI_BACT                    (EMI_REG_BASE_MAPPED + 0x430)
+#define EMI_BSCT                    (EMI_REG_BASE_MAPPED + 0x438)
+#define EMI_MSEL                    (EMI_REG_BASE_MAPPED + 0x440)
+#define EMI_TSCT2                   (EMI_REG_BASE_MAPPED + 0x448)
+#define EMI_TSCT3                   (EMI_REG_BASE_MAPPED + 0x450)
+#define EMI_WSCT2                   (EMI_REG_BASE_MAPPED + 0x458)
+#define EMI_WSCT3                   (EMI_REG_BASE_MAPPED + 0x460)
+#define EMI_WSCT4                   (EMI_REG_BASE_MAPPED + 0x464)
+#define EMI_MSEL2                   (EMI_REG_BASE_MAPPED + 0x468)
+
+#define EMI_BMEN2                   (EMI_REG_BASE_MAPPED + 0x4E8)
+
+#define EMI_BMRW0                   (EMI_REG_BASE_MAPPED + 0x4F8)
+
+#define EMI_TTYPE1                  (EMI_REG_BASE_MAPPED + 0x500)
+#define EMI_TTYPE17                 (EMI_REG_BASE_MAPPED + 0x580)
+
+#define EMI_BWVL                    (EMI_REG_BASE_MAPPED + 0x7D0)
+#define EMI_BWVL_2ND                (EMI_REG_BASE_MAPPED + 0x7D4)
+#define EMI_BWVL_3RD                (EMI_REG_BASE_MAPPED + 0x7D8)
+#define EMI_BWVL_4TH                (EMI_REG_BASE_MAPPED + 0x7DC)
+#define EMI_BWVL_5TH                (EMI_REG_BASE_MAPPED + 0x7E0)
+
+#define EMI_CH0_REG_BASE            (0x1022D000)
+#define EMI_CH0_REG_BASE_MAPPED     (emi->chn_emi_base[0])
+#define EMI_CH0_DRS_ST2             (EMI_CH0_REG_BASE_MAPPED + 0x17C)
+#define EMI_CH0_DRS_ST3             (EMI_CH0_REG_BASE_MAPPED + 0x180)
+#define EMI_CH0_DRS_ST4             (EMI_CH0_REG_BASE_MAPPED + 0x184)
+
+#define EMI_CH1_REG_BASE            (0x10235000)
+#define EMI_CH1_REG_BASE_MAPPED     (emi->chn_emi_base[1])
+#define EMI_CH1_DRS_ST2             (EMI_CH1_REG_BASE_MAPPED + 0x17C)
+#define EMI_CH1_DRS_ST3             (EMI_CH1_REG_BASE_MAPPED + 0x180)
+#define EMI_CH1_DRS_ST4             (EMI_CH1_REG_BASE_MAPPED + 0x184)
+
+/*
+ * DEFAULT_VALUE
+ */
+#define EMI_BMEN_DEFAULT_VALUE    (0x00FF0000)
+#define EMI_BMEN2_DEFAULT_VALUE   (0x02000000)
+#define EMI_BMRW0_DEFAULT_VALUE   (0xFFFFFFFF)
+#define EMI_MSEL_DEFAULT_VALUE    (0x00030024)
+#define EMI_MSEL2_DEFAULT_VALUE   (0x000000C0)
+#define BC_OVERRUN                (0x00000100)
+
+/* EMI_BMEN */
+#define BUS_MON_EN          BIT(0)
+#define BUS_MON_PAUSE       BIT(1)
+#define BUS_MON_IDLE        BIT(3)
+
+#define MAX_DRAM_CH_NUM     (2)
+#define DRAM_RANK_NUM       (2)
+#define DRAM_PDIR_NUM       (8)
+#define EMI_TTYPE_NUM       (21)
+#define EMI_TSCT_NUM        (3)
+#define EMI_MDCT_NUM        (2)
+#define EMI_DRS_ST_NUM      (3)
+#define EMI_BW_LIMIT_NUM    (8)
+
+#define DRAMC_CG_SHIFT      (9)
+
+#define EMI_IDX_SIZE        (1024)
+
+#define EMI_BWVL_UNIT       (271)
+
+#define MBW_BUF_LEN         (0x800000)
+#define DATA_CNT_PER_BLK    (35)
+#define BLK_CNT_PER_BUF     (0x800)
+
+/* public apis */
+unsigned long long emi_get_max_bw(void);
+
+#endif
diff --git a/include/soc/mediatek/smi.h b/include/soc/mediatek/smi.h
index 7a8d87051ee8..609397d69602 100644
--- a/include/soc/mediatek/smi.h
+++ b/include/soc/mediatek/smi.h
@@ -24,26 +24,6 @@ struct mtk_smi_iommu {
 	struct mtk_smi_larb_iommu larb_imu[MTK_LARB_NR_MAX];
 };
 
-/*
- * mtk_smi_larb_get: Enable the power domain and clocks for this local arbiter.
- *                   It also initialize some basic setting(like iommu).
- * mtk_smi_larb_put: Disable the power domain and clocks for this local arbiter.
- * Both should be called in non-atomic context.
- *
- * Returns 0 if successful, negative on failure.
- */
-int mtk_smi_larb_get(struct device *larbdev);
-void mtk_smi_larb_put(struct device *larbdev);
-
-#else
-
-static inline int mtk_smi_larb_get(struct device *larbdev)
-{
-	return 0;
-}
-
-static inline void mtk_smi_larb_put(struct device *larbdev) { }
-
 #endif
 
 #endif
diff --git a/sound/soc/mediatek/mt8183/mt8183-mt6358-ts3a227-max98357.c b/sound/soc/mediatek/mt8183/mt8183-mt6358-ts3a227-max98357.c
index 34c9102d56af..928687771b49 100644
--- a/sound/soc/mediatek/mt8183/mt8183-mt6358-ts3a227-max98357.c
+++ b/sound/soc/mediatek/mt8183/mt8183-mt6358-ts3a227-max98357.c
@@ -299,8 +299,6 @@ static struct snd_soc_card mt8183_mt6358_ts3a227_max98357_card = {
 	.owner = THIS_MODULE,
 	.dai_link = mt8183_mt6358_ts3a227_max98357_dai_links,
 	.num_links = ARRAY_SIZE(mt8183_mt6358_ts3a227_max98357_dai_links),
-	.aux_dev = &mt8183_mt6358_ts3a227_max98357_headset_dev,
-	.num_aux_devs = 1,
 };
 
 static int
@@ -360,10 +358,9 @@ mt8183_mt6358_ts3a227_max98357_dev_probe(struct platform_device *pdev)
 	mt8183_mt6358_ts3a227_max98357_headset_dev.codec_of_node =
 		of_parse_phandle(pdev->dev.of_node,
 				 "mediatek,headset-codec", 0);
-	if (!mt8183_mt6358_ts3a227_max98357_headset_dev.codec_of_node) {
-		dev_err(&pdev->dev,
-			"Property 'mediatek,headset-codec' missing/invalid\n");
-		return -EINVAL;
+	if (mt8183_mt6358_ts3a227_max98357_headset_dev.codec_of_node) {
+		card->aux_dev = &mt8183_mt6358_ts3a227_max98357_headset_dev;
+		card->num_aux_devs = 1;
 	}
 
 	default_pins =
