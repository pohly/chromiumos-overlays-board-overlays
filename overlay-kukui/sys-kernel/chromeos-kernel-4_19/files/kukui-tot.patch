diff --git a/Documentation/devicetree/bindings/display/bridge/ite,it6505.txt b/Documentation/devicetree/bindings/display/bridge/ite,it6505.txt
new file mode 100644
index 000000000000..c3506ac4c980
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/bridge/ite,it6505.txt
@@ -0,0 +1,30 @@
+iTE it6505 DP bridge bindings
+
+Required properties:
+        - compatible: "ite,it6505"
+        - reg: i2c address of the bridge
+        - ovdd-supply: I/O voltage
+        - pwr18-supply: Core voltage
+        - interrupts: interrupt specifier of INT pin
+        - reset-gpios: gpio specifier of RESET pin
+
+Example:
+	it6505dptx: it6505dptx@5c {
+                compatible = "ite,it6505";
+                status = "okay";
+                interrupt-parent = <&pio>;
+                interrupts = <152 IRQ_TYPE_EDGE_RISING 152 0>;
+                reg = <0x5c>;
+                pinctrl-names = "default";
+                pinctrl-0 = <&it6505_pins>;
+                ovdd-supply = <&mt6358_vsim1_reg>;
+                pwr18-supply = <&it6505_pp18_reg>;
+                reset-gpios = <&pio 179 1>;
+                hpd-gpios = <&pio 9 0>;
+                extcon = <&usbc_extcon>;
+                port {
+                        it6505_in: endpoint {
+                                remote-endpoint = <&dpi_out>;
+                        };
+                };
+        };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,disp.txt b/Documentation/devicetree/bindings/display/mediatek/mediatek,disp.txt
index 5467470c7b8a..bc8e30c20c64 100644
--- a/Documentation/devicetree/bindings/display/mediatek/mediatek,disp.txt
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,disp.txt
@@ -59,8 +59,6 @@ Required properties (DMA function blocks):
 	"mediatek,<chip>-disp-rdma"
 	"mediatek,<chip>-disp-wdma"
   the supported chips are mt2701 and mt8173.
-- larb: Should contain a phandle pointing to the local arbiter device as defined
-  in Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.txt
 - iommus: Should point to the respective IOMMU block with master port as
   argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
   for details.
@@ -87,7 +85,6 @@ ovl0: ovl@1400c000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_OVL0>;
 	iommus = <&iommu M4U_PORT_DISP_OVL0>;
-	mediatek,larb = <&larb0>;
 };
 
 ovl1: ovl@1400d000 {
@@ -97,7 +94,6 @@ ovl1: ovl@1400d000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_OVL1>;
 	iommus = <&iommu M4U_PORT_DISP_OVL1>;
-	mediatek,larb = <&larb4>;
 };
 
 rdma0: rdma@1400e000 {
@@ -107,7 +103,6 @@ rdma0: rdma@1400e000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_RDMA0>;
 	iommus = <&iommu M4U_PORT_DISP_RDMA0>;
-	mediatek,larb = <&larb0>;
 };
 
 rdma1: rdma@1400f000 {
@@ -117,7 +112,6 @@ rdma1: rdma@1400f000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_RDMA1>;
 	iommus = <&iommu M4U_PORT_DISP_RDMA1>;
-	mediatek,larb = <&larb4>;
 };
 
 rdma2: rdma@14010000 {
@@ -127,7 +121,6 @@ rdma2: rdma@14010000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_RDMA2>;
 	iommus = <&iommu M4U_PORT_DISP_RDMA2>;
-	mediatek,larb = <&larb4>;
 };
 
 wdma0: wdma@14011000 {
@@ -137,7 +130,6 @@ wdma0: wdma@14011000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_WDMA0>;
 	iommus = <&iommu M4U_PORT_DISP_WDMA0>;
-	mediatek,larb = <&larb0>;
 };
 
 wdma1: wdma@14012000 {
@@ -147,7 +139,6 @@ wdma1: wdma@14012000 {
 	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 	clocks = <&mmsys CLK_MM_DISP_WDMA1>;
 	iommus = <&iommu M4U_PORT_DISP_WDMA1>;
-	mediatek,larb = <&larb4>;
 };
 
 color0: color@14013000 {
diff --git a/Documentation/devicetree/bindings/media/i2c/ov02a10.txt b/Documentation/devicetree/bindings/media/i2c/ov02a10.txt
new file mode 100644
index 000000000000..d40aa879d8b0
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/i2c/ov02a10.txt
@@ -0,0 +1,43 @@
+* Omnivision OV02A10 MIPI CSI-2 sensor
+
+Required Properties:
+- compatible: shall be "ovti,ov02a10"
+- clocks: reference to the xvclk input clock
+- clock-names: shall be "xvclk"
+- avdd-supply: Analog voltage supply, 2.8 volts
+- dovdd-supply: Digital I/O voltage supply, 1.8 volts
+- dvdd-supply: Digital core voltage supply, 1.8 volts
+- reset-gpios: Low active reset gpio
+
+The device node shall contain one 'port' child node with an
+'endpoint' subnode for its digital output video port,
+in accordance with the video interface bindings defined in
+Documentation/devicetree/bindings/media/video-interfaces.txt.
+The endpoint optional property 'data-lanes' shall be "<1>".
+
+Example:
+&i2c4 {
+	ov02a10: camera-sensor@3d {
+		compatible = "ovti,ov02a10";
+		reg = <0x3d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&camera_pins_cam1_mclk_on>;
+
+		clocks = <&topckgen CLK_TOP_MUX_CAMTG2>,
+			<&topckgen CLK_TOP_UNIVP_192M_D8>;
+		clock-names = "xvclk", "freq_mux";
+
+		avdd-supply = <&mt6358_vcama1_reg>;
+		dvdd-supply = <&mt6358_vcn18_reg>;
+		dovdd-supply = <&mt6358_vcamio_reg>;
+		pwdn-gpios = <&pio 107 1>;
+		reset-gpios = <&pio 109 1>;
+
+		port {
+		   ov02a10_core: endpoint {
+		       remote-endpoint = <&ov02a10_0>;
+			   data-lanes = <1>;
+			};
+		};
+	};
+};
diff --git a/Documentation/devicetree/bindings/media/mediatek,camisp.txt b/Documentation/devicetree/bindings/media/mediatek,camisp.txt
new file mode 100644
index 000000000000..50a8b4d9ac8e
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/mediatek,camisp.txt
@@ -0,0 +1,57 @@
+* Mediatek Image Signal Processor Pass 1 (ISP P1)
+
+The Pass 1 unit of Mediatek's camera ISP system grabs the sensor data out
+from the sensor interface, applies ISP effects from tuning data and outputs
+the image data and statistics data to DRAM. Furthermore, Pass 1 unit has
+the ability to output two different resolutions frames at the same time to
+increase the performance of the camera application.
+
+Required properties:
+- compatible: Must be "mediatek,mt8183-camisp" for MT8183.
+- reg: Physical base address of the camera function block registers and
+  length of memory mapped region. Must contain an entry for each entry
+  in reg-names.
+- reg-names: Must include the following entries:
+  "cam_sys": Camsys base function block
+  "cam_uni": Camera UNI function block
+  "cam_a": Single camera ISP P1 hardware module A
+  "cam_b": Single camera ISP P1 hardware module B
+- interrupts: Interrupt number to the CPU.
+- iommus: Shall point to the respective IOMMU block with master port
+  as argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
+  for details.
+- clocks: A list of phandle and clock specifier pairs as listed
+  in clock-names property, see
+  Documentation/devicetree/bindings/clock/clock-bindings.txt for details.
+- clock-names: Must be "camsys_cam_cgpdn" and "camsys_camtg_cgpdn".
+- mediatek,larb: Must contain the local arbiters in the current SoCs, see
+  Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.txt
+  for details.
+- mediatek,scp : The node of system control processor (SCP), see
+  Documentation/devicetree/bindings/remoteproc/mtk,scp.txt for details.
+
+Example:
+SoC specific DT entry:
+
+		camisp: camisp@1a000000 {
+			compatible = "mediatek,mt8183-camisp", "syscon";
+			reg = <0 0x1a000000 0 0x1000>,
+			      <0 0x1a003000 0 0x1000>,
+			      <0 0x1a004000 0 0x2000>,
+			      <0 0x1a006000 0 0x2000>;
+			reg-names = "cam_sys",
+				    "cam_uni",
+				    "cam_a",
+				    "cam_b";
+			interrupts = <GIC_SPI 253 IRQ_TYPE_LEVEL_LOW>,
+				     <GIC_SPI 254 IRQ_TYPE_LEVEL_LOW>,
+				     <GIC_SPI 255 IRQ_TYPE_LEVEL_LOW>;
+			iommus = <&iommu M4U_PORT_CAM_IMGO>;
+			clocks = <&camsys CLK_CAM_CAM>,
+				 <&camsys CLK_CAM_CAMTG>;
+			clock-names = "camsys_cam_cgpdn",
+				      "camsys_camtg_cgpdn";
+			mediatek,larb = <&larb3>,
+					<&larb6>;
+			mediatek,scp = <&scp>;
+		};
\ No newline at end of file
diff --git a/Documentation/devicetree/bindings/media/mediatek,mt8183-dip.txt b/Documentation/devicetree/bindings/media/mediatek,mt8183-dip.txt
new file mode 100644
index 000000000000..0e1994bf82f0
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/mediatek,mt8183-dip.txt
@@ -0,0 +1,35 @@
+* Mediatek Digital Image Processor (DIP)
+
+Digital Image Processor (DIP) unit in Mediatek ISP system is responsible for
+image content adjustment according to the tuning parameters. DIP can process
+the image form memory buffer and output the processed image to multiple output
+buffers. Furthermore, it can support demosaicing and noise reduction on the
+images.
+
+Required properties:
+- compatible: "mediatek,mt8183-dip"
+- reg: Physical base address and length of the function block register space
+- interrupts: interrupt number to the cpu
+- iommus: should point to the respective IOMMU block with master port as
+  argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
+  for details.
+- mediatek,larb: must contain the local arbiters in the current Socs, see
+  Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.txt
+  for details.
+- clocks: must contain the local arbiters 5 (LARB5) and DIP clock
+- clock-names: must contain DIP_CG_IMG_LARB5 and DIP_CG_IMG_DIP
+
+Example:
+	dip: dip@15022000 {
+		compatible = "mediatek,mt8183-dip";
+		mediatek,larb = <&larb5>;
+		mediatek,mdp3 = <&mdp_rdma0>;
+		mediatek,vpu = <&vpu>;
+		iommus = <&iommu M4U_PORT_CAM_IMGI>;
+		reg = <0 0x15022000 0 0x6000>;
+		interrupts = <GIC_SPI 268 IRQ_TYPE_LEVEL_LOW>;
+		clocks = <&imgsys CLK_IMG_LARB5>,
+			 <&imgsys CLK_IMG_DIP>;
+		clock-names = "DIP_CG_IMG_LARB5",
+			      "DIP_CG_IMG_DIP";
+	};
diff --git a/Documentation/devicetree/bindings/media/mediatek,mt8183-fd.txt b/Documentation/devicetree/bindings/media/mediatek,mt8183-fd.txt
new file mode 100644
index 000000000000..97c12fd93e7e
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/mediatek,mt8183-fd.txt
@@ -0,0 +1,34 @@
+* Mediatek Face Detection Unit (FD)
+
+Face Detection (FD) unit is a typical memory-to-memory HW device.
+It provides hardware accelerated face detection function, and it
+is able to detect different poses of faces. FD will writre result
+of detected face into memory as output.
+
+Required properties:
+- compatible: "mediatek,mt8183-fd"
+- reg: Physical base address and length of the function block register space
+- interrupts: interrupt number to the cpu.
+- iommus: should point to the respective IOMMU block with master port as
+  argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
+  for details.
+- mediatek,larb: must contain the local arbiters in the current Socs, see
+  Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.txt
+  for details.
+- clocks : must contain the FDVT clock
+- clock-names: must contain FD_CLK_IMG_FD
+
+Example:
+	fd:fd@1502b000 {
+		compatible = "mediatek,mt8183-fd";
+		mediatek,larb = <&larb5>;
+		mediatek,scp = <&scp>;
+		iommus = <&iommu M4U_PORT_CAM_FDVT_RP>,
+			 <&iommu M4U_PORT_CAM_FDVT_WR>,
+			 <&iommu M4U_PORT_CAM_FDVT_RB>;
+		reg = <0 0x1502b000 0 0x1000>;
+		interrupts = <GIC_SPI 269 IRQ_TYPE_LEVEL_LOW>;
+		clocks = <&imgsys CLK_IMG_FDVT>;
+		clock-names = "FD_CLK_IMG_FD";
+	};
+
diff --git a/Documentation/devicetree/bindings/media/mediatek-jpeg-decoder.txt b/Documentation/devicetree/bindings/media/mediatek-jpeg-decoder.txt
index 3813947b4d4f..c9f89132830c 100644
--- a/Documentation/devicetree/bindings/media/mediatek-jpeg-decoder.txt
+++ b/Documentation/devicetree/bindings/media/mediatek-jpeg-decoder.txt
@@ -14,9 +14,6 @@ Required properties:
 - clock-names: must contain "jpgdec-smi" and "jpgdec".
 - power-domains: a phandle to the power domain, see
   Documentation/devicetree/bindings/power/power_domain.txt for details.
-- mediatek,larb: must contain the local arbiters in the current Socs, see
-  Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.txt
-  for details.
 - iommus: should point to the respective IOMMU block with master port as
   argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
   for details.
@@ -31,7 +28,6 @@ Example:
 		clock-names = "jpgdec-smi",
 			      "jpgdec";
 		power-domains = <&scpsys MT2701_POWER_DOMAIN_ISP>;
-		mediatek,larb = <&larb2>;
 		iommus = <&iommu MT2701_M4U_PORT_JPGDEC_WDMA>,
 			 <&iommu MT2701_M4U_PORT_JPGDEC_BSDMA>;
 	};
diff --git a/Documentation/devicetree/bindings/media/mediatek-mdp.txt b/Documentation/devicetree/bindings/media/mediatek-mdp.txt
index 0d03e3ae2be2..df69c5a06250 100644
--- a/Documentation/devicetree/bindings/media/mediatek-mdp.txt
+++ b/Documentation/devicetree/bindings/media/mediatek-mdp.txt
@@ -27,9 +27,6 @@ Required properties (DMA function blocks, child node):
 - iommus: should point to the respective IOMMU block with master port as
   argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
   for details.
-- mediatek,larb: must contain the local arbiters in the current Socs, see
-  Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.txt
-  for details.
 
 Example:
 	mdp_rdma0: rdma@14001000 {
@@ -40,7 +37,6 @@ Example:
 			 <&mmsys CLK_MM_MUTEX_32K>;
 		power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 		iommus = <&iommu M4U_PORT_MDP_RDMA0>;
-		mediatek,larb = <&larb0>;
 		mediatek,vpu = <&vpu>;
 	};
 
@@ -51,7 +47,6 @@ Example:
 			 <&mmsys CLK_MM_MUTEX_32K>;
 		power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 		iommus = <&iommu M4U_PORT_MDP_RDMA1>;
-		mediatek,larb = <&larb4>;
 	};
 
 	mdp_rsz0: rsz@14003000 {
@@ -81,7 +76,6 @@ Example:
 		clocks = <&mmsys CLK_MM_MDP_WDMA>;
 		power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 		iommus = <&iommu M4U_PORT_MDP_WDMA>;
-		mediatek,larb = <&larb0>;
 	};
 
 	mdp_wrot0: wrot@14007000 {
@@ -90,7 +84,6 @@ Example:
 		clocks = <&mmsys CLK_MM_MDP_WROT0>;
 		power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 		iommus = <&iommu M4U_PORT_MDP_WROT0>;
-		mediatek,larb = <&larb0>;
 	};
 
 	mdp_wrot1: wrot@14008000 {
@@ -99,5 +92,4 @@ Example:
 		clocks = <&mmsys CLK_MM_MDP_WROT1>;
 		power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
 		iommus = <&iommu M4U_PORT_MDP_WROT1>;
-		mediatek,larb = <&larb4>;
 	};
diff --git a/Documentation/devicetree/bindings/media/mediatek-seninf.txt b/Documentation/devicetree/bindings/media/mediatek-seninf.txt
new file mode 100644
index 000000000000..979063a485e8
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/mediatek-seninf.txt
@@ -0,0 +1,31 @@
+* Mediatek seninf MIPI-CSI2 host driver
+
+Seninf MIPI-CSI2 host driver is a HW camera interface controller. It support a widely adopted,
+simple, high-speed protocol primarily intended for point-to-point image and video
+transmission between cameras and host devices.
+
+Required properties:
+  - compatible: "mediatek,mt8183-seninf"
+  - reg: Must contain an entry for each entry in reg-names.
+  - reg-names: Must include the following entries:
+    "base_reg": seninf registers base
+    "rx_reg": Rx analog registers base
+  - interrupts: interrupt number to the cpu.
+  - clocks : clock name from clock manager
+  - clock-names: must be CLK_CAM_SENINF and CLK_TOP_MUX_SENINF.
+    It is the clocks of seninf
+
+Example:
+	seninf: seninf@1a040000 {
+		compatible = "mediatek,mt8183-seninf";
+		reg = <0 0x1a040000 0 0x8000>,
+		      <0 0x11C80000 0 0x6000>;
+		reg-names = "base_reg", "rx_reg";
+		interrupts = <GIC_SPI 251 IRQ_TYPE_LEVEL_LOW>;
+		power-domains = <&scpsys MT8183_POWER_DOMAIN_CAM>;
+		clocks =
+				<&camsys CLK_CAM_SENINF>, <&topckgen CLK_TOP_MUX_SENINF>;
+		clock-names =
+			"CLK_CAM_SENINF", "CLK_TOP_MUX_SENINF";
+	}
+
diff --git a/Documentation/devicetree/bindings/media/mediatek-vcodec.txt b/Documentation/devicetree/bindings/media/mediatek-vcodec.txt
index b6b5dde6abd8..5c9ee6af3cfa 100644
--- a/Documentation/devicetree/bindings/media/mediatek-vcodec.txt
+++ b/Documentation/devicetree/bindings/media/mediatek-vcodec.txt
@@ -9,7 +9,6 @@ Required properties:
 - reg : Physical base address of the video codec registers and length of
   memory mapped region.
 - interrupts : interrupt number to the cpu.
-- mediatek,larb : must contain the local arbiters in the current Socs.
 - clocks : list of clock specifiers, corresponding to entries in
   the clock-names property.
 - clock-names: encoder must contain "venc_sel_src", "venc_sel",,
@@ -39,7 +38,6 @@ vcodec_dec: vcodec@16000000 {
           <0 0x16027800 0 0x800>,   /*VP8_VL*/
           <0 0x16028400 0 0x400>;   /*VP9_VD*/
     interrupts = <GIC_SPI 204 IRQ_TYPE_LEVEL_LOW>;
-    mediatek,larb = <&larb1>;
     iommus = <&iommu M4U_PORT_HW_VDEC_MC_EXT>,
              <&iommu M4U_PORT_HW_VDEC_PP_EXT>,
              <&iommu M4U_PORT_HW_VDEC_AVC_MV_EXT>,
@@ -83,8 +81,6 @@ vcodec_dec: vcodec@16000000 {
           <0 0x19002000 0 0x1000>;    /*VENC_LT_SYS*/
     interrupts = <GIC_SPI 198 IRQ_TYPE_LEVEL_LOW>,
 		 <GIC_SPI 202 IRQ_TYPE_LEVEL_LOW>;
-    mediatek,larb = <&larb3>,
-		    <&larb5>;
     iommus = <&iommu M4U_PORT_VENC_RCPU>,
              <&iommu M4U_PORT_VENC_REC>,
              <&iommu M4U_PORT_VENC_BSDMA>,
diff --git a/Documentation/devicetree/bindings/media/mediatek-vpu.txt b/Documentation/devicetree/bindings/media/mediatek-vpu.txt
index 2a5bac37f9a2..015123250b82 100644
--- a/Documentation/devicetree/bindings/media/mediatek-vpu.txt
+++ b/Documentation/devicetree/bindings/media/mediatek-vpu.txt
@@ -4,7 +4,7 @@ Video Processor Unit is a HW video controller. It controls HW Codec including
 H.264/VP8/VP9 Decode, H.264/VP8 Encode and Image Processor (scale/rotate/color convert).
 
 Required properties:
-  - compatible: "mediatek,mt8173-vpu"
+  - compatible:"mediatek,mt8173-vpu", "mediatek,mt8183-vpu", "mediatek,reserve-memory-vpu_share"
   - reg: Must contain an entry for each entry in reg-names.
   - reg-names: Must include the following entries:
     "tcm": tcm base
diff --git a/Documentation/devicetree/bindings/memory-controllers/mediatek,emi.txt b/Documentation/devicetree/bindings/memory-controllers/mediatek,emi.txt
new file mode 100644
index 000000000000..a19e3b39ba66
--- /dev/null
+++ b/Documentation/devicetree/bindings/memory-controllers/mediatek,emi.txt
@@ -0,0 +1,19 @@
+EMI (External Memory Interface)
+
+Required properties:
+- compatible : must be one of :
+	"mediatek,mt8183-emi"
+- reg : the register and size of the EMI block.
+- interrupts : includes MPU, CGM, ELM.
+
+Example:
+	emi@10219000 {
+	compatible = "mediatek,mt8183-emi";
+	reg = <0 0x10219000 0 0x1000>, /* CEN EMI */
+		  <0 0x10226000 0 0x1000>, /* EMI MPU */
+		  <0 0x1022d000 0 0x1000>, /* CHA EMI */
+		  <0 0x10235000 0 0x1000>; /* CHB EMI */
+	interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_LOW>, /* MPU */
+			 <GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>, /* CGM */
+			 <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>; /* ELM */
+};
diff --git a/Documentation/devicetree/bindings/reserved-memory/mediatek,reserve-memory-cam-smem.txt b/Documentation/devicetree/bindings/reserved-memory/mediatek,reserve-memory-cam-smem.txt
new file mode 100644
index 000000000000..65a967cff91e
--- /dev/null
+++ b/Documentation/devicetree/bindings/reserved-memory/mediatek,reserve-memory-cam-smem.txt
@@ -0,0 +1,42 @@
+Mediatek ISP Pass 1 Shared Memory binding
+
+This binding describes the shared memory, which serves the purpose of
+describing the shared memory region used to exchange data between Pass 1
+unit of Image Signal Processor (ISP) and the co-processor in Mediatek
+SoCs.
+
+The co-processor doesn't have the iommu so we need to use the physical
+address to access the shared buffer in the firmware.
+
+The Pass 1 unit of ISP can access memory through the iommu so it
+uses the dma address to access the memory region.
+(See iommu/mediatek,iommu.txt for the detailed description of Mediatek IOMMU)
+
+For additional details about reserved memory regions see reserved-memory.txt
+
+Required properties:
+
+- compatible: must be "mediatek,reserve-memory-cam-smem"
+
+- size: required for dynamic allocation. The unit is bytes.
+
+- alloc-range: required for dynamic allocation. The range must
+  between 0x40000000 and 0x100000000 due to the co-processer's
+  addressing limitation.
+
+Example:
+
+The following example shows the ISP Pass 1 shared memory setup for MT8183.
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		cam_mem_reserved: cam_mem_region {
+			compatible = "mediatek,reserve-memory-cam-smem";
+			size = <0 0x1400000>;
+			no-map;
+			alignment = <0 0x1000>;
+			alloc-ranges = <0 0x40000000 0 0x10000000>;
+		};
+	};
diff --git a/Documentation/devicetree/bindings/reserved-memory/mediatek,reserve-memory-dip_smem.txt b/Documentation/devicetree/bindings/reserved-memory/mediatek,reserve-memory-dip_smem.txt
new file mode 100644
index 000000000000..64c001b476b9
--- /dev/null
+++ b/Documentation/devicetree/bindings/reserved-memory/mediatek,reserve-memory-dip_smem.txt
@@ -0,0 +1,45 @@
+Mediatek DIP Shared Memory binding
+
+This binding describes the shared memory, which serves the purpose of
+describing the shared memory region used to exchange data between Digital
+Image Processing (DIP) and co-processor in Mediatek SoCs.
+
+The co-processor doesn't have the iommu so we need to use the physical
+address to access the shared buffer in the firmware.
+
+The Digital Image Processing (DIP) can access memory through mt8183 IOMMU so
+it can use dma address to access the memory region.
+(See iommu/mediatek,iommu.txt for the detailed description of Mediatek IOMMU)
+
+
+Required properties:
+
+- compatible: must be "mediatek,reserve-memory-dip_smem"
+
+- reg: required for static allocation (see reserved-memory.txt for
+  the detailed usage)
+
+- alloc-range: required for dynamic allocation. The range must
+  between 0x00000400 and 0x100000000 due to the co-processer's
+  addressing limitation
+
+- size: required for dynamic allocation. The unit is bytes.
+  If you want to enable the full feature of Digital Processing Unit,
+  you need 20 MB at least.
+
+
+Example:
+
+The following example shows the DIP shared memory setup for MT8183.
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		reserve-memory-dip_smem {
+			compatible = "mediatek,reserve-memory-dip_smem";
+			size = <0 0x1400000>;
+			alignment = <0 0x1000>;
+			alloc-ranges = <0 0x40000000 0 0x50000000>;
+		};
+	};
diff --git a/Documentation/devicetree/bindings/reserved-memory/mediatek,reserve-memory-fd_smem.txt b/Documentation/devicetree/bindings/reserved-memory/mediatek,reserve-memory-fd_smem.txt
new file mode 100644
index 000000000000..52ae5071e238
--- /dev/null
+++ b/Documentation/devicetree/bindings/reserved-memory/mediatek,reserve-memory-fd_smem.txt
@@ -0,0 +1,44 @@
+Mediatek FD Shared Memory binding
+
+This binding describes the shared memory, which serves the purpose of
+describing the shared memory region used to exchange data between Face
+Detection hardware (FD) and co-processor in Mediatek SoCs.
+
+The co-processor doesn't have the iommu so we need to use the physical
+address to access the shared buffer in the firmware.
+
+The Face Detection hardware (FD) can access memory through mt8183 IOMMU so
+it can use dma address to access the memory region.
+(See iommu/mediatek,iommu.txt for the detailed description of Mediatek IOMMU)
+
+
+Required properties:
+
+- compatible: must be "mediatek,reserve-memory-fd_smem"
+
+- reg: required for static allocation (see reserved-memory.txt for
+  the detailed usage)
+
+- alloc-range: required for dynamic allocation. The range must
+  between 0x00000400 and 0x100000000 due to the co-processer's
+  addressing limitation
+
+- size: required for dynamic allocation. The unit is bytes.
+  for Face Detection Unit, you need 1 MB at least.
+
+
+Example:
+
+The following example shows the FD shared memory setup for MT8183.
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		reserve-memory-fd_smem {
+			compatible = "mediatek,reserve-memory-fd_smem";
+			size = <0 0x00100000>;
+			alignment = <0 0x1000>;
+			alloc-ranges = <0 0x40000000 0 0x100000000>;
+		};
+	};
\ No newline at end of file
diff --git a/Documentation/devicetree/bindings/vendor-prefixes.txt b/Documentation/devicetree/bindings/vendor-prefixes.txt
index 2c3fc512e746..c088646f3f1e 100644
--- a/Documentation/devicetree/bindings/vendor-prefixes.txt
+++ b/Documentation/devicetree/bindings/vendor-prefixes.txt
@@ -184,6 +184,7 @@ iom	Iomega Corporation
 isee	ISEE 2007 S.L.
 isil	Intersil
 issi	Integrated Silicon Solutions Inc.
+ite	iTE Tech. Inc.
 itead	ITEAD Intelligent Systems Co.Ltd
 iwave  iWave Systems Technologies Pvt. Ltd.
 jdi	Japan Display Inc.
diff --git a/Documentation/media/uapi/v4l/pixfmt-mtb8.rst b/Documentation/media/uapi/v4l/pixfmt-mtb8.rst
new file mode 100644
index 000000000000..2337ccd66277
--- /dev/null
+++ b/Documentation/media/uapi/v4l/pixfmt-mtb8.rst
@@ -0,0 +1,49 @@
+.. -*- coding: utf-8; mode: rst -*-
+
+.. _V4L2-PIX-FMT-MTISP_B8:
+
+*******************************
+V4L2_PIX_FMT_MTISP_B8 ('MTB8')
+*******************************
+
+8-bit Packed Bayer formats.
+
+
+Description
+===========
+
+The four pixel formats are used by Mediatek ISP.
+This is a packed format, meaning all the data for a pixel lie
+next to each other in memory, with a depth of 8 bits per pixel.
+Each sample is stored in a byte.
+The least significant byte is stored at lower memory addresses (little-endian).
+The RGB byte order follows raw sRGB / Bayer format from sensor.
+Below is an example of conventional RGB byte order BGGR.
+
+**Byte Order.**
+Each cell is one byte.
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - start + 0:
+      - B\ :sub:`00`
+      - G\ :sub:`01`
+      - B\ :sub:`02`
+      - G\ :sub:`03`
+    * - start + 4:
+      - G\ :sub:`10`
+      - R\ :sub:`11`
+      - G\ :sub:`12`
+      - R\ :sub:`13`
+    * - start + 8:
+      - B\ :sub:`20`
+      - G\ :sub:`21`
+      - B\ :sub:`22`
+      - G\ :sub:`23`
+    * - start + 12:
+      - G\ :sub:`30`
+      - R\ :sub:`31`
+      - G\ :sub:`32`
+      - R\ :sub:`33`
\ No newline at end of file
diff --git a/Documentation/media/uapi/v4l/pixfmt-mtba.rst b/Documentation/media/uapi/v4l/pixfmt-mtba.rst
new file mode 100644
index 000000000000..ade51d5472b0
--- /dev/null
+++ b/Documentation/media/uapi/v4l/pixfmt-mtba.rst
@@ -0,0 +1,62 @@
+.. -*- coding: utf-8; mode: rst -*-
+
+.. _V4L2-PIX-FMT-MTISP_B10:
+
+*******************************
+V4L2_PIX_FMT_MTISP_B10 ('MTBA')
+*******************************
+
+10-bit Packed Bayer formats.
+
+
+Description
+===========
+
+The four pixel formats are used by Mediatek ISP.
+This is a packed format, meaning all the data for a pixel lie
+next to each other with no padding in memory, with a depth of 10 bits per pixel.
+The least significant byte is stored at lower memory addresses (little-endian).
+The RGB byte order follows raw sRGB / Bayer format from sensor.
+Below is an example of conventional RGB byte order BGGR.
+
+**Byte Order.**
+Each cell is one byte.
+
+pixels cross the byte boundary and have a ratio of 5 bytes for each 4 pixels.
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - start + 0:
+      - B\ :sub:`00low bits 7--0`
+      - G\ :sub:`01low bits 5--0` (bits 7--2) B\ :sub:`00high bits 9--8`\ (bits 1--0)
+    * - start + 2:
+      - B\ :sub:`02low bits 3--0`\ (bits 7--4) G\ :sub:`01high bits 9--6`\ (bits 3--0)
+      - G\ :sub:`03low bits 1--0`\ (bits 7--6) B\ :sub:`02high bits 9--4`\ (bits 5--0)
+    * - start + 4:
+      - G\ :sub:`03high bits 9--2`
+    * - start + 6:
+      - G\ :sub:`10low bits 7--0`
+      - R\ :sub:`11low bits 5--0`\ (bits 7--2) G\ :sub:`10high bits 9--8`\ (bits 1--0)
+    * - start + 8:
+      - G\ :sub:`12low bits 3--0`\ (bits 7--4) R\ :sub:`11high bits 9--6`\ (bits 3--0)
+      - R\ :sub:`13low bits 1--0`\ (bits 7--6) G\ :sub:`12high bits 9--4`\ (bits 5--0)
+    * - start + 10:
+      - R\ :sub:`13high bits 9--2`
+    * - start + 12:
+      - B\ :sub:`20low bits 7--0`
+      - G\ :sub:`21low bits 5--0`\ (bits 7--2) B\ :sub:`20high bits 9--8`\ (bits 1--0)
+    * - start + 14:
+      - B\ :sub:`22low bits 3--0`\ (bits 7--4) G\ :sub:`21high bits 9--6`\ (bits 3--0)
+      - G\ :sub:`23low bits 1--0`\ (bits 7--6) B\ :sub:`22high bits 9--4`\ (bits 5--0)
+    * - start + 16:
+      - G\ :sub:`23high bits 9--2`
+    * - start + 18:
+      - G\ :sub:`30low bits 7--0`
+      - R\ :sub:`31low bits 5--0`\ (bits 7--2) G\ :sub:`30high bits 9--8`\ (bits 1--0)
+    * - start + 20:
+      - G\ :sub:`32low bits 3--0`\ (bits 7--4) R\ :sub:`31high bits 9--6`\ (bits 3--0)
+      - R\ :sub:`33low bits 1--0`\ (bits 7--6) G\ :sub:`32high bits 9--4`\ (bits 5--0)
+    * - start + 22:
+      - R\ :sub:`33high bits 9--2` (bits 7--0)
\ No newline at end of file
diff --git a/Documentation/media/uapi/v4l/pixfmt-mtbc.rst b/Documentation/media/uapi/v4l/pixfmt-mtbc.rst
new file mode 100644
index 000000000000..b122600fddb5
--- /dev/null
+++ b/Documentation/media/uapi/v4l/pixfmt-mtbc.rst
@@ -0,0 +1,58 @@
+.. -*- coding: utf-8; mode: rst -*-
+
+.. _V4L2-PIX-FMT-MTISP_B12:
+
+*******************************
+V4L2_PIX_FMT_MTISP_B12 ('MTBC')
+*******************************
+
+12-bit Packed Bayer formats.
+
+
+Description
+===========
+
+The four pixel formats are used by Mediatek ISP.
+This is a packed format, meaning all the data for a pixel lie
+next to each other with no padding in memory, with a depth of 12 bits per pixel.
+The least significant byte is stored at lower memory addresses (little-endian).
+The RGB byte order follows raw sRGB / Bayer format from sensor.
+Below is an example of conventional RGB byte order BGGR.
+
+**Byte Order.**
+Each cell is one byte.
+
+pixels cross the byte boundary and have a ratio of 6 bytes for each 4 pixels.
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - start + 0:
+      - B\ :sub:`00lowbits 7--0`
+      - G\ :sub:`01lowbits 3--0`\ (bits 7--4) B\ :sub:`00highbits 11--8`\ (bits 3--0)
+      - G\ :sub:`01highbits 7--0`
+      - B\ :sub:`02lowbits 7--0`
+      - G\ :sub:`03lowbits 3--0`\ (bits 7--4) B\ :sub:`02highbits 11--8`\ (bits 3--0)
+      - G\ :sub:`03highbits 7--0`
+    * - start + 6:
+      - G\ :sub:`10lowbits 7--0`
+      - R\ :sub:`11lowbits 3--0`\ (bits 7--4) G\ :sub:`10highbits 11--8`\ (bits 3--0)
+      - R\ :sub:`11highbits 7--0`
+      - G\ :sub:`12lowbits 7--0`
+      - R\ :sub:`13lowbits 3--0`\ (bits 7--4) G\ :sub:`12highbits 11--8`\ (bits 3--0)
+      - R\ :sub:`13highbits 7--0`
+    * - start + 12:
+      - B\ :sub:`20lowbits 7--0`
+      - G\ :sub:`21lowbits 3--0`\ (bits 7--4) B\ :sub:`20highbits 11--8`\ (bits 3--0)
+      - G\ :sub:`21highbits 7--0`
+      - B\ :sub:`22lowbits 7--0`
+      - G\ :sub:`23lowbits 3--0`\ (bits 7--4) B\ :sub:`22highbits 11--8`\ (bits 3--0)
+      - G\ :sub:`23highbits 7--0`
+    * - start + 18:
+      - G\ :sub:`30lowbits 7--0`
+      - R\ :sub:`31lowbits 3--0`\ (bits 7--4) G\ :sub:`30highbits 11--8`\ (bits 3--0)
+      - R\ :sub:`31highbits 7--0`
+      - G\ :sub:`32lowbits 7--0`
+      - R\ :sub:`33lowbits 3--0`\ (bits 7--4) G\ :sub:`32highbits 11--8`\ (bits 3--0)
+      - R\ :sub:`33highbits 7--0`
diff --git a/Documentation/media/uapi/v4l/pixfmt-mtbe.rst b/Documentation/media/uapi/v4l/pixfmt-mtbe.rst
new file mode 100644
index 000000000000..4b9bc9a62504
--- /dev/null
+++ b/Documentation/media/uapi/v4l/pixfmt-mtbe.rst
@@ -0,0 +1,70 @@
+.. -*- coding: utf-8; mode: rst -*-
+
+.. _V4L2-PIX-FMT-MTISP_B14:
+
+*******************************
+V4L2_PIX_FMT_MTISP_B14 ('MTBE')
+*******************************
+
+14-bit Packed Bayer formats.
+
+
+Description
+===========
+
+The four pixel formats are used by Mediatek ISP.
+This is a packed format, meaning all the data for a pixel lie
+next to each other with no padding in memory, with a depth of 14 bits per pixel.
+The least significant byte is stored at lower memory addresses (little-endian).
+The RGB byte order follows raw sRGB / Bayer format from sensor.
+Below is an example of conventional RGB byte order BGGR.
+
+**Byte Order.**
+Each cell is one byte.
+
+pixels cross the byte boundary and have a ratio of 7 bytes for each 4 pixels.
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - start + 0:
+      - B\ :sub:`00low bits 7--0`
+      - G\ :sub:`01low bits 1--0`\ (bits 7--6) B\ :sub:`00high bits 13--8`\ (bits 5--0)
+      - G\ :sub:`01low bits 9--2`\
+      - B\ :sub:`02low bits 3--0`\ (bits 7--4) G\ :sub:`01high bits 13--10`\ (bits 3--0)
+    * - start + 4:
+      - B\ :sub:`02low bits 11--4`\
+      - G\ :sub:`03low bits 5--0`\ (bits 7--2) B\ :sub:`02high bits 13--12`\ (bits 1--0)
+      - G\ :sub:`03high bits 13--6`\
+      -
+    * - start + 8:
+      - G\ :sub:`10low bits 7--0`
+      - R\ :sub:`11low bits 1--0`\ (bits 7--6) G\ :sub:`10high bits 13--8`\ (bits 5--0)
+      - R\ :sub:`11low bits 9--2`\
+      - G\ :sub:`12low bits 3--0`\ (bits 7--4) R\ :sub:`11high bits 13--10`\ (bits 3--0)
+    * - start + 12:
+      - G\ :sub:`12low bits 11--4`\
+      - R\ :sub:`13low bits 5--0`\ (bits 7--2) G\ :sub:`12high bits 13--12`\ (bits 1--0)
+      - R\ :sub:`13high bits 13--6`\
+      -
+    * - start + 16:
+      - B\ :sub:`20low bits 7--0`
+      - G\ :sub:`21low bits 1--0`\ (bits 7--6) B\ :sub:`20high bits 13--8`\ (bits 5--0)
+      - G\ :sub:`21low bits 9--2`\
+      - B\ :sub:`22low bits 3--0`\ (bits 7--4) G\ :sub:`21high bits 13--10`\ (bits 3--0)
+    * - start + 20:
+      - B\ :sub:`22low bits 11--4`\
+      - G\ :sub:`23low bits 5--0`\ (bits 7--2) B\ :sub:`22high bits 13--12`\ (bits 1--0)
+      - G\ :sub:`23high bits 13--6`\
+      -
+    * - start + 24:
+      - G\ :sub:`30low bits 7--0`
+      - R\ :sub:`31low bits 1--0`\ (bits 7--6) G\ :sub:`30high bits 13--8`\ (bits 5--0)
+      - R\ :sub:`31low bits 9--2`\
+      - G\ :sub:`32low bits 3--0`\ (bits 7--4) R\ :sub:`31high bits 13--10`\ (bits 3--0)
+    * - start + 28:
+      - G\ :sub:`32low bits 11--4`\
+      - R\ :sub:`33low bits 5--0`\ (bits 7--2) G\ :sub:`32high bits 13--12`\ (bits 1--0)
+      - R\ :sub:`33high bits 13--6`\
+      -
\ No newline at end of file
diff --git a/Documentation/media/uapi/v4l/pixfmt-mtf8.rst b/Documentation/media/uapi/v4l/pixfmt-mtf8.rst
new file mode 100644
index 000000000000..51c9ddc4e20d
--- /dev/null
+++ b/Documentation/media/uapi/v4l/pixfmt-mtf8.rst
@@ -0,0 +1,75 @@
+.. -*- coding: utf-8; mode: rst -*-
+
+.. _V4L2-PIX-FMT-MTISP_F8:
+
+*******************************
+V4L2_PIX_FMT_MTISP_F8 ('MTF8')
+*******************************
+
+8-bit Packed Full-G Bayer formats.
+
+
+Description
+===========
+
+The four pixel formats are used by Mediatek ISP.
+This is a packed format with a depth of 8 bits per pixel.
+Full-G means 1 more pixel for green channel every 2 pixels.
+The least significant byte is stored at lower memory addresses (little-endian).
+The RGB byte order follows raw sRGB / Bayer format from sensor.
+Below is an example of conventional RGB byte order BGGR.
+
+**Bit-packed representation.**
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - B\ :sub:`00`
+      - FG\ :sub:`01`
+      - G\ :sub:`02`
+      - B\ :sub:`03`
+      - FG\ :sub:`04`
+      - G\ :sub:`05`
+    * - G\ :sub:`10`
+      - R\ :sub:`11`
+      - FG\ :sub:`12`
+      - G\ :sub:`13`
+      - R\ :sub:`14`
+      - FG\ :sub:`15`
+
+**Byte Order.**
+Each cell is one byte.
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - start + 0:
+      - B\ :sub:`00`
+      - FG\ :sub:`01`
+      - G\ :sub:`02`
+      - B\ :sub:`03`
+      - FG\ :sub:`04`
+      - G\ :sub:`05`
+    * - start + 6:
+      - G\ :sub:`10`
+      - R\ :sub:`11`
+      - FG\ :sub:`12`
+      - G\ :sub:`13`
+      - R\ :sub:`14`
+      - FG\ :sub:`15`
+    * - start + 12:
+      - B\ :sub:`20`
+      - FG\ :sub:`21`
+      - G\ :sub:`22`
+      - B\ :sub:`23`
+      - FG\ :sub:`24`
+      - G\ :sub:`25`
+    * - start + 18:
+      - G\ :sub:`30`
+      - R\ :sub:`31`
+      - FG\ :sub:`32`
+      - G\ :sub:`33`
+      - R\ :sub:`34`
+      - FG\ :sub:`35`
\ No newline at end of file
diff --git a/Documentation/media/uapi/v4l/pixfmt-mtfa.rst b/Documentation/media/uapi/v4l/pixfmt-mtfa.rst
new file mode 100644
index 000000000000..68421c44f5e7
--- /dev/null
+++ b/Documentation/media/uapi/v4l/pixfmt-mtfa.rst
@@ -0,0 +1,87 @@
+.. -*- coding: utf-8; mode: rst -*-
+
+.. _V4L2-PIX-FMT-MTISP_F10:
+
+*******************************
+V4L2_PIX_FMT_MTISP_F10 ('MTFA')
+*******************************
+
+10-bit Packed Full-G Bayer formats.
+
+
+Description
+===========
+
+The four pixel formats are used by Mediatek ISP.
+This is a packed format with a depth of 10 bits per pixel.
+Full-G means 1 more pixel for green channel every 2 pixels.
+The least significant byte is stored at lower memory addresses (little-endian).
+The RGB byte order follows raw sRGB / Bayer format from sensor.
+Below is an example of conventional RGB byte order BGGR.
+
+**Bit-packed representation.**
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - B\ :sub:`00`
+      - FG\ :sub:`01`
+      - G\ :sub:`02`
+      - B\ :sub:`03`
+      - FG\ :sub:`04`
+      - G\ :sub:`05`
+    * - G\ :sub:`10`
+      - R\ :sub:`11`
+      - FG\ :sub:`12`
+      - G\ :sub:`13`
+      - R\ :sub:`14`
+      - FG\ :sub:`15`
+
+**Byte Order.**
+Each cell is one byte.
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - start + 0:
+      - B\ :sub:`00low bits 7--0`
+      - FG\ :sub:`01low bits 5--0`\ (bits 7--2) B\ :sub:`00high bits 9--8`\ (bits 1--0)
+      - G\ :sub:`02low bits 3--0`\ (bits 7--4) FG\ :sub:`01high bits 9--6`\ (bits 3--0)
+      - B\ :sub:`03low bits 1--0`\ (bits 7--6) G\ :sub:`02high bits 9--4`\ (bits 5--0)
+    * - start + 4:
+      - B\ :sub:`03high bits 9--2`
+      - FG\ :sub:`04low bits 7--0`
+      - G\ :sub:`05low bits 5--0`\ (bits 7--2) FG\ :sub:`04high bits 9--8`\ (bits 1--0)
+      - G\ :sub:`05high bits 3--0`
+    * - start + 8:
+      - G\ :sub:`10low bits 7--0`
+      - R\ :sub:`11low bits 5--0`\ (bits 7--2) G\ :sub:`10high bits 9--8`\ (bits 1--0)
+      - FG\ :sub:`12low bits 3--0`\ (bits 7--4) R\ :sub:`11high bits 9--6`\ (bits 3--0)
+      - G\ :sub:`13low bits 1--0`\ (bits 7--6) FG\ :sub:`12high bits 9--4`\ (bits 5--0)
+    * - start + 12:
+      - G\ :sub:`13high bits 9--2`
+      - R\ :sub:`14low bits 7--0`
+      - FG\ :sub:`15low bits 5--0`\ (bits 7--2) R\ :sub:`14high bits 9--8`\ (bits 1--0)
+      - FG\ :sub:`15high bits 3--0`
+    * - start + 16:
+      - B\ :sub:`20low bits 7--0`
+      - FG\ :sub:`21low bits 5--0`\ (bits 7--2) B\ :sub:`20high bits 9--8`\ (bits 1--0)
+      - G\ :sub:`22low bits 3--0`\ (bits 7--4) FG\ :sub:`21high bits 9--6`\ (bits 3--0)
+      - B\ :sub:`23low bits 1--0`\ (bits 7--6) G\ :sub:`22high bits 9--4`\ (bits 5--0)
+    * - start + 20:
+      - B\ :sub:`23high bits 9--2`
+      - FG\ :sub:`24low bits 7--0`
+      - G\ :sub:`25low bits 5--0`\ (bits 7--2) FG\ :sub:`24high bits 9--8`\ (bits 1--0)
+      - G\ :sub:`25high bits 3--0`
+    * - start + 24:
+      - G\ :sub:`30low bits 7--0`
+      - R\ :sub:`31low bits 5--0`\ (bits 7--2) G\ :sub:`30high bits 9--8`\ (bits 1--0)
+      - FG\ :sub:`32low bits 3--0`\ (bits 7--4) R\ :sub:`31high bits 9--6`\ (bits 3--0)
+      - G\ :sub:`33low bits 1--0`\ (bits 7--6) FG\ :sub:`32high bits 9--4`\ (bits 5--0)
+    * - start + 28:
+      - G\ :sub:`33high bits 9--2`
+      - R\ :sub:`34low bits 7--0`
+      - FG\ :sub:`35low bits 5--0`\ (bits 7--2) R\ :sub:`34high bits 9--8`\ (bits 1--0)
+      - FG\ :sub:`35high bits 3--0`
\ No newline at end of file
diff --git a/Documentation/media/uapi/v4l/pixfmt-mtfc.rst b/Documentation/media/uapi/v4l/pixfmt-mtfc.rst
new file mode 100644
index 000000000000..a3535f5435fa
--- /dev/null
+++ b/Documentation/media/uapi/v4l/pixfmt-mtfc.rst
@@ -0,0 +1,107 @@
+.. -*- coding: utf-8; mode: rst -*-
+
+.. _V4L2-PIX-FMT-MTISP_F12:
+
+*******************************
+V4L2_PIX_FMT_MTISP_F12 ('MTFC')
+*******************************
+
+12-bit Packed Full-G Bayer formats.
+
+
+Description
+===========
+
+The four pixel formats are used by Mediatek ISP.
+This is a packed format with a depth of 12 bits per pixel.
+Full-G means 1 more pixel for green channel every 2 pixels.
+The least significant byte is stored at lower memory addresses (little-endian).
+The RGB byte order follows raw sRGB / Bayer format from sensor.
+Below is an example of conventional RGB byte order BGGR.
+
+**Bit-packed representation.**
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - B\ :sub:`00`
+      - FG\ :sub:`01`
+      - G\ :sub:`02`
+      - B\ :sub:`03`
+      - FG\ :sub:`04`
+      - G\ :sub:`05`
+    * - G\ :sub:`10`
+      - R\ :sub:`11`
+      - FG\ :sub:`12`
+      - G\ :sub:`13`
+      - R\ :sub:`14`
+      - FG\ :sub:`15`
+
+**Byte Order.**
+Each cell is one byte.
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - start + 0:
+      - B\ :sub:`00low bits 7--0`
+      - FG\ :sub:`01low bits 3--0`\ (bits 7--4) B\ :sub:`00high bits 11--8`\ (bits 3--0)
+    * - start + 2:
+      - FG\ :sub:`01high bits 7--0`
+      - G\ :sub:`02low bits 7--0`
+    * - start + 4:
+      - B\ :sub:`03low bits 3--0`\ (bits 7--4) G\ :sub:`02high bits 11--8`\ (bits 3--0)
+      - B\ :sub:`03high bits 7--0`
+    * - start + 6:
+      - FG\ :sub:`04low bits 7--0`
+      - G\ :sub:`05low bits 3--0`\ (bits 7--4) FG\ :sub:`04high bits 11--8`\ (bits 3--0)
+    * - start + 8:
+      - G\ :sub:`05high bits 7--0`
+      -
+    * - start + 10:
+      - G\ :sub:`10low bits 7--0`
+      - R\ :sub:`11low bits 3--0`\ (bits 7--4) G\ :sub:`10high bits 11--8`\ (bits 3--0)
+    * - start + 12:
+      - R\ :sub:`11high bits 7--0`
+      - FG\ :sub:`12low bits 7--0`
+    * - start + 14:
+      - G\ :sub:`13low bits 3--0`\ (bits 7--4) FG\ :sub:`12high bits 11--8`\ (bits 3--0)
+      - G\ :sub:`13high bits 7--0`
+    * - start + 16:
+      - R\ :sub:`14low bits 7--0`
+      - FG\ :sub:`15low bits 3--0`\ (bits 7--4) R\ :sub:`14high bits 11--8`\ (bits 3--0)
+    * - start + 18:
+      - FG\ :sub:`15high bits 7--0`
+      -
+    * - start + 20:
+      - B\ :sub:`20low bits 7--0`
+      - FG\ :sub:`21low bits 3--0`\ (bits 7--4) B\ :sub:`20high bits 11--8`\ (bits 3--0)
+    * - start + 22:
+      - FG\ :sub:`21high bits 7--0`
+      - G\ :sub:`22low bits 7--0`
+    * - start + 24:
+      - B\ :sub:`23low bits 3--0`\ (bits 7--4) G\ :sub:`22high bits 11--8`\ (bits 3--0)
+      - B\ :sub:`23high bits 7--0`
+    * - start + 26:
+      - FG\ :sub:`24low bits 7--0`
+      - G\ :sub:`25low bits 3--0`\ (bits 7--4) FG\ :sub:`24high bits 11--8`\ (bits 3--0)
+    * - start + 28:
+      - G\ :sub:`25high bits 7--0`
+      -
+    * - start + 30:
+      - G\ :sub:`30low bits 7--0`
+      - R\ :sub:`31low bits 3--0`\ (bits 7--4) G\ :sub:`30high bits 11--8`\ (bits 3--0)
+    * - start + 32:
+      - R\ :sub:`31high bits 7--0`
+      - FG\ :sub:`32low bits 7--0`
+    * - start + 34:
+      - G\ :sub:`33low bits 3--0`\ (bits 7--4) FG\ :sub:`32high bits 11--8`\ (bits 3--0)
+      - G\ :sub:`33high bits 7--0`
+    * - start + 36:
+      - R\ :sub:`34low bits 7--0`
+      - FG\ :sub:`35low bits 3--0`\ (bits 7--4) R\ :sub:`34high bits 11--8`\ (bits 3--0)
+    * - start + 38:
+      - FG\ :sub:`35high bits 7--0`
+      -
\ No newline at end of file
diff --git a/Documentation/media/uapi/v4l/pixfmt-mtfe.rst b/Documentation/media/uapi/v4l/pixfmt-mtfe.rst
new file mode 100644
index 000000000000..324a258e897f
--- /dev/null
+++ b/Documentation/media/uapi/v4l/pixfmt-mtfe.rst
@@ -0,0 +1,107 @@
+.. -*- coding: utf-8; mode: rst -*-
+
+.. _V4L2-PIX-FMT-MTISP_F14:
+
+*******************************
+V4L2_PIX_FMT_MTISP_F14 ('MTFE')
+*******************************
+
+14-bit Packed Full-G Bayer formats.
+
+
+Description
+===========
+
+The four pixel formats are used by Mediatek ISP.
+This is a packed format with a depth of 14 bits per pixel.
+Full-G means 1 more pixel for green channel every 2 pixels.
+The least significant byte is stored at lower memory addresses (little-endian).
+The RGB byte order follows raw sRGB / Bayer format from sensor.
+Below is an example of conventional RGB byte order BGGR.
+
+**Bit-packed representation.**
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - B\ :sub:`00`
+      - FG\ :sub:`01`
+      - G\ :sub:`02`
+      - B\ :sub:`03`
+      - FG\ :sub:`04`
+      - G\ :sub:`05`
+    * - G\ :sub:`10`
+      - R\ :sub:`11`
+      - FG\ :sub:`12`
+      - G\ :sub:`13`
+      - R\ :sub:`14`
+      - FG\ :sub:`15`
+
+**Byte Order.**
+Each cell is one byte.
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - start + 0:
+      - B\ :sub:`00low bits 7--0`
+      - FG\ :sub:`01low bits 1--0`\ (bits 7--6) B\ :sub:`00high bits 13--8`\ (bits 5--0)
+      - FG\ :sub:`01low bits 9--2`
+      - G\ :sub:`02low bits 3--0`\ (bits 7--4) FG\ :sub:`01high bits 13--10`\ (bits 3--0)
+    * - start + 4:
+      - G\ :sub:`02low bits 11--4`
+      - B\ :sub:`03low bits 5--0`\ (bits 7--2) G\ :sub:`02high bits 13--12`\ (bits 1--0)
+      - B\ :sub:`03high bits 13--6`
+      - FG\ :sub:`04low bits 7--0`
+    * - start + 8:
+      - G\ :sub:`05low bits 1--0`\ (bits 7--6) FG\ :sub:`04high bits 13--8`\ (bits 5--0)
+      - G\ :sub:`05high bits 9--2`
+      - G\ :sub:`05high bits 13--10`
+      -
+    * - start + 12:
+      - G\ :sub:`10low bits 7--0`
+      - R\ :sub:`11low bits 1--0`\ (bits 7--6) G\ :sub:`10high bits 13--8`\ (bits 5--0)
+      - R\ :sub:`11low bits 9--2`
+      - FG\ :sub:`12low bits 3--0`\ (bits 7--4) R\ :sub:`11high bits 13--10`\ (bits 3--0)
+    * - start + 16:
+      - FG\ :sub:`12low bits 11--4`
+      - G\ :sub:`13low bits 5--0`\ (bits 7--2) FG\ :sub:`12high bits 13--12`\ (bits 1--0)
+      - G\ :sub:`13high bits 13--6`
+      - R\ :sub:`14low bits 7--0`
+    * - start + 20:
+      - FG\ :sub:`15low bits 1--0`\ (bits 7--6) R\ :sub:`14high bits 13--8`\ (bits 5--0)
+      - FG\ :sub:`15high bits 9--2`
+      - FG\ :sub:`15high bits 13--10`
+      -
+    * - start + 24:
+      - B\ :sub:`20low bits 7--0`
+      - FG\ :sub:`21low bits 1--0`\ (bits 7--6) B\ :sub:`20high bits 13--8`\ (bits 5--0)
+      - FG\ :sub:`21low bits 9--2`
+      - G\ :sub:`22low bits 3--0`\ (bits 7--4) FG\ :sub:`21high bits 13--10`\ (bits 3--0)
+    * - start + 28:
+      - G\ :sub:`22low bits 11--4`
+      - B\ :sub:`23low bits 5--0`\ (bits 7--2) G\ :sub:`22high bits 13--12`\ (bits 1--0)
+      - B\ :sub:`23high bits 13--6`
+      - FG\ :sub:`24low bits 7--0`
+    * - start + 32:
+      - G\ :sub:`25low bits 1--0`\ (bits 7--6) FG\ :sub:`24high bits 13--8`\ (bits 5--0)
+      - G\ :sub:`25high bits 9--2`
+      - G\ :sub:`25high bits 13--10`
+      -
+    * - start + 36:
+      - G\ :sub:`30low bits 7--0`
+      - R\ :sub:`31low bits 1--0`\ (bits 7--6) G\ :sub:`30high bits 13--8`\ (bits 5--0)
+      - R\ :sub:`31low bits 9--2`
+      - FG\ :sub:`32low bits 3--0`\ (bits 7--4) R\ :sub:`31high bits 13--10`\ (bits 3--0)
+    * - start + 40:
+      - FG\ :sub:`32low bits 11--4`
+      - G\ :sub:`33low bits 5--0`\ (bits 7--2) FG\ :sub:`32high bits 13--12`\ (bits 1--0)
+      - G\ :sub:`33high bits 13--6`
+      - R\ :sub:`34low bits 7--0`
+    * - start + 44:
+      - FG\ :sub:`35low bits 1--0`\ (bits 7--6) R\ :sub:`34high bits 13--8`\ (bits 5--0)
+      - FG\ :sub:`35high bits 9--2`
+      - FG\ :sub:`35high bits 13--10`
+      -
\ No newline at end of file
diff --git a/Documentation/media/uapi/v4l/pixfmt-mtu8.rst b/Documentation/media/uapi/v4l/pixfmt-mtu8.rst
new file mode 100644
index 000000000000..cacb3834b63d
--- /dev/null
+++ b/Documentation/media/uapi/v4l/pixfmt-mtu8.rst
@@ -0,0 +1,64 @@
+.. -*- coding: utf-8; mode: rst -*-
+
+.. _V4L2-PIX-FMT-MTISP_U8:
+
+*******************************
+V4L2_PIX_FMT_MTISP_U8 ('MTU8')
+*******************************
+
+8-bit Unpacked Bayer formats.
+
+
+Description
+===========
+
+The four pixel formats are used by Mediatek ISP.
+This is a unpacked format with a depth of 8 bits per pixel.
+Each sample is stored in two bytes.
+The least significant byte is stored at lower memory addresses (little-endian).
+The RGB byte order follows raw sRGB / Bayer format from sensor.
+Below is an example of conventional RGB byte order BGGR.
+
+**Byte Order.**
+Each cell is one byte.
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - start + 0:
+      - B\ :sub:`00`
+      -
+      - G\ :sub:`01`
+      -
+      - B\ :sub:`02`
+      -
+      - G\ :sub:`03`
+      -
+    * - start + 8:
+      - G\ :sub:`10`
+      -
+      - R\ :sub:`11`
+      -
+      - G\ :sub:`12`
+      -
+      - R\ :sub:`13`
+      -
+    * - start + 16:
+      - B\ :sub:`20`
+      -
+      - G\ :sub:`21`
+      -
+      - B\ :sub:`22`
+      -
+      - G\ :sub:`23`
+      -
+    * - start + 24:
+      - G\ :sub:`30`
+      -
+      - R\ :sub:`31`
+      -
+      - G\ :sub:`32`
+      -
+      - R\ :sub:`33`
+      -
diff --git a/Documentation/media/uapi/v4l/pixfmt-mtua.rst b/Documentation/media/uapi/v4l/pixfmt-mtua.rst
new file mode 100644
index 000000000000..dc2038b833bc
--- /dev/null
+++ b/Documentation/media/uapi/v4l/pixfmt-mtua.rst
@@ -0,0 +1,63 @@
+.. -*- coding: utf-8; mode: rst -*-
+
+.. _V4L2-PIX-FMT-MTISP_U10:
+
+*******************************
+V4L2_PIX_FMT_MTISP_U10 ('MTUA')
+*******************************
+
+10-bit Unpacked Bayer formats.
+
+
+Description
+===========
+
+The four pixel formats are used by Mediatek ISP.
+This is a unpacked format with a depth of 10 bits per pixel.
+The least significant byte is stored at lower memory addresses (little-endian).
+The RGB byte order follows raw sRGB / Bayer format from sensor.
+Below is an example of conventional RGB byte order BGGR.
+
+**Byte Order.**
+Each cell is one byte.
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - start + 0:
+      - B\ :sub:`00low bits 7--0`
+      - B\ :sub:`00high bits 9--8`\ (bits 1--0)
+      - G\ :sub:`01low bits 7--0`\
+      - G\ :sub:`01high bits 9--8`\ (bits 1--0)
+      - B\ :sub:`02low bits 7--0`\
+      - B\ :sub:`02high bits 9--8`\ (bits 1--0)
+      - G\ :sub:`03low bits 7--0`\
+      - G\ :sub:`03high bits 9--8`\ (bits 1--0)
+    * - start + 8:
+      - G\ :sub:`10low bits 7--0`
+      - G\ :sub:`10high bits 9--8`\ (bits 1--0)
+      - R\ :sub:`11low bits 7--0`\
+      - R\ :sub:`11high bits 9--8`\ (bits 1--0)
+      - G\ :sub:`12low bits 7--0`\
+      - G\ :sub:`12high bits 9--8`\ (bits 1--0)
+      - R\ :sub:`13low bits 7--0`\
+      - R\ :sub:`13high bits 9--8`\ (bits 1--0)
+    * - start + 16:
+      - B\ :sub:`20low bits 7--0`
+      - B\ :sub:`20high bits 9--8`\ (bits 1--0)
+      - G\ :sub:`21low bits 7--0`\
+      - G\ :sub:`21high bits 9--8`\ (bits 1--0)
+      - B\ :sub:`22low bits 7--0`\
+      - B\ :sub:`22high bits 9--8`\ (bits 1--0)
+      - G\ :sub:`23low bits 7--0`\
+      - G\ :sub:`23high bits 9--8`\ (bits 1--0)
+    * - start + 24:
+      - G\ :sub:`30low bits 7--0`
+      - G\ :sub:`30high bits 9--8`\ (bits 1--0)
+      - R\ :sub:`31low bits 7--0`\
+      - R\ :sub:`31high bits 9--8`\ (bits 1--0)
+      - G\ :sub:`32low bits 7--0`\
+      - G\ :sub:`32high bits 9--8`\ (bits 1--0)
+      - R\ :sub:`33low bits 7--0`\
+      - R\ :sub:`33high bits 9--8`\ (bits 1--0)
\ No newline at end of file
diff --git a/Documentation/media/uapi/v4l/pixfmt-mtuc.rst b/Documentation/media/uapi/v4l/pixfmt-mtuc.rst
new file mode 100644
index 000000000000..f86752ea0840
--- /dev/null
+++ b/Documentation/media/uapi/v4l/pixfmt-mtuc.rst
@@ -0,0 +1,63 @@
+.. -*- coding: utf-8; mode: rst -*-
+
+.. _V4L2-PIX-FMT-MTISP_U12:
+
+*******************************
+V4L2_PIX_FMT_MTISP_U12 ('MTUC')
+*******************************
+
+12-bit Unpacked Bayer formats.
+
+
+Description
+===========
+
+The four pixel formats are used by Mediatek ISP.
+This is a unpacked format with a depth of 12 bits per pixel.
+The least significant byte is stored at lower memory addresses (little-endian).
+The RGB byte order follows raw sRGB / Bayer format from sensor.
+Below is an example of conventional RGB byte order BGGR.
+
+**Byte Order.**
+Each cell is one byte.
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - start + 0:
+      - B\ :sub:`00low bits 7--0`
+      - B\ :sub:`00high bits 11--8`\ (bits 3--0)
+      - G\ :sub:`01low bits 7--0`
+      - G\ :sub:`01high bits 11--8`\ (bits 3--0)
+      - B\ :sub:`02low bits 7--0`
+      - B\ :sub:`02high bits 11--8`\ (bits 3--0)
+      - G\ :sub:`03low bits 7--0`
+      - G\ :sub:`03high bits 11--8`\ (bits 3--0)
+    * - start + 8:
+      - G\ :sub:`10low bits 7--0`
+      - G\ :sub:`10high bits 11--8`\ (bits 3--0)
+      - R\ :sub:`11low bits 7--0`
+      - R\ :sub:`11high bits 11--8`\ (bits 3--0)
+      - G\ :sub:`12low bits 7--0`
+      - G\ :sub:`12high bits 11--8`\ (bits 3--0)
+      - R\ :sub:`13low bits 7--0`
+      - R\ :sub:`13high bits 11--8`\ (bits 3--0)
+    * - start + 16:
+      - B\ :sub:`20low bits 7--0`
+      - B\ :sub:`20high bits 11--8`\ (bits 3--0)
+      - G\ :sub:`21low bits 7--0`
+      - G\ :sub:`21high bits 11--8`\ (bits 3--0)
+      - B\ :sub:`22low bits 7--0`
+      - B\ :sub:`22high bits 11--8`\ (bits 3--0)
+      - G\ :sub:`23low bits 7--0`
+      - G\ :sub:`23high bits 11--8`\ (bits 3--0)
+    * - start + 24:
+      - G\ :sub:`30low bits 7--0`
+      - G\ :sub:`30high bits 11--8`\ (bits 3--0)
+      - R\ :sub:`31low bits 7--0`
+      - R\ :sub:`31high bits 11--8`\ (bits 3--0)
+      - G\ :sub:`32low bits 7--0`
+      - G\ :sub:`32high bits 11--8`\ (bits 3--0)
+      - R\ :sub:`33low bits 7--0`
+      - R\ :sub:`33high bits 11--8`\ (bits 3--0)
diff --git a/Documentation/media/uapi/v4l/pixfmt-mtue.rst b/Documentation/media/uapi/v4l/pixfmt-mtue.rst
new file mode 100644
index 000000000000..a8d4a13a19f0
--- /dev/null
+++ b/Documentation/media/uapi/v4l/pixfmt-mtue.rst
@@ -0,0 +1,63 @@
+.. -*- coding: utf-8; mode: rst -*-
+
+.. _V4L2-PIX-FMT-MTISP_U14:
+
+*******************************
+V4L2_PIX_FMT_MTISP_U14 ('MTUE')
+*******************************
+
+14-bit Unpacked Bayer formats.
+
+
+Description
+===========
+
+The four pixel formats are used by Mediatek ISP.
+This is a unpacked format with a depth of 14 bits per pixel.
+The least significant byte is stored at lower memory addresses (little-endian).
+The RGB byte order follows raw sRGB / Bayer format from sensor.
+Below is an example of conventional RGB byte order BGGR.
+
+**Byte Order.**
+Each cell is one byte.
+
+.. flat-table::
+    :header-rows:  0
+    :stub-columns: 0
+
+    * - start + 0:
+      - B\ :sub:`00low bits 7--0`
+      - B\ :sub:`00high bits 13--8`\ (bits 5--0)
+      - G\ :sub:`01low bits 7--0`
+      - G\ :sub:`01high bits 13--8`\ (bits 5--0)
+      - B\ :sub:`02low bits 7--0`
+      - B\ :sub:`02high bits 13--8`\ (bits 5--0)
+      - G\ :sub:`03low bits 7--0`
+      - G\ :sub:`03high bits 13--8`\ (bits 5--0)
+    * - start + 8:
+      - G\ :sub:`10low bits 7--0`
+      - G\ :sub:`10high bits 13--8`\ (bits 5--0)
+      - R\ :sub:`11low bits 7--0`
+      - R\ :sub:`11high bits 13--8`\ (bits 5--0)
+      - G\ :sub:`12low bits 7--0`
+      - G\ :sub:`12high bits 13--8`\ (bits 5--0)
+      - R\ :sub:`13low bits 7--0`
+      - R\ :sub:`13high bits 13--8`\ (bits 5--0)
+    * - start + 16:
+      - B\ :sub:`20low bits 7--0`
+      - B\ :sub:`20high bits 13--8`\ (bits 5--0)
+      - G\ :sub:`21low bits 7--0`
+      - G\ :sub:`21high bits 13--8`\ (bits 5--0)
+      - B\ :sub:`22low bits 7--0`
+      - B\ :sub:`22high bits 13--8`\ (bits 5--0)
+      - G\ :sub:`23low bits 7--0`
+      - G\ :sub:`23high bits 13--8`\ (bits 5--0)
+    * - start + 24:
+      - G\ :sub:`30low bits 7--0`
+      - G\ :sub:`30high bits 13--8`\ (bits 5--0)
+      - R\ :sub:`31low bits 7--0`
+      - R\ :sub:`31high bits 13--8`\ (bits 5--0)
+      - G\ :sub:`32low bits 7--0`
+      - G\ :sub:`32high bits 13--8`\ (bits 5--0)
+      - R\ :sub:`33low bits 7--0`
+      - R\ :sub:`33high bits 13--8`\ (bits 5--0)
\ No newline at end of file
diff --git a/Documentation/media/uapi/v4l/pixfmt-rgb.rst b/Documentation/media/uapi/v4l/pixfmt-rgb.rst
index 1f9a7e3a07c9..37414eefb240 100644
--- a/Documentation/media/uapi/v4l/pixfmt-rgb.rst
+++ b/Documentation/media/uapi/v4l/pixfmt-rgb.rst
@@ -21,3 +21,15 @@ RGB Formats
     pixfmt-srggb12p
     pixfmt-srggb14p
     pixfmt-srggb16
+    pixfmt-mtb8
+    pixfmt-mtba
+    pixfmt-mtbc
+    pixfmt-mtbe
+    pixfmt-mtf8
+    pixfmt-mtfa
+    pixfmt-mtfc
+    pixfmt-mtfe
+    pixfmt-mtu8
+    pixfmt-mtua
+    pixfmt-mtuc
+    pixfmt-mtue
diff --git a/MAINTAINERS b/MAINTAINERS
index 4cf64da1c002..82d9aa395c4d 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -10722,6 +10722,14 @@ T:	git git://linuxtv.org/media_tree.git
 S:	Maintained
 F:	drivers/media/i2c/ov13858.c
 
+OMNIVISION OV02A10 SENSOR DRIVER
+M:	Dongchun Zhu <dongchun.zhu@mediatek.com>
+L:	linux-media@vger.kernel.org
+T:	git git://linuxtv.org/media_tree.git
+S:	Maintained
+F:	drivers/media/i2c/ov02a10.c
+F:	Documentation/devicetree/bindings/media/i2c/ov02a10.txt
+
 OMNIVISION OV2680 SENSOR DRIVER
 M:	Rui Miguel Silva <rmfrfs@gmail.com>
 L:	linux-media@vger.kernel.org
diff --git a/Makefile b/Makefile
index 4bfb6eda4577..e570b36bec79 100644
--- a/Makefile
+++ b/Makefile
@@ -1,3 +1,4 @@
+# kukui ToT!
 # SPDX-License-Identifier: GPL-2.0
 VERSION = 4
 PATCHLEVEL = 19
diff --git a/README b/README
index 2c927ccbd970..768caa3970ef 100644
--- a/README
+++ b/README
@@ -1,3 +1,4 @@
+MTK TOT
 Linux kernel
 ============
 
diff --git a/arch/arm64/boot/dts/mediatek/mt6358.dtsi b/arch/arm64/boot/dts/mediatek/mt6358.dtsi
index a7e655c42a54..a049ac2e39f7 100644
--- a/arch/arm64/boot/dts/mediatek/mt6358.dtsi
+++ b/arch/arm64/boot/dts/mediatek/mt6358.dtsi
@@ -114,8 +114,8 @@
 
 			mt6358_vsim1_reg: ldo_vsim1 {
 				regulator-name = "vsim1";
-				regulator-min-microvolt = <1700000>;
-				regulator-max-microvolt = <3100000>;
+				regulator-min-microvolt = <2700000>;
+				regulator-max-microvolt = <2700000>;
 				regulator-enable-ramp-delay = <540>;
 			};
 
@@ -349,8 +349,8 @@
 
 			mt6358_vsim2_reg: ldo_vsim2 {
 				regulator-name = "vsim2";
-				regulator-min-microvolt = <1700000>;
-				regulator-max-microvolt = <3100000>;
+				regulator-min-microvolt = <2700000>;
+				regulator-max-microvolt = <2700000>;
 				regulator-enable-ramp-delay = <540>;
 			};
 		};
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-evb.dts b/arch/arm64/boot/dts/mediatek/mt8183-evb.dts
index ef041d64459d..e015a11d0fe7 100644
--- a/arch/arm64/boot/dts/mediatek/mt8183-evb.dts
+++ b/arch/arm64/boot/dts/mediatek/mt8183-evb.dts
@@ -43,6 +43,18 @@
 			reg = <0 0x50000000 0 0x2900000>;
 			no-map;
 		};
+		dip_mem_reserved: dip_mem_region {
+			compatible = "mediatek,reserve-memory-dip-smem";
+			reg = <0 0x42000000 0 0x01A00000>;
+			no-map;
+		};
+		cam_mem_reserved: cam_mem_region {
+			compatible = "mediatek,reserve-memory-cam-smem";
+			no-map;
+			size = <0 0x01400000>; /* 20 MB share mem size */
+			alignment = <0 0x1000>;
+			alloc-ranges = <0 0x40000000 0 0x10000000>;
+		};
 	};
 
 	usb_p0_vbus: regulator@0 {
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-kukui-krane.dtsi b/arch/arm64/boot/dts/mediatek/mt8183-kukui-krane.dtsi
old mode 100644
new mode 100755
index 8ce922e6c95a..34f6df671ee8
--- a/arch/arm64/boot/dts/mediatek/mt8183-kukui-krane.dtsi
+++ b/arch/arm64/boot/dts/mediatek/mt8183-kukui-krane.dtsi
@@ -57,6 +57,136 @@
 	};
 };
 
+&i2c2 {
+	at24@58 {
+		compatible = "atmel,24c32";
+		reg = <0x58>;
+		pagesize = <32>;
+		power-supply = <&mt6358_vcama2_reg>;
+		i2c-supply = <&mt6358_vcamio_reg>;
+	};
+	
+	sensor_main: sensor_main {
+		status = "okay";
+		compatible = "ovti,ov8856";
+		reg = <0x10>;
+
+		clocks = <&topckgen CLK_TOP_MUX_CAMTG>,
+			<&topckgen CLK_TOP_UNIVP_192M_D8>;
+		clock-names = "xvclk", "freq_mux";
+		clock-frequency = <19200000>;
+
+		assigned-clocks = <&topckgen CLK_TOP_MUX_CAMTG>,
+		    <&topckgen CLK_TOP_UNIVP_192M_D8>;
+		assigned-clock-parents = <&topckgen CLK_TOP_UNIVP_192M_D8>;
+		assigned-clock-rates = <0>, <24000000>;
+
+		reset-gpios = <&pio 111 1>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&camera_pins_cam0_mclk_on>;
+
+		avdd-supply = <&mt6358_vcama2_reg>;
+		dvdd-supply = <&mt6358_vcamd_reg>;
+		dovdd-supply = <&mt6358_vcamio_reg>;
+
+		port@0 {
+		   ov8856_core: endpoint {
+		       remote-endpoint = <&ov8856_0>;
+		       data-lanes = <0 1 3 4>;
+		       clock-lanes = <2>;
+		       clock-noncontinuous;
+		       link-frequencies = /bits/ 64 <360000000 180000000>;
+		   };
+		};
+	};
+
+	camera_main_af: camera_main_af {
+		compatible = "dongwoon,dw9768";
+		reg = <0x0c>;
+
+		afvdd-supply = <&mt6358_vcama2_reg>;
+
+		port@0 {
+		   main_af_0: endpoint {
+		       remote-endpoint = <&dw9768_0>;
+		   };
+		};
+	};
+};
+
+&i2c4 {
+	at24@54 {
+		compatible = "atmel,24c32";
+		reg = <0x54>;
+		pagesize = <32>;
+		power-supply = <&mt6358_vcn18_reg>;
+		i2c-supply = <&mt6358_vcn18_reg>;
+	};
+
+	sensor_sub: sensor_sub {
+		status = "okay";
+		compatible = "ovti,ov02a10";
+		reg = <0x3d>;
+
+		clocks = <&topckgen CLK_TOP_MUX_CAMTG2>,
+			<&topckgen CLK_TOP_UNIVP_192M_D8>;
+		clock-names = "xvclk", "freq_mux";
+		clock-frequency = <24000000>;
+		rotation = <180>;
+
+		assigned-clocks = <&topckgen CLK_TOP_MUX_CAMTG2>,
+		    <&topckgen CLK_TOP_UNIVP_192M_D8>;
+		assigned-clock-parents = <&topckgen CLK_TOP_UNIVP_192M_D8>;
+		assigned-clock-rates = <0>, <24000000>;
+
+		pwdn-gpios = <&pio 107 1>;
+		reset-gpios = <&pio 109 1>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&camera_pins_cam1_mclk_on>;
+
+		avdd-supply = <&mt6358_vcama1_reg>;
+		dvdd-supply = <&mt6358_vcn18_reg>;
+		dovdd-supply = <&mt6358_vcamio_reg>;
+
+		port@0 {
+		   ov02a10_core: endpoint {
+		       remote-endpoint = <&ov02a10_0>;
+		       data-lanes = <1>;
+		   };
+		};
+	};
+};
+
+&seninf {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			ov8856_0: endpoint {
+				remote-endpoint = <&ov8856_core>;
+			};
+		};
+		port@1 {
+			ov02a10_0: endpoint {
+				remote-endpoint = <&ov02a10_core>;
+			};
+		};
+		port@2 {
+			dw9768_0: endpoint {
+				remote-endpoint = <&main_af_0>;
+			};
+		};
+	};
+
+	port@2 {
+		seninf_core: endpoint {
+			remote-endpoint = <&seninf_0>;
+		};
+	};
+};
+
 &pio {
 	/* 192 lines */
 	gpio-line-names =
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev1.dts b/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev1.dts
index 8bd78a2f97bf..96e101d6b346 100644
--- a/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev1.dts
+++ b/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev1.dts
@@ -225,6 +225,10 @@
 	};
 };
 
+&it6505dptx {
+	ovdd-supply = <&mt6358_vsim1_reg>;
+};
+
 &i2c0 {
 	status = "okay";
 
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev2.dts b/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev2.dts
index 64f0316d4a64..b7660fcd5aa6 100644
--- a/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev2.dts
+++ b/arch/arm64/boot/dts/mediatek/mt8183-kukui-rev2.dts
@@ -4,6 +4,7 @@
  */
 
 /dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
 #include "mt8183-kukui.dtsi"
 
 / {
@@ -24,6 +25,72 @@
 			wakeup-source;
 		};
 	};
+
+	pp1200_mipibrdg: pp1200-mipibrdg {
+		compatible = "regulator-fixed";
+		regulator-name = "pp1200_mipibrdg";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pp1200_mipibrdg_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 54 GPIO_ACTIVE_HIGH>;
+	};
+
+	pp1800_lcd: pp1800-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "pp1800_lcd";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pp1800_lcm_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 36 GPIO_ACTIVE_HIGH>;
+	};
+
+	pp3300_lcd: pp3300-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "pp3300_lcd";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pp3300_lcm_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 35 GPIO_ACTIVE_HIGH>;
+	};
+
+	ppvarn_lcd: ppvarn-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "ppvarn_lcd";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ppvarn_lcd_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 66 GPIO_ACTIVE_HIGH>;
+	};
+
+	ppvarp_lcd: ppvarp-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "ppvarp_lcd";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ppvarp_lcd_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 166 GPIO_ACTIVE_HIGH>;
+	};
+
+	vddio_mipibrdg: vddio-mipibrdg {
+		compatible = "regulator-fixed";
+		regulator-name = "vddio_mipibrdg";
+		pinctrl-names = "default";
+		pinctrl-0 = <&vddio_mipibrdg_en>;
+
+		enable-active-high;
+
+		gpio = <&pio 37 GPIO_ACTIVE_HIGH>;
+	};
 };
 
 &i2c0 {
@@ -52,6 +119,50 @@
 	};
 };
 
+&i2c2 {
+        sensor_main: sensor_main {
+                status = "okay";
+                reset-gpios = <&pio 111 1>;
+        };
+};
+
+&i2c4 {
+        sensor_sub: sensor_sub {
+                status = "okay";
+                reset-gpios = <&pio 107 1>;
+        };
+};
+
+&panel {
+	compatible = "innolux,p097pfg_ssd2858";
+	reg = <0>;
+	enable-gpios = <&pio 45 0 &pio 73 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&panel_pins_default>;
+	/delete-property/ power-supply;
+	avdd-supply = <&ppvarp_lcd>;
+	avee-supply = <&ppvarn_lcd>;
+	pp1800-supply = <&pp1800_lcd>;
+	pp3300-supply = <&pp3300_lcd>;
+	pp1200-bridge-supply = <&pp1200_mipibrdg>;
+	vddio-bridge-supply = <&vddio_mipibrdg>;
+	backlight = <&backlight_lcd0>;
+	status = "okay";
+	port {
+		panel_in: endpoint {
+			remote-endpoint = <&dsi_out>;
+		};
+	};
+};
+
+&panel_pins_default {
+	bridge_reset {
+		pinmux = <PINMUX_GPIO73__FUNC_GPIO73>;
+		output-low;
+		bias-pull-up;
+	};
+};
+
 &pio {
 	/* 192 lines */
 	gpio-line-names =
@@ -285,6 +396,41 @@
 		};
 	};
 
+	pp1200_mipibrdg_en: pp1200-mipibrdg-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO54__FUNC_GPIO54>;
+			output-low;
+		};
+	};
+
+	pp1800_lcm_en: pp1800-lcd-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO36__FUNC_GPIO36>;
+			output-low;
+		};
+	};
+
+	pp3300_lcm_en: pp3300-lcd-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO35__FUNC_GPIO35>;
+			output-low;
+		};
+	};
+
+	ppvarp_lcd_en: ppvarp-lcd-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO66__FUNC_GPIO66>;
+			output-low;
+		};
+	};
+
+	ppvarn_lcd_en: ppvarn-lcd-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO166__FUNC_GPIO166>;
+			output-low;
+		};
+	};
+
 	touch_default: touchdefault {
 		pin_irq {
 			pinmux = <PINMUX_GPIO155__FUNC_GPIO155>;
@@ -297,6 +443,13 @@
 			output-low;
 		};
 	};
+
+	vddio_mipibrdg_en: vddio_mipibrdg_en {
+		pins1 {
+			pinmux = <PINMUX_GPIO37__FUNC_GPIO37>;
+			output-low;
+		};
+	};
 };
 
 &scp_pins {
diff --git a/arch/arm64/boot/dts/mediatek/mt8183-kukui.dtsi b/arch/arm64/boot/dts/mediatek/mt8183-kukui.dtsi
index c4ff474f548b..0c7b5c7e7856 100644
--- a/arch/arm64/boot/dts/mediatek/mt8183-kukui.dtsi
+++ b/arch/arm64/boot/dts/mediatek/mt8183-kukui.dtsi
@@ -41,6 +41,15 @@
 		clock-output-names = "clk32k";
 	};
 
+	it6505_pp18_reg: regulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "it6505_pp18";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		gpio = <&pio 178 0>;
+		enable-active-high;
+	};
+
 	lcd_pp3300: regulator@1 {
 		compatible = "regulator-fixed";
 		regulator-name = "lcd_pp3300";
@@ -95,11 +104,35 @@
 			alloc-ranges = <0 0x50000000 0 0x10000000>;
 		};
 
+		reserve-memory-fd_smem {
+			compatible = "mediatek,reserve-memory-fd_smem";
+			no-map;
+			size = <0 0x00100000>;  /*1 MB share mem size */
+			alignment = <0 0x1000>;
+			alloc-ranges = <0 0x40000000 0 0x10000000>;
+		};
+
+		cam_mem_reserved: cam_mem_region {
+			compatible = "mediatek,reserve-memory-cam-smem";
+			no-map;
+			size = <0 0x01400000>; /* 20 MB share mem size */
+			alignment = <0 0x1000>;
+			alloc-ranges = <0 0x40000000 0 0x10000000>;
+		};
+
 		scp_mem_reserved: scp_mem_region {
 			compatible = "shared-dma-pool";
 			reg = <0 0x50000000 0 0x2900000>;
 			no-map;
 		};
+
+		dip_mem_reserved: dip_mem_region {
+			compatible = "mediatek,reserve-memory-dip-smem";
+			no-map;
+			size = <0 0x01A00000>;
+			alignment = <0 0x1000>;
+			alloc-ranges = <0 0x40000000 0 0x10000000>;
+		};
 	};
 
 	max98357a: max98357a {
@@ -114,8 +147,12 @@
 	sound: mt8183-mt6358-ts3a227e-max98357a {
 		compatible = "mediatek,mt8183_mt6358_ts3a227_max98357";
 		mediatek,platform = <&afe>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&aud_pins>;
+		pinctrl-names = "default",
+				"aud_tdm_out_on",
+				"aud_tdm_out_off";
+		pinctrl-0 = <&aud_pins_default>;
+		pinctrl-1 = <&aud_pins_tdm_out_on>;
+		pinctrl-2 = <&aud_pins_tdm_out_off>;
 		status = "okay";
 	};
 
@@ -170,6 +207,18 @@
 	proc-supply = <&mt6358_vproc11_reg>;
 };
 
+&dpi0 {
+	pinctrl-names = "default", "dpimode";
+	pinctrl-0 = <&dpi_pin_default>;
+	pinctrl-1 = <&dpi_pin_func>;
+	status = "okay";
+	port {
+		dpi_out: endpoint {
+			remote-endpoint = <&it6505_in>;
+		};
+	};
+};
+
 &dsi0 {
 	status = "okay";
 	#address-cells = <1>;
@@ -237,7 +286,36 @@
 	pinctrl-names = "default";
 	pinctrl-0 = <&i2c2_pins>;
 	status = "okay";
-	clock-frequency = <100000>;
+	clock-frequency = <400000>;
+
+	sensor_main: sensor_main {
+		compatible = "ovti,ov5695";
+		reg = <0x36>;
+
+		clocks = <&topckgen CLK_TOP_MUX_CAMTG>,
+			<&topckgen CLK_TOP_UNIVP_192M_D8>;
+		clock-names = "xvclk", "freq_mux";
+
+		assigned-clocks = <&topckgen CLK_TOP_MUX_CAMTG>,
+		    <&topckgen CLK_TOP_UNIVP_192M_D8>;
+		assigned-clock-parents = <&topckgen CLK_TOP_UNIVP_192M_D8>;
+		assigned-clock-rates = <0>, <24000000>;
+
+		reset-gpios = <&pio 112 1>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&camera_pins_cam0_mclk_on>;
+
+		avdd-supply = <&mt6358_vcama2_reg>;
+		dvdd-supply = <&mt6358_vcamd_reg>;
+		dovdd-supply = <&mt6358_vcamio_reg>;
+
+		port@0 {
+		   ov5695_core: endpoint {
+		       remote-endpoint = <&ov5695_0>;
+		       data-lanes = <1 3>;
+		   };
+		};
+	};
 };
 
 &i2c3 {
@@ -245,13 +323,64 @@
 	pinctrl-0 = <&i2c3_pins>;
 	status = "okay";
 	clock-frequency = <100000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	it6505dptx: it6505dptx@5c {
+		compatible = "ite,it6505";
+		status = "okay";
+		interrupt-parent = <&pio>;
+		interrupts = <152 IRQ_TYPE_EDGE_RISING 152 0>;
+		reg = <0x5c>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&it6505_pins>;
+		ovdd-supply = <&mt6358_vsim2_reg>;
+		pwr18-supply = <&it6505_pp18_reg>;
+		reset-gpios = <&pio 179 1>;
+		hpd-gpios = <&pio 9 0>;
+		extcon = <&usbc_extcon>;
+		port {
+			it6505_in: endpoint {
+				remote-endpoint = <&dpi_out>;
+			};
+		};
+	};
 };
 
 &i2c4 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&i2c4_pins>;
 	status = "okay";
-	clock-frequency = <100000>;
+	clock-frequency = <400000>;
+
+	sensor_sub: sensor_sub {
+		compatible = "ovti,ov2685";
+		reg = <0x3c>;
+
+		clocks = <&topckgen CLK_TOP_MUX_CAMTG2>,
+			<&topckgen CLK_TOP_UNIVP_192M_D8>;
+		clock-names = "xvclk", "freq_mux";
+
+		assigned-clocks = <&topckgen CLK_TOP_MUX_CAMTG2>,
+		    <&topckgen CLK_TOP_UNIVP_192M_D8>;
+		assigned-clock-parents = <&topckgen CLK_TOP_UNIVP_192M_D8>;
+		assigned-clock-rates = <0>, <24000000>;
+
+		reset-gpios = <&pio 110 1>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&camera_pins_cam1_mclk_on>;
+
+		avdd-supply = <&mt6358_vcama1_reg>;
+		dvdd-supply = <&mt6358_vcn18_reg>;
+		dovdd-supply = <&mt6358_vcamio_reg>;
+
+		port@0 {
+		   ov2685_core: endpoint {
+		       remote-endpoint = <&ov2685_0>;
+		       data-lanes = <1 3>;
+		   };
+		};
+	};
 };
 
 &i2c5 {
@@ -349,8 +478,41 @@
 	Avdd-supply = <&mt6358_vaud28_reg>;
 };
 
+&camisp {
+	port@0 {
+		seninf_0: endpoint {
+			remote-endpoint = <&seninf_core>;
+		};
+	};
+};
+
+&seninf {
+	status = "okay";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			ov2685_0: endpoint {
+				remote-endpoint = <&ov2685_core>;
+			};
+		};
+
+		port@1 {
+			ov5695_0: endpoint {
+				remote-endpoint = <&ov5695_core>;
+			};
+		};
+	};
+
+	port@2 {
+		seninf_core: endpoint {
+			remote-endpoint = <&seninf_0>;
+	   };
+	};
+};
+
 &pio {
-	aud_pins: audiopins {
+	aud_pins_default: audiopins {
 		pins_bus {
 			pinmux = <PINMUX_GPIO97__FUNC_I2S2_MCK>,
 				<PINMUX_GPIO98__FUNC_I2S2_BCK>,
@@ -368,13 +530,33 @@
 				<PINMUX_GPIO140__FUNC_AUD_CLK_MISO>,
 				<PINMUX_GPIO141__FUNC_AUD_SYNC_MISO>,
 				<PINMUX_GPIO142__FUNC_AUD_DAT_MISO0>,
-				<PINMUX_GPIO143__FUNC_AUD_DAT_MISO1>, /*mtkaif3.0*/
-				<PINMUX_GPIO169__FUNC_TDM_BCK_2ND>,
+				<PINMUX_GPIO143__FUNC_AUD_DAT_MISO1>; /*mtkaif3.0*/
+		};
+	};
+
+	aud_pins_tdm_out_on: audiotdmouton {
+		pins_bus {
+			pinmux = <PINMUX_GPIO169__FUNC_TDM_BCK_2ND>,
 				<PINMUX_GPIO170__FUNC_TDM_LRCK_2ND>,
 				<PINMUX_GPIO171__FUNC_TDM_DATA0_2ND>,
 				<PINMUX_GPIO172__FUNC_TDM_DATA1_2ND>,
 				<PINMUX_GPIO173__FUNC_TDM_DATA2_2ND>,
 				<PINMUX_GPIO10__FUNC_TDM_DATA3>; /*8ch-i2s to it6505*/
+			drive-strength = <MTK_DRIVE_6mA>;
+		};
+	};
+
+	aud_pins_tdm_out_off: audiotdmoutoff {
+		pins_bus {
+			pinmux = <PINMUX_GPIO169__FUNC_GPIO169>,
+				<PINMUX_GPIO170__FUNC_GPIO170>,
+				<PINMUX_GPIO171__FUNC_GPIO171>,
+				<PINMUX_GPIO172__FUNC_GPIO172>,
+				<PINMUX_GPIO173__FUNC_GPIO173>,
+				<PINMUX_GPIO10__FUNC_GPIO10>;
+			input-enable;
+			bias-pull-down;
+			drive-strength = <MTK_DRIVE_2mA>;
 		};
 	};
 
@@ -385,6 +567,51 @@
 		};
 	};
 
+	dpi_pin_default: dpi_pin_default {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO13__FUNC_GPIO13>,
+				<PINMUX_GPIO14__FUNC_GPIO14>,
+				<PINMUX_GPIO15__FUNC_GPIO15>,
+				<PINMUX_GPIO16__FUNC_GPIO16>,
+				<PINMUX_GPIO17__FUNC_GPIO17>,
+				<PINMUX_GPIO18__FUNC_GPIO18>,
+				<PINMUX_GPIO19__FUNC_GPIO19>,
+				<PINMUX_GPIO20__FUNC_GPIO20>,
+				<PINMUX_GPIO21__FUNC_GPIO21>,
+				<PINMUX_GPIO22__FUNC_GPIO22>,
+				<PINMUX_GPIO23__FUNC_GPIO23>,
+				<PINMUX_GPIO24__FUNC_GPIO24>,
+				<PINMUX_GPIO25__FUNC_GPIO25>,
+				<PINMUX_GPIO26__FUNC_GPIO26>,
+				<PINMUX_GPIO27__FUNC_GPIO27>,
+				<PINMUX_GPIO28__FUNC_GPIO28>;
+				drive-strength = <MTK_DRIVE_6mA>;
+				output-low;
+		};
+	};
+
+	dpi_pin_func: dpi_pin_func {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO13__FUNC_DBPI_D0>,
+				<PINMUX_GPIO14__FUNC_DBPI_D1>,
+				<PINMUX_GPIO15__FUNC_DBPI_D2>,
+				<PINMUX_GPIO16__FUNC_DBPI_D3>,
+				<PINMUX_GPIO17__FUNC_DBPI_D4>,
+				<PINMUX_GPIO18__FUNC_DBPI_D5>,
+				<PINMUX_GPIO19__FUNC_DBPI_D6>,
+				<PINMUX_GPIO20__FUNC_DBPI_D7>,
+				<PINMUX_GPIO21__FUNC_DBPI_D8>,
+				<PINMUX_GPIO22__FUNC_DBPI_D9>,
+				<PINMUX_GPIO23__FUNC_DBPI_D10>,
+				<PINMUX_GPIO24__FUNC_DBPI_D11>,
+				<PINMUX_GPIO25__FUNC_DBPI_HSYNC>,
+				<PINMUX_GPIO26__FUNC_DBPI_VSYNC>,
+				<PINMUX_GPIO27__FUNC_DBPI_DE>,
+				<PINMUX_GPIO28__FUNC_DBPI_CK>;
+				drive-strength = <MTK_DRIVE_6mA>;
+		};
+	};
+
 	ec_ap_int_odl: ec_ap_int_odl {
 		pins1 {
 			pinmux = <PINMUX_GPIO151__FUNC_GPIO151>;
@@ -470,6 +697,34 @@
 		};
 	};
 
+	it6505_pins: it6505_pins {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO178__FUNC_GPIO178>,
+					<PINMUX_GPIO179__FUNC_GPIO179>;
+			output-low;
+			bias-pull-up;
+		};
+
+		pins_cmd_dat1 {
+			pinmux = <PINMUX_GPIO9__FUNC_GPIO9>,
+					<PINMUX_GPIO152__FUNC_GPIO152>;
+			input-enable;
+			bias-pull-up;
+		};
+	};
+
+	camera_pins_cam0_mclk_on: cam0@2 {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO99__FUNC_CMMCLK0>;
+		};
+	};
+
+	camera_pins_cam1_mclk_on: cam1@2 {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO100__FUNC_CMMCLK1>;
+		};
+	};
+
 	mmc0_pins_default: mmc0default {
 		pins_cmd_dat {
 			pinmux = <PINMUX_GPIO123__FUNC_MSDC0_DAT0>,
@@ -791,6 +1046,12 @@
 			#address-cells = <1>;
 			#size-cells = <0>;
 		};
+
+		usbc_extcon: extcon@0 {
+			compatible = "google,extcon-usbc-cros-ec";
+			google,usb-port-id = <0>;
+			#extcon-cells = <0>;
+		};
 	};
 };
 
@@ -834,7 +1095,8 @@
 };
 
 &ssusb {
-	dr_mode = "host";
+	maximum-speed = "high-speed";
+	enable-manual-drd;
 	vusb33-supply = <&mt6358_vusb_reg>;
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/mediatek/mt8183.dtsi b/arch/arm64/boot/dts/mediatek/mt8183.dtsi
old mode 100644
new mode 100755
index 29c9fbb9673d..6b6f7ff7ae0b
--- a/arch/arm64/boot/dts/mediatek/mt8183.dtsi
+++ b/arch/arm64/boot/dts/mediatek/mt8183.dtsi
@@ -483,6 +483,89 @@
 			     <GIC_PPI 10 IRQ_TYPE_LEVEL_LOW 0>;
 	};
 
+
+	tboard_thermistor1: thermal-sensor1 {
+		compatible = "generic-adc-thermal";
+		#thermal-sensor-cells = <0>;
+		io-channels = <&auxadc 0>;
+		io-channel-names = "sensor-channel";
+		temperature-lookup-table = <    (-40000) 4833
+						(-35000) 4798
+						(-30000) 4754
+						(-25000) 4694
+						(-20000) 4615
+						(-15000) 4517
+						(-10000) 4391
+						(-5000) 4241
+						0 4063
+						5000 3856
+						10000 3621
+						15000 3364
+						20000 3091
+						25000 2810
+						30000 2526
+						35000 2247
+						40000 1982
+						45000 1734
+						50000 1507
+						55000 1305
+						60000 1122
+						65000 964
+						70000 827
+						75000 710
+						80000 606
+						85000 519
+						90000 445
+						95000 382
+						100000 330
+						105000 284
+						110000 846
+						115000 213
+						120000 183
+						125000 161>;
+	};
+
+	tboard_thermistor2: thermal-sensor2 {
+		compatible = "generic-adc-thermal";
+		#thermal-sensor-cells = <0>;
+		io-channels = <&auxadc 1>;
+		io-channel-names = "sensor-channel";
+		temperature-lookup-table = <    (-40000) 4833
+						(-35000) 4798
+						(-30000) 4754
+						(-25000) 4694
+						(-20000) 4615
+						(-15000) 4517
+						(-10000) 4391
+						(-5000) 4241
+						0 4063
+						5000 3856
+						10000 3621
+						15000 3364
+						20000 3091
+						25000 2810
+						30000 2526
+						35000 2247
+						40000 1982
+						45000 1734
+						50000 1507
+						55000 1305
+						60000 1122
+						65000 964
+						70000 827
+						75000 710
+						80000 606
+						85000 519
+						90000 445
+						95000 382
+						100000 330
+						105000 284
+						110000 846
+						115000 213
+						120000 183
+						125000 161>;
+	};
+
 	soc {
 		#address-cells = <2>;
 		#size-cells = <2>;
@@ -548,6 +631,13 @@
 			#reset-cells = <1>;
 		};
 
+		pericfg: power-controller@10003000 {
+			compatible = "mediatek,mt8183-pericfg", "syscon";
+			reg = <0 0x10003000 0 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
 		pio: pinctrl@10005000 {
 			compatible = "mediatek,mt8183-pinctrl";
 			reg = <0 0x10005000 0 0x1000>,
@@ -668,6 +758,17 @@
 			#iommu-cells = <1>;
 		};
 
+		emi@10219000 {
+			compatible = "mediatek,mt8183-emi";
+			reg = <0 0x10219000 0 0x1000>, /* CEN EMI */
+				  <0 0x10226000 0 0x1000>, /* EMI MPU */
+				  <0 0x1022d000 0 0x1000>, /* CHA EMI */
+			      <0 0x10235000 0 0x1000>; /* CHB EMI */
+			interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_LOW>, /* MPU */
+						 <GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>, /* CGM */
+						 <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>; /* ELM */
+		};
+
 		gce: gce@10238000 {
 			compatible = "mediatek,mt8183-gce";
 			reg = <0 0x10238000 0 0x4000>;
@@ -687,6 +788,17 @@
 			clocks = <&infracfg CLK_INFRA_SCPSYS>;
 			clock-names = "main";
 			memory-region = <&scp_mem_reserved>;
+			status = "okay";
+		};
+
+		vpu: vpu@10500000 {
+			compatible = "mediatek,mt8183-vpu", "mediatek,mt8173-vpu";
+			reg = <0 0x10500000 0 0x80000>,
+			      <0 0x105c0000 0 0x1000>;
+			reg-names = "tcm", "cfg_reg";
+			interrupts = <GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&infracfg CLK_INFRA_SCPSYS>;
+			clock-names = "main";
 			status = "disabled";
 		};
 
@@ -697,6 +809,8 @@
 			clocks = <&infracfg CLK_INFRA_AUXADC>;
 			clock-names = "main";
 			#io-channel-cells = <1>;
+			nvmem-cells = <&auxadc_calibration>;
+			nvmem-cell-names = "calibration-data";
 			status = "disabled";
 		};
 
@@ -924,6 +1038,18 @@
 				trips {};
 				cooling-maps {};
 			};
+
+	                Tboard1 {
+				polling-delay = <1000>; /* milliseconds */
+				polling-delay-passive = <0>; /* milliseconds */
+				thermal-sensors = <&tboard_thermistor1>;
+	                };
+
+	                Tboard2 {
+				polling-delay = <1000>; /* milliseconds */
+				polling-delay-passive = <0>; /* milliseconds */
+				thermal-sensors = <&tboard_thermistor2>;
+	                };
 		};
 
 		pwm0: pwm@1100e000 {
@@ -1141,6 +1267,8 @@
 			clocks = <&infracfg CLK_INFRA_UNIPRO_SCK>,
 				 <&infracfg CLK_INFRA_USB>;
 			clock-names = "sys_ck", "ref_ck";
+			wakeup-source;
+			mediatek,syscon-wakeup = <&pericfg 0x400 1>;
 			#address-cells = <2>;
 			#size-cells = <2>;
 			ranges;
@@ -1294,6 +1422,9 @@
 			reg = <0 0x11f10000 0 0x1000>;
 			#address-cells = <1>;
 			#size-cells = <1>;
+                        auxadc_calibration: auxadccali@1b4 {
+                                reg = <0x1b4 0x4>;
+                        };
 			thermal_calibration: calib@180 {
 				reg = <0x180 0xc>;
 			};
@@ -1311,6 +1442,7 @@
 				clocks = <&clk26m>;
 				clock-names = "ref";
 				#phy-cells = <1>;
+				mediatek,eye-vrt = <1>;
 				status = "okay";
 			};
 
@@ -1496,9 +1628,143 @@
 		mmsys: syscon@14000000 {
 			compatible = "mediatek,mt8183-mmsys", "syscon";
 			reg = <0 0x14000000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0 0x1000>;
 			#clock-cells = <1>;
 		};
 
+		mdp_camin@14000000 {
+			compatible = "mediatek,mt8183-mdp-dl";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14000000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0 0x1000>;
+			clocks = <&mmsys CLK_MM_MDP_DL_TXCK>,
+				<&mmsys CLK_MM_MDP_DL_RX>;
+		};
+
+		mdp_camin2@14000000 {
+			compatible = "mediatek,mt8183-mdp-dl";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14000000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0 0x1000>;
+			clocks = <&mmsys CLK_MM_IPU_DL_TXCK>,
+				<&mmsys CLK_MM_IPU_DL_RX>;
+		};
+
+		mdp_rdma0: mdp_rdma0@14001000 {
+			compatible = "mediatek,mt8183-mdp-rdma",
+				     "mediatek,mt8183-mdp3";
+			mediatek,vpu = <&vpu>;
+			mediatek,scp = <&scp>;
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14001000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x1000 0x1000>;
+			power-domains = <&scpsys MT8183_POWER_DOMAIN_DISP>;
+			clocks = <&mmsys CLK_MM_MDP_RDMA0>,
+				<&mmsys CLK_MM_MDP_RSZ1>;
+			iommus = <&iommu M4U_PORT_MDP_RDMA0>;
+			mediatek,larb = <&larb0>;
+			mediatek,mmsys = <&mmsys>;
+			mediatek,mm-mutex = <&mutex>;
+			mediatek,mailbox-gce = <&gce>;
+			mdp_rsz0 = <&mdp_rsz0>;
+			mdp_rsz1 = <&mdp_rsz1>;
+			mdp_wrot0 = <&mdp_wrot0>;
+			mdp_wdma0 = <&mdp_wdma>;
+			mdp_ccorr0 = <&mdp_ccorr>;
+			mboxes = <&gce 20 0 CMDQ_THR_PRIO_LOWEST>,
+				<&gce 21 0 CMDQ_THR_PRIO_LOWEST>,
+				<&gce 22 0 CMDQ_THR_PRIO_LOWEST>,
+				<&gce 23 0 CMDQ_THR_PRIO_LOWEST>;
+			gce-subsys = <&gce 0x14000000 SUBSYS_1400XXXX>,
+				<&gce 0x14010000 SUBSYS_1401XXXX>,
+				<&gce 0x14020000 SUBSYS_1402XXXX>,
+				<&gce 0x15020000 SUBSYS_1502XXXX>;
+			mediatek,gce-events = <CMDQ_EVENT_MDP_RDMA0_SOF>,
+				<CMDQ_EVENT_MDP_RDMA0_EOF>,
+				<CMDQ_EVENT_MDP_RSZ0_SOF>,
+				<CMDQ_EVENT_MDP_RSZ1_SOF>,
+				<CMDQ_EVENT_MDP_TDSHP_SOF>,
+				<CMDQ_EVENT_MDP_WROT0_SOF>,
+				<CMDQ_EVENT_MDP_WROT0_EOF>,
+				<CMDQ_EVENT_MDP_WDMA0_SOF>,
+				<CMDQ_EVENT_MDP_WDMA0_EOF>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_0>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_1>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_2>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_3>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_4>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_5>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_6>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_7>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_8>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_9>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_10>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_11>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_12>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_13>,
+				<CMDQ_EVENT_ISP_FRAME_DONE_P2_14>,
+				<CMDQ_EVENT_WPE_A_DONE>,
+				<CMDQ_EVENT_SPE_B_DONE>;
+		};
+
+		mdp_imgi@15020000 {
+			compatible = "mediatek,mt8183-mdp-imgi";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x15020000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce SUBSYS_1502XXXX 0 0x1000>;
+		};
+
+		mdp_img2o@15020000 {
+			compatible = "mediatek,mt8183-mdp-exto";
+			mediatek,mdp-id = <1>;
+		};
+
+		mdp_rsz0: mdp_rsz0@14003000 {
+			compatible = "mediatek,mt8183-mdp-rsz";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14003000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x3000 0x1000>;
+			clocks = <&mmsys CLK_MM_MDP_RSZ0>;
+		};
+
+		mdp_rsz1: mdp_rsz1@14004000 {
+			compatible = "mediatek,mt8183-mdp-rsz";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14004000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x4000 0x1000>;
+			clocks = <&mmsys CLK_MM_MDP_RSZ1>;
+		};
+
+		mdp_wrot0: mdp_wrot0@14005000 {
+			compatible = "mediatek,mt8183-mdp-wrot";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14005000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x5000 0x1000>;
+			clocks = <&mmsys CLK_MM_MDP_WROT0>;
+			iommus = <&iommu M4U_PORT_MDP_WROT0>;
+			mediatek,larb = <&larb0>;
+		};
+
+		mdp_path0_sout@14005000 {
+			compatible = "mediatek,mt8183-mdp-path";
+			mediatek,mdp-id = <0>;
+		};
+
+		mdp_wdma: mdp_wdma@14006000 {
+			compatible = "mediatek,mt8183-mdp-wdma";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14006000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x6000 0x1000>;
+			clocks = <&mmsys CLK_MM_MDP_WDMA0>;
+			iommus = <&iommu M4U_PORT_MDP_WDMA0>;
+			mediatek,larb = <&larb0>;
+		};
+
+		mdp_path1_sout@14006000 {
+			compatible = "mediatek,mt8183-mdp-path";
+			mediatek,mdp-id = <1>;
+		};
+
 		display_components: dispsys@14000000 {
 			compatible = "mediatek,mt8183-display";
 			reg = <0 0x14000000 0 0x1000>;
@@ -1612,9 +1878,21 @@
 			phy-names = "dphy";
 		};
 
+		dpi0: dpi@14015000 {
+			compatible = "mediatek,mt8183-dpi";
+			reg = <0 0x14015000 0 0x1000>;
+			interrupts = <GIC_SPI 237 IRQ_TYPE_LEVEL_LOW>;
+			power-domains = <&scpsys MT8183_POWER_DOMAIN_DISP>;
+			clocks = <&mmsys CLK_MM_DPI_IF>,
+				 <&mmsys CLK_MM_DPI_MM>,
+				 <&apmixedsys CLK_APMIXED_TVDPLL>;
+			clock-names = "pixel", "engine", "pll";
+		};
+
 		mutex: mutex@14016000 {
 			compatible = "mediatek,mt8183-disp-mutex";
 			reg = <0 0x14016000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce SUBSYS_1401XXXX 0x6000 0x1000>;
 			interrupts = <GIC_SPI 217 IRQ_TYPE_LEVEL_LOW>;
 			power-domains = <&scpsys MT8183_POWER_DOMAIN_DISP>;
 		};
@@ -1640,12 +1918,37 @@
 			power-domains = <&scpsys MT8183_POWER_DOMAIN_DISP>;
 		};
 
+		mdp_ccorr: mdp_ccorr@1401c000 {
+			compatible = "mediatek,mt8183-mdp-ccorr";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x1401c000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce SUBSYS_1401XXXX 0xc000 0x1000>;
+			clocks = <&mmsys CLK_MM_MDP_CCORR>;
+		};
+
 		imgsys: syscon@15020000 {
 			compatible = "mediatek,mt8183-imgsys", "syscon";
 			reg = <0 0x15020000 0 0x1000>;
 			#clock-cells = <1>;
 		};
 
+		dip: dip@15022000 {
+			compatible = "mediatek,mt8183-dip";
+			mediatek,larb = <&larb5>;
+			mediatek,mdp3 = <&mdp_rdma0>;
+			mediatek,scp = <&scp>;
+			iommus = <&iommu M4U_PORT_CAM_IMGI>;
+			reg = <0 0x15022000 0 0x6000>;
+			interrupts = <GIC_SPI 268 IRQ_TYPE_LEVEL_LOW>;
+			clocks =
+					<&imgsys CLK_IMG_LARB5>,
+					<&imgsys CLK_IMG_DIP>;
+			clock-names =
+					"DIP_CG_IMG_LARB5",
+					"DIP_CG_IMG_DIP";
+			memory-region = <&dip_mem_reserved>;
+		};
+
 		larb5: larb@15021000 {
 			compatible = "mediatek,mt8183-smi-larb";
 			reg = <0 0x15021000 0 0x1000>;
@@ -1656,6 +1959,19 @@
 			power-domains = <&scpsys MT8183_POWER_DOMAIN_ISP>;
 		};
 
+		fd:fd@1502b000 {
+			compatible = "mediatek,mt8183-fd";
+			mediatek,larb = <&larb5>;
+			mediatek,scp = <&scp>;
+			iommus = <&iommu M4U_PORT_CAM_FDVT_RP>,
+				 <&iommu M4U_PORT_CAM_FDVT_WR>,
+				 <&iommu M4U_PORT_CAM_FDVT_RB>;
+			reg = <0 0x1502b000 0 0x1000>;
+			interrupts = <GIC_SPI 269 IRQ_TYPE_LEVEL_LOW>;
+			clocks = <&imgsys CLK_IMG_FDVT>;
+			clock-names = "FD_CLK_IMG_FD";
+		};
+
 		larb2: larb@1502f000 {
 			compatible = "mediatek,mt8183-smi-larb";
 			reg = <0 0x1502f000 0 0x1000>;
@@ -1727,6 +2043,29 @@
 			#clock-cells = <1>;
 		};
 
+		camisp: camisp@1a000000 {
+			compatible = "mediatek,mt8183-camisp", "syscon";
+			reg = <0 0x1a000000 0 0x1000>,
+			      <0 0x1a003000 0 0x1000>,
+			      <0 0x1a004000 0 0x2000>,
+			      <0 0x1a006000 0 0x2000>;
+			reg-names = "cam_sys",
+				    "cam_uni",
+				    "cam_a",
+				    "cam_b";
+			interrupts = <GIC_SPI 253 IRQ_TYPE_LEVEL_LOW>,
+				     <GIC_SPI 254 IRQ_TYPE_LEVEL_LOW>,
+				     <GIC_SPI 255 IRQ_TYPE_LEVEL_LOW>;
+			iommus = <&iommu M4U_PORT_CAM_IMGO>;
+			clocks = <&camsys CLK_CAM_CAM>,
+				 <&camsys CLK_CAM_CAMTG>;
+			clock-names = "camsys_cam_cgpdn",
+				      "camsys_camtg_cgpdn";
+			mediatek,larb = <&larb3>,
+					<&larb6>;
+			mediatek,scp = <&scp>;
+		};
+
 		larb6: larb@1a001000 {
 			compatible = "mediatek,mt8183-smi-larb";
 			reg = <0 0x1a001000 0 0x1000>;
@@ -1746,5 +2085,19 @@
 			clock-names = "apb", "smi", "gals";
 			power-domains = <&scpsys MT8183_POWER_DOMAIN_CAM>;
 		};
+
+	seninf: seninf@1a040000 {
+		compatible = "mediatek,mt8183-seninf";
+		reg = <0 0x1a040000 0 0x8000>,
+		      <0 0x11C80000 0 0x6000>;
+		reg-names = "base_reg", "rx_reg";
+		interrupts = <GIC_SPI 251 IRQ_TYPE_LEVEL_LOW>;
+		power-domains = <&scpsys MT8183_POWER_DOMAIN_CAM>;
+		clocks =
+				<&camsys CLK_CAM_SENINF>, <&topckgen CLK_TOP_MUX_SENINF>;
+		clock-names =
+			"CLK_CAM_SENINF", "CLK_TOP_MUX_SENINF";
+		status = "disabled";
+		};
 	};
 };
diff --git a/arch/arm64/mm/dma-mapping.c b/arch/arm64/mm/dma-mapping.c
index f4d5765940a3..aa86b84bdb86 100644
--- a/arch/arm64/mm/dma-mapping.c
+++ b/arch/arm64/mm/dma-mapping.c
@@ -37,6 +37,9 @@ static int swiotlb __ro_after_init;
 static pgprot_t __get_dma_pgprot(unsigned long attrs, pgprot_t prot,
 				 bool coherent)
 {
+	if (attrs & DMA_ATTR_NON_CONSISTENT)
+		return prot;
+
 	if (!coherent || (attrs & DMA_ATTR_WRITE_COMBINE))
 		return pgprot_writecombine(prot);
 	return prot;
diff --git a/chromeos/config/arm64/chromiumos-arm64.flavour.config b/chromeos/config/arm64/chromiumos-arm64.flavour.config
index d69d671119a9..2a9b2cc437db 100644
--- a/chromeos/config/arm64/chromiumos-arm64.flavour.config
+++ b/chromeos/config/arm64/chromiumos-arm64.flavour.config
@@ -49,6 +49,7 @@ CONFIG_DRM_TI_SN65DSI86=y
 CONFIG_DRM_VIRTIO_GPU=y
 # CONFIG_DWMAC_IPQ806X is not set
 CONFIG_DW_WATCHDOG=y
+CONFIG_DYNAMIC_DEBUG=y
 CONFIG_EDAC=y
 # CONFIG_EDAC_LEGACY_SYSFS is not set
 CONFIG_EDAC_QCOM=y
@@ -67,7 +68,9 @@ CONFIG_I2C_RK3X=y
 CONFIG_INTERCONNECT=y
 CONFIG_INTERCONNECT_QCOM=y
 CONFIG_INTERCONNECT_QCOM_SDM845=y
+CONFIG_MEDIATEK_MT6577_AUXADC=y
 CONFIG_MEDIATEK_WATCHDOG=y
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
 CONFIG_MFD_PALMAS=y
 CONFIG_MFD_RK808=y
 CONFIG_MFD_SPMI_PMIC=y
@@ -77,11 +80,14 @@ CONFIG_MMC_MTK=y
 CONFIG_MMC_SDHCI_MSM=y
 CONFIG_MSM_GCC_8916=y
 CONFIG_MTD_MT81xx_NOR=y
-CONFIG_MTK_CMDQ=y
+CONFIG_MTK_CMDQ_DEBUG=y
+CONFIG_MTK_CMDQ_DEBUG_SOC=8183
 CONFIG_MTK_EFUSE=y
+CONFIG_MTK_EMI_MBW=y
 CONFIG_MTK_IOMMU=y
 CONFIG_MTK_PMIC_WRAP=y
-CONFIG_MTK_SCP=m
+CONFIG_MTK_SCP=y
+CONFIG_MTK_SENINF=y
 CONFIG_MWIFIEX_PCIE=m
 CONFIG_MWIFIEX_SDIO=m
 CONFIG_PCI=y
@@ -192,11 +198,24 @@ CONFIG_SPI_ROCKCHIP=y
 CONFIG_SPMI=y
 CONFIG_STMMAC_ETH=m
 CONFIG_TOUCHSCREEN_MELFAS_MIP4=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_SERIAL=y
 CONFIG_USB_MTU3=y
-CONFIG_USB_MTU3_HOST=y
+CONFIG_USB_MTU3_DEBUG=y
 CONFIG_USB_ULPI=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_DW9768=y
+CONFIG_VIDEO_MEDIATEK_FD_SUPPORT=y
+CONFIG_VIDEO_MEDIATEK_ISP_DIP_SUPPORT=y
+CONFIG_VIDEO_MEDIATEK_ISP_PASS1=y
 CONFIG_VIDEO_MEDIATEK_MDP=y
+CONFIG_VIDEO_MEDIATEK_MDP3=y
 CONFIG_VIDEO_MEDIATEK_VCODEC=y
+CONFIG_VIDEO_OV02A10=y
+CONFIG_VIDEO_OV2685=y
+CONFIG_VIDEO_OV5695=y
+CONFIG_VIDEO_OV8856=y
 CONFIG_VIRTIO_BLK=y
 CONFIG_VIRTIO_CONSOLE=y
 CONFIG_VIRTIO_INPUT=y
diff --git a/chromeos/config/arm64/chromiumos-mediatek.flavour.config b/chromeos/config/arm64/chromiumos-mediatek.flavour.config
index 77c307ba18f0..0ef4ae92f13c 100644
--- a/chromeos/config/arm64/chromiumos-mediatek.flavour.config
+++ b/chromeos/config/arm64/chromiumos-mediatek.flavour.config
@@ -28,10 +28,13 @@ CONFIG_CROS_EC_RPMSG=m
 CONFIG_DEVFREQ_GOV_PASSIVE=y
 CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
 CONFIG_DRM_ANALOGIX_ANX78XX=y
+CONFIG_DRM_ITE_IT6505=y
 CONFIG_DRM_MEDIATEK=y
 CONFIG_DRM_MEDIATEK_HDMI=y
 CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=y
 CONFIG_DRM_PANEL_INNOLUX_P079ZCA=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_EEPROM_AT24=y
 # CONFIG_EFI is not set
 CONFIG_ENERGY_MODEL=y
 CONFIG_EXTCON=y
@@ -41,16 +44,20 @@ CONFIG_MALI_DMA_FENCE=y
 CONFIG_MALI_EXPERT=y
 CONFIG_MALI_MIDGARD=y
 CONFIG_MALI_PLATFORM_NAME="mediatek"
+CONFIG_MEDIATEK_MT6577_AUXADC=y
 CONFIG_MEDIATEK_WATCHDOG=y
-CONFIG_MEDIA_CONTROLLER=y
 CONFIG_MEDIA_CONTROLLER_REQUEST_API=y
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
 CONFIG_MMC_MTK=y
 CONFIG_MTD_MT81xx_NOR=y
-CONFIG_MTK_CMDQ=y
+CONFIG_MTK_CMDQ_DEBUG=y
+CONFIG_MTK_CMDQ_DEBUG_SOC=8183
 CONFIG_MTK_EFUSE=y
+CONFIG_MTK_EMI_MBW=y
 CONFIG_MTK_IOMMU=y
 CONFIG_MTK_PMIC_WRAP=y
-CONFIG_MTK_SCP=m
+CONFIG_MTK_SCP=y
+CONFIG_MTK_SENINF=y
 CONFIG_PHY_MTK_TPHY=y
 # CONFIG_PINCTRL_MT2712 is not set
 # CONFIG_PINCTRL_MT6397 is not set
@@ -78,7 +85,19 @@ CONFIG_SPI_MT65XX=y
 CONFIG_STAGING_MEDIA=y
 CONFIG_TCG_CR50_I2C=y
 CONFIG_TMPFS=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_SERIAL=y
 CONFIG_USB_MTU3=y
-CONFIG_USB_MTU3_HOST=y
-CONFIG_VIDEO_MEDIATEK_MDP=y
+CONFIG_USB_MTU3_DEBUG=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_DW9768=y
+CONFIG_VIDEO_MEDIATEK_FD_SUPPORT=y
+CONFIG_VIDEO_MEDIATEK_ISP_DIP_SUPPORT=y
+CONFIG_VIDEO_MEDIATEK_ISP_PASS1=y
+CONFIG_VIDEO_MEDIATEK_MDP3=y
 CONFIG_VIDEO_MEDIATEK_VCODEC=y
+CONFIG_VIDEO_OV02A10=y
+CONFIG_VIDEO_OV2685=y
+CONFIG_VIDEO_OV5695=y
+CONFIG_VIDEO_OV8856=y
diff --git a/chromeos/config/arm64/common.config b/chromeos/config/arm64/common.config
index aa1125ebaf46..b330923bab0f 100644
--- a/chromeos/config/arm64/common.config
+++ b/chromeos/config/arm64/common.config
@@ -51,13 +51,14 @@ CONFIG_HARDLOCKUP_DETECTOR_BUDDY_CPU=y
 CONFIG_HID_RMI=m
 CONFIG_I2C_CHARDEV=y
 CONFIG_I2C_CROS_EC_TUNNEL=y
-CONFIG_IIO=m
+CONFIG_IIO=y
 CONFIG_IIO_CROS_EC_ACTIVITY=m
 CONFIG_IIO_CROS_EC_BARO=m
 CONFIG_IIO_CROS_EC_LIGHT_PROX=m
 CONFIG_IIO_CROS_EC_SENSORS=m
 CONFIG_IIO_CROS_EC_SENSORS_RING=m
 CONFIG_IIO_CROS_EC_SENSORS_SYNC=m
+CONFIG_IIO_SYSFS_TRIGGER=y
 # CONFIG_KEYBOARD_ATKBD is not set
 CONFIG_KEYBOARD_GPIO=y
 CONFIG_MAC80211_DEBUGFS=y
diff --git a/chromeos/config/armel/common.config b/chromeos/config/armel/common.config
index d742b8676277..81701344992c 100644
--- a/chromeos/config/armel/common.config
+++ b/chromeos/config/armel/common.config
@@ -64,6 +64,7 @@ CONFIG_I2C_HID=m
 CONFIG_I2C_RK3X=y
 CONFIG_IIO=y
 CONFIG_IIO_CROS_EC_ACCEL_LEGACY=m
+CONFIG_IIO_SYSFS_TRIGGER=m
 CONFIG_KERNEL_MODE_NEON=y
 # CONFIG_KEYBOARD_ATKBD is not set
 CONFIG_KEYBOARD_GPIO=y
diff --git a/chromeos/config/base.config b/chromeos/config/base.config
index 409e0802ed35..c9001fb33a45 100644
--- a/chromeos/config/base.config
+++ b/chromeos/config/base.config
@@ -124,7 +124,6 @@ CONFIG_HW_RANDOM=y
 CONFIG_HZ_1000=y
 CONFIG_I2C_STUB=m
 CONFIG_IIO_CROS_EC_SENSORS_CORE=m
-CONFIG_IIO_SYSFS_TRIGGER=m
 CONFIG_IKCONFIG=m
 CONFIG_IKCONFIG_PROC=y
 CONFIG_INET=y
diff --git a/chromeos/config/x86_64/common.config b/chromeos/config/x86_64/common.config
index 08da32adcd37..38297186a10b 100644
--- a/chromeos/config/x86_64/common.config
+++ b/chromeos/config/x86_64/common.config
@@ -77,6 +77,7 @@ CONFIG_IIO_CROS_EC_SENSORS=m
 CONFIG_IIO_CROS_EC_SENSORS_LID_ANGLE=m
 CONFIG_IIO_CROS_EC_SENSORS_RING=m
 CONFIG_IIO_CROS_EC_SENSORS_SYNC=m
+CONFIG_IIO_SYSFS_TRIGGER=m
 CONFIG_INT340X_THERMAL=y
 CONFIG_INTEL_VBTN=m
 CONFIG_IO_DELAY_0XED=y
diff --git a/drivers/clk/mediatek/Makefile b/drivers/clk/mediatek/Makefile
index 3dc1b9f15ea2..5df0e476e94d 100644
--- a/drivers/clk/mediatek/Makefile
+++ b/drivers/clk/mediatek/Makefile
@@ -44,3 +44,5 @@ obj-$(CONFIG_COMMON_CLK_MT8183_MFGCFG) += clk-mt8183-mfgcfg.o
 obj-$(CONFIG_COMMON_CLK_MT8183_MMSYS) += clk-mt8183-mm.o
 obj-$(CONFIG_COMMON_CLK_MT8183_VDECSYS) += clk-mt8183-vdec.o
 obj-$(CONFIG_COMMON_CLK_MT8183_VENCSYS) += clk-mt8183-venc.o
+obj-$(CONFIG_COMMON_CLK_MT8183) += clkdbg.o clkdbg-mt8183.o
+obj-$(CONFIG_COMMON_CLK_MT8183) += clkchk.o clkchk-mt8183.o
diff --git a/drivers/clk/mediatek/clk-mt8183.c b/drivers/clk/mediatek/clk-mt8183.c
index e749f40660a2..de22ba0b372a 100644
--- a/drivers/clk/mediatek/clk-mt8183.c
+++ b/drivers/clk/mediatek/clk-mt8183.c
@@ -1001,6 +1001,25 @@ static const struct mtk_gate infra_clks[] = {
 		"msdc50_0_sel", 24),
 };
 
+static const struct mtk_gate_regs peri_cg_regs = {
+	.set_ofs = 0x20c,
+	.clr_ofs = 0x20c,
+	.sta_ofs = 0x20c,
+};
+
+#define GATE_PERI(_id, _name, _parent, _shift) {        \
+	.id = _id,                              \
+	.name = _name,                          \
+	.parent_name = _parent,                 \
+	.regs = &peri_cg_regs,                  \
+	.shift = _shift,                        \
+	.ops = &mtk_clk_gate_ops_no_setclr_inv, \
+}
+
+static const struct mtk_gate peri_clks[] = {
+	GATE_PERI(CLK_PERIAXI, "periaxi", "axi_sel", 31),
+};
+
 static const struct mtk_gate_regs apmixed_cg_regs = {
 	.set_ofs = 0x20,
 	.clr_ofs = 0x20,
@@ -1224,6 +1243,25 @@ static int clk_mt8183_infra_probe(struct platform_device *pdev)
 	return r;
 }
 
+static int clk_mt8183_peri_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+
+	clk_data = mtk_alloc_clk_data(CLK_PERI_NR_CLK);
+
+	mtk_clk_register_gates(node, peri_clks, ARRAY_SIZE(peri_clks),
+		clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+	if (r)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	return r;
+}
+
 static int clk_mt8183_mcu_probe(struct platform_device *pdev)
 {
 	struct clk_onecell_data *clk_data;
@@ -1254,6 +1292,9 @@ static const struct of_device_id of_match_clk_mt8183[] = {
 		.compatible = "mediatek,mt8183-infracfg",
 		.data = clk_mt8183_infra_probe,
 	}, {
+		.compatible = "mediatek,mt8183-pericfg",
+		.data = clk_mt8183_peri_probe,
+	},  {
 		.compatible = "mediatek,mt8183-mcucfg",
 		.data = clk_mt8183_mcu_probe,
 	}, {
diff --git a/drivers/clk/mediatek/clkchk-mt8183.c b/drivers/clk/mediatek/clkchk-mt8183.c
new file mode 100644
index 000000000000..c7b081fbc44b
--- /dev/null
+++ b/drivers/clk/mediatek/clkchk-mt8183.c
@@ -0,0 +1,387 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2018 MediaTek Inc.
+// Author: Weiyi Lu <weiyi.lu@mediatek.com>
+
+#include <linux/module.h>
+#include "clkchk.h"
+
+static const char * const off_pll_names[] = {
+	"univ2pll",
+	"msdcpll",
+	"mmpll",
+	"mfgpll",
+	"tvdpll",
+	"apll1",
+	"apll2",
+	NULL
+};
+
+static const char * const all_clk_names[] = {
+	"univ2pll",
+	"msdcpll",
+	"mmpll",
+	"mfgpll",
+	"tvdpll",
+	"apll1",
+	"apll2",
+	"apmixed_ssusb26m",
+	"apmixed_mipic026m",
+	"apmixed_mdpll26m",
+	"apmixed_mmsys26m",
+	"apmixed_ufs26m",
+	"apmixed_mipic126m",
+	"apmixed_mempll26m",
+	"apmixed_lvpll26m",
+	"apmixed_mipid026m",
+	"apmixed_mipid126m",
+	"syspll_d3",
+	"syspll_d5",
+	"syspll_d2_d2",
+	"syspll_d2_d4",
+	"syspll_d2_d16",
+	"syspll_d3_d2",
+	"syspll_d3_d4",
+	"syspll_d3_d8",
+	"syspll_d5_d2",
+	"syspll_d5_d4",
+	"syspll_d7_d2",
+	"syspll_d7_d4",
+	"univpll_ck",
+	"univpll_d2",
+	"univpll_d3",
+	"univpll_d5",
+	"univpll_d7",
+	"univpll_d2_d2",
+	"univpll_d2_d4",
+	"univpll_d2_d8",
+	"univpll_d3_d2",
+	"univpll_d3_d4",
+	"univpll_d3_d8",
+	"univpll_d5_d2",
+	"univpll_d5_d4",
+	"univpll_d5_d8",
+	"apll1_ck",
+	"apll1_d2",
+	"apll1_d4",
+	"apll1_d8",
+	"apll2_ck",
+	"apll2_d2",
+	"apll2_d4",
+	"apll2_d8",
+	"tvdpll_ck",
+	"tvdpll_d2",
+	"tvdpll_d4",
+	"tvdpll_d8",
+	"tvdpll_d16",
+	"msdcpll_ck",
+	"msdcpll_d2",
+	"msdcpll_d4",
+	"msdcpll_d8",
+	"msdcpll_d16",
+	"ad_osc_ck",
+	"osc_d2",
+	"osc_d4",
+	"osc_d8",
+	"osc_d16",
+	"csw_f26m_ck_d2",
+	"mfgpll_ck",
+	"univ_192m_ck",
+	"univ_192m_d2",
+	"univ_192m_d4",
+	"univ_192m_d8",
+	"univ_192m_d16",
+	"univ_192m_d32",
+	"mmpll_ck",
+	"mmpll_d4",
+	"mmpll_d4_d2",
+	"mmpll_d4_d4",
+	"mmpll_d5",
+	"mmpll_d5_d2",
+	"mmpll_d5_d4",
+	"mmpll_d6",
+	"mmpll_d7",
+	"osc",
+	"univpll_192m",
+	"apll_i2s0_sel",
+	"apll_i2s1_sel",
+	"apll_i2s2_sel",
+	"apll_i2s3_sel",
+	"apll_i2s4_sel",
+	"apll_i2s5_sel",
+	"apll12_div0",
+	"apll12_div1",
+	"apll12_div2",
+	"apll12_div3",
+	"apll12_div4",
+	"apll12_divb",
+	"univpll",
+	"armpll_div_pll2",
+	"mm_sel",
+	"cam_sel",
+	"mfg_sel",
+	"camtg_sel",
+	"spi_sel",
+	"msdc50_hclk_sel",
+	"msdc50_0_sel",
+	"msdc30_1_sel",
+	"msdc30_2_sel",
+	"audio_sel",
+	"aud_intbus_sel",
+	"fpwrap_ulposc_sel",
+	"scp_sel",
+	"atb_sel",
+	"sspm_sel",
+	"dpi0_sel",
+	"scam_sel",
+	"aud_1_sel",
+	"aud_2_sel",
+	"disppwm_sel",
+	"ssusb_top_xhci_sel",
+	"usb_top_sel",
+	"i2c_sel",
+	"f52m_mfg_sel",
+	"seninf_sel",
+	"dxcc_sel",
+	"camtg2_sel",
+	"aud_eng1_sel",
+	"aud_eng2_sel",
+	"faes_ufsfde_sel",
+	"fufs_sel",
+	"img_sel",
+	"dsp_sel",
+	"dsp1_sel",
+	"dsp2_sel",
+	"ipu_if_sel",
+	"camtg3_sel",
+	"camtg4_sel",
+	"mcu_mp0_sel",
+	"mcu_mp2_sel",
+	"mcu_bus_sel",
+	"infra_pmic_tmr",
+	"infra_pmic_md",
+	"infra_pmic_conn",
+	"infra_scp",
+	"infra_sej",
+	"infra_apxgpt",
+	"infra_icusb",
+	"infra_gce",
+	"infra_therm",
+	"infra_i2c0",
+	"infra_i2c1",
+	"infra_i2c2",
+	"infra_i2c3",
+	"infra_pwm_hclk",
+	"infra_pwm1",
+	"infra_pwm2",
+	"infra_pwm3",
+	"infra_pwm4",
+	"infra_pwm",
+	"infra_uart1",
+	"infra_uart2",
+	"infra_uart3",
+	"infra_gce_26m",
+	"infra_cqdma_fpc",
+	"infra_btif",
+	"infra_spi0",
+	"infra_msdc0",
+	"infra_msdc1",
+	"infra_msdc2",
+	"infra_msdc0_sck",
+	"infra_dvfsrc",
+	"infra_gcpu",
+	"infra_trng",
+	"infra_auxadc",
+	"infra_cpum",
+	"infra_ccif1_ap",
+	"infra_ccif1_md",
+	"infra_auxadc_md",
+	"infra_msdc1_sck",
+	"infra_msdc2_sck",
+	"infra_apdma",
+	"infra_xiu",
+	"infra_device_apc",
+	"infra_ccif_ap",
+	"infra_debugsys",
+	"infra_audio",
+	"infra_ccif_md",
+	"infra_dxcc_sec_core",
+	"infra_dxcc_ao",
+	"infra_dramc_f26m",
+	"infra_irtx",
+	"infra_disppwm",
+	"infra_cldma_bclk",
+	"infra_audio_26m_bclk",
+	"infra_spi1",
+	"infra_i2c4",
+	"infra_md_tmp_share",
+	"infra_spi2",
+	"infra_spi3",
+	"infra_unipro_sck",
+	"infra_unipro_tick",
+	"infra_ufs_mp_sap_bck",
+	"infra_md32_bclk",
+	"infra_sspm",
+	"infra_unipro_mbist",
+	"infra_sspm_bus_hclk",
+	"infra_i2c5",
+	"infra_i2c5_arbiter",
+	"infra_i2c5_imm",
+	"infra_i2c1_arbiter",
+	"infra_i2c1_imm",
+	"infra_i2c2_arbiter",
+	"infra_i2c2_imm",
+	"infra_spi4",
+	"infra_spi5",
+	"infra_cqdma",
+	"infra_ufs",
+	"infra_aes_ufsfde",
+	"infra_ufs_tick",
+	"infra_msdc0_self",
+	"infra_msdc1_self",
+	"infra_msdc2_self",
+	"infra_sspm_26m_self",
+	"infra_sspm_32k_self",
+	"infra_ufs_axi",
+	"infra_i2c6",
+	"infra_ap_msdc0",
+	"infra_md_msdc0",
+	"infra_usb",
+	"infra_devmpu_bclk",
+	"infra_ccif2_ap",
+	"infra_ccif2_md",
+	"infra_ccif3_ap",
+	"infra_ccif3_md",
+	"infra_sej_f13m",
+	"infra_aes_bclk",
+	"infra_i2c7",
+	"infra_i2c8",
+	"infra_fbist2fpc",
+	"aud_tml",
+	"aud_dac_predis",
+	"aud_dac",
+	"aud_adc",
+	"aud_apll_tuner",
+	"aud_apll2_tuner",
+	"aud_24m",
+	"aud_22m",
+	"aud_afe",
+	"aud_i2s4",
+	"aud_i2s3",
+	"aud_i2s2",
+	"aud_i2s1",
+	"aud_pdn_adda6_adc",
+	"aud_tdm",
+	"mfg_bg3d",
+	"mm_smi_common",
+	"mm_smi_larb0",
+	"mm_smi_larb1",
+	"mm_gals_comm0",
+	"mm_gals_comm1",
+	"mm_gals_ccu2mm",
+	"mm_gals_ipu12mm",
+	"mm_gals_img2mm",
+	"mm_gals_cam2mm",
+	"mm_gals_ipu2mm",
+	"mm_mdp_dl_txck",
+	"mm_ipu_dl_txck",
+	"mm_mdp_rdma0",
+	"mm_mdp_rdma1",
+	"mm_mdp_rsz0",
+	"mm_mdp_rsz1",
+	"mm_mdp_tdshp",
+	"mm_mdp_wrot0",
+	"mm_fake_eng",
+	"mm_disp_ovl0",
+	"mm_disp_ovl0_2l",
+	"mm_disp_ovl1_2l",
+	"mm_disp_rdma0",
+	"mm_disp_rdma1",
+	"mm_disp_wdma0",
+	"mm_disp_color0",
+	"mm_disp_ccorr0",
+	"mm_disp_aal0",
+	"mm_disp_gamma0",
+	"mm_disp_dither0",
+	"mm_disp_split",
+	"mm_dsi0_mm",
+	"mm_dsi0_if",
+	"mm_dpi_mm",
+	"mm_dpi_if",
+	"mm_fake_eng2",
+	"mm_mdp_dl_rx",
+	"mm_ipu_dl_rx",
+	"mm_26m",
+	"mm_mmsys_r2y",
+	"mm_disp_rsz",
+	"mm_mdp_wdma0",
+	"mm_mdp_aal",
+	"mm_mdp_ccorr",
+	"mm_dbi_mm",
+	"mm_dbi_if",
+	"vdec_vdec",
+	"vdec_larb1",
+	"venc_larb",
+	"venc_venc",
+	"venc_jpgenc",
+	"img_owe",
+	"img_wpe_b",
+	"img_wpe_a",
+	"img_mfb",
+	"img_rsc",
+	"img_dpe",
+	"img_fdvt",
+	"img_dip",
+	"img_larb2",
+	"img_larb5",
+	"cam_larb6",
+	"cam_dfp_vad",
+	"cam_cam",
+	"cam_camtg",
+	"cam_seninf",
+	"cam_camsv0",
+	"cam_camsv1",
+	"cam_camsv2",
+	"cam_ccu",
+	"cam_larb3",
+	"ipu_conn_ipu",
+	"ipu_conn_ahb",
+	"ipu_conn_axi",
+	"ipu_conn_isp",
+	"ipu_conn_cam_adl",
+	"ipu_conn_img_adl",
+	"ipu_conn_dap_rx",
+	"ipu_conn_apb2axi",
+	"ipu_conn_apb2ahb",
+	"ipu_conn_ipu_cab1to2",
+	"ipu_conn_ipu1_cab1to2",
+	"ipu_conn_ipu2_cab1to2",
+	"ipu_conn_cab3to3",
+	"ipu_conn_cab2to1",
+	"ipu_conn_cab3to1_slice",
+	"ipu_adl_cabgen",
+	"ipu_core0_jtag",
+	"ipu_core0_axi",
+	"ipu_core0_ipu",
+	"ipu_core1_jtag",
+	"ipu_core1_axi",
+	"ipu_core1_ipu",
+	/* end */
+	NULL
+};
+
+static const char * const compatible[] = {"mediatek,mt8183", NULL};
+
+static struct clkchk_cfg_t cfg = {
+	.aee_excp_on_fail = false,
+	.warn_on_fail = true,
+	.compatible = compatible,
+	.off_pll_names = off_pll_names,
+	.all_clk_names = all_clk_names,
+};
+
+static int __init clkchk_platform_init(void)
+{
+	return clkchk_init(&cfg);
+}
+subsys_initcall(clkchk_platform_init);
diff --git a/drivers/clk/mediatek/clkchk.c b/drivers/clk/mediatek/clkchk.c
new file mode 100644
index 000000000000..d50110a0d538
--- /dev/null
+++ b/drivers/clk/mediatek/clkchk.c
@@ -0,0 +1,188 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2018 MediaTek Inc.
+// Author: Weiyi Lu <weiyi.lu@mediatek.com>
+
+#define pr_fmt(fmt) "[clkchk] " fmt
+
+#include <linux/clk-provider.h>
+#include <linux/syscore_ops.h>
+#include "clkchk.h"
+
+#define AEE_EXCP_CHECK_PLL_FAIL	0
+#define CLKDBG_CCF_API_4_4	1
+#define MAX_PLLS		32
+
+#if AEE_EXCP_CHECK_PLL_FAIL
+#include <mt-plat/aee.h>
+#endif
+
+#if !CLKDBG_CCF_API_4_4
+
+/* backward compatible */
+
+static const char *clk_hw_get_name(const struct clk_hw *hw)
+{
+	return __clk_get_name(hw->clk);
+}
+
+static bool clk_hw_is_prepared(const struct clk_hw *hw)
+{
+	return __clk_is_prepared(hw->clk);
+}
+
+static bool clk_hw_is_enabled(const struct clk_hw *hw)
+{
+	return __clk_is_enabled(hw->clk);
+}
+
+static unsigned long clk_hw_get_rate(const struct clk_hw *hw)
+{
+	return __clk_get_rate(hw->clk);
+}
+
+static struct clk_hw *clk_hw_get_parent(const struct clk_hw *hw)
+{
+	return __clk_get_hw(clk_get_parent(hw->clk));
+}
+
+#endif /* !CLKDBG_CCF_API_4_4 */
+
+static struct clkchk_cfg_t *clkchk_cfg;
+
+static const char *ccf_state(struct clk_hw *hw)
+{
+	if (__clk_get_enable_count(hw->clk))
+		return "enabled";
+
+	if (clk_hw_is_prepared(hw))
+		return "prepared";
+
+	return "disabled";
+}
+
+static void print_enabled_clks(void)
+{
+	const char * const *cn = clkchk_cfg->all_clk_names;
+
+	pr_warn("enabled clks:\n");
+
+	for (; *cn != NULL; cn++) {
+		struct clk *c = __clk_lookup(*cn);
+		struct clk_hw *c_hw = __clk_get_hw(c);
+		struct clk_hw *p_hw;
+
+		if (IS_ERR_OR_NULL(c) || c_hw == NULL)
+			continue;
+
+		p_hw = clk_hw_get_parent(c_hw);
+
+		if (p_hw == NULL)
+			continue;
+
+		if (!clk_hw_is_prepared(c_hw) &&
+			__clk_get_enable_count(c) <= 0U)
+			continue;
+
+		pr_warn("[%-17s: %8s, %3d, %3d, %10ld, %17s]\n",
+			clk_hw_get_name(c_hw),
+			ccf_state(c_hw),
+			clk_hw_is_prepared(c_hw),
+			__clk_get_enable_count(c),
+			clk_hw_get_rate(c_hw),
+			p_hw != NULL ? clk_hw_get_name(p_hw) : "- ");
+	}
+}
+
+static void check_pll_off(void)
+{
+	static struct clk *off_plls[MAX_PLLS];
+
+	struct clk **c;
+	int invalid = 0;
+	char buf[128] = {0};
+	int n = 0;
+
+	if (off_plls[0] == NULL) {
+		const char * const *pn = clkchk_cfg->off_pll_names;
+		struct clk **end = off_plls + MAX_PLLS - 1;
+
+		for (c = off_plls; *pn != NULL && c < end; pn++, c++)
+			*c = __clk_lookup(*pn);
+	}
+
+	for (c = off_plls; *c != NULL; c++) {
+		struct clk_hw *c_hw = __clk_get_hw(*c);
+
+		if (c_hw == NULL)
+			continue;
+
+		if (!clk_hw_is_prepared(c_hw) && !clk_hw_is_enabled(c_hw))
+			continue;
+
+		n += snprintf(buf + n, sizeof(buf) - (size_t)n, "%s ",
+				clk_hw_get_name(c_hw));
+
+		invalid++;
+	}
+
+	if (invalid == 0)
+		return;
+
+	/* invalid. output debug info */
+
+	pr_warn("unexpected unclosed PLL: %s\n", buf);
+	print_enabled_clks();
+
+#if AEE_EXCP_CHECK_PLL_FAIL
+	if (clkchk_cfg->aee_excp_on_fail)
+		aee_kernel_exception("clkchk", "unclosed PLL: %s\n", buf);
+#endif
+
+	if (clkchk_cfg->warn_on_fail)
+		WARN_ON(true);
+}
+
+static int clkchk_syscore_suspend(void)
+{
+	check_pll_off();
+
+	return 0;
+}
+
+static void clkchk_syscore_resume(void)
+{
+}
+
+static struct syscore_ops clkchk_syscore_ops = {
+	.suspend = clkchk_syscore_suspend,
+	.resume = clkchk_syscore_resume,
+};
+
+int clkchk_init(struct clkchk_cfg_t *cfg)
+{
+	const char * const *c;
+	bool match = false;
+
+	if (cfg == NULL || cfg->compatible == NULL
+		|| cfg->all_clk_names == NULL || cfg->off_pll_names == NULL) {
+		pr_warn("Invalid clkchk_cfg.\n");
+		return -EINVAL;
+	}
+
+	clkchk_cfg = cfg;
+
+	for (c = cfg->compatible; *c != NULL; c++) {
+		if (of_machine_is_compatible(*c) != 0) {
+			match = true;
+			break;
+		}
+	}
+
+	if (!match)
+		return -ENODEV;
+
+	register_syscore_ops(&clkchk_syscore_ops);
+
+	return 0;
+}
diff --git a/drivers/clk/mediatek/clkchk.h b/drivers/clk/mediatek/clkchk.h
new file mode 100644
index 000000000000..d99e1acb6477
--- /dev/null
+++ b/drivers/clk/mediatek/clkchk.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
+ */
+
+#include <stdbool.h>
+#include <stddef.h>
+
+struct clkchk_cfg_t {
+	bool aee_excp_on_fail;
+	bool warn_on_fail;
+	const char * const *compatible;
+	const char * const *off_pll_names;
+	const char * const *all_clk_names;
+};
+
+int clkchk_init(struct clkchk_cfg_t *cfg);
diff --git a/drivers/clk/mediatek/clkdbg-mt8183.c b/drivers/clk/mediatek/clkdbg-mt8183.c
new file mode 100644
index 000000000000..7b82ef2bce81
--- /dev/null
+++ b/drivers/clk/mediatek/clkdbg-mt8183.c
@@ -0,0 +1,865 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2018 MediaTek Inc.
+// Author: Weiyi Lu <weiyi.lu@mediatek.com>
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+
+#include "clkdbg.h"
+
+#define DUMP_INIT_STATE		0
+
+/*
+ * clkdbg dump_regs
+ */
+
+enum {
+	topckgen,
+	infracfg,
+	scpsys,
+	apmixedsys,
+	audiosys,
+	mfgsys,
+	mmsys,
+	imgsys,
+	camsys,
+	vencsys,
+};
+
+#define REGBASE_V(_phys, _id_name) { .phys = _phys, .name = #_id_name }
+
+/*
+ * checkpatch.pl ERROR:COMPLEX_MACRO
+ *
+ * #define REGBASE(_phys, _id_name) [_id_name] = REGBASE_V(_phys, _id_name)
+ */
+
+static struct regbase rb[] = {
+	[topckgen] = REGBASE_V(0x10000000, topckgen),
+	[infracfg] = REGBASE_V(0x10001000, infracfg),
+	[scpsys]   = REGBASE_V(0x10006000, scpsys),
+	[apmixedsys]  = REGBASE_V(0x1000c000, apmixedsys),
+	[audiosys]    = REGBASE_V(0x11220000, audiosys),
+	[mfgsys]   = REGBASE_V(0x13000000, mfgsys),
+	[mmsys]    = REGBASE_V(0x14000000, mmsys),
+	[imgsys]   = REGBASE_V(0x15020000, imgsys),
+	[camsys]   = REGBASE_V(0x1a000000, camsys),
+	[vencsys]  = REGBASE_V(0x17000000, vencsys),
+};
+
+#define REGNAME(_base, _ofs, _name)	\
+	{ .base = &rb[_base], .ofs = _ofs, .name = #_name }
+
+static struct regname rn[] = {
+	REGNAME(topckgen,  0x040, CLK_CFG_0),
+	REGNAME(topckgen,  0x050, CLK_CFG_1),
+	REGNAME(topckgen,  0x060, CLK_CFG_2),
+	REGNAME(topckgen,  0x070, CLK_CFG_3),
+	REGNAME(topckgen,  0x080, CLK_CFG_4),
+	REGNAME(topckgen,  0x090, CLK_CFG_5),
+	REGNAME(topckgen,  0x0a0, CLK_CFG_6),
+	REGNAME(topckgen,  0x0b0, CLK_CFG_7),
+	REGNAME(topckgen,  0x0c0, CLK_CFG_8),
+	REGNAME(topckgen,  0x0d0, CLK_CFG_9),
+	REGNAME(topckgen,  0x0e0, CLK_CFG_10),
+	REGNAME(audiosys,  0x000, AUDIO_TOP_CON0),
+	REGNAME(audiosys,  0x004, AUDIO_TOP_CON1),
+	REGNAME(camsys,  0x000, CAMSYS_CG),
+	REGNAME(imgsys,  0x000, IMG_CG),
+	REGNAME(infracfg,  0x090, MODULE_SW_CG_0),
+	REGNAME(infracfg,  0x094, MODULE_SW_CG_1),
+	REGNAME(infracfg,  0x0ac, MODULE_SW_CG_2),
+	REGNAME(infracfg,  0x0c8, MODULE_SW_CG_3),
+	REGNAME(mfgsys,  0x000, MFG_CG),
+	REGNAME(mmsys,	0x100, MMSYS_CG_CON0),
+	REGNAME(mmsys,	0x110, MMSYS_CG_CON1),
+	REGNAME(vencsys,  0x000, VENCSYS_CG),
+	REGNAME(apmixedsys,  0x200, ARMPLL_LL_CON0),
+	REGNAME(apmixedsys,  0x204, ARMPLL_LL_CON1),
+	REGNAME(apmixedsys,  0x20C, ARMPLL_LL_PWR_CON0),
+	REGNAME(apmixedsys,  0x210, ARMPLL_L_CON0),
+	REGNAME(apmixedsys,  0x214, ARMPLL_L_CON1),
+	REGNAME(apmixedsys,  0x21C, ARMPLL_L_PWR_CON0),
+	REGNAME(apmixedsys,  0x220, MAINPLL_CON0),
+	REGNAME(apmixedsys,  0x224, MAINPLL_CON1),
+	REGNAME(apmixedsys,  0x22C, MAINPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x230, UNIVPLL_CON0),
+	REGNAME(apmixedsys,  0x234, UNIVPLL_CON1),
+	REGNAME(apmixedsys,  0x23C, UNIVPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x240, MFGPLL_CON0),
+	REGNAME(apmixedsys,  0x244, MFGPLL_CON1),
+	REGNAME(apmixedsys,  0x24C, MFGPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x250, MSDCPLL_CON0),
+	REGNAME(apmixedsys,  0x254, MSDCPLL_CON1),
+	REGNAME(apmixedsys,  0x25C, MSDCPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x260, TVDPLL_CON0),
+	REGNAME(apmixedsys,  0x264, TVDPLL_CON1),
+	REGNAME(apmixedsys,  0x26C, TVDPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x270, MMPLL_CON0),
+	REGNAME(apmixedsys,  0x274, MMPLL_CON1),
+	REGNAME(apmixedsys,  0x27C, MMPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x280, MPLL_CON0),
+	REGNAME(apmixedsys,  0x284, MPLL_CON1),
+	REGNAME(apmixedsys,  0x28C, MPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x290, CCIPLL_CON0),
+	REGNAME(apmixedsys,  0x294, CCIPLL_CON1),
+	REGNAME(apmixedsys,  0x29C, CCIPLL_PWR_CON0),
+	REGNAME(apmixedsys,  0x2A0, APLL1_CON0),
+	REGNAME(apmixedsys,  0x2A4, APLL1_CON1),
+	REGNAME(apmixedsys,  0x2B0, APLL1_PWR_CON0),
+	REGNAME(apmixedsys,  0x2B4, APLL2_CON0),
+	REGNAME(apmixedsys,  0x2B8, APLL2_CON1),
+	REGNAME(apmixedsys,  0x2C4, APLL2_PWR_CON0),
+	REGNAME(scpsys,  0x0180, PWR_STATUS),
+	REGNAME(scpsys,  0x0184, PWR_STATUS_2ND),
+	REGNAME(scpsys,  0x0334, MFG_ASYNC_PWR_CON),
+	REGNAME(scpsys,  0x0338, MFG_PWR_CON),
+	REGNAME(scpsys,  0x033C, MFG_CORE0_PWR_CON),
+	REGNAME(scpsys,  0x0340, MFG_CORE1_PWR_CON),
+	REGNAME(scpsys,  0x0320, MD1_PWR_CON),
+	REGNAME(scpsys,  0x032C, CONN_PWR_CON),
+	REGNAME(scpsys,  0x0314, AUD_PWR_CON),
+	REGNAME(scpsys,  0x030C, DIS_PWR_CON),
+	REGNAME(scpsys,  0x0344, CAM_PWR_CON),
+	REGNAME(scpsys,  0x0308, ISP_PWR_CON),
+	REGNAME(scpsys,  0x0304, VEN_PWR_CON),
+	{}
+};
+
+static const struct regname *get_all_regnames(void)
+{
+	return rn;
+}
+
+static void __init init_regbase(void)
+{
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(rb); i++)
+		rb[i].virt = ioremap(rb[i].phys, PAGE_SIZE);
+}
+
+/*
+ * clkdbg fmeter
+ */
+
+#include <linux/delay.h>
+
+#define clk_readl(addr)		readl(addr)
+#define clk_writel(addr, val)	\
+	do { writel(val, addr); wmb(); } while (0) /* sync write */
+
+#define FMCLK(_t, _i, _n) { .type = _t, .id = _i, .name = _n }
+
+static const struct fmeter_clk fclks[] = {
+	FMCLK(CKGEN,  1, "hd_faxi_ck"),
+	FMCLK(CKGEN,  2, "hf_fmm_ck"),
+	FMCLK(CKGEN,  3, "hf_fimg_ck"),
+	FMCLK(CKGEN,  4, "hf_fcam_ck"),
+	FMCLK(CKGEN,  5, "hf_fdsp_ck"),
+	FMCLK(CKGEN,  6, "hf_fdsp1_ck"),
+	FMCLK(CKGEN,  7, "hf_fdsp2_ck"),
+	FMCLK(CKGEN,  8, "hf_fipu_if_ck"),
+	FMCLK(CKGEN,  9, "hf_fmfg_ck"),
+	FMCLK(CKGEN,  10, "f52m_mfg_ck"),
+	FMCLK(CKGEN,  11, "f_fcamtg_ck"),
+	FMCLK(CKGEN,  12, "f_fcamtg2_ck"),
+	FMCLK(CKGEN,  13, "f_fcamtg3_ck"),
+	FMCLK(CKGEN,  14, "f_fcamtg4_ck"),
+	FMCLK(CKGEN,  15, "f_fuart_ck"),
+	FMCLK(CKGEN,  16, "hf_fspi_ck"),
+	FMCLK(CKGEN,  17, "hf_fmsdc50_0_hclk_ck"),
+	FMCLK(CKGEN,  18, "hf_fmsdc50_0_ck"),
+	FMCLK(CKGEN,  19, "hf_fmsdc30_1_ck"),
+	FMCLK(CKGEN,  20, "hf_fmsdc30_2_ck"),
+	FMCLK(CKGEN,  21, "hf_faudio_ck"),
+	FMCLK(CKGEN,  22, "hf_faud_intbus_ck"),
+	FMCLK(CKGEN,  23, "hf_fpmicspi_ck"),
+	FMCLK(CKGEN,  24, "f_fpwrap_ulposc_ck"),
+	FMCLK(CKGEN,  25, "hf_fatb_ck"),
+	FMCLK(CKGEN,  26, "hf_fsspm_ck"),
+	FMCLK(CKGEN,  27, "hf_fdpi0_ck"),
+	FMCLK(CKGEN,  28, "hf_fscam_ck"),
+	FMCLK(CKGEN,  29, "f_fdisp_pwm_ck"),
+	FMCLK(CKGEN,  30, "f_fusb_top_ck"),
+	FMCLK(CKGEN,  31, "f_fssusb_xhci_ck"),
+	FMCLK(CKGEN,  32, "hg_fspm_ck"),
+	FMCLK(CKGEN,  33, "f_fi2c_ck"),
+	FMCLK(CKGEN,  34, "hf_fscp_ck"),
+	FMCLK(CKGEN,  35, "f_fseninf_ck"),
+	FMCLK(CKGEN,  36, "f_fdxcc_ck"),
+	FMCLK(CKGEN,  37, "hf_faud_engin1_ck"),
+	FMCLK(CKGEN,  38, "hf_faud_engin2_ck"),
+	FMCLK(CKGEN,  39, "hf_faes_ufsfde_ck"),
+	FMCLK(CKGEN,  40, "hf_fufs_ck"),
+	FMCLK(CKGEN,  41, "hf_faud_1_ck"),
+	FMCLK(CKGEN,  42, "hf_faud_2_ck"),
+	FMCLK(CKGEN,  49, "hf_fref_mm_ck"),
+	FMCLK(CKGEN,  50, "hf_fref_cam_ck"),
+	FMCLK(CKGEN,  51, "hf_hddrphycfg_ck"),
+	FMCLK(CKGEN,  52, "f_ufs_mp_sap_cfg_ck"),
+	FMCLK(CKGEN,  53, "f_ufs_tick1us_ck"),
+	FMCLK(CKGEN,  54, "hd_faxi_east_ck"),
+	FMCLK(CKGEN,  55, "hd_faxi_west_ck"),
+	FMCLK(CKGEN,  56, "hd_faxi_north_ck"),
+	FMCLK(CKGEN,  57, "hd_faxi_south_ck"),
+	FMCLK(CKGEN,  58, "hg_fmipicfg_tx_ck"),
+	FMCLK(CKGEN,  59, "fmem_ck_bfe_dcm_ch0"),
+	FMCLK(CKGEN,  60, "fmem_ck_aft_dcm_ch0"),
+	FMCLK(CKGEN,  61, "fmem_ck_bfe_dcm_ch1"),
+	FMCLK(CKGEN,  62, "fmem_ck_aft_dcm_ch1"),
+	FMCLK(CKGEN,  63, "dramc_pll104m_ck"),
+	FMCLK(ABIST,  1, "AD_WBG_DIG_CK_832M"),
+	FMCLK(ABIST,  2, "AD_WBG_DIG_CK_960M"),
+	FMCLK(ABIST,  3, "UFS_MP_CLK2FREQ"),
+	FMCLK(ABIST,  4, "AD_CSI0A_CDPHY_DELAYCAL_CK"),
+	FMCLK(ABIST,  5, "AD_CSI0B_CDPHY_DELAYCAL_CK"),
+	FMCLK(ABIST,  6, "AD_CSI1A_DPHY_DELAYCAL_CK"),
+	FMCLK(ABIST,  7, "AD_CSI1B_DPHY_DELAYCAL_CK"),
+	FMCLK(ABIST,  8, "AD_CSI2A_DPHY_DELAYCAL_CK"),
+	FMCLK(ABIST,  9, "AD_CSI2B_DPHY_DELAYCAL_CK"),
+	FMCLK(ABIST,  10, "AD_MDBPIPLL_CK"),
+	FMCLK(ABIST,  11, "AD_MDBRPPLL_CK"),
+	FMCLK(ABIST,  12, "AD_MDMCUPLL_CK"),
+	FMCLK(ABIST,  13, "AD_MDTXPLL_CK"),
+	FMCLK(ABIST,  14, "AD_MDVDSPPLL_CK"),
+	FMCLK(ABIST,  16, "AD_MDPLL_FS26M_CK"),
+	FMCLK(ABIST,  20, "AD_ARMPLL_L_CK"),
+	FMCLK(ABIST,  22, "AD_ARMPLL_LL_CK"),
+	FMCLK(ABIST,  23, "AD_MAINPLL_1092M_CK"),
+	FMCLK(ABIST,  24, "AD_UNIVPLL_1248M_CK"),
+	FMCLK(ABIST,  25, "AD_MFGPLL_CK"),
+	FMCLK(ABIST,  26, "AD_MSDCPLL_CK"),
+	FMCLK(ABIST,  27, "AD_MMPLL_CK"),
+	FMCLK(ABIST,  28, "AD_APLL1_CK"),
+	FMCLK(ABIST,  29, "AD_APLL2_CK"),
+	FMCLK(ABIST,  30, "AD_APPLLGP_TST_CK"),
+	FMCLK(ABIST,  32, "AD_UNIV_192M_CK"),
+	FMCLK(ABIST,  34, "AD_TVDPLL_CK"),
+	FMCLK(ABIST,  35, "AD_DSI0_MPPLL_TST_CK"),
+	FMCLK(ABIST,  36, "AD_DSI0_LNTC_DSICLK"),
+	FMCLK(ABIST,  37, "AD_OSC_CK_2"),
+	FMCLK(ABIST,  38, "AD_OSC_CK"),
+	FMCLK(ABIST,  39, "rtc32k_ck_i"),
+	FMCLK(ABIST,  40, "mcusys_arm_clk_out_all"),
+	FMCLK(ABIST,  41, "AD_OSC_SYNC_CK"),
+	FMCLK(ABIST,  42, "AD_OSC_SYNC_CK_2"),
+	FMCLK(ABIST,  43, "msdc01_in_ck"),
+	FMCLK(ABIST,  44, "msdc02_in_ck"),
+	FMCLK(ABIST,  45, "msdc11_in_ck"),
+	FMCLK(ABIST,  46, "msdc12_in_ck"),
+	FMCLK(ABIST,  49, "AD_CCIPLL_CK"),
+	FMCLK(ABIST,  50, "AD_MPLL_208M_CK"),
+	FMCLK(ABIST,  51, "AD_WBG_DIG_CK_CK_416M"),
+	FMCLK(ABIST,  52, "AD_WBG_B_DIG_CK_64M"),
+	FMCLK(ABIST,  53, "AD_WBG_W_DIG_CK_160M"),
+	FMCLK(ABIST,  55, "DA_UNIV_48M_DIV_CK"),
+	FMCLK(ABIST,  57, "DA_MPLL_52M_DIV_CK"),
+	FMCLK(ABIST,  60, "ckmon1_ck"),
+	FMCLK(ABIST,  61, "ckmon2_ck"),
+	FMCLK(ABIST,  62, "ckmon3_ck"),
+	FMCLK(ABIST,  63, "ckmon4_ck"),
+	{}
+};
+
+#define CLK_MISC_CFG_0	(rb[topckgen].virt + 0x104)
+#define CLK_DBG_CFG		(rb[topckgen].virt + 0x10C)
+#define CLK26CALI_0		(rb[topckgen].virt + 0x220)
+#define CLK26CALI_1		(rb[topckgen].virt + 0x224)
+
+static unsigned int mt_get_ckgen_freq(unsigned int ID)
+{
+	int output = 0, i = 0;
+	unsigned int temp, clk_dbg_cfg, clk_misc_cfg_0;
+
+	clk_dbg_cfg = clk_readl(CLK_DBG_CFG);
+	clk_writel(CLK_DBG_CFG, (clk_dbg_cfg & 0xFFFFC0FC)|(ID << 8)|(0x1));
+
+	clk_misc_cfg_0 = clk_readl(CLK_MISC_CFG_0);
+	clk_writel(CLK_MISC_CFG_0, (clk_misc_cfg_0 & 0x00FFFFFF));
+
+	clk_writel(CLK26CALI_0, 0x1000);
+	clk_writel(CLK26CALI_0, 0x1010);
+
+	while (clk_readl(CLK26CALI_0) & 0x10) {
+		mdelay(10);
+		i++;
+		if (i > 10)
+			break;
+	}
+
+	temp = clk_readl(CLK26CALI_1) & 0xFFFF;
+
+	output = (temp * 26000) / 1024;
+
+	clk_writel(CLK_DBG_CFG, clk_dbg_cfg);
+	clk_writel(CLK_MISC_CFG_0, clk_misc_cfg_0);
+
+	if (i > 10)
+		return 0;
+	else
+		return output;
+
+}
+
+static unsigned int mt_get_abist_freq(unsigned int ID)
+{
+	int output = 0, i = 0;
+	unsigned int temp, clk_dbg_cfg, clk_misc_cfg_0;
+
+	clk_dbg_cfg = clk_readl(CLK_DBG_CFG);
+	clk_writel(CLK_DBG_CFG, (clk_dbg_cfg & 0xFFC0FFFC)|(ID << 16));
+
+	clk_misc_cfg_0 = clk_readl(CLK_MISC_CFG_0);
+	clk_writel(CLK_MISC_CFG_0, (clk_misc_cfg_0 & 0x00FFFFFF) | (1 << 24));
+
+	clk_writel(CLK26CALI_0, 0x1000);
+	clk_writel(CLK26CALI_0, 0x1010);
+
+	while (clk_readl(CLK26CALI_0) & 0x10) {
+		mdelay(10);
+		i++;
+		if (i > 10)
+			break;
+	}
+
+	temp = clk_readl(CLK26CALI_1) & 0xFFFF;
+
+	output = (temp * 26000) / 1024;
+
+	clk_writel(CLK_DBG_CFG, clk_dbg_cfg);
+	clk_writel(CLK_MISC_CFG_0, clk_misc_cfg_0);
+
+	if (i > 10)
+		return 0;
+	else
+		return (output * 2);
+}
+
+static u32 fmeter_freq_op(const struct fmeter_clk *fclk)
+{
+	if (fclk->type == ABIST)
+		return mt_get_abist_freq(fclk->id);
+	else if (fclk->type == CKGEN)
+		return mt_get_ckgen_freq(fclk->id);
+	return 0;
+}
+
+static const struct fmeter_clk *get_all_fmeter_clks(void)
+{
+	return fclks;
+}
+
+/*
+ * clkdbg dump_state
+ */
+
+static const char * const *get_all_clk_names(void)
+{
+	static const char * const clks[] = {
+		"armpll_ll",
+		"armpll_l",
+		"ccipll",
+		"mainpll",
+		"univ2pll",
+		"msdcpll",
+		"mmpll",
+		"mfgpll",
+		"tvdpll",
+		"apll1",
+		"apll2",
+		"apmixed_ssusb26m",
+		"apmixed_appll26m",
+		"apmixed_mipic026m",
+		"apmixed_mdpll26m",
+		"apmixed_mmsys26m",
+		"apmixed_ufs26m",
+		"apmixed_mipic126m",
+		"apmixed_mempll26m",
+		"apmixed_lvpll26m",
+		"apmixed_mipid026m",
+		"apmixed_mipid126m",
+		"syspll_ck",
+		"syspll_d2",
+		"syspll_d3",
+		"syspll_d5",
+		"syspll_d7",
+		"syspll_d2_d2",
+		"syspll_d2_d4",
+		"syspll_d2_d8",
+		"syspll_d2_d16",
+		"syspll_d3_d2",
+		"syspll_d3_d4",
+		"syspll_d3_d8",
+		"syspll_d5_d2",
+		"syspll_d5_d4",
+		"syspll_d7_d2",
+		"syspll_d7_d4",
+		"univpll_ck",
+		"univpll_d2",
+		"univpll_d3",
+		"univpll_d5",
+		"univpll_d7",
+		"univpll_d2_d2",
+		"univpll_d2_d4",
+		"univpll_d2_d8",
+		"univpll_d3_d2",
+		"univpll_d3_d4",
+		"univpll_d3_d8",
+		"univpll_d5_d2",
+		"univpll_d5_d4",
+		"univpll_d5_d8",
+		"apll1_ck",
+		"apll1_d2",
+		"apll1_d4",
+		"apll1_d8",
+		"apll2_ck",
+		"apll2_d2",
+		"apll2_d4",
+		"apll2_d8",
+		"tvdpll_ck",
+		"tvdpll_d2",
+		"tvdpll_d4",
+		"tvdpll_d8",
+		"tvdpll_d16",
+		"msdcpll_ck",
+		"msdcpll_d2",
+		"msdcpll_d4",
+		"msdcpll_d8",
+		"msdcpll_d16",
+		"ad_osc_ck",
+		"osc_d2",
+		"osc_d4",
+		"osc_d8",
+		"osc_d16",
+		"csw_f26m_ck_d2",
+		"mfgpll_ck",
+		"univ_192m_ck",
+		"univ_192m_d2",
+		"univ_192m_d4",
+		"univ_192m_d8",
+		"univ_192m_d16",
+		"univ_192m_d32",
+		"mmpll_ck",
+		"mmpll_d4",
+		"mmpll_d4_d2",
+		"mmpll_d4_d4",
+		"mmpll_d5",
+		"mmpll_d5_d2",
+		"mmpll_d5_d4",
+		"mmpll_d6",
+		"mmpll_d7",
+		"f_f26m_ck",
+		"clk13m",
+		"osc",
+		"univpll_192m",
+		"apll_i2s0_sel",
+		"apll_i2s1_sel",
+		"apll_i2s2_sel",
+		"apll_i2s3_sel",
+		"apll_i2s4_sel",
+		"apll_i2s5_sel",
+		"apll12_div0",
+		"apll12_div1",
+		"apll12_div2",
+		"apll12_div3",
+		"apll12_div4",
+		"apll12_divb",
+		"univpll",
+		"armpll_div_pll1",
+		"armpll_div_pll2",
+		"axi_sel",
+		"mm_sel",
+		"cam_sel",
+		"mfg_sel",
+		"camtg_sel",
+		"uart_sel",
+		"spi_sel",
+		"msdc50_hclk_sel",
+		"msdc50_0_sel",
+		"msdc30_1_sel",
+		"msdc30_2_sel",
+		"audio_sel",
+		"aud_intbus_sel",
+		"fpwrap_ulposc_sel",
+		"scp_sel",
+		"atb_sel",
+		"sspm_sel",
+		"dpi0_sel",
+		"scam_sel",
+		"aud_1_sel",
+		"aud_2_sel",
+		"disppwm_sel",
+		"ssusb_top_xhci_sel",
+		"usb_top_sel",
+		"spm_sel",
+		"i2c_sel",
+		"f52m_mfg_sel",
+		"seninf_sel",
+		"dxcc_sel",
+		"camtg2_sel",
+		"aud_eng1_sel",
+		"aud_eng2_sel",
+		"faes_ufsfde_sel",
+		"fufs_sel",
+		"img_sel",
+		"dsp_sel",
+		"dsp1_sel",
+		"dsp2_sel",
+		"ipu_if_sel",
+		"camtg3_sel",
+		"camtg4_sel",
+		"pmicspi_sel",
+		"mcu_mp0_sel",
+		"mcu_mp2_sel",
+		"mcu_bus_sel",
+		"infra_pmic_tmr",
+		"infra_pmic_ap",
+		"infra_pmic_md",
+		"infra_pmic_conn",
+		"infra_scp",
+		"infra_sej",
+		"infra_apxgpt",
+		"infra_icusb",
+		"infra_gce",
+		"infra_therm",
+		"infra_i2c0",
+		"infra_i2c1",
+		"infra_i2c2",
+		"infra_i2c3",
+		"infra_pwm_hclk",
+		"infra_pwm1",
+		"infra_pwm2",
+		"infra_pwm3",
+		"infra_pwm4",
+		"infra_pwm",
+		"infra_uart0",
+		"infra_uart1",
+		"infra_uart2",
+		"infra_uart3",
+		"infra_gce_26m",
+		"infra_cqdma_fpc",
+		"infra_btif",
+		"infra_spi0",
+		"infra_msdc0",
+		"infra_msdc1",
+		"infra_msdc2",
+		"infra_msdc0_sck",
+		"infra_dvfsrc",
+		"infra_gcpu",
+		"infra_trng",
+		"infra_auxadc",
+		"infra_cpum",
+		"infra_ccif1_ap",
+		"infra_ccif1_md",
+		"infra_auxadc_md",
+		"infra_msdc1_sck",
+		"infra_msdc2_sck",
+		"infra_apdma",
+		"infra_xiu",
+		"infra_device_apc",
+		"infra_ccif_ap",
+		"infra_debugsys",
+		"infra_audio",
+		"infra_ccif_md",
+		"infra_dxcc_sec_core",
+		"infra_dxcc_ao",
+		"infra_dramc_f26m",
+		"infra_irtx",
+		"infra_disppwm",
+		"infra_cldma_bclk",
+		"infra_audio_26m_bclk",
+		"infra_spi1",
+		"infra_i2c4",
+		"infra_md_tmp_share",
+		"infra_spi2",
+		"infra_spi3",
+		"infra_unipro_sck",
+		"infra_unipro_tick",
+		"infra_ufs_mp_sap_bck",
+		"infra_md32_bclk",
+		"infra_sspm",
+		"infra_unipro_mbist",
+		"infra_sspm_bus_hclk",
+		"infra_i2c5",
+		"infra_i2c5_arbiter",
+		"infra_i2c5_imm",
+		"infra_i2c1_arbiter",
+		"infra_i2c1_imm",
+		"infra_i2c2_arbiter",
+		"infra_i2c2_imm",
+		"infra_spi4",
+		"infra_spi5",
+		"infra_cqdma",
+		"infra_ufs",
+		"infra_aes_ufsfde",
+		"infra_ufs_tick",
+		"infra_msdc0_self",
+		"infra_msdc1_self",
+		"infra_msdc2_self",
+		"infra_sspm_26m_self",
+		"infra_sspm_32k_self",
+		"infra_ufs_axi",
+		"infra_i2c6",
+		"infra_ap_msdc0",
+		"infra_md_msdc0",
+		"infra_usb",
+		"infra_devmpu_bclk",
+		"infra_ccif2_ap",
+		"infra_ccif2_md",
+		"infra_ccif3_ap",
+		"infra_ccif3_md",
+		"infra_sej_f13m",
+		"infra_aes_bclk",
+		"infra_i2c7",
+		"infra_i2c8",
+		"infra_fbist2fpc",
+		"aud_tml",
+		"aud_dac_predis",
+		"aud_dac",
+		"aud_adc",
+		"aud_apll_tuner",
+		"aud_apll2_tuner",
+		"aud_24m",
+		"aud_22m",
+		"aud_afe",
+		"aud_i2s4",
+		"aud_i2s3",
+		"aud_i2s2",
+		"aud_i2s1",
+		"aud_pdn_adda6_adc",
+		"aud_tdm",
+		"mfg_bg3d",
+		"mm_smi_common",
+		"mm_smi_larb0",
+		"mm_smi_larb1",
+		"mm_gals_comm0",
+		"mm_gals_comm1",
+		"mm_gals_ccu2mm",
+		"mm_gals_ipu12mm",
+		"mm_gals_img2mm",
+		"mm_gals_cam2mm",
+		"mm_gals_ipu2mm",
+		"mm_mdp_dl_txck",
+		"mm_ipu_dl_txck",
+		"mm_mdp_rdma0",
+		"mm_mdp_rdma1",
+		"mm_mdp_rsz0",
+		"mm_mdp_rsz1",
+		"mm_mdp_tdshp",
+		"mm_mdp_wrot0",
+		"mm_fake_eng",
+		"mm_disp_ovl0",
+		"mm_disp_ovl0_2l",
+		"mm_disp_ovl1_2l",
+		"mm_disp_rdma0",
+		"mm_disp_rdma1",
+		"mm_disp_wdma0",
+		"mm_disp_color0",
+		"mm_disp_ccorr0",
+		"mm_disp_aal0",
+		"mm_disp_gamma0",
+		"mm_disp_dither0",
+		"mm_disp_split",
+		"mm_dsi0_mm",
+		"mm_dsi0_if",
+		"mm_dpi_mm",
+		"mm_dpi_if",
+		"mm_fake_eng2",
+		"mm_mdp_dl_rx",
+		"mm_ipu_dl_rx",
+		"mm_26m",
+		"mm_mmsys_r2y",
+		"mm_disp_rsz",
+		"mm_mdp_wdma0",
+		"mm_mdp_aal",
+		"mm_mdp_ccorr",
+		"mm_dbi_mm",
+		"mm_dbi_if",
+		"vdec_vdec",
+		"vdec_larb1",
+		"venc_larb",
+		"venc_venc",
+		"venc_jpgenc",
+		"img_owe",
+		"img_wpe_b",
+		"img_wpe_a",
+		"img_mfb",
+		"img_rsc",
+		"img_dpe",
+		"img_fdvt",
+		"img_dip",
+		"img_larb2",
+		"img_larb5",
+		"cam_larb6",
+		"cam_dfp_vad",
+		"cam_cam",
+		"cam_camtg",
+		"cam_seninf",
+		"cam_camsv0",
+		"cam_camsv1",
+		"cam_camsv2",
+		"cam_ccu",
+		"cam_larb3",
+		"ipu_conn_ipu",
+		"ipu_conn_ahb",
+		"ipu_conn_axi",
+		"ipu_conn_isp",
+		"ipu_conn_cam_adl",
+		"ipu_conn_img_adl",
+		"ipu_conn_dap_rx",
+		"ipu_conn_apb2axi",
+		"ipu_conn_apb2ahb",
+		"ipu_conn_ipu_cab1to2",
+		"ipu_conn_ipu1_cab1to2",
+		"ipu_conn_ipu2_cab1to2",
+		"ipu_conn_cab3to3",
+		"ipu_conn_cab2to1",
+		"ipu_conn_cab3to1_slice",
+		"ipu_adl_cabgen",
+		"ipu_core0_jtag",
+		"ipu_core0_axi",
+		"ipu_core0_ipu",
+		"ipu_core1_jtag",
+		"ipu_core1_axi",
+		"ipu_core1_ipu",
+		/* end */
+		NULL
+	};
+
+	return clks;
+}
+
+/*
+ * clkdbg pwr_status
+ */
+
+static const char * const *get_pwr_names(void)
+{
+	static const char * const pwr_names[] = {
+		[0]  = "MD1",
+		[1]  = "CONN",
+		[2]  = "DDRPHY",
+		[3]  = "DISP",
+		[4]  = "MFG",
+		[5]  = "ISP",
+		[6]  = "INFRA",
+		[7]  = "MFG_CORE0",
+		[8]  = "MP0_CPUTOP",
+		[9]  = "MP0_CPU0",
+		[10] = "MP0_CPU1",
+		[11] = "MP0_CPU2",
+		[12] = "MP0_CPU3",
+		[13] = "",
+		[14] = "",
+		[15] = "",
+		[16] = "",
+		[17] = "",
+		[18] = "",
+		[19] = "",
+		[20] = "MFG_CORE1",
+		[21] = "VENC",
+		[22] = "MFG_2D",
+		[23] = "MFG_ASYNC",
+		[24] = "AUDIO",
+		[25] = "CAM",
+		[26] = "VPU_TOP",
+		[27] = "VPU_CORE0",
+		[28] = "VPU_CORE1",
+		[29] = "VPU_CORE2",
+		[30] = "",
+		[31] = "VDEC",
+	};
+
+	return pwr_names;
+}
+
+u32 get_spm_pwr_status(void)
+{
+	static void __iomem *scpsys_base, *pwr_sta, *pwr_sta_2nd;
+
+	if (scpsys_base == NULL || pwr_sta == NULL || pwr_sta_2nd == NULL) {
+		scpsys_base = ioremap(0x10006000, PAGE_SIZE);
+		pwr_sta = scpsys_base + 0x180;
+		pwr_sta_2nd = scpsys_base + 0x184;
+	}
+
+	return clk_readl(pwr_sta) & clk_readl(pwr_sta_2nd);
+}
+
+/*
+ * clkdbg dump_clks
+ */
+
+static void setup_provider_clk(struct provider_clk *pvdck)
+{
+	static const struct {
+		const char *pvdname;
+		u32 pwr_mask;
+	} pvd_pwr_mask[] = {
+		{"mmsys", BIT(3)},
+		{"imgsys", BIT(5)},
+		{"camsys", BIT(25)},
+		{"ipu_conn", BIT(26)},
+		{"ipu_core0", BIT(27)},
+		{"ipu_core1", BIT(28)},
+		{"audiosys", BIT(24)},
+		{"mfgcfg", BIT(22)},
+	};
+
+	size_t i;
+	const char *pvdname = pvdck->provider_name;
+
+	if (pvdname == NULL)
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(pvd_pwr_mask); i++) {
+		if (strcmp(pvdname, pvd_pwr_mask[i].pvdname) == 0) {
+			pvdck->pwr_mask = pvd_pwr_mask[i].pwr_mask;
+			return;
+		}
+	}
+}
+
+/*
+ * init functions
+ */
+
+static struct clkdbg_ops clkdbg_mt8183_ops = {
+	.get_all_fmeter_clks = get_all_fmeter_clks,
+	.fmeter_freq = fmeter_freq_op,
+	.get_all_regnames = get_all_regnames,
+	.get_all_clk_names = get_all_clk_names,
+	.get_pwr_names = get_pwr_names,
+	.setup_provider_clk = setup_provider_clk,
+	.get_spm_pwr_status = get_spm_pwr_status,
+};
+
+static void __init init_custom_cmds(void)
+{
+	static const struct cmd_fn cmds[] = {
+		{}
+	};
+
+	set_custom_cmds(cmds);
+}
+
+static int __init clkdbg_mt8183_init(void)
+{
+	if (of_machine_is_compatible("mediatek,mt8183") == 0)
+		return -ENODEV;
+
+	init_regbase();
+
+	init_custom_cmds();
+	set_clkdbg_ops(&clkdbg_mt8183_ops);
+
+#if DUMP_INIT_STATE
+	print_regs();
+	print_fmeter_all();
+#endif /* DUMP_INIT_STATE */
+
+	return 0;
+}
+device_initcall(clkdbg_mt8183_init);
diff --git a/drivers/clk/mediatek/clkdbg.c b/drivers/clk/mediatek/clkdbg.c
new file mode 100644
index 000000000000..8c9f67968160
--- /dev/null
+++ b/drivers/clk/mediatek/clkdbg.c
@@ -0,0 +1,2242 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2018 MediaTek Inc.
+// Author: Weiyi Lu <weiyi.lu@mediatek.com>
+
+#define pr_fmt(fmt) "[clkdbg] " fmt
+
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/pm_domain.h>
+#include <linux/pm_runtime.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include "clkdbg.h"
+
+#if defined(CONFIG_PM_DEBUG)
+#define CLKDBG_PM_DOMAIN	1
+#else
+#define CLKDBG_PM_DOMAIN	0
+#endif
+#define CLKDBG_PM_DOMAIN_API_4_9	1
+#define CLKDBG_CCF_API_4_4	1
+#define CLKDBG_HACK_CLK		0
+#define CLKDBG_HACK_CLK_CORE	1
+#define CLKDBG_DROP_GENPD_AS_IN_PARAM	1
+
+#if !CLKDBG_CCF_API_4_4
+
+/* backward compatible */
+
+static const char *clk_hw_get_name(const struct clk_hw *hw)
+{
+	return __clk_get_name(hw->clk);
+}
+
+static bool clk_hw_is_prepared(const struct clk_hw *hw)
+{
+	return __clk_is_prepared(hw->clk);
+}
+
+static bool clk_hw_is_enabled(const struct clk_hw *hw)
+{
+	return __clk_is_enabled(hw->clk);
+}
+
+static unsigned long clk_hw_get_rate(const struct clk_hw *hw)
+{
+	return __clk_get_rate(hw->clk);
+}
+
+static unsigned int clk_hw_get_num_parents(const struct clk_hw *hw)
+{
+	return __clk_get_num_parents(hw->clk);
+}
+
+static struct clk_hw *clk_hw_get_parent_by_index(const struct clk_hw *hw,
+					  unsigned int index)
+{
+	return __clk_get_hw(clk_get_parent_by_index(hw->clk, index));
+}
+
+#endif /* !CLKDBG_CCF_API_4_4 */
+
+#if CLKDBG_HACK_CLK
+
+#include <linux/clk-private.h>
+
+static bool clk_hw_is_on(struct clk_hw *hw)
+{
+	const struct clk_ops *ops = hw->clk->ops;
+
+	if (ops->is_enabled)
+		return clk_hw_is_enabled(hw);
+	else if (ops->is_prepared)
+		return clk_hw_is_prepared(hw);
+	return clk_hw_is_enabled(hw) || clk_hw_is_prepared(hw);
+}
+
+#elif CLKDBG_HACK_CLK_CORE
+
+struct clk_core {
+	const char		*name;
+	const struct clk_ops	*ops;
+	struct clk_hw		*hw;
+};
+
+static bool clk_hw_is_on(struct clk_hw *hw)
+{
+	const struct clk_ops *ops = hw->core->ops;
+
+	if (ops->is_enabled)
+		return clk_hw_is_enabled(hw);
+	else if (ops->is_prepared)
+		return clk_hw_is_prepared(hw);
+	return clk_hw_is_enabled(hw) || clk_hw_is_prepared(hw);
+}
+
+#else
+
+static bool clk_hw_is_on(struct clk_hw *hw)
+{
+	return __clk_get_enable_count(hw->clk) || clk_hw_is_prepared(hw);
+}
+
+#endif /* !CLKDBG_HACK_CLK && !CLKDBG_HACK_CLK_CORE */
+
+static const struct clkdbg_ops *clkdbg_ops;
+
+void set_clkdbg_ops(const struct clkdbg_ops *ops)
+{
+	clkdbg_ops = ops;
+}
+
+static const struct fmeter_clk *get_all_fmeter_clks(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->get_all_fmeter_clks  == NULL)
+		return NULL;
+
+	return clkdbg_ops->get_all_fmeter_clks();
+}
+
+static void *prepare_fmeter(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->prepare_fmeter == NULL)
+		return NULL;
+
+	return clkdbg_ops->prepare_fmeter();
+}
+
+static void unprepare_fmeter(void *data)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->unprepare_fmeter == NULL)
+		return;
+
+	clkdbg_ops->unprepare_fmeter(data);
+}
+
+static u32 fmeter_freq(const struct fmeter_clk *fclk)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->fmeter_freq == NULL)
+		return 0;
+
+	return clkdbg_ops->fmeter_freq(fclk);
+}
+
+static const struct regname *get_all_regnames(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->get_all_regnames == NULL)
+		return NULL;
+
+	return clkdbg_ops->get_all_regnames();
+}
+
+static const char * const *get_all_clk_names(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->get_all_clk_names == NULL)
+		return NULL;
+
+	return clkdbg_ops->get_all_clk_names();
+}
+
+static const char * const *get_pwr_names(void)
+{
+	static const char * const default_pwr_names[] = {
+		[0]  = "(MD)",
+		[1]  = "(CONN)",
+		[2]  = "(DDRPHY)",
+		[3]  = "(DISP)",
+		[4]  = "(MFG)",
+		[5]  = "(ISP)",
+		[6]  = "(INFRA)",
+		[7]  = "(VDEC)",
+		[8]  = "(CPU, CA7_CPUTOP)",
+		[9]  = "(FC3, CA7_CPU0, CPUTOP)",
+		[10] = "(FC2, CA7_CPU1, CPU3)",
+		[11] = "(FC1, CA7_CPU2, CPU2)",
+		[12] = "(FC0, CA7_CPU3, CPU1)",
+		[13] = "(MCUSYS, CA7_DBG, CPU0)",
+		[14] = "(MCUSYS, VEN, BDP)",
+		[15] = "(CA15_CPUTOP, ETH, MCUSYS)",
+		[16] = "(CA15_CPU0, HIF)",
+		[17] = "(CA15_CPU1, CA15-CX0, INFRA_MISC)",
+		[18] = "(CA15_CPU2, CA15-CX1)",
+		[19] = "(CA15_CPU3, CA15-CPU0)",
+		[20] = "(VEN2, MJC, CA15-CPU1)",
+		[21] = "(VEN, CA15-CPUTOP)",
+		[22] = "(MFG_2D)",
+		[23] = "(MFG_ASYNC, DBG)",
+		[24] = "(AUDIO, MFG_2D)",
+		[25] = "(USB, VCORE_PDN, MFG_ASYNC)",
+		[26] = "(ARMPLL_DIV, CPUTOP_SRM_SLPB)",
+		[27] = "(MD2, CPUTOP_SRM_PDN)",
+		[28] = "(CPU3_SRM_PDN)",
+		[29] = "(CPU2_SRM_PDN)",
+		[30] = "(CPU1_SRM_PDN)",
+		[31] = "(CPU0_SRM_PDN)",
+	};
+
+	if (clkdbg_ops == NULL || clkdbg_ops->get_pwr_names == NULL)
+		return default_pwr_names;
+
+	return clkdbg_ops->get_pwr_names();
+}
+
+static void setup_provider_clk(struct provider_clk *pvdck)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->setup_provider_clk == NULL)
+		return;
+
+	clkdbg_ops->setup_provider_clk(pvdck);
+}
+
+static bool is_valid_reg(void __iomem *addr)
+{
+#ifdef CONFIG_64BIT
+	return ((u64)addr & 0xf0000000) != 0UL ||
+			(((u64)addr >> 32U) & 0xf0000000) != 0UL;
+#else
+	return ((u32)addr & 0xf0000000) != 0U;
+#endif
+}
+
+enum clkdbg_opt {
+	CLKDBG_EN_SUSPEND_SAVE_1,
+	CLKDBG_EN_SUSPEND_SAVE_2,
+	CLKDBG_EN_SUSPEND_SAVE_3,
+	CLKDBG_EN_LOG_SAVE_POINTS,
+};
+
+static u32 clkdbg_flags;
+
+static void set_clkdbg_flag(enum clkdbg_opt opt)
+{
+	clkdbg_flags |= BIT(opt);
+}
+
+static void clr_clkdbg_flag(enum clkdbg_opt opt)
+{
+	clkdbg_flags &= ~BIT(opt);
+}
+
+static bool has_clkdbg_flag(enum clkdbg_opt opt)
+{
+	return (clkdbg_flags & BIT(opt)) != 0U;
+}
+
+typedef void (*fn_fclk_freq_proc)(const struct fmeter_clk *fclk,
+					u32 freq, void *data);
+
+static void proc_all_fclk_freq(fn_fclk_freq_proc proc, void *data)
+{
+	void *fmeter_data;
+	const struct fmeter_clk *fclk;
+
+	fclk = get_all_fmeter_clks();
+
+	if (fclk == NULL || proc == NULL)
+		return;
+
+	fmeter_data = prepare_fmeter();
+
+	for (; fclk->type != FT_NULL; fclk++) {
+		u32 freq;
+
+		freq = fmeter_freq(fclk);
+		proc(fclk, freq, data);
+	}
+
+	unprepare_fmeter(fmeter_data);
+}
+
+static void print_fclk_freq(const struct fmeter_clk *fclk, u32 freq, void *data)
+{
+	pr_info("%2d: %-29s: %u\n", fclk->id, fclk->name, freq);
+}
+
+void print_fmeter_all(void)
+{
+	proc_all_fclk_freq(print_fclk_freq, NULL);
+}
+
+static void seq_print_fclk_freq(const struct fmeter_clk *fclk,
+				u32 freq, void *data)
+{
+	struct seq_file *s = data;
+
+	seq_printf(s, "%2d: %-29s: %u\n", fclk->id, fclk->name, freq);
+}
+
+static int seq_print_fmeter_all(struct seq_file *s, void *v)
+{
+	proc_all_fclk_freq(seq_print_fclk_freq, s);
+
+	return 0;
+}
+
+typedef void (*fn_regname_proc)(const struct regname *rn, void *data);
+
+static void proc_all_regname(fn_regname_proc proc, void *data)
+{
+	const struct regname *rn = get_all_regnames();
+
+	if (rn == NULL)
+		return;
+
+	for (; rn->base != NULL; rn++)
+		proc(rn, data);
+}
+
+static void print_reg(const struct regname *rn, void *data)
+{
+	if (!is_valid_reg(ADDR(rn)))
+		return;
+
+	pr_info("%-21s: [0x%08x][0x%p] = 0x%08x\n",
+			rn->name, PHYSADDR(rn), ADDR(rn), clk_readl(ADDR(rn)));
+}
+
+void print_regs(void)
+{
+	proc_all_regname(print_reg, NULL);
+}
+
+static void seq_print_reg(const struct regname *rn, void *data)
+{
+	struct seq_file *s = data;
+
+	if (!is_valid_reg(ADDR(rn)))
+		return;
+
+	seq_printf(s, "%-21s: [0x%08x][0x%p] = 0x%08x\n",
+		rn->name, PHYSADDR(rn), ADDR(rn), clk_readl(ADDR(rn)));
+}
+
+static int seq_print_regs(struct seq_file *s, void *v)
+{
+	proc_all_regname(seq_print_reg, s);
+
+	return 0;
+}
+
+static void print_reg2(const struct regname *rn, void *data)
+{
+	if (!is_valid_reg(ADDR(rn)))
+		return;
+
+	pr_info("%-21s: [0x%08x][0x%p] = 0x%08x\n",
+		rn->name, PHYSADDR(rn), ADDR(rn), clk_readl(ADDR(rn)));
+
+	msleep(20);
+}
+
+static int clkdbg_dump_regs2(struct seq_file *s, void *v)
+{
+	proc_all_regname(print_reg2, s);
+
+	return 0;
+}
+
+static u32 read_spm_pwr_status(void)
+{
+	static void __iomem *scpsys_base, *pwr_sta, *pwr_sta_2nd;
+
+	if (clkdbg_ops == NULL || clkdbg_ops->get_spm_pwr_status  == NULL) {
+		if (scpsys_base == NULL ||
+		    pwr_sta == NULL || pwr_sta_2nd == NULL) {
+			scpsys_base = ioremap(0x10006000, PAGE_SIZE);
+			pwr_sta = scpsys_base + 0x60c;
+			pwr_sta_2nd = scpsys_base + 0x610;
+		}
+
+		return clk_readl(pwr_sta) & clk_readl(pwr_sta_2nd);
+	} else
+		return clkdbg_ops->get_spm_pwr_status();
+}
+
+static bool clk_hw_pwr_is_on(struct clk_hw *c_hw,
+			u32 spm_pwr_status, u32 pwr_mask)
+{
+	if ((spm_pwr_status & pwr_mask) != pwr_mask)
+		return false;
+
+	return clk_hw_is_on(c_hw);
+}
+
+static bool pvdck_pwr_is_on(struct provider_clk *pvdck, u32 spm_pwr_status)
+{
+	struct clk *c = pvdck->ck;
+	struct clk_hw *c_hw = __clk_get_hw(c);
+
+	return clk_hw_pwr_is_on(c_hw, spm_pwr_status, pvdck->pwr_mask);
+}
+
+static bool pvdck_is_on(struct provider_clk *pvdck)
+{
+	u32 spm_pwr_status = 0;
+
+	if (pvdck->pwr_mask != 0U)
+		spm_pwr_status = read_spm_pwr_status();
+
+	return pvdck_pwr_is_on(pvdck, spm_pwr_status);
+}
+
+static const char *ccf_state(struct clk_hw *hw)
+{
+	if (__clk_get_enable_count(hw->clk))
+		return "enabled";
+
+	if (clk_hw_is_prepared(hw))
+		return "prepared";
+
+	return "disabled";
+}
+
+static void dump_clk_state(const char *clkname, struct seq_file *s)
+{
+	struct clk *c = __clk_lookup(clkname);
+	struct clk *p = IS_ERR_OR_NULL(c) ? NULL : clk_get_parent(c);
+	struct clk_hw *c_hw = __clk_get_hw(c);
+	struct clk_hw *p_hw = __clk_get_hw(p);
+
+	if (IS_ERR_OR_NULL(c)) {
+		seq_printf(s, "[%17s: NULL]\n", clkname);
+		return;
+	}
+
+	seq_printf(s, "[%-17s: %8s, %3d, %3d, %10ld, %17s]\n",
+		clk_hw_get_name(c_hw),
+		ccf_state(c_hw),
+		clk_hw_is_prepared(c_hw),
+		__clk_get_enable_count(c),
+		clk_hw_get_rate(c_hw),
+		p != NULL ? clk_hw_get_name(p_hw) : "- ");
+}
+
+static int clkdbg_dump_state_all(struct seq_file *s, void *v)
+{
+	const char * const *ckn = get_all_clk_names();
+
+	if (ckn == NULL)
+		return 0;
+
+	for (; *ckn != NULL; ckn++)
+		dump_clk_state(*ckn, s);
+
+	return 0;
+}
+
+static const char *get_provider_name(struct device_node *node, u32 *cells)
+{
+	const char *name;
+	const char *p;
+	u32 cc;
+
+	if (of_property_read_u32(node, "#clock-cells", &cc) != 0)
+		cc = 0;
+
+	if (cells != NULL)
+		*cells = cc;
+
+	if (cc == 0U) {
+		if (of_property_read_string(node,
+				"clock-output-names", &name) < 0)
+			name = node->name;
+
+		return name;
+	}
+
+	if (of_property_read_string(node, "compatible", &name) < 0)
+		name = node->name;
+
+	p = strchr(name, (int)'-');
+
+	if (p != NULL)
+		return p + 1;
+	else
+		return name;
+}
+
+struct provider_clk *get_all_provider_clks(void)
+{
+	static struct provider_clk provider_clks[512];
+	struct device_node *node = NULL;
+	int n = 0;
+
+	if (provider_clks[0].ck != NULL)
+		return provider_clks;
+
+	do {
+		const char *node_name;
+		u32 cells;
+
+		node = of_find_node_with_property(node, "#clock-cells");
+
+		if (node == NULL)
+			break;
+
+		node_name = get_provider_name(node, &cells);
+
+		if (cells == 0U) {
+			struct clk *ck = __clk_lookup(node_name);
+
+			if (IS_ERR_OR_NULL(ck))
+				continue;
+
+			provider_clks[n].ck = ck;
+			setup_provider_clk(&provider_clks[n]);
+			++n;
+		} else {
+			unsigned int i;
+
+			for (i = 0; i < 256; i++) {
+				struct of_phandle_args pa;
+				struct clk *ck;
+
+				pa.np = node;
+				pa.args[0] = i;
+				pa.args_count = 1;
+				ck = of_clk_get_from_provider(&pa);
+
+				if (PTR_ERR(ck) == -EINVAL)
+					break;
+				else if (IS_ERR_OR_NULL(ck))
+					continue;
+
+				provider_clks[n].ck = ck;
+				provider_clks[n].idx = i;
+				provider_clks[n].provider_name = node_name;
+				setup_provider_clk(&provider_clks[n]);
+				++n;
+			}
+		}
+	} while (node != NULL);
+
+	return provider_clks;
+}
+
+static void dump_provider_clk(struct provider_clk *pvdck, struct seq_file *s)
+{
+	struct clk *c = pvdck->ck;
+	struct clk *p = IS_ERR_OR_NULL(c) ? NULL : clk_get_parent(c);
+	struct clk_hw *c_hw = __clk_get_hw(c);
+	struct clk_hw *p_hw = __clk_get_hw(p);
+
+	seq_printf(s, "[%10s: %-17s: %3s, %3d, %3d, %10ld, %17s]\n",
+		pvdck->provider_name != NULL ? pvdck->provider_name : "/ ",
+		clk_hw_get_name(c_hw),
+		pvdck_is_on(pvdck) ? "ON" : "off",
+		clk_hw_is_prepared(c_hw),
+		__clk_get_enable_count(c),
+		clk_hw_get_rate(c_hw),
+		p != NULL ? clk_hw_get_name(p_hw) : "- ");
+}
+
+static int clkdbg_dump_provider_clks(struct seq_file *s, void *v)
+{
+	struct provider_clk *pvdck = get_all_provider_clks();
+
+	for (; pvdck->ck != NULL; pvdck++)
+		dump_provider_clk(pvdck, s);
+
+	return 0;
+}
+
+static void dump_provider_mux(struct provider_clk *pvdck, struct seq_file *s)
+{
+	unsigned int i;
+	struct clk *c = pvdck->ck;
+	struct clk_hw *c_hw = __clk_get_hw(c);
+	unsigned int np = clk_hw_get_num_parents(c_hw);
+
+	if (np <= 1U)
+		return;
+
+	dump_provider_clk(pvdck, s);
+
+	for (i = 0; i < np; i++) {
+		struct clk_hw *p_hw = clk_hw_get_parent_by_index(c_hw, i);
+
+		if (IS_ERR_OR_NULL(p_hw))
+			continue;
+
+		seq_printf(s, "\t\t\t(%2d: %-17s: %8s, %10ld)\n",
+			i,
+			clk_hw_get_name(p_hw),
+			ccf_state(p_hw),
+			clk_hw_get_rate(p_hw));
+	}
+}
+
+static int clkdbg_dump_muxes(struct seq_file *s, void *v)
+{
+	struct provider_clk *pvdck = get_all_provider_clks();
+
+	for (; pvdck->ck != NULL; pvdck++)
+		dump_provider_mux(pvdck, s);
+
+	return 0;
+}
+
+static void show_pwr_status(u32 spm_pwr_status)
+{
+	unsigned int i;
+	const char * const *pwr_name = get_pwr_names();
+
+	pr_info("SPM_PWR_STATUS: 0x%08x\n\n", spm_pwr_status);
+
+	for (i = 0; i < 32; i++) {
+		const char *st = (spm_pwr_status & BIT(i)) != 0U ? "ON" : "off";
+
+		pr_info("[%2d]: %3s: %s\n", i, st, pwr_name[i]);
+		mdelay(20);
+	}
+}
+
+static int dump_pwr_status(u32 spm_pwr_status, struct seq_file *s)
+{
+	unsigned int i;
+	const char * const *pwr_name = get_pwr_names();
+
+	seq_printf(s, "SPM_PWR_STATUS: 0x%08x\n\n", spm_pwr_status);
+
+	for (i = 0; i < 32; i++) {
+		const char *st = (spm_pwr_status & BIT(i)) != 0U ? "ON" : "off";
+
+		seq_printf(s, "[%2d]: %3s: %s\n", i, st, pwr_name[i]);
+	}
+
+	return 0;
+}
+
+static int clkdbg_pwr_status(struct seq_file *s, void *v)
+{
+	return dump_pwr_status(read_spm_pwr_status(), s);
+}
+
+static char last_cmd[128] = "null";
+
+const char *get_last_cmd(void)
+{
+	return last_cmd;
+}
+
+static int clkop_int_ckname(int (*clkop)(struct clk *clk),
+			const char *clkop_name, const char *clk_name,
+			struct clk *ck, struct seq_file *s)
+{
+	struct clk *clk;
+
+	if (!IS_ERR_OR_NULL(ck)) {
+		clk = ck;
+	} else {
+		clk = __clk_lookup(clk_name);
+		if (IS_ERR_OR_NULL(clk)) {
+			seq_printf(s, "clk_lookup(%s): 0x%p\n", clk_name, clk);
+			return PTR_ERR(clk);
+		}
+	}
+
+	return clkop(clk);
+}
+
+static int clkdbg_clkop_int_ckname(int (*clkop)(struct clk *clk),
+			const char *clkop_name, struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *clk_name;
+	int r = 0;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	clk_name = strsep(&c, " ");
+
+	if (clk_name == NULL)
+		return 0;
+
+	if (strcmp(clk_name, "all") == 0) {
+		struct provider_clk *pvdck = get_all_provider_clks();
+
+		for (; pvdck->ck != NULL; pvdck++) {
+			r |= clkop_int_ckname(clkop, clkop_name, NULL,
+						pvdck->ck, s);
+		}
+
+		seq_printf(s, "%s(%s): %d\n", clkop_name, clk_name, r);
+
+		return r;
+	}
+
+	r = clkop_int_ckname(clkop, clkop_name, clk_name, NULL, s);
+	seq_printf(s, "%s(%s): %d\n", clkop_name, clk_name, r);
+
+	return r;
+}
+
+static void clkop_void_ckname(void (*clkop)(struct clk *clk),
+			const char *clkop_name, const char *clk_name,
+			struct clk *ck, struct seq_file *s)
+{
+	struct clk *clk;
+
+	if (!IS_ERR_OR_NULL(ck)) {
+		clk = ck;
+	} else {
+		clk = __clk_lookup(clk_name);
+		if (IS_ERR_OR_NULL(clk)) {
+			seq_printf(s, "clk_lookup(%s): 0x%p\n", clk_name, clk);
+			return;
+		}
+	}
+
+	clkop(clk);
+}
+
+static int clkdbg_clkop_void_ckname(void (*clkop)(struct clk *clk),
+			const char *clkop_name, struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *clk_name;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	clk_name = strsep(&c, " ");
+
+	if (clk_name == NULL)
+		return 0;
+
+	if (strcmp(clk_name, "all") == 0) {
+		struct provider_clk *pvdck = get_all_provider_clks();
+
+		for (; pvdck->ck != NULL; pvdck++) {
+			clkop_void_ckname(clkop, clkop_name, NULL,
+						pvdck->ck, s);
+		}
+
+		seq_printf(s, "%s(%s)\n", clkop_name, clk_name);
+
+		return 0;
+	}
+
+	clkop_void_ckname(clkop, clkop_name, clk_name, NULL, s);
+	seq_printf(s, "%s(%s)\n", clkop_name, clk_name);
+
+	return 0;
+}
+
+static int clkdbg_prepare(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_int_ckname(clk_prepare,
+					"clk_prepare", s, v);
+}
+
+static int clkdbg_unprepare(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_void_ckname(clk_unprepare,
+					"clk_unprepare", s, v);
+}
+
+static int clkdbg_enable(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_int_ckname(clk_enable,
+					"clk_enable", s, v);
+}
+
+static int clkdbg_disable(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_void_ckname(clk_disable,
+					"clk_disable", s, v);
+}
+
+static int clkdbg_prepare_enable(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_int_ckname(clk_prepare_enable,
+					"clk_prepare_enable", s, v);
+}
+
+static int clkdbg_disable_unprepare(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_void_ckname(clk_disable_unprepare,
+					"clk_disable_unprepare", s, v);
+}
+
+void prepare_enable_provider(const char *pvd)
+{
+	bool allpvd = (pvd == NULL || strcmp(pvd, "all") == 0);
+	struct provider_clk *pvdck = get_all_provider_clks();
+
+	for (; pvdck->ck != NULL; pvdck++) {
+		if (allpvd || (pvdck->provider_name != NULL &&
+				strcmp(pvd, pvdck->provider_name) == 0)) {
+			int r = clk_prepare_enable(pvdck->ck);
+
+			if (r != 0)
+				pr_info("clk_prepare_enable(): %d\n", r);
+		}
+	}
+}
+
+void disable_unprepare_provider(const char *pvd)
+{
+	bool allpvd = (pvd == NULL || strcmp(pvd, "all") == 0);
+	struct provider_clk *pvdck = get_all_provider_clks();
+
+	for (; pvdck->ck != NULL; pvdck++) {
+		if (allpvd || (pvdck->provider_name != NULL &&
+				strcmp(pvd, pvdck->provider_name) == 0))
+			clk_disable_unprepare(pvdck->ck);
+	}
+}
+
+static void clkpvdop(void (*pvdop)(const char *), const char *clkpvdop_name,
+			struct seq_file *s)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *pvd_name;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	pvd_name = strsep(&c, " ");
+
+	if (pvd_name == NULL)
+		return;
+
+	pvdop(pvd_name);
+	seq_printf(s, "%s(%s)\n", clkpvdop_name, pvd_name);
+}
+
+static int clkdbg_prepare_enable_provider(struct seq_file *s, void *v)
+{
+	clkpvdop(prepare_enable_provider, "prepare_enable_provider", s);
+	return 0;
+}
+
+static int clkdbg_disable_unprepare_provider(struct seq_file *s, void *v)
+{
+	clkpvdop(disable_unprepare_provider, "disable_unprepare_provider", s);
+	return 0;
+}
+
+static int clkdbg_set_parent(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *clk_name;
+	char *parent_name;
+	struct clk *clk;
+	struct clk *parent;
+	int r;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	clk_name = strsep(&c, " ");
+	parent_name = strsep(&c, " ");
+
+	if (clk_name == NULL || parent_name == NULL)
+		return 0;
+
+	seq_printf(s, "clk_set_parent(%s, %s): ", clk_name, parent_name);
+
+	clk = __clk_lookup(clk_name);
+	if (IS_ERR_OR_NULL(clk)) {
+		seq_printf(s, "__clk_lookup(): 0x%p\n", clk);
+		return PTR_ERR(clk);
+	}
+
+	parent = __clk_lookup(parent_name);
+	if (IS_ERR_OR_NULL(parent)) {
+		seq_printf(s, "__clk_lookup(): 0x%p\n", parent);
+		return PTR_ERR(parent);
+	}
+
+	r = clk_prepare_enable(clk);
+	if (r != 0) {
+		seq_printf(s, "clk_prepare_enable(): %d\n", r);
+		return r;
+	}
+
+	r = clk_set_parent(clk, parent);
+	seq_printf(s, "%d\n", r);
+
+	clk_disable_unprepare(clk);
+
+	return r;
+}
+
+static int clkdbg_set_rate(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *clk_name;
+	char *rate_str;
+	struct clk *clk;
+	unsigned long rate;
+	int r;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	clk_name = strsep(&c, " ");
+	rate_str = strsep(&c, " ");
+
+	if (clk_name == NULL || rate_str == NULL)
+		return 0;
+
+	r = kstrtoul(rate_str, 0, &rate);
+
+	seq_printf(s, "clk_set_rate(%s, %lu): %d: ", clk_name, rate, r);
+
+	clk = __clk_lookup(clk_name);
+	if (IS_ERR_OR_NULL(clk)) {
+		seq_printf(s, "__clk_lookup(): 0x%p\n", clk);
+		return PTR_ERR(clk);
+	}
+
+	r = clk_set_rate(clk, rate);
+	seq_printf(s, "%d\n", r);
+
+	return r;
+}
+
+static void *reg_from_str(const char *str)
+{
+	static phys_addr_t phys;
+	static void __iomem *virt;
+
+	if (sizeof(void *) == sizeof(unsigned long)) {
+		unsigned long v;
+
+		if (kstrtoul(str, 0, &v) == 0U) {
+			if ((0xf0000000 & v) < 0x20000000) {
+				if (virt != NULL && v > phys
+						&& v < phys + PAGE_SIZE)
+					return virt + v - phys;
+
+				if (virt != NULL)
+					iounmap(virt);
+
+				phys = v & ~(PAGE_SIZE - 1U);
+				virt = ioremap(phys, PAGE_SIZE);
+
+				return virt + v - phys;
+			}
+
+			return (void *)((uintptr_t)v);
+		}
+	} else if (sizeof(void *) == sizeof(unsigned long long)) {
+		unsigned long long v;
+
+		if (kstrtoull(str, 0, &v) == 0) {
+			if ((0xfffffffff0000000ULL & v) < 0x20000000) {
+				if (virt && v > phys && v < phys + PAGE_SIZE)
+					return virt + v - phys;
+
+				if (virt != NULL)
+					iounmap(virt);
+
+				phys = v & ~(PAGE_SIZE - 1);
+				virt = ioremap(phys, PAGE_SIZE);
+
+				return virt + v - phys;
+			}
+
+			return (void *)((uintptr_t)v);
+		}
+	} else {
+		pr_warn("unexpected pointer size: sizeof(void *): %zu\n",
+			sizeof(void *));
+	}
+
+	pr_warn("%s(): parsing error: %s\n", __func__, str);
+
+	return NULL;
+}
+
+static int parse_reg_val_from_cmd(void __iomem **preg, unsigned long *pval)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *reg_str;
+	char *val_str;
+	int r = 0;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	reg_str = strsep(&c, " ");
+	val_str = strsep(&c, " ");
+
+	if (preg != NULL && reg_str != NULL) {
+		*preg = reg_from_str(reg_str);
+		if (*preg != NULL)
+			r++;
+	}
+
+	if (pval != NULL && val_str != NULL && kstrtoul(val_str, 0, pval) == 0)
+		r++;
+
+	return r;
+}
+
+static int clkdbg_reg_read(struct seq_file *s, void *v)
+{
+	void __iomem *reg;
+	unsigned long val;
+
+	if (parse_reg_val_from_cmd(&reg, NULL) != 1)
+		return 0;
+
+	seq_printf(s, "readl(0x%p): ", reg);
+
+	val = clk_readl(reg);
+	seq_printf(s, "0x%08x\n", (u32)val);
+
+	return 0;
+}
+
+static int clkdbg_reg_write(struct seq_file *s, void *v)
+{
+	void __iomem *reg;
+	unsigned long val;
+
+	if (parse_reg_val_from_cmd(&reg, &val) != 2)
+		return 0;
+
+	seq_printf(s, "writel(0x%p, 0x%08x): ", reg, (u32)val);
+
+	clk_writel(reg, val);
+	val = clk_readl(reg);
+	seq_printf(s, "0x%08x\n", (u32)val);
+
+	return 0;
+}
+
+static int clkdbg_reg_set(struct seq_file *s, void *v)
+{
+	void __iomem *reg;
+	unsigned long val;
+
+	if (parse_reg_val_from_cmd(&reg, &val) != 2)
+		return 0;
+
+	seq_printf(s, "writel(0x%p, 0x%08x): ", reg, (u32)val);
+
+	clk_setl(reg, val);
+	val = clk_readl(reg);
+	seq_printf(s, "0x%08x\n", (u32)val);
+
+	return 0;
+}
+
+static int clkdbg_reg_clr(struct seq_file *s, void *v)
+{
+	void __iomem *reg;
+	unsigned long val;
+
+	if (parse_reg_val_from_cmd(&reg, &val) != 2)
+		return 0;
+
+	seq_printf(s, "writel(0x%p, 0x%08x): ", reg, (u32)val);
+
+	clk_clrl(reg, val);
+	val = clk_readl(reg);
+	seq_printf(s, "0x%08x\n", (u32)val);
+
+	return 0;
+}
+
+static int parse_val_from_cmd(unsigned long *pval)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *val_str;
+	int r = 0;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	val_str = strsep(&c, " ");
+
+	if (pval != NULL && val_str != NULL && kstrtoul(val_str, 0, pval) == 0)
+		r++;
+
+	return r;
+}
+
+static int clkdbg_show_flags(struct seq_file *s, void *v)
+{
+	static const char * const clkdbg_opt_name[] = {
+		"CLKDBG_EN_SUSPEND_SAVE_1",
+		"CLKDBG_EN_SUSPEND_SAVE_2",
+		"CLKDBG_EN_SUSPEND_SAVE_3",
+		"CLKDBG_EN_LOG_SAVE_POINTS",
+	};
+
+	size_t i;
+
+	seq_printf(s, "clkdbg_flags: 0x%08x\n", clkdbg_flags);
+
+	for (i = 0; i < ARRAY_SIZE(clkdbg_opt_name); i++) {
+		const char *onff =
+			has_clkdbg_flag((enum clkdbg_opt)i) ? "ON" : "off";
+
+		seq_printf(s, "[%2zd]: %3s: %s\n", i, onff, clkdbg_opt_name[i]);
+	}
+
+	return 0;
+}
+
+static int clkdbg_set_flag(struct seq_file *s, void *v)
+{
+	unsigned long val;
+
+	if (parse_val_from_cmd(&val) != 1)
+		return 0;
+
+	set_clkdbg_flag((enum clkdbg_opt)val);
+
+	seq_printf(s, "clkdbg_flags: 0x%08x\n", clkdbg_flags);
+
+	return 0;
+}
+
+static int clkdbg_clr_flag(struct seq_file *s, void *v)
+{
+	unsigned long val;
+
+	if (parse_val_from_cmd(&val) != 1)
+		return 0;
+
+	clr_clkdbg_flag((enum clkdbg_opt)val);
+
+	seq_printf(s, "clkdbg_flags: 0x%08x\n", clkdbg_flags);
+
+	return 0;
+}
+
+#if CLKDBG_PM_DOMAIN
+
+/*
+ * pm_domain support
+ */
+
+static struct generic_pm_domain **get_all_genpd(void)
+{
+	static struct generic_pm_domain *pds[20];
+	static int num_pds;
+	const size_t maxpd = ARRAY_SIZE(pds);
+	struct device_node *node;
+#if CLKDBG_PM_DOMAIN_API_4_9
+	struct platform_device *pdev;
+	int r;
+#endif
+
+	if (num_pds != 0)
+		goto out;
+
+	node = of_find_node_with_property(NULL, "#power-domain-cells");
+
+	if (node == NULL)
+		return NULL;
+
+#if CLKDBG_PM_DOMAIN_API_4_9
+	pdev = platform_device_alloc("traverse", 0);
+#endif
+
+	for (num_pds = 0; num_pds < maxpd; num_pds++) {
+		struct of_phandle_args pa;
+
+		pa.np = node;
+		pa.args[0] = num_pds;
+		pa.args_count = 1;
+
+#if CLKDBG_PM_DOMAIN_API_4_9
+		r = of_genpd_add_device(&pa, &pdev->dev);
+		if (r == -EINVAL)
+			continue;
+		else if (r != 0)
+			pr_warn("%s(): of_genpd_add_device(%d)\n", __func__, r);
+		pds[num_pds] = pd_to_genpd(pdev->dev.pm_domain);
+#if CLKDBG_DROP_GENPD_AS_IN_PARAM
+		r = pm_genpd_remove_device(&pdev->dev);
+#else
+		r = pm_genpd_remove_device(pds[num_pds], &pdev->dev);
+#endif
+		if (r != 0)
+			pr_warn("%s(): pm_genpd_remove_device(%d)\n",
+					__func__, r);
+#else
+		pds[num_pds] = of_genpd_get_from_provider(&pa);
+#endif
+
+		if (IS_ERR(pds[num_pds])) {
+			pds[num_pds] = NULL;
+			break;
+		}
+	}
+
+#if CLKDBG_PM_DOMAIN_API_4_9
+	platform_device_put(pdev);
+#endif
+
+out:
+	return pds;
+}
+
+static struct platform_device *pdev_from_name(const char *name)
+{
+	struct generic_pm_domain **pds = get_all_genpd();
+
+	for (; *pds != NULL; pds++) {
+		struct pm_domain_data *pdd;
+		struct generic_pm_domain *pd = *pds;
+
+		if (IS_ERR_OR_NULL(pd))
+			continue;
+
+		list_for_each_entry(pdd, &pd->dev_list, list_node) {
+			struct device *dev = pdd->dev;
+			struct platform_device *pdev = to_platform_device(dev);
+
+			if (strcmp(name, pdev->name) == 0)
+				return pdev;
+		}
+	}
+
+	return NULL;
+}
+
+static struct generic_pm_domain *genpd_from_name(const char *name)
+{
+	struct generic_pm_domain **pds = get_all_genpd();
+
+	for (; *pds != NULL; pds++) {
+		struct generic_pm_domain *pd = *pds;
+
+		if (IS_ERR_OR_NULL(pd))
+			continue;
+
+		if (strcmp(name, pd->name) == 0)
+			return pd;
+	}
+
+	return NULL;
+}
+
+struct genpd_dev_state {
+	struct device *dev;
+	bool active;
+	atomic_t usage_count;
+	unsigned int disable_depth;
+	enum rpm_status runtime_status;
+};
+
+struct genpd_state {
+	struct generic_pm_domain *pd;
+	enum gpd_status status;
+	struct genpd_dev_state *dev_state;
+	int num_dev_state;
+};
+
+static void save_all_genpd_state(struct genpd_state *genpd_states,
+				struct genpd_dev_state *genpd_dev_states)
+{
+	struct genpd_state *pdst = genpd_states;
+	struct genpd_dev_state *devst = genpd_dev_states;
+	struct generic_pm_domain **pds = get_all_genpd();
+
+	for (; *pds != NULL; pds++) {
+		struct pm_domain_data *pdd;
+		struct generic_pm_domain *pd = *pds;
+
+		if (IS_ERR_OR_NULL(pd))
+			continue;
+
+		pdst->pd = pd;
+		pdst->status = pd->status;
+		pdst->dev_state = devst;
+		pdst->num_dev_state = 0;
+
+		list_for_each_entry(pdd, &pd->dev_list, list_node) {
+			struct device *d = pdd->dev;
+
+			devst->dev = d;
+			devst->active = pm_runtime_active(d);
+			devst->usage_count = d->power.usage_count;
+			devst->disable_depth = d->power.disable_depth;
+			devst->runtime_status = d->power.runtime_status;
+
+			devst++;
+			pdst->num_dev_state++;
+		}
+
+		pdst++;
+	}
+
+	pdst->pd = NULL;
+	devst->dev = NULL;
+}
+
+static void show_genpd_state(struct genpd_state *pdst)
+{
+	static const char * const gpd_status_name[] = {
+		"ACTIVE",
+		"POWER_OFF",
+	};
+
+	static const char * const prm_status_name[] = {
+		"active",
+		"resuming",
+		"suspended",
+		"suspending",
+	};
+
+	pr_info("domain_on [pmd_name  status]\n");
+	pr_info("\tdev_on (dev_name usage_count, disable, status)\n");
+	pr_info("------------------------------------------------------\n");
+
+	for (; pdst->pd != NULL; pdst++) {
+		int i;
+		struct generic_pm_domain *pd = pdst->pd;
+
+		if (IS_ERR_OR_NULL(pd)) {
+			pr_info("pd: 0x%p\n", pd);
+			continue;
+		}
+
+		pr_info("%c [%-9s %11s]\n",
+			(pdst->status == GPD_STATE_ACTIVE) ? '+' : '-',
+			pd->name, gpd_status_name[pdst->status]);
+
+		for (i = 0; i < pdst->num_dev_state; i++) {
+			struct genpd_dev_state *devst = &pdst->dev_state[i];
+			struct device *dev = devst->dev;
+			struct platform_device *pdev = to_platform_device(dev);
+
+			pr_info("\t%c (%-19s %3d, %d, %10s)\n",
+				devst->active ? '+' : '-',
+				pdev->name,
+				atomic_read(&dev->power.usage_count),
+				devst->disable_depth,
+				prm_status_name[devst->runtime_status]);
+			mdelay(20);
+		}
+	}
+}
+
+static void dump_genpd_state(struct genpd_state *pdst, struct seq_file *s)
+{
+	static const char * const gpd_status_name[] = {
+		"ACTIVE",
+		"POWER_OFF",
+	};
+
+	static const char * const prm_status_name[] = {
+		"active",
+		"resuming",
+		"suspended",
+		"suspending",
+	};
+
+	seq_puts(s, "domain_on [pmd_name  status]\n");
+	seq_puts(s, "\tdev_on (dev_name usage_count, disable, status)\n");
+	seq_puts(s, "------------------------------------------------------\n");
+
+	for (; pdst->pd != NULL; pdst++) {
+		int i;
+		struct generic_pm_domain *pd = pdst->pd;
+
+		if (IS_ERR_OR_NULL(pd)) {
+			seq_printf(s, "pd: 0x%p\n", pd);
+			continue;
+		}
+
+		seq_printf(s, "%c [%-9s %11s]\n",
+			(pdst->status == GPD_STATE_ACTIVE) ? '+' : '-',
+			pd->name, gpd_status_name[pdst->status]);
+
+		for (i = 0; i < pdst->num_dev_state; i++) {
+			struct genpd_dev_state *devst = &pdst->dev_state[i];
+			struct device *dev = devst->dev;
+			struct platform_device *pdev = to_platform_device(dev);
+
+			seq_printf(s, "\t%c (%-19s %3d, %d, %10s)\n",
+				devst->active ? '+' : '-',
+				pdev->name,
+				atomic_read(&dev->power.usage_count),
+				devst->disable_depth,
+				prm_status_name[devst->runtime_status]);
+		}
+	}
+}
+
+static void seq_print_all_genpd(struct seq_file *s)
+{
+	static struct genpd_dev_state devst[100];
+	static struct genpd_state pdst[20];
+
+	save_all_genpd_state(pdst, devst);
+	dump_genpd_state(pdst, s);
+}
+
+static int clkdbg_dump_genpd(struct seq_file *s, void *v)
+{
+	seq_print_all_genpd(s);
+
+	return 0;
+}
+
+static int clkdbg_pm_runtime_enable(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *dev_name;
+	struct platform_device *pdev;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	dev_name = strsep(&c, " ");
+
+	if (dev_name == NULL)
+		return 0;
+
+	seq_printf(s, "pm_runtime_enable(%s): ", dev_name);
+
+	pdev = pdev_from_name(dev_name);
+	if (pdev != NULL) {
+		pm_runtime_enable(&pdev->dev);
+		seq_puts(s, "\n");
+	} else {
+		seq_puts(s, "NULL\n");
+	}
+
+	return 0;
+}
+
+static int clkdbg_pm_runtime_disable(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *dev_name;
+	struct platform_device *pdev;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	dev_name = strsep(&c, " ");
+
+	if (dev_name == NULL)
+		return 0;
+
+	seq_printf(s, "pm_runtime_disable(%s): ", dev_name);
+
+	pdev = pdev_from_name(dev_name);
+	if (pdev != NULL) {
+		pm_runtime_disable(&pdev->dev);
+		seq_puts(s, "\n");
+	} else {
+		seq_puts(s, "NULL\n");
+	}
+
+	return 0;
+}
+
+static int clkdbg_pm_runtime_get_sync(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *dev_name;
+	struct platform_device *pdev;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	dev_name = strsep(&c, " ");
+
+	if (dev_name == NULL)
+		return 0;
+
+	seq_printf(s, "pm_runtime_get_sync(%s): ", dev_name);
+
+	pdev = pdev_from_name(dev_name);
+	if (pdev != NULL) {
+		int r = pm_runtime_get_sync(&pdev->dev);
+
+		seq_printf(s, "%d\n", r);
+	} else {
+		seq_puts(s, "NULL\n");
+	}
+
+	return 0;
+}
+
+static int clkdbg_pm_runtime_put_sync(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *dev_name;
+	struct platform_device *pdev;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	dev_name = strsep(&c, " ");
+
+	if (dev_name == NULL)
+		return 0;
+
+	seq_printf(s, "pm_runtime_put_sync(%s): ", dev_name);
+
+	pdev = pdev_from_name(dev_name);
+	if (pdev != NULL) {
+		int r = pm_runtime_put_sync(&pdev->dev);
+
+		seq_printf(s, "%d\n", r);
+	} else {
+		seq_puts(s, "NULL\n");
+	}
+
+	return 0;
+}
+
+static int genpd_op(const char *gpd_op_name, struct seq_file *s)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *pd_name;
+	struct generic_pm_domain *genpd;
+	int gpd_op_id;
+	int (*gpd_op)(struct generic_pm_domain *genpd);
+	int r = 0;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	pd_name = strsep(&c, " ");
+
+	if (pd_name == NULL)
+		return 0;
+
+	if (strcmp(gpd_op_name, "power_on") == 0)
+		gpd_op_id = 1;
+	else
+		gpd_op_id = 0;
+
+	if (strcmp(pd_name, "all") == 0) {
+		struct generic_pm_domain **pds = get_all_genpd();
+
+		for (; *pds != NULL; pds++) {
+			genpd = *pds;
+
+			if (IS_ERR_OR_NULL(genpd))
+				continue;
+
+			gpd_op = (gpd_op_id == 1) ?
+					genpd->power_on : genpd->power_off;
+			r |= gpd_op(genpd);
+		}
+
+		seq_printf(s, "%s(%s): %d\n", gpd_op_name, pd_name, r);
+
+		return 0;
+	}
+
+	genpd = genpd_from_name(pd_name);
+	if (genpd != NULL) {
+		gpd_op = (gpd_op_id == 1) ? genpd->power_on : genpd->power_off;
+		r = gpd_op(genpd);
+
+		seq_printf(s, "%s(%s): %d\n", gpd_op_name, pd_name, r);
+	} else {
+		seq_printf(s, "genpd_from_name(%s): NULL\n", pd_name);
+	}
+
+	return 0;
+}
+
+static int clkdbg_pwr_on(struct seq_file *s, void *v)
+{
+	return genpd_op("power_on", s);
+}
+
+static int clkdbg_pwr_off(struct seq_file *s, void *v)
+{
+	return genpd_op("power_off", s);
+}
+
+/*
+ * clkdbg reg_pdrv/runeg_pdrv support
+ */
+
+static int clkdbg_probe(struct platform_device *pdev)
+{
+	int r;
+
+	pm_runtime_enable(&pdev->dev);
+	r = pm_runtime_get_sync(&pdev->dev);
+	if (r != 0)
+		pr_warn("%s(): pm_runtime_get_sync(%d)\n", __func__, r);
+
+	return r;
+}
+
+static int clkdbg_remove(struct platform_device *pdev)
+{
+	int r;
+
+	r = pm_runtime_put_sync(&pdev->dev);
+	if (r != 0)
+		pr_warn("%s(): pm_runtime_put_sync(%d)\n", __func__, r);
+	pm_runtime_disable(&pdev->dev);
+
+	return r;
+}
+
+struct pdev_drv {
+	struct platform_driver pdrv;
+	struct platform_device *pdev;
+	struct generic_pm_domain *genpd;
+};
+
+#define PDEV_DRV(_name) {				\
+	.pdrv = {					\
+		.probe		= clkdbg_probe,		\
+		.remove		= clkdbg_remove,	\
+		.driver		= {			\
+			.name	= _name,		\
+		},					\
+	},						\
+}
+
+static struct pdev_drv pderv[] = {
+	PDEV_DRV("clkdbg-pd0"),
+	PDEV_DRV("clkdbg-pd1"),
+	PDEV_DRV("clkdbg-pd2"),
+	PDEV_DRV("clkdbg-pd3"),
+	PDEV_DRV("clkdbg-pd4"),
+	PDEV_DRV("clkdbg-pd5"),
+	PDEV_DRV("clkdbg-pd6"),
+	PDEV_DRV("clkdbg-pd7"),
+	PDEV_DRV("clkdbg-pd8"),
+	PDEV_DRV("clkdbg-pd9"),
+	PDEV_DRV("clkdbg-pd10"),
+	PDEV_DRV("clkdbg-pd11"),
+	PDEV_DRV("clkdbg-pd12"),
+	PDEV_DRV("clkdbg-pd13"),
+	PDEV_DRV("clkdbg-pd14"),
+	PDEV_DRV("clkdbg-pd15"),
+};
+
+static void reg_pdev_drv(const char *pdname, struct seq_file *s)
+{
+	size_t i;
+	struct generic_pm_domain **pds = get_all_genpd();
+	bool allpd = (pdname == NULL || strcmp(pdname, "all") == 0);
+	int r;
+
+	for (i = 0; i < ARRAY_SIZE(pderv) && *pds != NULL; i++, pds++) {
+		const char *name = pderv[i].pdrv.driver.name;
+		struct generic_pm_domain *pd = *pds;
+
+		if (IS_ERR_OR_NULL(pd) || pderv[i].genpd != NULL)
+			continue;
+
+		if (!allpd && strcmp(pdname, pd->name) != 0)
+			continue;
+
+		pderv[i].genpd = pd;
+
+		pderv[i].pdev = platform_device_alloc(name, 0);
+		r = platform_device_add(pderv[i].pdev);
+		if (r != 0 && s != NULL)
+			seq_printf(s, "%s(): platform_device_add(%d)\n",
+						__func__, r);
+
+		r = pm_genpd_add_device(pd, &pderv[i].pdev->dev);
+		if (r != 0 && s != NULL)
+			seq_printf(s, "%s(): pm_genpd_add_device(%d)\n",
+						__func__, r);
+		r = platform_driver_register(&pderv[i].pdrv);
+		if (r != 0 && s != NULL)
+			seq_printf(s, "%s(): platform_driver_register(%d)\n",
+						__func__, r);
+
+		if (s != NULL)
+			seq_printf(s, "%s --> %s\n", name, pd->name);
+	}
+}
+
+static void unreg_pdev_drv(const char *pdname, struct seq_file *s)
+{
+	ssize_t i;
+	bool allpd = (pdname == NULL || strcmp(pdname, "all") == 0);
+	int r;
+
+	for (i = ARRAY_SIZE(pderv) - 1L; i >= 0L; i--) {
+		const char *name = pderv[i].pdrv.driver.name;
+		struct generic_pm_domain *pd = pderv[i].genpd;
+
+		if (IS_ERR_OR_NULL(pd))
+			continue;
+
+		if (!allpd && strcmp(pdname, pd->name) != 0)
+			continue;
+
+#if CLKDBG_DROP_GENPD_AS_IN_PARAM
+		r = pm_genpd_remove_device(&pderv[i].pdev->dev);
+#else
+		r = pm_genpd_remove_device(pd, &pderv[i].pdev->dev);
+#endif
+		if (r != 0 && s != NULL)
+			seq_printf(s, "%s(): pm_genpd_remove_device(%d)\n",
+						__func__, r);
+
+		platform_driver_unregister(&pderv[i].pdrv);
+		platform_device_unregister(pderv[i].pdev);
+
+		pderv[i].genpd = NULL;
+
+		if (s != NULL)
+			seq_printf(s, "%s -x- %s\n", name, pd->name);
+	}
+}
+
+static int clkdbg_reg_pdrv(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *pd_name;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	pd_name = strsep(&c, " ");
+
+	if (pd_name == NULL)
+		return 0;
+
+	reg_pdev_drv(pd_name, s);
+
+	return 0;
+}
+
+static int clkdbg_unreg_pdrv(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *pd_name;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	pd_name = strsep(&c, " ");
+
+	if (pd_name == NULL)
+		return 0;
+
+	unreg_pdev_drv(pd_name, s);
+
+	return 0;
+}
+
+#endif /* CLKDBG_PM_DOMAIN */
+
+void reg_pdrv(const char *pdname)
+{
+#if CLKDBG_PM_DOMAIN
+	reg_pdev_drv(pdname, NULL);
+#endif
+}
+
+void unreg_pdrv(const char *pdname)
+{
+#if CLKDBG_PM_DOMAIN
+	unreg_pdev_drv(pdname, NULL);
+#endif
+}
+
+/*
+ * Suspend / resume handler
+ */
+
+#include <linux/suspend.h>
+#include <linux/syscore_ops.h>
+
+struct provider_clk_state {
+	struct provider_clk *pvdck;
+	bool prepared;
+	bool enabled;
+	unsigned int enable_count;
+	unsigned long rate;
+	struct clk *parent;
+};
+
+struct save_point {
+	u32 spm_pwr_status;
+	struct provider_clk_state clks_states[512];
+#if CLKDBG_PM_DOMAIN
+	struct genpd_state genpd_states[20];
+	struct genpd_dev_state genpd_dev_states[100];
+#endif
+};
+
+static struct save_point save_point_1;
+static struct save_point save_point_2;
+static struct save_point save_point_3;
+
+static void save_pwr_status(u32 *spm_pwr_status)
+{
+	*spm_pwr_status = read_spm_pwr_status();
+}
+
+static void save_all_clks_state(struct provider_clk_state *clks_states,
+				u32 spm_pwr_status)
+{
+	struct provider_clk *pvdck = get_all_provider_clks();
+	struct provider_clk_state *st = clks_states;
+
+	for (; pvdck->ck != NULL; pvdck++, st++) {
+		struct clk *c = pvdck->ck;
+		struct clk_hw *c_hw = __clk_get_hw(c);
+
+		st->pvdck = pvdck;
+		st->prepared = clk_hw_is_prepared(c_hw);
+		st->enabled = clk_hw_pwr_is_on(c_hw, spm_pwr_status,
+							pvdck->pwr_mask);
+		st->enable_count = __clk_get_enable_count(c);
+		st->rate = clk_hw_get_rate(c_hw);
+		st->parent = IS_ERR_OR_NULL(c) ? NULL : clk_get_parent(c);
+	}
+}
+
+static void show_provider_clk_state(struct provider_clk_state *st)
+{
+	struct provider_clk *pvdck = st->pvdck;
+	struct clk_hw *c_hw = __clk_get_hw(pvdck->ck);
+
+	pr_info("[%10s: %-17s: %3s, %3d, %3d, %10ld, %17s]\n",
+		pvdck->provider_name != NULL ? pvdck->provider_name : "/ ",
+		clk_hw_get_name(c_hw),
+		st->enabled ? "ON" : "off",
+		st->prepared,
+		st->enable_count,
+		st->rate,
+		st->parent != NULL ?
+			clk_hw_get_name(__clk_get_hw(st->parent)) : "- ");
+	mdelay(20);
+}
+
+static void dump_provider_clk_state(struct provider_clk_state *st,
+					struct seq_file *s)
+{
+	struct provider_clk *pvdck = st->pvdck;
+	struct clk_hw *c_hw = __clk_get_hw(pvdck->ck);
+
+	seq_printf(s, "[%10s: %-17s: %3s, %3d, %3d, %10ld, %17s]\n",
+		pvdck->provider_name != NULL ? pvdck->provider_name : "/ ",
+		clk_hw_get_name(c_hw),
+		st->enabled ? "ON" : "off",
+		st->prepared,
+		st->enable_count,
+		st->rate,
+		st->parent != NULL ?
+			clk_hw_get_name(__clk_get_hw(st->parent)) : "- ");
+}
+
+static void show_save_point(struct save_point *sp)
+{
+	struct provider_clk_state *st = sp->clks_states;
+
+	for (; st->pvdck != NULL; st++)
+		show_provider_clk_state(st);
+
+	pr_info("\n");
+	show_pwr_status(sp->spm_pwr_status);
+
+#if CLKDBG_PM_DOMAIN
+	pr_info("\n");
+	show_genpd_state(sp->genpd_states);
+#endif
+}
+
+static void store_save_point(struct save_point *sp)
+{
+	save_pwr_status(&sp->spm_pwr_status);
+	save_all_clks_state(sp->clks_states, sp->spm_pwr_status);
+
+#if CLKDBG_PM_DOMAIN
+	save_all_genpd_state(sp->genpd_states, sp->genpd_dev_states);
+#endif
+
+	if (has_clkdbg_flag(CLKDBG_EN_LOG_SAVE_POINTS))
+		show_save_point(sp);
+}
+
+static void dump_save_point(struct save_point *sp, struct seq_file *s)
+{
+	struct provider_clk_state *st = sp->clks_states;
+
+	for (; st->pvdck != NULL; st++)
+		dump_provider_clk_state(st, s);
+
+	seq_puts(s, "\n");
+	dump_pwr_status(sp->spm_pwr_status, s);
+
+#if CLKDBG_PM_DOMAIN
+	seq_puts(s, "\n");
+	dump_genpd_state(sp->genpd_states, s);
+#endif
+}
+
+static int clkdbg_dump_suspend_clks_1(struct seq_file *s, void *v)
+{
+	dump_save_point(&save_point_1, s);
+	return 0;
+}
+
+static int clkdbg_dump_suspend_clks_2(struct seq_file *s, void *v)
+{
+	dump_save_point(&save_point_2, s);
+	return 0;
+}
+
+static int clkdbg_dump_suspend_clks_3(struct seq_file *s, void *v)
+{
+	dump_save_point(&save_point_3, s);
+	return 0;
+}
+
+static int clkdbg_dump_suspend_clks(struct seq_file *s, void *v)
+{
+	if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_3) &&
+			save_point_3.spm_pwr_status != 0U)
+		return clkdbg_dump_suspend_clks_3(s, v);
+	else if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_2) &&
+			save_point_2.spm_pwr_status != 0U)
+		return clkdbg_dump_suspend_clks_2(s, v);
+	else if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_1) &&
+			save_point_1.spm_pwr_status != 0U)
+		return clkdbg_dump_suspend_clks_1(s, v);
+
+	return 0;
+}
+
+static int clkdbg_pm_event_handler(struct notifier_block *nb,
+					unsigned long event, void *ptr)
+{
+	switch (event) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		/* suspend */
+		if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_1)) {
+			store_save_point(&save_point_1);
+			return NOTIFY_OK;
+		}
+
+		break;
+	case PM_POST_HIBERNATION:
+	case PM_POST_SUSPEND:
+		/* resume */
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block clkdbg_pm_notifier = {
+	.notifier_call = clkdbg_pm_event_handler,
+};
+
+static int clkdbg_syscore_suspend(void)
+{
+	if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_2))
+		store_save_point(&save_point_2);
+
+	return 0;
+}
+
+static void clkdbg_syscore_resume(void)
+{
+}
+
+static struct syscore_ops clkdbg_syscore_ops = {
+	.suspend = clkdbg_syscore_suspend,
+	.resume = clkdbg_syscore_resume,
+};
+
+static int __init clkdbg_pm_init(void)
+{
+	int r;
+
+	register_syscore_ops(&clkdbg_syscore_ops);
+	r = register_pm_notifier(&clkdbg_pm_notifier);
+	if (r != 0)
+		pr_warn("%s(): register_pm_notifier(%d)\n", __func__, r);
+
+	return r;
+}
+subsys_initcall(clkdbg_pm_init);
+
+static int clkdbg_suspend_ops_valid(suspend_state_t state)
+{
+	return state == PM_SUSPEND_MEM ? 1 : 0;
+}
+
+static int clkdbg_suspend_ops_begin(suspend_state_t state)
+{
+	return 0;
+}
+
+static int clkdbg_suspend_ops_prepare(void)
+{
+	return 0;
+}
+
+static int clkdbg_suspend_ops_enter(suspend_state_t state)
+{
+	if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_3))
+		store_save_point(&save_point_3);
+
+	return 0;
+}
+
+static void clkdbg_suspend_ops_finish(void)
+{
+}
+
+static void clkdbg_suspend_ops_end(void)
+{
+}
+
+static const struct platform_suspend_ops clkdbg_suspend_ops = {
+	.valid = clkdbg_suspend_ops_valid,
+	.begin = clkdbg_suspend_ops_begin,
+	.prepare = clkdbg_suspend_ops_prepare,
+	.enter = clkdbg_suspend_ops_enter,
+	.finish = clkdbg_suspend_ops_finish,
+	.end = clkdbg_suspend_ops_end,
+};
+
+static int clkdbg_suspend_set_ops(struct seq_file *s, void *v)
+{
+	suspend_set_ops(&clkdbg_suspend_ops);
+
+	return 0;
+}
+
+static const struct cmd_fn *custom_cmds;
+
+void set_custom_cmds(const struct cmd_fn *cmds)
+{
+	custom_cmds = cmds;
+}
+
+static int clkdbg_cmds(struct seq_file *s, void *v);
+
+static const struct cmd_fn common_cmds[] = {
+	CMDFN("dump_regs", seq_print_regs),
+	CMDFN("dump_regs2", clkdbg_dump_regs2),
+	CMDFN("dump_state", clkdbg_dump_state_all),
+	CMDFN("dump_clks", clkdbg_dump_provider_clks),
+	CMDFN("dump_muxes", clkdbg_dump_muxes),
+	CMDFN("fmeter", seq_print_fmeter_all),
+	CMDFN("pwr_status", clkdbg_pwr_status),
+	CMDFN("prepare", clkdbg_prepare),
+	CMDFN("unprepare", clkdbg_unprepare),
+	CMDFN("enable", clkdbg_enable),
+	CMDFN("disable", clkdbg_disable),
+	CMDFN("prepare_enable", clkdbg_prepare_enable),
+	CMDFN("disable_unprepare", clkdbg_disable_unprepare),
+	CMDFN("prepare_enable_provider", clkdbg_prepare_enable_provider),
+	CMDFN("disable_unprepare_provider", clkdbg_disable_unprepare_provider),
+	CMDFN("set_parent", clkdbg_set_parent),
+	CMDFN("set_rate", clkdbg_set_rate),
+	CMDFN("reg_read", clkdbg_reg_read),
+	CMDFN("reg_write", clkdbg_reg_write),
+	CMDFN("reg_set", clkdbg_reg_set),
+	CMDFN("reg_clr", clkdbg_reg_clr),
+	CMDFN("show_flags", clkdbg_show_flags),
+	CMDFN("set_flag", clkdbg_set_flag),
+	CMDFN("clr_flag", clkdbg_clr_flag),
+#if CLKDBG_PM_DOMAIN
+	CMDFN("dump_genpd", clkdbg_dump_genpd),
+	CMDFN("pm_runtime_enable", clkdbg_pm_runtime_enable),
+	CMDFN("pm_runtime_disable", clkdbg_pm_runtime_disable),
+	CMDFN("pm_runtime_get_sync", clkdbg_pm_runtime_get_sync),
+	CMDFN("pm_runtime_put_sync", clkdbg_pm_runtime_put_sync),
+	CMDFN("pwr_on", clkdbg_pwr_on),
+	CMDFN("pwr_off", clkdbg_pwr_off),
+	CMDFN("reg_pdrv", clkdbg_reg_pdrv),
+	CMDFN("unreg_pdrv", clkdbg_unreg_pdrv),
+#endif /* CLKDBG_PM_DOMAIN */
+	CMDFN("suspend_set_ops", clkdbg_suspend_set_ops),
+	CMDFN("dump_suspend_clks", clkdbg_dump_suspend_clks),
+	CMDFN("dump_suspend_clks_1", clkdbg_dump_suspend_clks_1),
+	CMDFN("dump_suspend_clks_2", clkdbg_dump_suspend_clks_2),
+	CMDFN("dump_suspend_clks_3", clkdbg_dump_suspend_clks_3),
+	CMDFN("cmds", clkdbg_cmds),
+	{}
+};
+
+static int clkdbg_cmds(struct seq_file *s, void *v)
+{
+	const struct cmd_fn *cf;
+
+	for (cf = common_cmds; cf->cmd != NULL; cf++)
+		seq_printf(s, "%s\n", cf->cmd);
+
+	for (cf = custom_cmds; cf != NULL && cf->cmd != NULL; cf++)
+		seq_printf(s, "%s\n", cf->cmd);
+
+	seq_puts(s, "\n");
+
+	return 0;
+}
+
+static int clkdbg_show(struct seq_file *s, void *v)
+{
+	const struct cmd_fn *cf;
+	char cmd[sizeof(last_cmd)];
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	for (cf = custom_cmds; cf != NULL && cf->cmd != NULL; cf++) {
+		char *c = cmd;
+		char *token = strsep(&c, " ");
+
+		if (strcmp(cf->cmd, token) == 0)
+			return cf->fn(s, v);
+	}
+
+	for (cf = common_cmds; cf->cmd != NULL; cf++) {
+		char *c = cmd;
+		char *token = strsep(&c, " ");
+
+		if (strcmp(cf->cmd, token) == 0)
+			return cf->fn(s, v);
+	}
+
+	return 0;
+}
+
+static int clkdbg_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clkdbg_show, NULL);
+}
+
+static ssize_t clkdbg_write(
+		struct file *file,
+		const char __user *buffer,
+		size_t count,
+		loff_t *data)
+{
+	size_t len = 0;
+
+	len = (count < (sizeof(last_cmd) - 1UL)) ?
+				count : (sizeof(last_cmd) - 1UL);
+	if (copy_from_user(last_cmd, buffer, len) != 0UL)
+		return 0;
+
+	last_cmd[len] = '\0';
+
+	if (last_cmd[len - 1UL] == '\n')
+		last_cmd[len - 1UL] = '\0';
+
+	return (ssize_t)len;
+}
+
+static const struct file_operations clkdbg_fops = {
+	.owner		= THIS_MODULE,
+	.open		= clkdbg_open,
+	.read		= seq_read,
+	.write		= clkdbg_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/*
+ * init functions
+ */
+
+static int __init clkdbg_debug_init(void)
+{
+	struct proc_dir_entry *entry;
+
+	entry = proc_create("clkdbg", 0644, NULL, &clkdbg_fops);
+	if (entry == 0)
+		return -ENOMEM;
+
+	set_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_3);
+
+	return 0;
+}
+module_init(clkdbg_debug_init);
diff --git a/drivers/clk/mediatek/clkdbg.h b/drivers/clk/mediatek/clkdbg.h
new file mode 100644
index 000000000000..b9cddf3445ff
--- /dev/null
+++ b/drivers/clk/mediatek/clkdbg.h
@@ -0,0 +1,83 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
+ */
+
+struct seq_file;
+
+#define clk_readl(addr)		readl(addr)
+#define clk_writel(addr, val)	\
+	do { writel(val, addr); wmb(); } while (0) /* sync write */
+#define clk_setl(addr, val)	clk_writel(addr, clk_readl(addr) | (val))
+#define clk_clrl(addr, val)	clk_writel(addr, clk_readl(addr) & ~(val))
+
+enum FMETER_TYPE {
+	FT_NULL,
+	ABIST,
+	CKGEN
+};
+
+struct fmeter_clk {
+	enum FMETER_TYPE type;
+	u32 id;
+	const char *name;
+};
+
+struct regbase {
+	u32 phys;
+	void __iomem *virt;
+	const char *name;
+};
+
+struct regname {
+	struct regbase *base;
+	u32 ofs;
+	const char *name;
+};
+
+#define ADDR(rn)	(rn->base->virt + rn->ofs)
+#define PHYSADDR(rn)	(rn->base->phys + rn->ofs)
+
+struct cmd_fn {
+	const char	*cmd;
+	int (*fn)(struct seq_file *s, void *v);
+};
+
+#define CMDFN(_cmd, _fn) {	\
+	.cmd = _cmd,		\
+	.fn = _fn,		\
+}
+
+struct provider_clk {
+	const char *provider_name;
+	u32 idx;
+	struct clk *ck;
+	u32 pwr_mask;
+};
+
+struct clkdbg_ops {
+	const struct fmeter_clk *(*get_all_fmeter_clks)(void);
+	void *(*prepare_fmeter)(void);
+	void (*unprepare_fmeter)(void *data);
+	u32 (*fmeter_freq)(const struct fmeter_clk *fclk);
+	const struct regname *(*get_all_regnames)(void);
+	const char * const *(*get_all_clk_names)(void);
+	const char * const *(*get_pwr_names)(void);
+	void (*setup_provider_clk)(struct provider_clk *pvdck);
+	u32 (*get_spm_pwr_status)(void);
+};
+
+void set_clkdbg_ops(const struct clkdbg_ops *ops);
+void set_custom_cmds(const struct cmd_fn *cmds);
+
+struct provider_clk *get_all_provider_clks(void);
+const char *get_last_cmd(void);
+
+void reg_pdrv(const char *pdname);
+void unreg_pdrv(const char *pdname);
+void prepare_enable_provider(const char *pvd);
+void disable_unprepare_provider(const char *pvd);
+
+void print_regs(void);
+void print_fmeter_all(void);
diff --git a/drivers/gpu/drm/bridge/Kconfig b/drivers/gpu/drm/bridge/Kconfig
index 9c9c4df1a1cf..751c25f3cc9f 100644
--- a/drivers/gpu/drm/bridge/Kconfig
+++ b/drivers/gpu/drm/bridge/Kconfig
@@ -43,6 +43,13 @@ config DRM_DUMB_VGA_DAC
 	  Support for non-programmable RGB to VGA DAC bridges, such as ADI
 	  ADV7123, TI THS8134 and THS8135 or passive resistor ladder DACs.
 
+config DRM_ITE_IT6505
+	tristate "ITE IT6505 DP bridge"
+	depends on OF
+	select DRM_KMS_HELPER
+	help
+	  ITE IT6505 DP bridge chip driver.
+
 config DRM_LVDS_ENCODER
 	tristate "Transparent parallel to LVDS encoder support"
 	depends on OF
diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index 4934fcf5a6f8..f5abca593f71 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -2,6 +2,7 @@
 obj-$(CONFIG_DRM_ANALOGIX_ANX78XX) += analogix-anx78xx.o
 obj-$(CONFIG_DRM_CDNS_DSI) += cdns-dsi.o
 obj-$(CONFIG_DRM_DUMB_VGA_DAC) += dumb-vga-dac.o
+obj-$(CONFIG_DRM_ITE_IT6505) += ite-it6505.o
 obj-$(CONFIG_DRM_LVDS_ENCODER) += lvds-encoder.o
 obj-$(CONFIG_DRM_MEGACHIPS_STDPXXXX_GE_B850V3_FW) += megachips-stdpxxxx-ge-b850v3-fw.o
 obj-$(CONFIG_DRM_NXP_PTN3460) += nxp-ptn3460.o
diff --git a/drivers/gpu/drm/bridge/ite-it6505.c b/drivers/gpu/drm/bridge/ite-it6505.c
new file mode 100644
index 000000000000..f36d19faee89
--- /dev/null
+++ b/drivers/gpu/drm/bridge/ite-it6505.c
@@ -0,0 +1,2566 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ */
+#include <linux/bits.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/extcon.h>
+#include <linux/fs.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/semaphore.h>
+#include <linux/types.h>
+
+#include <crypto/hash.h>
+#include <crypto/sha.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_dp_helper.h>
+#include <drm/drm_edid.h>
+
+#define AX 0
+#define BX 1
+#define AUDSEL I2S
+#define AUDTYPE LPCM
+#define AUDFS AUD48K
+#define AUDCH 2
+/* 0: Standard I2S;1: 32bit I2S */
+#define I2SINPUTFMT 1
+/* 0: Left-justified;1: Right-justified */
+#define I2SJUSTIFIED 0
+/* 0: Data delay 1T correspond to WS;1: No data delay correspond to WS */
+#define I2SDATADELAY 0
+/* 0: is left channel;1: is right channel */
+#define I2SWSCHANNEL 0
+/* 0: MSB shift first;1: LSB shift first */
+#define I2SDATASEQ 0
+
+#define LANESWAP 0
+#define LANE 4
+#define _HBR 1
+#define ENHFRAME 1
+#define ENSSC 1
+#define FLAGTRAINDOWN 100
+#define TRAINFAILCNT 5
+#define TRAINFAILHPD 3
+#define AUX_WAIT_TIMEOUT_MS 15
+#define PCLK_DELAY 1
+#define PCLK_INV 0
+#define EDIDRETRYTIME 5
+#define SHOWVIDEOTIMING 2
+#define PWROFFRETRYTIME 5
+#define WAITBRIDGEENABLE 80
+#define MAXPCLK 80000
+#define DEFAULTHDCP 1
+#define DEFAULTAUDIO 1
+#define DEFAULTPWRONOFF 1
+#define DEFAULTDRVHOLD 0
+#define DEFAULTPWRON 0
+
+/* AX or BX */
+#define CHIP_VERSION BX
+
+enum sys_status {
+	SYS_UNPLUG = 0,
+	SYS_HPD,
+	SYS_AUTOTRAIN,
+	SYS_WAIT,
+	SYS_TRAINFAIL,
+	SYS_ReHDCP,
+	SYS_PWRDN,
+	SYS_NOROP,
+	SYS_Unknown,
+};
+
+enum it6505_aud_sel {
+	I2S = 0,
+	SPDIF,
+};
+
+enum it6505_aud_fs {
+	AUD24K = 0x6,
+	AUD32K = 0x3,
+	AUD48K = 0x2,
+	AUD96K = 0xA,
+	AUD192K = 0xE,
+	AUD44P1K = 0x0,
+	AUD88P2K = 0x8,
+	AUD176P4K = 0xC,
+};
+
+enum it6505_aud_type {
+	LPCM = 0,
+	NLPCM,
+	DSS,
+	HBR,
+};
+
+enum aud_word_length {
+	AUD16BIT = 0,
+	AUD18BIT,
+	AUD20BIT,
+	AUD24BIT,
+};
+
+/* Audio Sample Word Length: AUD16BIT, AUD18BIT, AUD20BIT, AUD24BIT */
+#define AUDWORDLENGTH AUD24BIT
+
+struct it6505_platform_data {
+	struct regulator *pwr18;
+	struct regulator *ovdd;
+	struct gpio_desc *gpiod_hpd;
+	struct gpio_desc *gpiod_reset;
+};
+
+struct it6505 {
+	struct drm_dp_aux aux;
+	struct drm_bridge bridge;
+	struct i2c_client *client;
+	struct edid *edid;
+	struct drm_connector connector;
+	struct drm_dp_link link;
+	struct it6505_platform_data pdata;
+	struct mutex lock;
+	struct regmap *regmap;
+	struct drm_display_mode vid_info;
+	/* thread sequence control */
+	struct semaphore sem_notifier;
+
+	struct notifier_block event_nb;
+	struct extcon_dev *extcon;
+	struct work_struct extcon_wq;
+	enum sys_status status;
+	bool hbr;
+	u8 lane;
+	u8 en_ssc;
+	bool en_hframe;
+	bool laneswap;
+
+	enum it6505_aud_sel aud_sel;
+	enum it6505_aud_fs aud_fs;
+	enum it6505_aud_type aud_type;
+	u8 aud_ch;
+	u8 i2s_input_fmt;
+	u8 i2s_justified;
+	u8 i2s_data_delay;
+	u8 i2s_ws_channel;
+	u8 i2s_data_seq;
+	u8 vidstable_done;
+	enum aud_word_length audwordlength;
+	unsigned int en_hdcp;
+	unsigned int en_pwronoff;
+	unsigned int en_audio;
+	u8 cntfsm;
+	u8 train_fail_hpd;
+	bool cp_capable;
+	bool cp_done;
+	u8 downstream_repeater;
+	u8 shainput[64];
+	u8 av[5][4];
+	u8 bv[5][4];
+	bool powered;
+	u8 run_bridge_enable;
+	/* it6505 driver hold option */
+	unsigned int drv_hold;
+};
+
+static const struct regmap_range it6505_bridge_volatile_ranges[] = {
+	{ .range_min = 0, .range_max = 0xFF },
+};
+
+static const struct regmap_access_table it6505_bridge_volatile_table = {
+	.yes_ranges = it6505_bridge_volatile_ranges,
+	.n_yes_ranges = ARRAY_SIZE(it6505_bridge_volatile_ranges),
+};
+
+static const struct regmap_config it6505_bridge_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.volatile_table = &it6505_bridge_volatile_table,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int dptxrd(struct it6505 *it6505, unsigned int reg_addr,
+		  unsigned int *value)
+{
+	int err;
+	struct device *dev = &it6505->client->dev;
+
+	err = regmap_read(it6505->regmap, reg_addr, value);
+	if (err < 0) {
+		DRM_DEV_ERROR(dev, "read failed reg[0x%x] err: %d", reg_addr,
+			      err);
+		return err;
+	}
+
+	return 0;
+}
+
+static void it6505_dump(struct it6505 *it6505)
+{
+	unsigned int temp[16], i, j;
+	u8 value[16];
+	struct device *dev = &it6505->client->dev;
+
+	for (i = 0; i <= 0xff; i += 16) {
+		for (j = 0; j < 16; j++) {
+			dptxrd(it6505, i + j, temp + j);
+			value[j] = temp[j];
+		}
+		DRM_DEV_DEBUG_DRIVER(dev, "[0x%02x] = %16ph", i, value);
+	}
+}
+
+static int dptxwr(struct it6505 *it6505, unsigned int reg_addr,
+		  unsigned int reg_val)
+{
+	int err;
+	struct device *dev = &it6505->client->dev;
+
+	err = regmap_write(it6505->regmap, reg_addr, reg_val);
+
+	if (err < 0) {
+		DRM_DEV_ERROR(dev, "write failed reg[0x%x] = 0x%x err = %d",
+			      reg_addr, reg_val, err);
+		return err;
+	}
+
+	return 0;
+}
+
+static int dptxset(struct it6505 *it6505, unsigned int reg, unsigned int mask,
+		   unsigned int value)
+{
+	int err;
+	struct device *dev = &it6505->client->dev;
+
+	err = regmap_update_bits(it6505->regmap, reg, mask, value);
+	if (err < 0) {
+		DRM_DEV_ERROR(
+			dev, "write reg[0x%x] = 0x%x mask = 0x%x failed err %d",
+			reg, value, mask, err);
+		return err;
+	}
+
+	return 0;
+}
+
+static inline struct it6505 *connector_to_it6505(struct drm_connector *c)
+{
+	return container_of(c, struct it6505, connector);
+}
+
+static inline struct it6505 *bridge_to_it6505(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct it6505, bridge);
+}
+
+static void it6505_init_fsm(struct it6505 *it6505)
+{
+	it6505->aud_sel = AUDSEL;
+	it6505->aud_fs = AUDFS;
+	it6505->aud_ch = AUDCH;
+	it6505->aud_type = AUDTYPE;
+	it6505->i2s_input_fmt = I2SINPUTFMT;
+	it6505->i2s_justified = I2SJUSTIFIED;
+	it6505->i2s_data_delay = I2SDATADELAY;
+	it6505->i2s_ws_channel = I2SWSCHANNEL;
+	it6505->i2s_data_seq = I2SDATASEQ;
+	it6505->audwordlength = AUDWORDLENGTH;
+
+	it6505->hbr = _HBR;
+	it6505->lane = LANE;
+	it6505->en_ssc = ENSSC;
+	it6505->en_hframe = ENHFRAME;
+	it6505->laneswap = LANESWAP;
+	it6505->vidstable_done = 0;
+	it6505->run_bridge_enable = 0;
+}
+
+static void it6505_termination_on(struct it6505 *it6505)
+{
+#if (CHIP_VERSION == BX)
+	dptxset(it6505, 0x5D, 0x80, 0x00);
+	dptxset(it6505, 0x5E, 0x02, 0x02);
+#endif
+}
+
+static void it6505_termination_off(struct it6505 *it6505)
+{
+#if (CHIP_VERSION == BX)
+	dptxset(it6505, 0x5D, 0x80, 0x80);
+	dptxset(it6505, 0x5E, 0x02, 0x00);
+	dptxset(it6505, 0x5C, 0xF0, 0x00);
+#endif
+}
+
+static bool dptx_getsinkhpd(struct it6505 *it6505)
+{
+	unsigned int value;
+	int ret;
+
+	ret = dptxrd(it6505, 0x0D, &value);
+
+	if (ret < 0)
+		return false;
+
+	return (value & BIT(1)) == BIT(1);
+}
+
+static void dptx_init(struct it6505 *it6505)
+{
+	dptxwr(it6505, 0x05, 0x3B);
+	usleep_range(1000, 2000);
+	dptxwr(it6505, 0x05, 0x1F);
+	usleep_range(1000, 1500);
+}
+
+static int it6505_poweron(struct it6505 *it6505)
+{
+	struct it6505_platform_data *pdata = &it6505->pdata;
+	int err = 0;
+	struct device *dev = &it6505->client->dev;
+
+	if (it6505->powered) {
+		DRM_DEV_DEBUG_DRIVER(dev, "it6505 already powered on");
+		return 0;
+	}
+
+	DRM_DEV_DEBUG_DRIVER(dev, "it6505 start to power on");
+
+	err = regulator_enable(pdata->pwr18);
+	DRM_DEV_DEBUG_DRIVER(dev, "%s to enable pwr18 regulator",
+			     err ? "Failed" : "Succeeded");
+	if (err)
+		return err;
+	/* time interval between IVDD and OVDD at least be 1ms */
+	usleep_range(1000, 2000);
+	err = regulator_enable(pdata->ovdd);
+	DRM_DEV_DEBUG_DRIVER(dev, "%s to enable ovdd regulator",
+			     err ? "Failed" : "Succeeded");
+	if (err) {
+		regulator_disable(pdata->pwr18);
+		return err;
+	}
+	/* time interval between OVDD and SYSRSTN at least be 10ms */
+	usleep_range(10000, 20000);
+	gpiod_set_value_cansleep(pdata->gpiod_reset, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(pdata->gpiod_reset, 1);
+	usleep_range(10000, 20000);
+
+	dptx_init(it6505);
+	it6505->powered = true;
+	return 0;
+}
+
+static int it6505_poweroff(struct it6505 *it6505)
+{
+	struct it6505_platform_data *pdata = &it6505->pdata;
+	int err = 0;
+	struct device *dev = &it6505->client->dev;
+
+	if (!(it6505->powered)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "power had been already off");
+		return 0;
+	}
+	gpiod_set_value_cansleep(pdata->gpiod_reset, 0);
+	err = regulator_disable(pdata->pwr18);
+	DRM_DEV_DEBUG_DRIVER(dev, "%s to disable pwr18 regulator",
+			     err ? "Failed" : "Succeeded");
+	if (err)
+		return err;
+	err = regulator_disable(pdata->ovdd);
+	DRM_DEV_DEBUG_DRIVER(dev, "%s to disable ovdd regulator",
+			     err ? "Failed" : "Succeeded");
+	if (err)
+		return err;
+
+	kfree(it6505->edid);
+	it6505->edid = NULL;
+	it6505->powered = false;
+	return 0;
+}
+
+static void dptx_chgbank(struct it6505 *it6505, unsigned int bank_id)
+{
+	dptxset(it6505, 0x0F, 0x01, bank_id & BIT(0));
+}
+
+static void it6505_int_mask_on(struct it6505 *it6505)
+{
+	dptxwr(it6505, 0x09, 0x1F);
+	dptxwr(it6505, 0x0A, 0x07);
+	dptxwr(it6505, 0x0B, 0x90);
+}
+
+static void it6505_int_mask_off(struct it6505 *it6505)
+{
+	dptxwr(it6505, 0x09, 0x00);
+	dptxwr(it6505, 0x0A, 0x00);
+	dptxwr(it6505, 0x0B, 0x00);
+}
+
+static void show_vid_info(struct it6505 *it6505)
+{
+	int hsync_pol, vsync_pol, interlaced;
+	int htotal, hdes, hdew, hfph, hsyncw;
+	int vtotal, vdes, vdew, vfph, vsyncw;
+	int rddata, rddata1, i;
+	int pclk, sum;
+
+	usleep_range(10000, 15000);
+	dptx_chgbank(it6505, 0);
+	dptxrd(it6505, 0xa0, &rddata);
+	hsync_pol = rddata & BIT(0);
+	vsync_pol = (rddata & BIT(2)) >> 2;
+	interlaced = (rddata & BIT(4)) >> 4;
+
+	dptxrd(it6505, 0xa1, &rddata);
+	dptxrd(it6505, 0xa2, &rddata1);
+	htotal = ((rddata1 & 0x1F) << 8) + rddata;
+
+	dptxrd(it6505, 0xa3, &rddata);
+	dptxrd(it6505, 0xa4, &rddata1);
+
+	hdes = ((rddata1 & 0x1F) << 8) + rddata;
+
+	dptxrd(it6505, 0xa5, &rddata);
+	dptxrd(it6505, 0xa6, &rddata1);
+
+	hdew = ((rddata1 & 0x1F) << 8) + rddata;
+
+	dptxrd(it6505, 0xa7, &rddata);
+	dptxrd(it6505, 0xa8, &rddata1);
+
+	hfph = ((rddata1 & 0x1F) << 8) + rddata;
+
+	dptxrd(it6505, 0xa9, &rddata);
+	dptxrd(it6505, 0xaa, &rddata1);
+
+	hsyncw = ((rddata1 & 0x1F) << 8) + rddata;
+
+	dptxrd(it6505, 0xab, &rddata);
+	dptxrd(it6505, 0xac, &rddata1);
+	vtotal = ((rddata1 & 0x0F) << 8) + rddata;
+
+	dptxrd(it6505, 0xad, &rddata);
+	dptxrd(it6505, 0xae, &rddata1);
+	vdes = ((rddata1 & 0x0F) << 8) + rddata;
+
+	dptxrd(it6505, 0xaf, &rddata);
+	dptxrd(it6505, 0xb0, &rddata1);
+	vdew = ((rddata1 & 0x0F) << 8) + rddata;
+
+	dptxrd(it6505, 0xb1, &rddata);
+	dptxrd(it6505, 0xb2, &rddata1);
+	vfph = ((rddata1 & 0x0F) << 8) + rddata;
+
+	dptxrd(it6505, 0xb3, &rddata);
+	dptxrd(it6505, 0xb4, &rddata1);
+	vsyncw = ((rddata1 & 0x0F) << 8) + rddata;
+
+	sum = 0;
+	for (i = 0; i < 100; i++) {
+		dptxset(it6505, 0x12, 0x80, 0x80);
+		usleep_range(10000, 15000);
+		dptxset(it6505, 0x12, 0x80, 0x00);
+
+		dptxrd(it6505, 0x13, &rddata);
+		dptxrd(it6505, 0x14, &rddata1);
+		rddata = ((rddata1 & 0x0F) << 8) + rddata;
+
+		sum += rddata;
+	}
+
+	sum /= 100;
+	pclk = 13500 * 2048 / sum;
+	it6505->vid_info.clock = pclk;
+	it6505->vid_info.hdisplay = hdew;
+	it6505->vid_info.hsync_start = hdew + hfph;
+	it6505->vid_info.hsync_end = hdew + hfph + hsyncw;
+	it6505->vid_info.htotal = htotal;
+	it6505->vid_info.vdisplay = vdew;
+	it6505->vid_info.vsync_start = vdew + vfph;
+	it6505->vid_info.vsync_end = vdew + vfph + vsyncw;
+	it6505->vid_info.vtotal = vtotal;
+	it6505->vid_info.vrefresh = pclk / htotal / vtotal;
+
+	DRM_DEV_DEBUG_DRIVER(&it6505->client->dev, DRM_MODE_FMT,
+			     DRM_MODE_ARG(&it6505->vid_info));
+}
+
+static const char *const state_string[] = {
+	[SYS_UNPLUG] = "SYS_UNPLUG",
+	[SYS_HPD] = "SYS_HPD",
+	[SYS_AUTOTRAIN] = "SYS_AUTOTRAIN",
+	[SYS_WAIT] = "SYS_WAIT",
+	[SYS_TRAINFAIL] = "SYS_TRAINFAIL",
+	[SYS_ReHDCP] = "SYS_ReHDCP",
+	[SYS_PWRDN] = "SYS_PWRDN",
+	[SYS_NOROP] = "SYS_NOROP",
+	[SYS_Unknown] = "SYS_Unknown",
+};
+
+static void dptx_sys_chg(struct it6505 *it6505, enum sys_status newstate)
+{
+	unsigned int i = 0;
+	struct device *dev = &it6505->client->dev;
+
+	if (newstate != SYS_UNPLUG) {
+		if (!dptx_getsinkhpd(it6505))
+			newstate = SYS_UNPLUG;
+	}
+	if (it6505->status == newstate)
+		return;
+
+	DRM_DEV_DEBUG_DRIVER(dev, "sys_state change: %s -> %s",
+			     state_string[it6505->status],
+			     state_string[newstate]);
+	it6505->status = newstate;
+
+	switch (it6505->status) {
+	case SYS_UNPLUG:
+		kfree(it6505->edid);
+		it6505->edid = NULL;
+		DRM_DEV_DEBUG_DRIVER(dev, "Free it6505 EDID memory");
+		dptx_init(it6505);
+		it6505_termination_off(it6505);
+		it6505_int_mask_on(it6505);
+		break;
+	case SYS_HPD:
+		it6505_termination_on(it6505);
+		it6505_init_fsm(it6505);
+		break;
+	case SYS_AUTOTRAIN:
+		break;
+	case SYS_WAIT:
+		break;
+	case SYS_ReHDCP:
+		break;
+	case SYS_NOROP:
+		for (i = 0; i < SHOWVIDEOTIMING; i++)
+			show_vid_info(it6505);
+		break;
+	case SYS_TRAINFAIL:
+		/* it6505 goes to idle */
+		break;
+	default:
+		break;
+	}
+}
+
+static bool it6505_aux_op_finished(struct it6505 *it6505)
+{
+	unsigned int value;
+	int err;
+
+	err = regmap_read(it6505->regmap, 0x2b, &value);
+	if (err < 0)
+		return false;
+
+	return (value & BIT(5)) == 0;
+}
+
+static int dptx_auxwait(struct it6505 *it6505)
+{
+	unsigned int status;
+	unsigned long timeout;
+	int err;
+	struct device *dev = &it6505->client->dev;
+
+	timeout = jiffies + msecs_to_jiffies(AUX_WAIT_TIMEOUT_MS) + 1;
+
+	while (!it6505_aux_op_finished(it6505)) {
+		if (time_after(jiffies, timeout)) {
+			DRM_DEV_ERROR(dev, "Timed out waiting AUX to finish");
+			return -ETIMEDOUT;
+		}
+		usleep_range(1000, 2000);
+	}
+
+	err = dptxrd(it6505, 0x9f, &status);
+	if (err < 0) {
+		DRM_DEV_ERROR(dev, "Failed to read AUX channel: %d", err);
+		return err;
+	}
+
+	if (status & 0x03) {
+		DRM_DEV_ERROR(dev, "Failed to wait for AUX (status: 0x%x)",
+			      status);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int dptx_aux_r_edid(struct it6505 *it6505, unsigned int nosegw,
+			   unsigned int block, unsigned int offset)
+{
+	unsigned int value, status;
+	int ret;
+	struct device *dev = &it6505->client->dev;
+
+	/* enable pc aux access */
+	dptxwr(it6505, 0x23, (nosegw << 6) + 0x03);
+	/* edid fifo clr */
+	dptxwr(it6505, 0x23, (nosegw << 6) + 0x82);
+	/* start address[7:0] */
+	dptxwr(it6505, 0x24, (block % 2) * 128 + offset);
+	/* start address[15:8] */
+	dptxwr(it6505, 0x25, block / 256);
+	/* writenum[3:0]+startadr[19:16] */
+	dptxwr(it6505, 0x26, 0xf0);
+	/* aux edid read fire */
+	dptxwr(it6505, 0x2b, 0x0b);
+	dptx_auxwait(it6505);
+
+	ret = dptxrd(it6505, 0x07, &value);
+	if (ret)
+		return ret;
+
+	if (value & BIT(0)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "aux channel request fail interrupt");
+
+		ret = dptxrd(it6505, 0x9f, &status);
+		if (ret) {
+			DRM_DEV_DEBUG_DRIVER(dev, "AUX channel failed: %d",
+					     ret);
+			return ret;
+		}
+
+		switch ((status & 0xc0) >> 6) {
+		case 0:
+			DRM_DEV_DEBUG_DRIVER(dev, "no error !!!");
+			return 0;
+		case 1:
+			DRM_DEV_DEBUG_DRIVER(
+				dev, "defer > 7 times status: 0x%x!", status);
+			return -ETIMEDOUT;
+
+		case 2:
+			DRM_DEV_DEBUG_DRIVER(dev, "Nack response status: 0x%x!",
+					     status);
+			return -ETIMEDOUT;
+
+		default:
+			DRM_DEV_DEBUG_DRIVER(dev, "timeout status: 0x%x!",
+					     status);
+			return -ETIMEDOUT;
+		}
+	}
+	return 0;
+}
+
+static int dptx_get_edidblock(struct it6505 *it6505, u8 *pedidbuff,
+			      unsigned int blockno, unsigned int *chk)
+{
+	ushort i;
+	unsigned int offset, value, reg0d;
+	struct device *dev = &it6505->client->dev;
+
+	if (pedidbuff == NULL)
+		return -ENOMEM;
+
+	dptxset(it6505, 0x05, 0x08, 0x08);
+	dptxset(it6505, 0x05, 0x08, 0x00);
+	DRM_DEV_DEBUG_DRIVER(dev, "blocknum = %d", blockno);
+	for (offset = 0; offset < 0x80; offset += 8) {
+		dptxrd(it6505, 0x0D, &reg0d);
+		if (!(reg0d & BIT(1))) {
+			dptx_sys_chg(it6505, SYS_UNPLUG);
+			return -ENXIO;
+		}
+		dptx_aux_r_edid(it6505, 1, blockno, offset);
+
+		for (i = 0; i < 8; i++) {
+			dptxrd(it6505, 0x2f, &value);
+			pedidbuff[offset + i] = value;
+		}
+		DRM_DEV_DEBUG_DRIVER(dev, "[0x%02x]: %8ph", offset,
+				     pedidbuff + offset);
+	}
+	/* disable pc aux access */
+	dptxwr(it6505, 0x23, 1 << 6);
+
+	*chk = 0;
+	for (i = 0; i < 0x80; i++)
+		*chk += pedidbuff[i];
+
+	*chk &= 0xff;
+
+	return 0;
+}
+
+static int it6505_get_extension_num(struct it6505 *it6505, u8 *block)
+{
+	unsigned int checksum = 0, retrytime = 0, reg0d;
+	int err;
+	u8 buff[EDID_LENGTH];
+	struct device *dev = &it6505->client->dev;
+
+	do {
+		dptxrd(it6505, 0x0D, &reg0d);
+		if (!(reg0d & BIT(1))) {
+			dptx_sys_chg(it6505, SYS_UNPLUG);
+			return -ENXIO;
+		}
+		err = dptx_get_edidblock(it6505, buff, 0, &checksum);
+		if (err < 0)
+			return err;
+		retrytime++;
+		DRM_DEV_DEBUG_DRIVER(dev, "read EDID %d time", retrytime);
+	} while (checksum != 0 && retrytime < EDIDRETRYTIME);
+
+	if (checksum)
+		return -EINVAL;
+	*block = buff[0x7e];
+	DRM_DEV_DEBUG_DRIVER(dev, "extension number: %d", *block);
+	return 0;
+}
+
+static struct edid *it6505_get_edid(struct it6505 *it6505)
+{
+	unsigned int checksum = 0, retrytime = 0;
+	unsigned int i, reg0d, total_size;
+	u8 block;
+	u8 *pedidbuff = kmalloc(EDID_LENGTH, GFP_KERNEL);
+	u8 *pedidbuff1;
+	struct device *dev = &it6505->client->dev;
+
+	if (!pedidbuff)
+		return NULL;
+
+	it6505_dump(it6505);
+	if (it6505_get_extension_num(it6505, &block) < 0)
+		return NULL;
+	/* dp does not have the hdmi tx four block test requirement */
+	if (block > 2)
+		block = 2;
+
+	total_size = (block + 1) * EDID_LENGTH;
+	if (total_size > EDID_LENGTH) {
+		pedidbuff1 = krealloc(pedidbuff, total_size, GFP_KERNEL);
+		if (!pedidbuff1) {
+			kfree(pedidbuff);
+			return NULL;
+		}
+		pedidbuff = pedidbuff1;
+	}
+
+	for (i = 0; i <= block; i++) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Read block 0x%x", i);
+		retrytime = 0;
+		do {
+			dptxrd(it6505, 0x0D, &reg0d);
+			if (!(reg0d & BIT(1))) {
+				dptx_sys_chg(it6505, SYS_UNPLUG);
+				kfree(pedidbuff);
+				return NULL;
+			}
+			if (dptx_get_edidblock(it6505,
+					       pedidbuff + i * EDID_LENGTH, i,
+					       &checksum) < 0)
+				return NULL;
+			DRM_DEV_DEBUG_DRIVER(dev, "%s in block %d %s!",
+					     checksum ? "Fake" : "True", i,
+					     checksum ? "and read again" : "");
+			retrytime++;
+			DRM_DEV_DEBUG_DRIVER(dev, "read EDID %d time",
+					     retrytime);
+		} while (checksum != 0 && retrytime < EDIDRETRYTIME);
+		if (checksum) {
+			kfree(pedidbuff);
+			return NULL;
+		}
+	}
+	return (struct edid *)pedidbuff;
+}
+
+static int it6505_get_modes(struct drm_connector *connector)
+{
+	struct it6505 *it6505 = connector_to_it6505(connector);
+	int err, num_modes = 0;
+	unsigned int reg9f;
+	struct device *dev = &it6505->client->dev;
+
+	it6505->train_fail_hpd = TRAINFAILHPD;
+	if (it6505->edid)
+		return drm_add_edid_modes(connector, it6505->edid);
+	mutex_lock(&it6505->lock);
+
+	dptxrd(it6505, 0x9F, &reg9f);
+	DRM_DEV_DEBUG_DRIVER(dev, "Aux status reg9F = 0x%02x", reg9f);
+	it6505->edid = it6505_get_edid(it6505);
+	if (!it6505->edid) {
+		DRM_DEV_ERROR(dev, "Failed to read EDID");
+		goto unlock;
+	}
+
+	err = drm_connector_update_edid_property(connector, it6505->edid);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to update EDID property: %d", err);
+		goto unlock;
+	}
+
+	num_modes = drm_add_edid_modes(connector, it6505->edid);
+
+unlock:
+	mutex_unlock(&it6505->lock);
+
+	return num_modes;
+}
+
+static const struct drm_connector_helper_funcs it6505_connector_helper_funcs = {
+	.get_modes = it6505_get_modes,
+};
+
+static enum drm_connector_status it6505_detect(struct drm_connector *connector,
+					       bool force)
+{
+	struct it6505 *it6505 = connector_to_it6505(connector);
+
+	if (gpiod_get_value(it6505->pdata.gpiod_hpd))
+		return connector_status_disconnected;
+
+	return connector_status_connected;
+}
+
+static const struct drm_connector_funcs it6505_connector_funcs = {
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.detect = it6505_detect,
+	.destroy = drm_connector_cleanup,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static ssize_t it6505_aux_transfer(struct drm_dp_aux *aux,
+				   struct drm_dp_aux_msg *msg)
+{
+	return 0;
+}
+
+static int it6505_extcon_notifier(struct notifier_block *self,
+				  unsigned long event, void *ptr)
+{
+	struct it6505 *it6505 = container_of(self, struct it6505, event_nb);
+
+	schedule_work(&it6505->extcon_wq);
+	return NOTIFY_DONE;
+}
+
+static void it6505_extcon_work(struct work_struct *work)
+{
+	struct it6505 *it6505 = container_of(work, struct it6505, extcon_wq);
+	int state = extcon_get_state(it6505->extcon, EXTCON_DISP_DP);
+	unsigned int pwroffretry = 0;
+	struct device *dev = &it6505->client->dev;
+
+	if (it6505->drv_hold)
+		return;
+	down(&it6505->sem_notifier);
+	DRM_DEV_DEBUG_DRIVER(dev, "EXTCON_DISP_DP = 0x%02x", state);
+	if (state > 0) {
+		DRM_DEV_DEBUG_DRIVER(dev, "start to power on");
+		msleep(1000);
+		it6505_poweron(it6505);
+		it6505_int_mask_on(it6505);
+	} else {
+		if (it6505->en_pwronoff) {
+			DRM_DEV_DEBUG_DRIVER(dev, "start to power off");
+			while (it6505_poweroff(it6505) &&
+			       pwroffretry++ < PWROFFRETRYTIME) {
+				DRM_DEV_DEBUG_DRIVER(dev,
+						     "power off fail %d times",
+						     pwroffretry);
+			}
+			drm_helper_hpd_irq_event(it6505->connector.dev);
+			DRM_DEV_DEBUG_DRIVER(dev, "power off it6505 success!");
+		}
+	}
+	up(&it6505->sem_notifier);
+}
+
+static int it6505_use_notifier_module(struct it6505 *it6505)
+{
+	int ret;
+	struct device *dev = &it6505->client->dev;
+
+	it6505->event_nb.notifier_call = it6505_extcon_notifier;
+	INIT_WORK(&it6505->extcon_wq, it6505_extcon_work);
+	ret = devm_extcon_register_notifier(&it6505->client->dev,
+					    it6505->extcon, EXTCON_DISP_DP,
+					    &it6505->event_nb);
+	if (ret) {
+		DRM_DEV_ERROR(dev, "failed to register notifier for DP");
+		return ret;
+	}
+	return 0;
+}
+
+static int it6505_bridge_attach(struct drm_bridge *bridge)
+{
+	struct it6505 *it6505 = bridge_to_it6505(bridge);
+	struct device *dev;
+	int err;
+
+	dev = &it6505->client->dev;
+	if (!bridge->encoder) {
+		DRM_DEV_ERROR(dev, "Parent encoder object not found");
+		return -ENODEV;
+	}
+
+	err = drm_connector_init(bridge->dev, &it6505->connector,
+				 &it6505_connector_funcs,
+				 DRM_MODE_CONNECTOR_DisplayPort);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to initialize connector: %d", err);
+		goto unregister_aux;
+	}
+
+	drm_connector_helper_add(&it6505->connector,
+				 &it6505_connector_helper_funcs);
+
+	err = drm_connector_register(&it6505->connector);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to register connector: %d", err);
+		goto unregister_aux;
+	}
+
+	it6505->connector.polled = DRM_CONNECTOR_POLL_HPD;
+
+	err = drm_connector_attach_encoder(&it6505->connector, bridge->encoder);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to link up connector to encoder: %d",
+			      err);
+		goto unregister_connector;
+	}
+
+	err = it6505_use_notifier_module(it6505);
+	if (err < 0)
+		goto unregister_connector;
+	schedule_work(&it6505->extcon_wq);
+
+	return 0;
+
+unregister_connector:
+	drm_connector_unregister(&it6505->connector);
+unregister_aux:
+	drm_dp_aux_unregister(&it6505->aux);
+	return err;
+}
+
+static void it6505_bridge_detach(struct drm_bridge *bridge)
+{
+	struct it6505 *it6505 = bridge_to_it6505(bridge);
+
+
+	devm_extcon_unregister_notifier(&it6505->client->dev, it6505->extcon,
+					EXTCON_DISP_DP, &it6505->event_nb);
+	flush_work(&it6505->extcon_wq);
+	drm_connector_unregister(&it6505->connector);
+	drm_dp_aux_unregister(&it6505->aux);
+}
+
+static enum drm_mode_status
+it6505_bridge_mode_valid(struct drm_bridge *bridge,
+			 const struct drm_display_mode *mode)
+{
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+		return MODE_NO_INTERLACE;
+
+	/* Max 1200p at 5.4 Ghz, one lane */
+	if (mode->clock > MAXPCLK)
+		return MODE_CLOCK_HIGH;
+
+	return MODE_OK;
+}
+
+static int it6505_send_video_infoframe(struct it6505 *it6505,
+				       struct hdmi_avi_infoframe *frame)
+{
+	u8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];
+	int err;
+	struct device *dev = &it6505->client->dev;
+
+	err = hdmi_avi_infoframe_pack(frame, buffer, sizeof(buffer));
+	if (err < 0) {
+		DRM_DEV_ERROR(dev, "Failed to pack AVI infoframe: %d\n", err);
+		return err;
+	}
+
+	err = dptxset(it6505, 0xe8, 1, 0);
+	if (err)
+		return err;
+
+	err = regmap_bulk_write(it6505->regmap, 0xe9, buffer, frame->length);
+	if (err)
+		return err;
+
+	err = dptxset(it6505, 0xe8, 1, 1);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static void it6505_bridge_mode_set(struct drm_bridge *bridge,
+				   struct drm_display_mode *mode,
+				   struct drm_display_mode *adjusted_mode)
+{
+	struct it6505 *it6505 = bridge_to_it6505(bridge);
+	struct hdmi_avi_infoframe frame;
+	int err;
+	struct device *dev = &it6505->client->dev;
+
+	mutex_lock(&it6505->lock);
+	err = drm_hdmi_avi_infoframe_from_display_mode(&frame, adjusted_mode,
+						       false);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to setup AVI infoframe: %d", err);
+		goto unlock;
+	}
+	it6505->vid_info.base.id = adjusted_mode->base.id;
+	strlcpy(it6505->vid_info.name, adjusted_mode->name,
+		DRM_DISPLAY_MODE_LEN);
+	it6505->vid_info.type = adjusted_mode->type;
+	it6505->vid_info.flags = adjusted_mode->flags;
+	err = it6505_send_video_infoframe(it6505, &frame);
+	if (err)
+		DRM_DEV_ERROR(dev, "Failed to send AVI infoframe: %d", err);
+
+unlock:
+	mutex_unlock(&it6505->lock);
+}
+
+static void dptx_set_aud_fmt(struct it6505 *it6505, enum it6505_aud_sel audsel,
+			     unsigned int audch)
+{
+	unsigned int audsrc;
+	/* I2S MODE */
+	dptxwr(it6505, 0xB9,
+	       (it6505->audwordlength << 5) | (it6505->i2s_data_seq << 4) |
+		       (it6505->i2s_ws_channel << 3) |
+		       (it6505->i2s_data_delay << 2) |
+		       (it6505->i2s_justified << 1) | it6505->i2s_input_fmt);
+	if (audsel == SPDIF) {
+		dptxwr(it6505, 0xBA, 0x00);
+		/* 0x30 = 128*FS */
+		dptxset(it6505, 0x11, 0xF0, 0x30);
+	} else {
+		dptxwr(it6505, 0xBA, 0xe4);
+	}
+
+	dptxwr(it6505, 0xBB, 0x00);
+	dptxwr(it6505, 0xBC, 0x00);
+	audsrc = 1;
+
+	if (audch > 2)
+		audsrc |= 2;
+
+	if (audch > 4)
+		audsrc |= 4;
+
+	if (audch == 8)
+		audsrc |= 8;
+
+	audsrc |= audsel << 4;
+
+	dptxwr(it6505, 0xB8, audsrc);
+}
+
+static void dptx_set_aud_chsts(struct it6505 *it6505,
+			       enum it6505_aud_type audtype,
+			       enum it6505_aud_fs audfs)
+{
+	/* Channel Status */
+	dptxwr(it6505, 0xBF, audtype << 1);
+	dptxwr(it6505, 0xC0, 0x00);
+	dptxwr(it6505, 0xC1, 0x00);
+	dptxwr(it6505, 0xC2, audfs);
+	switch (it6505->audwordlength) {
+	case AUD16BIT:
+		dptxwr(it6505, 0xC3, ((~audfs) << 4) + 0x02);
+		break;
+
+	case AUD18BIT:
+		dptxwr(it6505, 0xC3, ((~audfs) << 4) + 0x04);
+		break;
+
+	case AUD20BIT:
+		dptxwr(it6505, 0xC3, ((~audfs) << 4) + 0x03);
+		break;
+
+	case AUD24BIT:
+		dptxwr(it6505, 0xC3, ((~audfs) << 4) + 0x0B);
+		break;
+	}
+}
+
+static void dptx_set_audio_infoframe(struct it6505 *it6505, unsigned int audch)
+{
+	struct device *dev = &it6505->client->dev;
+
+	dptxwr(it6505, 0xf7, audch - 1);
+
+	switch (audch) {
+	case 2:
+		dptxwr(it6505, 0xF9, 0x00);
+		break;
+	case 3:
+		dptxwr(it6505, 0xF9, 0x01);
+		break;
+	case 4:
+		dptxwr(it6505, 0xF9, 0x03);
+		break;
+	case 5:
+		dptxwr(it6505, 0xF9, 0x07);
+		break;
+	case 6:
+		dptxwr(it6505, 0xF9, 0x0B);
+		break;
+	case 7:
+		dptxwr(it6505, 0xF9, 0x0F);
+		break;
+	case 8:
+		dptxwr(it6505, 0xF9, 0x1F);
+		break;
+	default:
+		DRM_DEV_ERROR(dev, "audio channel number error: %u", audch);
+	}
+	/* Enable Audio InfoFrame */
+	dptxset(it6505, 0xE8, 0x22, 0x22);
+}
+
+static void it6505_set_audio(struct it6505 *it6505, enum it6505_aud_sel audsel,
+			     enum it6505_aud_type audtype,
+			     enum it6505_aud_fs audfs, unsigned int audch)
+{
+	/* Audio Clock Domain Reset */
+	dptxset(it6505, 0x05, 0x02, 0x02);
+	/* Audio mute */
+	dptxset(it6505, 0xD3, 0x20, 0x20);
+	/* Release Audio Clock Domain Reset */
+	dptxset(it6505, 0x05, 0x02, 0x00);
+
+	dptx_set_aud_chsts(it6505, audtype, audfs);
+	dptx_set_audio_infoframe(it6505, audch);
+	dptx_set_aud_fmt(it6505, audsel, audch);
+	/* Enable Enhanced Audio TimeStmp Mode */
+	dptxset(it6505, 0xD4, 0x04, 0x04);
+	/* Disable Full Audio Packet */
+	dptxset(it6505, 0xBB, 0x10, 0x00);
+
+	dptxwr(it6505, 0xDE, 0x00);
+	dptxwr(it6505, 0xDF, 0x80);
+	dptxwr(it6505, 0xE0, 0x00);
+	dptxset(it6505, 0xD3, 0x20, 0x00);
+
+	/* Clear Video M Error Interrupt */
+	dptxset(it6505, 0x08, 0x08, 0x08);
+	/* Clear Audio FIFO OverFlow Interrupt */
+	dptxset(it6505, 0x07, 0x04, 0x04);
+}
+
+/***************************************************************************
+ * DPCD Read and EDID
+ ***************************************************************************/
+
+static unsigned int dptx_dpcdrd(struct it6505 *it6505, unsigned long offset)
+{
+	unsigned int startadr0, startadr1, startadr2;
+
+	startadr0 = (unsigned int)((offset >> 0) & 0xFF);
+	startadr1 = (unsigned int)((offset >> 8) & 0xFF);
+	startadr2 = (unsigned int)((offset >> 16) & 0x0F);
+	/* Enable PC Aux Access */
+	dptxwr(it6505, 0x23, (0 << 6) + 0x02);
+	/* Start Address[7:0] */
+	dptxwr(it6505, 0x24, startadr0);
+	/* Start Address[15:8] */
+	dptxwr(it6505, 0x25, startadr1);
+	/* WriteNum[3:0]+StartAdr[19:16] */
+	dptxwr(it6505, 0x26, startadr2);
+	/* Aux Read Fire */
+	dptxwr(it6505, 0x2B, 0x00);
+	dptx_auxwait(it6505);
+	/* Disable PC Aux Access */
+	dptxwr(it6505, 0x23, (0 << 6) + 0x00);
+
+	dptxrd(it6505, 0x2C, &startadr0);
+
+	return startadr0;
+}
+
+static int dptx_dpcdwr(struct it6505 *it6505, unsigned long offset,
+		       unsigned long datain)
+{
+	unsigned int startadr0, startadr1, startadr2;
+
+	startadr0 = (unsigned int)(offset >> 0) & 0xFF;
+	startadr1 = (unsigned int)(offset >> 8) & 0xFF;
+	startadr2 = (unsigned int)(offset >> 16) & 0x0F;
+	/* Enable PC Aux Access */
+	dptxwr(it6505, 0x23, (1 << 6) + 0x02);
+	/* Start Address[7:0] */
+	dptxwr(it6505, 0x24, startadr0);
+	/* Start Address[15:8] */
+	dptxwr(it6505, 0x25, startadr1);
+	/* WriteNum[3:0]+StartAdr[19:16] */
+	dptxwr(it6505, 0x26, startadr2);
+	/* WriteData Byte 1 */
+	dptxwr(it6505, 0x27, datain);
+	/* Aux Write Fire */
+	dptxwr(it6505, 0x2B, 0x05);
+	dptx_auxwait(it6505);
+	/* Aux Read Fire */
+	dptxwr(it6505, 0x2B, 0x00);
+	dptx_auxwait(it6505);
+	/* Disable PC Aux Access */
+	dptxwr(it6505, 0x23, (1 << 6) + 0x00);
+
+	dptxrd(it6505, 0x2C, &startadr0);
+
+	if (startadr0 != datain)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void it6505_get_dpcd(struct it6505 *it6505, u8 *dpcd, u8 num)
+{
+	unsigned int offset = 0;
+	struct device *dev = &it6505->client->dev;
+
+	for (offset = 0; offset < num; offset++)
+		dpcd[offset] = dptx_dpcdrd(it6505, offset);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "DPCD[0x00] = %*ph", num, dpcd);
+}
+
+static void it6505_parse_dpcd(struct it6505 *it6505)
+{
+	u8 max_lanes, dpcd_rev, dpcd[16];
+	struct device *dev = &it6505->client->dev;
+
+	it6505_get_dpcd(it6505, dpcd, ARRAY_SIZE(dpcd));
+	dpcd_rev = dpcd[0];
+	DRM_DEV_DEBUG_DRIVER(dev, "#########DPCD Rev.: %d.%d###########",
+			     dpcd_rev >> 4, dpcd_rev & 0x0F);
+
+	switch (dpcd[1]) {
+	case 0x06:
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Maximum Link Rate: 1.62Gbps per lane");
+		if (it6505->hbr) {
+			DRM_DEV_DEBUG_DRIVER(
+				dev, "Not support HBR Mode, will train LBR");
+			it6505->hbr = false;
+		} else {
+			DRM_DEV_DEBUG_DRIVER(dev, "Training LBR");
+		}
+		break;
+
+	case 0x0A:
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Maximum Link Rate: 2.7Gbps per lane");
+		if (!it6505->hbr) {
+			DRM_DEV_DEBUG_DRIVER(
+				dev, "Support HBR Mode, will train LBR");
+			it6505->hbr = false;
+		} else {
+			DRM_DEV_DEBUG_DRIVER(dev, "Training HBR");
+		}
+		break;
+
+	case 0x14:
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Maximum Link Rate: 2.7Gbps per lane");
+		break;
+
+	default:
+		DRM_DEV_ERROR(dev, "Unknown Maximum Link Rate: %u",
+			      dpcd[1]);
+		break;
+	}
+
+	max_lanes = dpcd[2] & 0x1F;
+	if (max_lanes == 1 || max_lanes == 2 || max_lanes == 4) {
+		DRM_DEV_DEBUG_DRIVER(
+			dev, "Maximum Lane Count: %u lane, it6505->lane = %u",
+			max_lanes, it6505->lane);
+		if (it6505->lane > max_lanes)
+			it6505->lane = max_lanes;
+		DRM_DEV_DEBUG_DRIVER(dev, "Training %u lane", it6505->lane);
+	} else {
+		DRM_DEV_ERROR(dev, "Maximum Lane Count Error: %u", max_lanes);
+	}
+
+	if (dpcd_rev >= 0x11 && dpcd[2] & BIT(7)) {
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Support Enhanced Framing, en_hframe : %d"
+				     , it6505->en_hframe);
+	} else {
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Can not support Enhanced Framing Mode");
+		it6505->en_hframe = 0;
+	}
+
+	if (dpcd[3] & BIT(0)) {
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Maximum Down-Spread: 0.5, support SSC!");
+	} else {
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Maximum Down-Spread: 0, No support SSC!");
+		it6505->en_ssc = 0;
+	}
+
+	if (dpcd_rev >= 0x11 && dpcd[3] & BIT(6))
+		DRM_DEV_DEBUG_DRIVER(dev, "Support No AUX Training");
+	else
+		DRM_DEV_DEBUG_DRIVER(dev, "Can not support No AUX Training");
+
+	if (dptx_dpcdrd(it6505, 0x68028) & BIT(0)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Sink support HDCP!");
+		it6505->cp_capable = true;
+	} else {
+		DRM_DEV_DEBUG_DRIVER(dev, "Sink not support HDCP!");
+		it6505->cp_capable = false;
+		it6505->en_hdcp = 0;
+	}
+
+	if (dptx_dpcdrd(it6505, 0x68028) & BIT(1)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Downstream is repeater!!");
+		it6505->downstream_repeater = true;
+	} else {
+		DRM_DEV_DEBUG_DRIVER(dev, "Downstream is receiver!!");
+		it6505->downstream_repeater = false;
+	}
+}
+
+static void it6505_enable_hdcp(struct it6505 *it6505)
+{
+	int i;
+	u8 bksvs[5], c;
+	struct device *dev = &it6505->client->dev;
+
+	/* Disable CP_Desired */
+	dptxset(it6505, 0x38, 0x0B, 0x00);
+	dptxset(it6505, 0x05, 0x10, 0x10);
+
+	usleep_range(1000, 1500);
+	c = dptx_dpcdrd(it6505, 0x68028);
+	DRM_DEV_DEBUG_DRIVER(dev, "DPCD[0x68028]: 0x%x\n", c);
+	if (!c)
+		return;
+
+	dptxset(it6505, 0x05, 0x10, 0x00);
+	/* Disable CP_Desired */
+	dptxset(it6505, 0x38, 0x01, 0x00);
+	/* Use R0' 100ms waiting */
+	dptxset(it6505, 0x38, 0x08, 0x00);
+	/* clear the repeater List Chk Done and fail bit */
+	dptxset(it6505, 0x39, 0x30, 0x00);
+
+	for (i = 0; i < 5; i++)
+		bksvs[i] = dptx_dpcdrd(it6505, 0x68000 + i);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "Sink BKSV = %5ph", bksvs);
+
+	/* Select An Generator */
+	dptxset(it6505, 0x3A, 0x01, 0x01);
+	/* Enable An Generator */
+	dptxset(it6505, 0x3A, 0x02, 0x02);
+	/* delay1ms(10);*/
+	usleep_range(10000, 15000);
+	/* Stop An Generator */
+	dptxset(it6505, 0x3A, 0x02, 0x00);
+
+	dptxset(it6505, 0x38, 0x01, 0x01);
+	dptxset(it6505, 0x39, 0x01, 0x01);
+}
+
+static void it6505_lanespeed_setup(struct it6505 *it6505)
+{
+	if (!it6505->hbr) {
+		dptxset(it6505, 0x16, 0x01, 0x01);
+		dptxset(it6505, 0x5C, 0x02, 0x00);
+	} else {
+		dptxset(it6505, 0x16, 0x01, 0x00);
+		dptxset(it6505, 0x5C, 0x02, 0x02);
+	}
+}
+
+static void it6505_lane_swap(struct it6505 *it6505)
+{
+	int err;
+	union extcon_property_value property;
+	struct device *dev = &it6505->client->dev;
+
+	err = extcon_get_property(it6505->extcon, EXTCON_DISP_DP,
+				  EXTCON_PROP_USB_TYPEC_POLARITY, &property);
+	if (err) {
+		DRM_DEV_ERROR(dev, "get property fail!");
+		return;
+	}
+	it6505->laneswap = property.intval;
+
+	dptxset(it6505, 0x16, 0x08, it6505->laneswap ? 0x08 : 0x00);
+	dptxset(it6505, 0x16, 0x06, (it6505->lane - 1) << 1);
+	DRM_DEV_DEBUG_DRIVER(dev, "it6505->laneswap = 0x%x", it6505->laneswap);
+
+	if (it6505->laneswap) {
+		switch (it6505->lane) {
+		case 1:
+			dptxset(it6505, 0x5C, 0xF1, 0x81);
+			break;
+		case 2:
+			dptxset(it6505, 0x5C, 0xF1, 0xC1);
+			break;
+		default:
+			dptxset(it6505, 0x5C, 0xF1, 0xF1);
+			break;
+		}
+	} else {
+		switch (it6505->lane) {
+		case 1:
+			dptxset(it6505, 0x5C, 0xF1, 0x11);
+			break;
+		case 2:
+			dptxset(it6505, 0x5C, 0xF1, 0x31);
+			break;
+		default:
+			dptxset(it6505, 0x5C, 0xF1, 0xF1);
+			break;
+		}
+	}
+}
+
+static void it6505_lane_config(struct it6505 *it6505)
+{
+	it6505_lanespeed_setup(it6505);
+	it6505_lane_swap(it6505);
+}
+
+static void it6505_set_ssc(struct it6505 *it6505)
+{
+	struct device *dev = &it6505->client->dev;
+
+	dptxset(it6505, 0x16, 0x10, it6505->en_ssc << 4);
+	if (it6505->en_ssc) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Enable 27M 4463 PPM SSC");
+		dptx_chgbank(it6505, 1);
+		dptxwr(it6505, 0x88, 0x9e);
+		dptxwr(it6505, 0x89, 0x1c);
+		dptxwr(it6505, 0x8A, 0x42);
+		dptx_chgbank(it6505, 0);
+		dptxwr(it6505, 0x58, 0x07);
+		dptxwr(it6505, 0x59, 0x29);
+		dptxwr(it6505, 0x5A, 0x03);
+		/* Stamp Interrupt Step */
+		dptxset(it6505, 0xD4, 0x30, 0x10);
+		dptx_dpcdwr(it6505, 0x107, 0x10);
+	} else {
+		dptx_dpcdwr(it6505, 0x107, 0x00);
+		dptxset(it6505, 0xD4, 0x30, 0x00);
+	}
+}
+
+static void pclk_phase(struct it6505 *it6505)
+{
+	dptxset(it6505, 0x10, 0x03, PCLK_DELAY);
+	dptxset(it6505, 0x12, 0x10, PCLK_INV << 4);
+}
+
+static void afe_driving_setting(struct it6505 *it6505)
+{
+	dptx_chgbank(it6505, 1);
+	dptxwr(it6505, 0x7E, 0x93);
+	dptxwr(it6505, 0x7F, 0x2A);
+	dptxwr(it6505, 0x81, 0x85);
+	dptx_chgbank(it6505, 0);
+}
+
+static void dptx_output(struct it6505 *it6505, unsigned int hbr,
+			unsigned int lane, unsigned int laneswap,
+			unsigned int en_ssc, unsigned int en_hframe)
+{
+	/* change bank 0 */
+	dptx_chgbank(it6505, 0);
+	dptxwr(it6505, 0x64, 0x10);
+	dptxwr(it6505, 0x65, 0x80);
+	dptxwr(it6505, 0x66, 0x10);
+	dptxwr(it6505, 0x67, 0x4F);
+	dptxwr(it6505, 0x68, 0x09);
+	dptxwr(it6505, 0x69, 0xBA);
+	dptxwr(it6505, 0x6A, 0x3B);
+	dptxwr(it6505, 0x6B, 0x4B);
+	dptxwr(it6505, 0x6C, 0x3E);
+	dptxwr(it6505, 0x6D, 0x4F);
+	dptxwr(it6505, 0x6E, 0x09);
+	dptxwr(it6505, 0x6F, 0x56);
+	dptxwr(it6505, 0x70, 0x0E);
+	dptxwr(it6505, 0x71, 0x00);
+	dptxwr(it6505, 0x72, 0x00);
+	dptxwr(it6505, 0x73, 0x4F);
+	dptxwr(it6505, 0x74, 0x09);
+	dptxwr(it6505, 0x75, 0x00);
+	dptxwr(it6505, 0x76, 0x00);
+	dptxwr(it6505, 0x77, 0xE7);
+	dptxwr(it6505, 0x78, 0x10);
+	dptxwr(it6505, 0xE8, 0x00);
+	dptxset(it6505, 0xCE, 0x70, 0x60);
+	dptxset(it6505, 0xD0, 0xC0, 0x80);
+	dptxwr(it6505, 0xCA, 0x4D);
+	dptxwr(it6505, 0xC9, 0xF5);
+	dptxwr(it6505, 0x5C, 0x02);
+
+	dptx_dpcdwr(it6505, 0x600, 0x01);
+	dptxset(it6505, 0x59, 0x01, 0x01);
+	dptxset(it6505, 0x5A, 0x05, 0x01);
+	dptxwr(it6505, 0x12, 0x01);
+	dptxwr(it6505, 0xCB, 0x17);
+	dptxwr(it6505, 0x11, 0x09);
+	dptxwr(it6505, 0x20, 0x28);
+	dptxset(it6505, 0x23, 0x30, 0x00);
+	dptxset(it6505, 0x3A, 0x04, 0x04);
+	dptxset(it6505, 0x15, 0x01, 0x01);
+	dptxwr(it6505, 0x0C, 0x08);
+
+	dptxset(it6505, 0x5F, 0x20, 0x00);
+	it6505_lane_config(it6505);
+
+	it6505_set_ssc(it6505);
+
+	if (en_hframe) {
+		dptxwr(it6505, 0xD3, 0x33);
+		dptx_dpcdwr(it6505, 0x101, 0x80);
+	} else {
+		dptxwr(it6505, 0xD3, 0x32);
+	}
+
+	dptxset(it6505, 0x15, 0x02, 0x02);
+	dptxset(it6505, 0x15, 0x02, 0x00);
+	dptxset(it6505, 0x05, 0x03, 0x02);
+	dptxset(it6505, 0x05, 0x03, 0x00);
+
+	/* reg60[2] = InDDR */
+	dptxwr(it6505, 0x60, 0x44);
+	/* M444B24 format */
+	dptxwr(it6505, 0x62, 0x01);
+	/* select RGB Bypass CSC */
+	dptxwr(it6505, 0x63, 0x00);
+
+	pclk_phase(it6505);
+	dptxset(it6505, 0x61, 0x01, 0x01);
+	dptxwr(it6505, 0x06, 0xFF);
+	dptxwr(it6505, 0x07, 0xFF);
+	dptxwr(it6505, 0x08, 0xFF);
+
+	dptxset(it6505, 0xd3, 0x30, 0x00);
+	dptxset(it6505, 0xd4, 0x41, 0x41);
+	dptxset(it6505, 0xe8, 0x11, 0x11);
+
+	afe_driving_setting(it6505);
+	dptxwr(it6505, 0x17, 0x04);
+	dptxwr(it6505, 0x17, 0x01);
+}
+
+static void dptx_process_sys_wait(struct it6505 *it6505)
+{
+	u8 dpcd1[0x09], dpcd2[0x18];
+	int i, reg0e, reg0d, len1, len2;
+	struct device *dev = &it6505->client->dev;
+
+	dptxrd(it6505, 0x0E, &reg0e);
+	len1 = ARRAY_SIZE(dpcd1);
+	len2 = ARRAY_SIZE(dpcd2);
+	DRM_DEV_DEBUG_DRIVER(dev,
+			     "SYS_WAIT state parse %d dpcd offset!",
+			     len1 + len2);
+
+	for (i = 0; i < len1; i++)
+		dpcd1[i] = dptx_dpcdrd(it6505, 0x100 + i);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd[0x100] = %*ph", len1, dpcd1);
+	for (i = 0; i < len2; i++)
+		dpcd2[i] = dptx_dpcdrd(it6505, 0x200 + i);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd[0x200] = %*ph", len2, dpcd2);
+	if (reg0e & BIT(4)) {
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Auto Link Training Success...");
+		DRM_DEV_DEBUG_DRIVER(dev, "Link State : 0x%x",
+				     reg0e & 0x1F);
+		if (it6505->en_audio) {
+			DRM_DEV_DEBUG_DRIVER(dev, "Enable audio!");
+			it6505_set_audio(it6505, it6505->aud_sel,
+					 it6505->aud_type,
+					 it6505->aud_fs,
+					 it6505->aud_ch);
+		}
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "it6505->VidStable_Done = %02x",
+				     it6505->vidstable_done);
+		if (it6505->cp_capable) {
+			DRM_DEV_DEBUG_DRIVER(dev, "Support HDCP");
+			if (it6505->en_hdcp) {
+				DRM_DEV_DEBUG_DRIVER(dev,
+						     "Enable HDCP");
+				dptx_sys_chg(it6505, SYS_ReHDCP);
+			} else {
+				DRM_DEV_DEBUG_DRIVER(dev,
+						     "Disable HDCP");
+				dptx_sys_chg(it6505, SYS_NOROP);
+			}
+		} else {
+			DRM_DEV_DEBUG_DRIVER(dev, "Not support HDCP");
+			dptx_sys_chg(it6505, SYS_NOROP);
+		}
+	} else {
+		dptxrd(it6505, 0x0D, &reg0d);
+		dptxrd(it6505, 0x0E, &reg0e);
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "Auto Link Training fail step %d",
+				     it6505->cntfsm);
+		DRM_DEV_DEBUG_DRIVER(dev, "reg0E:0x%x, reg0D:0x%x",
+				     reg0e, reg0d);
+		if (it6505->cntfsm > 0) {
+			it6505->cntfsm--;
+			dptx_sys_chg(it6505, SYS_AUTOTRAIN);
+		} else {
+			DRM_DEV_DEBUG_DRIVER(
+				dev, "Auto Training Fail %d times",
+				TRAINFAILCNT);
+			DRM_DEV_DEBUG_DRIVER(dev,
+					     "Sys change to SYS_HPD");
+			dptx_dpcdwr(it6505, 0x102, 0x00);
+			if (it6505->train_fail_hpd > 0) {
+				it6505->train_fail_hpd--;
+				dptx_sys_chg(it6505, SYS_HPD);
+			} else {
+				dptx_sys_chg(it6505, SYS_TRAINFAIL);
+			}
+		}
+	}
+}
+
+static void dptx_sys_fsm(struct it6505 *it6505)
+{
+	unsigned int i;
+	int reg0e, reg0d, reg9f;
+	struct device *dev = &it6505->client->dev;
+	unsigned int ar0_low, ar0_high, br0_low, br0_high;
+
+	dptxrd(it6505, 0x0D, &reg0d);
+
+	if (it6505->status != SYS_UNPLUG && !(reg0d & BIT(1)))
+		dptx_sys_chg(it6505, SYS_UNPLUG);
+	DRM_DEV_DEBUG_DRIVER(dev, "state: %s", state_string[it6505->status]);
+	switch (it6505->status) {
+	case SYS_UNPLUG:
+		drm_helper_hpd_irq_event(it6505->connector.dev);
+		break;
+
+	case SYS_HPD:
+		dptxrd(it6505, 0x9f, &reg9f);
+		DRM_DEV_DEBUG_DRIVER(dev, "Aux channel status reg9F=0x%02x",
+				     reg9f);
+		drm_helper_hpd_irq_event(it6505->connector.dev);
+		for (i = 0; i <= WAITBRIDGEENABLE; i++) {
+			msleep(50);
+			if (it6505->run_bridge_enable) {
+				it6505->run_bridge_enable = 0;
+				break;
+			}
+		}
+		/* GETDPCD */
+		it6505_parse_dpcd(it6505);
+
+		/*
+		 * training fail TRAINFAILCNT times,
+		 * then change to HPD to restart
+		 */
+		it6505->cntfsm = TRAINFAILCNT;
+		DRM_DEV_DEBUG_DRIVER(dev, "will Train %s %d lanes",
+				     it6505->hbr ? "HBR" : "LBR", it6505->lane);
+		dptx_sys_chg(it6505, SYS_AUTOTRAIN);
+		break;
+
+	case SYS_AUTOTRAIN:
+		dptx_output(it6505, it6505->hbr, it6505->lane, it6505->laneswap,
+			    it6505->en_ssc, it6505->en_hframe);
+
+		/*
+		 * waiting for training down flag
+		 * because we don't know
+		 * how long this step will be completed
+		 * so use step 1ms to wait
+		 */
+		for (i = 0; i < FLAGTRAINDOWN; i++) {
+			usleep_range(1000, 2000);
+			dptxrd(it6505, 0x0E, &reg0e);
+			if (reg0e & BIT(4))
+				break;
+		}
+
+		dptx_sys_chg(it6505, SYS_WAIT);
+		break;
+
+	case SYS_WAIT:
+		dptx_process_sys_wait(it6505);
+		break;
+
+	case SYS_ReHDCP:
+		msleep(1200);
+		dptxrd(it6505, 0x3B, &ar0_low);
+		dptxrd(it6505, 0x3C, &ar0_high);
+		dptxrd(it6505, 0x45, &br0_low);
+		dptxrd(it6505, 0x46, &br0_high);
+		DRM_DEV_DEBUG_DRIVER(dev, "Before EnableHDCP");
+		DRM_DEV_DEBUG_DRIVER(dev, "Ar0_low:%x, Ar0_high:%x", ar0_low,
+				     ar0_high);
+		DRM_DEV_DEBUG_DRIVER(dev, "Br0_low:%x, Br0_high:%x", br0_low,
+				     br0_high);
+		it6505_enable_hdcp(it6505);
+		msleep(200);
+		DRM_DEV_DEBUG_DRIVER(dev, "SYS_ReHDCP end");
+		break;
+
+	case SYS_NOROP:
+		break;
+
+	case SYS_TRAINFAIL:
+		break;
+
+	default:
+		DRM_DEV_ERROR(dev, "sys_state change to unknown_state: %d",
+			      it6505->status);
+		break;
+	}
+}
+
+static int sha1_digest(struct it6505 *it6505, u8 *sha1_input, unsigned int size,
+		       u8 *output_av)
+{
+	struct shash_desc *desc;
+	struct crypto_shash *tfm;
+	int err;
+	struct device *dev = &it6505->client->dev;
+
+	tfm = crypto_alloc_shash("sha1", 0, 0);
+	if (IS_ERR(tfm)) {
+		DRM_DEV_ERROR(dev, "crypto_alloc_shash sha1 failed");
+		return PTR_ERR(tfm);
+	}
+	desc = kzalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
+	if (!desc) {
+		crypto_free_shash(tfm);
+		return -ENOMEM;
+	}
+
+	desc->tfm = tfm;
+	err = crypto_shash_digest(desc, sha1_input, size, output_av);
+	if (err)
+		DRM_DEV_ERROR(dev, "crypto_shash_digest sha1 failed");
+
+	crypto_free_shash(tfm);
+	kfree(desc);
+	return err;
+}
+
+static int it6505_makeup_sha1_input(struct it6505 *it6505)
+{
+	int msgcnt = 0, i;
+	unsigned int value;
+	u8 am0[8], binfo[2];
+	struct device *dev = &it6505->client->dev;
+
+	dptxset(it6505, 0x3A, 0x20, 0x20);
+	for (i = 0; i < 8; i++) {
+		dptxrd(it6505, 0x4C + i, &value);
+		am0[i] = value;
+	}
+	DRM_DEV_DEBUG_DRIVER(dev, "read am0 = %8ph", am0);
+	dptxset(it6505, 0x3A, 0x20, 0x00);
+
+	binfo[0] = dptx_dpcdrd(it6505, 0x6802A);
+	binfo[1] = dptx_dpcdrd(it6505, 0x6802B);
+	DRM_DEV_DEBUG_DRIVER(dev, "read Binfo!!");
+	DRM_DEV_DEBUG_DRIVER(dev, "Attached devices: %02x",
+			     binfo[0] & 0x7F);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "%s 127 devices are attached",
+			     (binfo[0] & BIT(7)) ? "over" : "under");
+	DRM_DEV_DEBUG_DRIVER(dev, "depth, attached levels: %02x",
+			     binfo[1] & 0x07);
+	DRM_DEV_DEBUG_DRIVER(dev, "%s than seven levels cascaded",
+			     (binfo[1] & BIT(3)) ? "more" : "less");
+
+	for (i = 0; i < (binfo[0] & 0x7F); i++) {
+		it6505->shainput[msgcnt] =
+			dptx_dpcdrd(it6505, 0x6802C + (i % 3) * 5);
+		msgcnt++;
+		it6505->shainput[msgcnt] =
+			dptx_dpcdrd(it6505, 0x6802D + (i % 3) * 5);
+		msgcnt++;
+		it6505->shainput[msgcnt] =
+			dptx_dpcdrd(it6505, 0x6802E + (i % 3) * 5);
+		msgcnt++;
+		it6505->shainput[msgcnt] =
+			dptx_dpcdrd(it6505, 0x6802F + (i % 3) * 5);
+		msgcnt++;
+		it6505->shainput[msgcnt] =
+			dptx_dpcdrd(it6505, 0x68030 + (i % 3) * 5);
+		msgcnt++;
+
+		DRM_DEV_DEBUG_DRIVER(dev, "KSV List %d device : %5ph", i,
+				     it6505->shainput + i * 5);
+	}
+	it6505->shainput[msgcnt++] = binfo[0];
+	it6505->shainput[msgcnt++] = binfo[1];
+	for (i = 0; i < 8; i++)
+		it6505->shainput[msgcnt++] = am0[i];
+
+	DRM_DEV_DEBUG_DRIVER(dev, "SHA Message Count = %d", msgcnt);
+	return msgcnt;
+}
+
+static void it6505_check_sha1_result(struct it6505 *it6505)
+{
+	unsigned int i, shapass;
+	struct device *dev = &it6505->client->dev;
+
+	DRM_DEV_DEBUG_DRIVER(dev, "SHA calculate complete");
+	for (i = 0; i < 5; i++)
+		DRM_DEV_DEBUG_DRIVER(dev, "av %d: %4ph", i, it6505->av[i]);
+
+	shapass = 1;
+	for (i = 0; i < 5; i++) {
+		it6505->bv[i][0] = dptx_dpcdrd(it6505, 0x68017 + i * 4);
+		it6505->bv[i][1] = dptx_dpcdrd(it6505, 0x68016 + i * 4);
+		it6505->bv[i][2] = dptx_dpcdrd(it6505, 0x68015 + i * 4);
+		it6505->bv[i][3] = dptx_dpcdrd(it6505, 0x68014 + i * 4);
+		DRM_DEV_DEBUG_DRIVER(dev, "bv %d: %4ph", i, it6505->bv[i]);
+		if ((it6505->bv[i][0] != it6505->av[i][0]) ||
+		    (it6505->bv[i][1] != it6505->av[i][1]) ||
+		    (it6505->bv[i][2] != it6505->av[i][2]) ||
+		    (it6505->bv[i][3] != it6505->av[i][3])) {
+			shapass = 0;
+		}
+	}
+	if (shapass) {
+		DRM_DEV_DEBUG_DRIVER(dev, "SHA check result pass!");
+		dptxset(it6505, 0x39, BIT(4), BIT(4));
+	} else {
+		DRM_DEV_DEBUG_DRIVER(dev, "SHA check result fail");
+		dptxset(it6505, 0x39, BIT(5), BIT(5));
+	}
+}
+
+static void to_fsm_status(struct it6505 *it6505, enum sys_status status)
+{
+	while (it6505->status != status) {
+		dptx_sys_fsm(it6505);
+		if (it6505->status == SYS_UNPLUG)
+			return;
+	}
+}
+
+static void go_on_fsm(struct it6505 *it6505);
+
+static void hpd_irq(struct it6505 *it6505)
+{
+	unsigned int dpcd200, dpcd201, dpcd202, dpcd203, dpcd204, dpcd205;
+	unsigned int value, reg55, bstatus;
+	int ret, len;
+	struct device *dev = &it6505->client->dev;
+
+	dpcd200 = dptx_dpcdrd(it6505, 0x200);
+	dpcd201 = dptx_dpcdrd(it6505, 0x201);
+	dpcd202 = dptx_dpcdrd(it6505, 0x202);
+	dpcd203 = dptx_dpcdrd(it6505, 0x203);
+	dpcd204 = dptx_dpcdrd(it6505, 0x204);
+	dpcd205 = dptx_dpcdrd(it6505, 0x205);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd200 = 0x%x", dpcd200);
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd201 = 0x%x", dpcd201);
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd202 = 0x%x", dpcd202);
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd203 = 0x%x", dpcd203);
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd204 = 0x%x", dpcd204);
+	DRM_DEV_DEBUG_DRIVER(dev, "dpcd205 = 0x%x", dpcd205);
+
+	if (dpcd201 & BIT(2)) {
+		ret = dptxrd(it6505, 0x38, &value);
+		bstatus = dptx_dpcdrd(it6505, 0x68029);
+		dptxset(it6505, 0x39, 0x02, 0x02);
+		dptxrd(it6505, 0x55, &reg55);
+		DRM_DEV_DEBUG_DRIVER(dev,
+				     "reg0x55 = 0x%02x, reg0x68029 = 0x%02x",
+				     reg55, bstatus);
+		DRM_DEV_DEBUG_DRIVER(dev, "Receive CP_IRQ!");
+
+		if (bstatus & BIT(0)) {
+			DRM_DEV_DEBUG_DRIVER(dev, "HDCP KSV list ready");
+			len = it6505_makeup_sha1_input(it6505);
+			sha1_digest(it6505, it6505->shainput, len,
+				    (u8 *)it6505->av);
+			it6505_check_sha1_result(it6505);
+		}
+		if (bstatus & BIT(2)) {
+			DRM_DEV_DEBUG_DRIVER(
+				dev, "Link Integrity Fail, restart HDCP");
+			dptxset(it6505, 0x39, 0x02, 0x02);
+			return;
+		}
+		if (bstatus & BIT(1)) {
+			DRM_DEV_DEBUG_DRIVER(dev, "HDCP R0' ready");
+			dptxset(it6505, 0x39, 0x02, 0x02);
+		}
+	}
+
+	if ((dpcd204 & BIT(7)) == 0x80) {
+		if ((it6505->lane == 1 && (dpcd202 & BIT(2)) != 0x04) ||
+		    (it6505->lane == 2 && (dpcd202 & 0x44) != 0x44) ||
+		    (it6505->lane == 4 &&
+		     ((dpcd202 & 0x44) != 0x44 || (dpcd203 & 0x44) != 0x44)) ||
+		    (it6505->lane == 1 && (dpcd203 & BIT(6)) != 0x40) ||
+		    (it6505->lane == 2 && (dpcd203 & 0x44) != 0x44) ||
+		    (it6505->lane == 4 &&
+		     ((dpcd203 & 0x44) != 0x44 || (dpcd202 & 0x44) != 0x44)) ||
+		    (dpcd204 & BIT(0)) != 0x01) {
+			DRM_DEV_DEBUG_DRIVER(dev, "Link Re-Training");
+			dptxset(it6505, 0xD3, 0x30, 0x30);
+			dptxset(it6505, 0xE8, 0x33, 0x00);
+			msleep(500);
+			dptx_sys_chg(it6505, SYS_HPD);
+			go_on_fsm(it6505);
+		}
+	}
+}
+
+static void go_on_fsm(struct it6505 *it6505)
+{
+	struct device *dev = &it6505->client->dev;
+
+	if (it6505->cp_capable) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Support HDCP, cp_capable: %d",
+				     it6505->cp_capable);
+		if (it6505->en_hdcp) {
+			DRM_DEV_DEBUG_DRIVER(dev, "Enable HDCP");
+			to_fsm_status(it6505, SYS_ReHDCP);
+			dptx_sys_fsm(it6505);
+
+		} else {
+			DRM_DEV_DEBUG_DRIVER(dev, "Disable HDCP");
+			to_fsm_status(it6505, SYS_NOROP);
+		}
+	} else {
+		DRM_DEV_DEBUG_DRIVER(dev, "Not support HDCP");
+		to_fsm_status(it6505, SYS_NOROP);
+	}
+}
+
+static void it6505_check_reg06(struct it6505 *it6505, unsigned int reg06)
+{
+	unsigned int rddata, err;
+	union extcon_property_value property;
+	struct device *dev = &it6505->client->dev;
+
+	if (reg06 & BIT(0)) {
+		/* hpd pin status change */
+		DRM_DEV_DEBUG_DRIVER(dev, "HPD Change Interrupt");
+		dptxrd(it6505, 0x0D, &rddata);
+		if (rddata & BIT(1)) {
+			err = extcon_get_property(
+				it6505->extcon, EXTCON_DISP_DP,
+				EXTCON_PROP_USB_TYPEC_POLARITY, &property);
+			if (err)
+				DRM_DEV_DEBUG_DRIVER(dev, "get property fail");
+
+			it6505->laneswap = property.intval;
+			DRM_DEV_DEBUG_DRIVER(dev, "laneswap: %d",
+					     it6505->laneswap);
+			dptx_sys_chg(it6505, SYS_HPD);
+			dptx_sys_fsm(it6505);
+			dptxwr(it6505, 0x05, 0x00);
+
+		} else {
+			dptx_sys_chg(it6505, SYS_UNPLUG);
+			dptx_sys_fsm(it6505);
+			return;
+		}
+	}
+
+	if (it6505->cp_capable) {
+		if (reg06 & BIT(4)) {
+			DRM_DEV_DEBUG_DRIVER(dev,
+					     "HDCP encryption Done Interrupt");
+			it6505->cp_done = 1;
+			dptx_sys_chg(it6505, SYS_NOROP);
+		}
+
+		if (reg06 & BIT(3)) {
+			DRM_DEV_DEBUG_DRIVER(dev,
+					     "HDCP encryption Fail Interrupt");
+			DRM_DEV_DEBUG_DRIVER(dev, "HDCP retry");
+			it6505->cp_done = 0;
+			dptx_init(it6505);
+			it6505_int_mask_on(it6505);
+		}
+	}
+
+	if (reg06 & BIT(1)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "HPD IRQ Interrupt");
+		hpd_irq(it6505);
+	}
+
+	if (reg06 & BIT(2)) {
+		dptxrd(it6505, 0x0D, &rddata);
+
+		if ((rddata & BIT(2)) >> 2) {
+			DRM_DEV_DEBUG_DRIVER(dev, "Video Stable On Interrupt");
+			it6505->vidstable_done = 1;
+			dptx_sys_chg(it6505, SYS_AUTOTRAIN);
+			go_on_fsm(it6505);
+		} else {
+			DRM_DEV_DEBUG_DRIVER(dev, "Video Stable Off Interrupt");
+			it6505->vidstable_done = 0;
+		}
+	}
+}
+
+static void it6505_check_reg07(struct it6505 *it6505, unsigned int reg07)
+{
+	struct device *dev = &it6505->client->dev;
+
+	if (it6505->status == SYS_UNPLUG)
+		return;
+	if (reg07 & BIT(0))
+		DRM_DEV_DEBUG_DRIVER(dev, "AUX PC Request Fail Interrupt");
+
+	if (reg07 & BIT(1)) {
+		unsigned int ar0_low, ar0_high, br0_low, br0_high, bstatus;
+
+		DRM_DEV_DEBUG_DRIVER(dev, "HDCP event Interrupt");
+		bstatus = dptx_dpcdrd(it6505, 0x68029);
+		dptxrd(it6505, 0x3B, &ar0_low);
+		dptxrd(it6505, 0x3C, &ar0_high);
+		dptxrd(it6505, 0x45, &br0_low);
+		dptxrd(it6505, 0x46, &br0_high);
+		/*
+		 * Read Bstatus to determine what happened
+		 */
+		DRM_DEV_DEBUG_DRIVER(dev, "Bstatus reg0x68029: %02x", bstatus);
+		if (!(bstatus & BIT(0))) {
+			DRM_DEV_DEBUG_DRIVER(dev,
+					     "Ar0_low: %02x Ar0_high: %02x",
+					     ar0_low, ar0_high);
+			DRM_DEV_DEBUG_DRIVER(dev,
+					     "Br0_low: %02x Br0_high: %02x",
+					     br0_low, br0_high);
+		}
+	}
+	if (it6505->en_audio && (reg07 & BIT(2))) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Audio FIFO OverFlow Interrupt");
+		dptxset(it6505, 0xD3, 0x20, 0x20);
+		dptxset(it6505, 0xE8, 0x22, 0x00);
+		dptxset(it6505, 0xB8, 0x80, 0x80);
+		dptxset(it6505, 0xB8, 0x80, 0x00);
+		it6505_set_audio(it6505, it6505->aud_sel, it6505->aud_type,
+				 it6505->aud_fs, it6505->aud_ch);
+	}
+}
+
+static void it6505_check_reg08(struct it6505 *it6505, unsigned int reg08)
+{
+	struct device *dev = &it6505->client->dev;
+
+	if (it6505->status == SYS_UNPLUG)
+		return;
+	if (reg08 & BIT(4)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "Link Training Fail Interrupt");
+		/* restart training */
+		dptx_sys_chg(it6505, SYS_AUTOTRAIN);
+		go_on_fsm(it6505);
+	}
+
+	if (reg08 & BIT(7)) {
+		DRM_DEV_DEBUG_DRIVER(dev, "IO Latch FIFO OverFlow Interrupt");
+		dptxset(it6505, 0x61, 0x02, 0x02);
+		dptxset(it6505, 0x61, 0x02, 0x00);
+	}
+}
+
+static void it6505_dptx_irq(struct it6505 *it6505)
+{
+	unsigned int reg06, reg07, reg08, reg0d;
+	struct device *dev = &it6505->client->dev;
+
+	dptxrd(it6505, 0x06, &reg06);
+	dptxrd(it6505, 0x07, &reg07);
+	dptxrd(it6505, 0x08, &reg08);
+	dptxrd(it6505, 0x0D, &reg0d);
+
+	dptxwr(it6505, 0x06, reg06);
+	dptxwr(it6505, 0x07, reg07);
+	dptxwr(it6505, 0x08, reg08);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "reg06 = 0x%02x", reg06);
+	DRM_DEV_DEBUG_DRIVER(dev, "reg07 = 0x%02x", reg07);
+	DRM_DEV_DEBUG_DRIVER(dev, "reg08 = 0x%02x", reg08);
+	DRM_DEV_DEBUG_DRIVER(dev, "reg0d = 0x%02x", reg0d);
+
+	if (reg06 != 0)
+		it6505_check_reg06(it6505, reg06);
+
+	if (reg07 != 0)
+		it6505_check_reg07(it6505, reg07);
+
+	if (reg08 != 0)
+		it6505_check_reg08(it6505, reg08);
+}
+
+static void it6505_bridge_enable(struct drm_bridge *bridge)
+{
+	struct it6505 *it6505 = bridge_to_it6505(bridge);
+
+	if (!it6505->drv_hold) {
+		it6505->run_bridge_enable = 1;
+		it6505_int_mask_on(it6505);
+		dptx_sys_chg(it6505, SYS_HPD);
+	}
+}
+
+static void it6505_bridge_disable(struct drm_bridge *bridge)
+{
+	struct it6505 *it6505 = bridge_to_it6505(bridge);
+
+	dptx_sys_chg(it6505, SYS_UNPLUG);
+}
+
+static const struct drm_bridge_funcs it6505_bridge_funcs = {
+	.attach = it6505_bridge_attach,
+	.detach = it6505_bridge_detach,
+	.mode_valid = it6505_bridge_mode_valid,
+	.mode_set = it6505_bridge_mode_set,
+	.enable = it6505_bridge_enable,
+	.disable = it6505_bridge_disable,
+};
+
+static void it6505_clear_int(struct it6505 *it6505)
+{
+	dptxwr(it6505, 0x06, 0xFF);
+	dptxwr(it6505, 0x07, 0xFF);
+	dptxwr(it6505, 0x08, 0xFF);
+}
+
+static irqreturn_t it6505_intp_threaded_handler(int unused, void *data)
+{
+	struct it6505 *it6505 = data;
+	struct device *dev = &it6505->client->dev;
+
+	msleep(150);
+	down(&it6505->sem_notifier);
+
+	if (it6505->drv_hold == 0 && it6505->powered) {
+		DRM_DEV_DEBUG_DRIVER(dev, "into it6505_dptx_irq");
+		it6505_dptx_irq(it6505);
+	}
+
+	up(&it6505->sem_notifier);
+	return IRQ_HANDLED;
+}
+
+static int it6505_init_pdata(struct it6505 *it6505)
+{
+	struct it6505_platform_data *pdata = &it6505->pdata;
+	struct device *dev = &it6505->client->dev;
+
+	/* 1.0V digital core power regulator  */
+	pdata->pwr18 = devm_regulator_get(dev, "pwr18");
+	if (IS_ERR(pdata->pwr18)) {
+		DRM_DEV_ERROR(dev, "pwr18 regulator not found");
+		return PTR_ERR(pdata->pwr18);
+	}
+
+	pdata->ovdd = devm_regulator_get(dev, "ovdd");
+	if (IS_ERR(pdata->ovdd)) {
+		DRM_DEV_ERROR(dev, "ovdd regulator not found");
+		return PTR_ERR(pdata->ovdd);
+	}
+
+	/* GPIO for HPD */
+	pdata->gpiod_hpd = devm_gpiod_get(dev, "hpd", GPIOD_IN);
+	if (IS_ERR(pdata->gpiod_hpd))
+		return PTR_ERR(pdata->gpiod_hpd);
+
+	/* GPIO for chip reset */
+	pdata->gpiod_reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+
+	return PTR_ERR_OR_ZERO(pdata->gpiod_reset);
+}
+
+static ssize_t drv_hold_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct it6505 *it6505 = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", it6505->drv_hold);
+}
+
+static ssize_t drv_hold_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct it6505 *it6505 = dev_get_drvdata(dev);
+
+	if (kstrtoint(buf, 10, &it6505->drv_hold) < 0)
+		return -EINVAL;
+
+	if (it6505->drv_hold) {
+		it6505_int_mask_off(it6505);
+	} else {
+		it6505_clear_int(it6505);
+		it6505_int_mask_on(it6505);
+	}
+	return count;
+}
+
+static ssize_t print_timing_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct it6505 *it6505 = dev_get_drvdata(dev);
+	struct drm_display_mode *vid = &it6505->vid_info;
+	char *str = buf, *end = buf + PAGE_SIZE;
+
+	str += scnprintf(str, end - str, "---video timing---\n");
+	str += scnprintf(str, end - str, "PCLK:%d.%03dMHz\n", vid->clock / 1000,
+			 vid->clock % 1000);
+	str += scnprintf(str, end - str, "HTotal:%d\n", vid->htotal);
+	str += scnprintf(str, end - str, "HActive:%d\n", vid->hdisplay);
+	str += scnprintf(str, end - str, "HFrontPorch:%d\n",
+			 vid->hsync_start - vid->hdisplay);
+	str += scnprintf(str, end - str, "HSyncWidth:%d\n",
+			 vid->hsync_end - vid->hsync_start);
+	str += scnprintf(str, end - str, "HBackPorch:%d\n",
+			 vid->htotal - vid->hsync_end);
+	str += scnprintf(str, end - str, "VTotal:%d\n", vid->vtotal);
+	str += scnprintf(str, end - str, "VActive:%d\n", vid->vdisplay);
+	str += scnprintf(str, end - str, "VFrontPorch:%d\n",
+			 vid->vsync_start - vid->vdisplay);
+	str += scnprintf(str, end - str, "VSyncWidth:%d\n",
+			 vid->vsync_end - vid->vsync_start);
+	str += scnprintf(str, end - str, "VBackPorch:%d\n",
+			 vid->vtotal - vid->vsync_end);
+
+	return str - buf;
+}
+
+static ssize_t sha_debug_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	int i = 0;
+	char *str = buf, *end = buf + PAGE_SIZE;
+	struct it6505 *it6505 = dev_get_drvdata(dev);
+
+	str += scnprintf(str, end - str, "sha input:\n");
+	for (i = 0; i < ARRAY_SIZE(it6505->shainput); i += 16) {
+		str += scnprintf(str, end - str, "%16ph\n",
+				 it6505->shainput + i);
+	}
+
+	str += scnprintf(str, end - str, "av:\n");
+	for (i = 0; i < ARRAY_SIZE(it6505->av); i++)
+		str += scnprintf(str, end - str, "%4ph\n", it6505->av[i]);
+
+	str += scnprintf(str, end - str, "bv:\n");
+	for (i = 0; i < ARRAY_SIZE(it6505->bv); i++)
+		str += scnprintf(str, end - str, "%4ph\n", it6505->bv[i]);
+
+	return end - str;
+}
+
+static ssize_t en_hdcp_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct it6505 *it6505 = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", it6505->en_hdcp);
+}
+
+static ssize_t en_hdcp_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct it6505 *it6505 = dev_get_drvdata(dev);
+	unsigned int reg3f, hdcp;
+
+	if (kstrtoint(buf, 10, &it6505->en_hdcp) < 0)
+		return -EINVAL;
+
+	if (!it6505->powered || it6505->status == SYS_UNPLUG) {
+		DRM_DEV_DEBUG_DRIVER(dev,
+			      "power down or unplug, can not fire HDCP");
+		return -EINVAL;
+	}
+
+	if (it6505->en_hdcp) {
+		if (it6505->cp_capable) {
+			dptx_sys_chg(it6505, SYS_ReHDCP);
+			dptx_sys_fsm(it6505);
+		} else {
+			DRM_DEV_ERROR(dev, "sink not support HDCP");
+			it6505->cp_done = 0;
+		}
+	} else {
+		dptxset(it6505, 0x05, 0x10, 0x10);
+		dptxset(it6505, 0x05, 0x10, 0x00);
+		dptxrd(it6505, 0x3F, &reg3f);
+		hdcp = (reg3f & BIT(7)) >> 7;
+		DRM_DEV_DEBUG_DRIVER(dev, "%s to disable hdcp",
+				     hdcp ? "failed" : "succeeded");
+		it6505->cp_done = hdcp;
+	}
+	return count;
+}
+
+static ssize_t en_pwronoff_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct it6505 *it6505 = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", it6505->en_pwronoff);
+}
+
+static ssize_t en_pwronoff_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct it6505 *it6505 = dev_get_drvdata(dev);
+
+	if (kstrtoint(buf, 10, &it6505->en_pwronoff) < 0)
+		return -EINVAL;
+	return count;
+}
+
+static ssize_t en_audio_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct it6505 *it6505 = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", it6505->en_audio);
+}
+
+static ssize_t en_audio_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct it6505 *it6505 = dev_get_drvdata(dev);
+
+	if (kstrtoint(buf, 10, &it6505->en_audio) < 0)
+		return -EINVAL;
+	if (!it6505->powered || it6505->status == SYS_UNPLUG) {
+		DRM_DEV_DEBUG_DRIVER(
+			dev, "power down or unplug, can not output audio");
+		return -EINVAL;
+	}
+
+	if (it6505->en_audio) {
+		it6505_set_audio(it6505, it6505->aud_sel, it6505->aud_type,
+				 it6505->aud_fs, it6505->aud_ch);
+	} else {
+		dptxset(it6505, 0x05, 0x02, 0x02);
+		dptxset(it6505, 0x05, 0x02, 0x00);
+	}
+	DRM_DEV_DEBUG_DRIVER(dev, "%s audio",
+			     it6505->en_audio ? "Enable" : "Disable");
+	return count;
+}
+
+static ssize_t force_pwronoff_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct it6505 *it6505 = dev_get_drvdata(dev);
+	int pwr;
+
+	if (kstrtoint(buf, 10, &pwr) < 0)
+		return -EINVAL;
+	if (pwr)
+		it6505_poweron(it6505);
+	else
+		it6505_poweroff(it6505);
+	return count;
+}
+
+static ssize_t pwr_status_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct it6505 *it6505 = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", it6505->powered);
+}
+
+static DEVICE_ATTR_RO(print_timing);
+static DEVICE_ATTR_RO(pwr_status);
+static DEVICE_ATTR_RO(sha_debug);
+static DEVICE_ATTR_WO(force_pwronoff);
+static DEVICE_ATTR_RW(drv_hold);
+static DEVICE_ATTR_RW(en_hdcp);
+static DEVICE_ATTR_RW(en_pwronoff);
+static DEVICE_ATTR_RW(en_audio);
+
+static const struct attribute *it6505_attrs[] = {
+	&dev_attr_drv_hold.attr,
+	&dev_attr_print_timing.attr,
+	&dev_attr_sha_debug.attr,
+	&dev_attr_en_hdcp.attr,
+	&dev_attr_en_pwronoff.attr,
+	&dev_attr_en_audio.attr,
+	&dev_attr_force_pwronoff.attr,
+	&dev_attr_pwr_status.attr,
+	NULL,
+};
+
+static int it6505_i2c_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	struct it6505 *it6505;
+	struct it6505_platform_data *pdata;
+	struct device *dev = &client->dev;
+	struct extcon_dev *extcon;
+	int err = 0, intp_irq;
+
+	it6505 = devm_kzalloc(&client->dev, sizeof(*it6505), GFP_KERNEL);
+	if (!it6505)
+		return -ENOMEM;
+
+	mutex_init(&it6505->lock);
+
+	pdata = &it6505->pdata;
+
+	it6505->bridge.of_node = client->dev.of_node;
+	it6505->client = client;
+	i2c_set_clientdata(client, it6505);
+
+	/* get extcon device from DTS */
+	extcon = extcon_get_edev_by_phandle(dev, 0);
+	if (PTR_ERR(extcon) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (IS_ERR(extcon)) {
+		DRM_DEV_ERROR(dev, "can not get extcon device!");
+		return -EINVAL;
+	}
+
+	it6505->extcon = extcon;
+
+	err = it6505_init_pdata(it6505);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to initialize pdata: %d", err);
+		return err;
+	}
+
+	it6505->regmap =
+		devm_regmap_init_i2c(client, &it6505_bridge_regmap_config);
+	if (IS_ERR(it6505->regmap)) {
+		DRM_DEV_ERROR(dev, "regmap i2c init failed");
+		return PTR_ERR(it6505->regmap);
+	}
+
+	intp_irq = client->irq;
+
+	if (!intp_irq) {
+		DRM_DEV_ERROR(dev, "Failed to get CABLE_DET and INTP IRQ");
+		return -ENODEV;
+	}
+
+	err = devm_request_threaded_irq(&client->dev, intp_irq, NULL,
+					it6505_intp_threaded_handler,
+					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					"it6505-intp", it6505);
+	if (err) {
+		DRM_DEV_ERROR(dev, "Failed to request INTP threaded IRQ: %d",
+			      err);
+		return err;
+	}
+
+	/* Register aux channel */
+	it6505->aux.name = "DP-AUX";
+	it6505->aux.dev = dev;
+	it6505->aux.transfer = it6505_aux_transfer;
+	err = drm_dp_aux_register(&it6505->aux);
+	if (err < 0) {
+		DRM_DEV_ERROR(dev, "Failed to register aux: %d", err);
+		return err;
+	}
+
+	/* thread sequence control */
+	sema_init(&it6505->sem_notifier, 1);
+	it6505->en_pwronoff = DEFAULTPWRONOFF;
+	it6505->drv_hold = DEFAULTDRVHOLD;
+	it6505->en_hdcp = DEFAULTHDCP;
+	it6505->en_audio = DEFAULTAUDIO;
+	it6505->powered = 0;
+
+	if (DEFAULTPWRON)
+		it6505_poweron(it6505);
+	err = sysfs_create_files(&client->dev.kobj, it6505_attrs);
+	if (err) {
+		drm_dp_aux_unregister(&it6505->aux);
+		return err;
+	}
+
+	it6505->bridge.funcs = &it6505_bridge_funcs;
+	drm_bridge_add(&it6505->bridge);
+	return 0;
+}
+
+static int it6505_remove(struct i2c_client *client)
+{
+	struct it6505 *it6505 = i2c_get_clientdata(client);
+
+	drm_bridge_remove(&it6505->bridge);
+	sysfs_remove_files(&client->dev.kobj, it6505_attrs);
+	kfree(it6505->edid);
+	it6505->edid = NULL;
+	drm_connector_unregister(&it6505->connector);
+	drm_dp_aux_unregister(&it6505->aux);
+	return 0;
+}
+
+static const struct i2c_device_id it6505_id[] = {
+	{ "it6505", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, it6505_id);
+
+static const struct of_device_id it6505_of_match[] = {
+	{ .compatible = "ite,it6505" },
+	{ }
+};
+
+struct i2c_driver it6505_i2c_driver = {
+	.driver = {
+		.name = "it6505_dptx",
+		.owner = THIS_MODULE,
+		.of_match_table = it6505_of_match,
+	},
+	.probe = it6505_i2c_probe,
+	.remove = it6505_remove,
+	.id_table = it6505_id,
+};
+
+module_i2c_driver(it6505_i2c_driver);
+
+MODULE_AUTHOR("Jitao Shi <jitao.shi@mediatek.com>");
+MODULE_DESCRIPTION("IT6505 DisplayPort Transmitter driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_crtc.c b/drivers/gpu/drm/mediatek/mtk_drm_crtc.c
index f70d33c8b495..60e101ca9d03 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_crtc.c
+++ b/drivers/gpu/drm/mediatek/mtk_drm_crtc.c
@@ -18,7 +18,6 @@
 #include <drm/drm_plane_helper.h>
 #include <linux/clk.h>
 #include <linux/pm_runtime.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_drm_drv.h"
 #include "mtk_drm_crtc.h"
@@ -396,20 +395,12 @@ static void mtk_drm_crtc_atomic_enable(struct drm_crtc *crtc,
 				       struct drm_crtc_state *old_state)
 {
 	struct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);
-	struct mtk_ddp_comp *comp = mtk_crtc->ddp_comp[0];
 	int ret;
 
 	DRM_DEBUG_DRIVER("%s %d\n", __func__, crtc->base.id);
 
-	ret = mtk_smi_larb_get(comp->larb_dev);
-	if (ret) {
-		DRM_ERROR("Failed to get larb: %d\n", ret);
-		return;
-	}
-
 	ret = mtk_crtc_ddp_hw_init(mtk_crtc);
 	if (ret) {
-		mtk_smi_larb_put(comp->larb_dev);
 		return;
 	}
 
@@ -421,7 +412,6 @@ static void mtk_drm_crtc_atomic_disable(struct drm_crtc *crtc,
 					struct drm_crtc_state *old_state)
 {
 	struct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);
-	struct mtk_ddp_comp *comp = mtk_crtc->ddp_comp[0];
 	int i;
 
 	DRM_DEBUG_DRIVER("%s %d\n", __func__, crtc->base.id);
@@ -444,7 +434,6 @@ static void mtk_drm_crtc_atomic_disable(struct drm_crtc *crtc,
 
 	drm_crtc_vblank_off(crtc);
 	mtk_crtc_ddp_hw_fini(mtk_crtc);
-	mtk_smi_larb_put(comp->larb_dev);
 
 	mtk_crtc->enabled = false;
 }
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c
index bb55d1dc8746..6a66373df6e9 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c
+++ b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c
@@ -351,8 +351,6 @@ int mtk_ddp_comp_init(struct device *dev, struct device_node *node,
 		      const struct mtk_ddp_comp_funcs *funcs)
 {
 	enum mtk_ddp_comp_type type;
-	struct device_node *larb_node;
-	struct platform_device *larb_pdev;
 
 	if (comp_id < 0 || comp_id >= DDP_COMPONENT_ID_MAX)
 		return -EINVAL;
@@ -382,31 +380,6 @@ int mtk_ddp_comp_init(struct device *dev, struct device_node *node,
 	if (IS_ERR(comp->clk))
 		return PTR_ERR(comp->clk);
 
-	/* Only DMA capable components need the LARB property */
-	comp->larb_dev = NULL;
-	if (type != MTK_DISP_OVL &&
-	    type != MTK_DISP_OVL_2L &&
-	    type != MTK_DISP_RDMA &&
-	    type != MTK_DISP_WDMA)
-		return 0;
-
-	larb_node = of_parse_phandle(node, "mediatek,larb", 0);
-	if (!larb_node) {
-		dev_err(dev,
-			"Missing mediadek,larb phandle in %pOF node\n", node);
-		return -EINVAL;
-	}
-
-	larb_pdev = of_find_device_by_node(larb_node);
-	if (!larb_pdev) {
-		dev_warn(dev, "Waiting for larb device %pOF\n", larb_node);
-		of_node_put(larb_node);
-		return -EPROBE_DEFER;
-	}
-	of_node_put(larb_node);
-
-	comp->larb_dev = &larb_pdev->dev;
-
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h
index 6bf46d1f39b4..9e7969bc755f 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h
+++ b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h
@@ -101,7 +101,6 @@ struct mtk_ddp_comp {
 	struct clk *clk;
 	void __iomem *regs;
 	int irq;
-	struct device *larb_dev;
 	enum mtk_ddp_comp_id id;
 	const struct mtk_ddp_comp_funcs *funcs;
 };
diff --git a/drivers/gpu/drm/panel/panel-innolux-p079zca.c b/drivers/gpu/drm/panel/panel-innolux-p079zca.c
index 88c7d035ace6..f52c892323c3 100644
--- a/drivers/gpu/drm/panel/panel-innolux-p079zca.c
+++ b/drivers/gpu/drm/panel/panel-innolux-p079zca.c
@@ -56,7 +56,7 @@ struct innolux_panel {
 	struct backlight_device *backlight;
 	struct regulator_bulk_data *supplies;
 	unsigned int num_supplies;
-	struct gpio_desc *enable_gpio;
+	struct gpio_desc *enable_gpio[2];
 
 	bool prepared;
 	bool enabled;
@@ -84,7 +84,7 @@ static int innolux_panel_disable(struct drm_panel *panel)
 static int innolux_panel_unprepare(struct drm_panel *panel)
 {
 	struct innolux_panel *innolux = to_innolux_panel(panel);
-	int err;
+	int err, i;
 
 	if (!innolux->prepared)
 		return 0;
@@ -104,7 +104,8 @@ static int innolux_panel_unprepare(struct drm_panel *panel)
 	if (innolux->desc->sleep_mode_delay)
 		msleep(innolux->desc->sleep_mode_delay);
 
-	gpiod_set_value_cansleep(innolux->enable_gpio, 0);
+	for (i = 0; i < ARRAY_SIZE(innolux->enable_gpio); i++)
+		gpiod_set_value_cansleep(innolux->enable_gpio[i], 0);
 
 	if (innolux->desc->power_down_delay)
 		msleep(innolux->desc->power_down_delay);
@@ -122,22 +123,28 @@ static int innolux_panel_unprepare(struct drm_panel *panel)
 static int innolux_panel_prepare(struct drm_panel *panel)
 {
 	struct innolux_panel *innolux = to_innolux_panel(panel);
-	int err;
+	int err, i;
 
 	if (innolux->prepared)
 		return 0;
 
-	gpiod_set_value_cansleep(innolux->enable_gpio, 0);
+	for (i = 0; i < ARRAY_SIZE(innolux->enable_gpio); i++)
+		gpiod_set_value_cansleep(innolux->enable_gpio[i], 0);
 
 	err = regulator_bulk_enable(innolux->desc->num_supplies,
 				    innolux->supplies);
 	if (err < 0)
 		return err;
 
-	/* p079zca: t2 (20ms), p097pfg: t4 (15ms) */
-	usleep_range(20000, 21000);
+	for (i = 0; i < ARRAY_SIZE(innolux->enable_gpio); i++) {
+		if (!innolux->enable_gpio[i])
+			break;
 
-	gpiod_set_value_cansleep(innolux->enable_gpio, 1);
+		/* p079zca: t2 (20ms), p097pfg: t4 (15ms); ssd2858: 20ms */
+		usleep_range(20000, 21000);
+
+		gpiod_set_value_cansleep(innolux->enable_gpio[i], 1);
+	}
 
 	/* p079zca: t4, p097pfg: t5 */
 	usleep_range(20000, 21000);
@@ -158,6 +165,18 @@ static int innolux_panel_prepare(struct drm_panel *panel)
 				goto poweroff;
 			}
 
+			/*
+			 * If the command list contains exit sleep mode or set
+			 * display on, wait the appropriate time (needed for
+			 * displays behind a bridge).
+			 */
+			/* T6: 120ms - 1000ms*/
+			if (cmd->data[0] == MIPI_DCS_EXIT_SLEEP_MODE)
+				msleep(120);
+			/* T7: 5ms */
+			if (cmd->data[0] == MIPI_DCS_SET_DISPLAY_ON)
+				usleep_range(5000, 6000);
+
 			/*
 			 * Included by random guessing, because without this
 			 * (or at least, some delay), the panel sometimes
@@ -197,7 +216,8 @@ static int innolux_panel_prepare(struct drm_panel *panel)
 	return 0;
 
 poweroff:
-	gpiod_set_value_cansleep(innolux->enable_gpio, 0);
+	for (i = 0; i < ARRAY_SIZE(innolux->enable_gpio); i++)
+		gpiod_set_value_cansleep(innolux->enable_gpio[i], 0);
 	regulator_bulk_disable(innolux->desc->num_supplies, innolux->supplies);
 
 	return err;
@@ -405,6 +425,90 @@ static const struct panel_desc innolux_p097pfg_panel_desc = {
 	.sleep_mode_delay = 100, /* T15 */
 };
 
+static const char * const innolux_p097pfg_ssd2858_supply_names[] = {
+	"avdd",
+	"avee",
+	"pp1800",
+	"pp3300",
+	"pp1200-bridge",
+	"vddio-bridge",
+};
+
+static const struct drm_display_mode innolux_p097pfg_ssd2858_mode = {
+	.clock = 211660,
+	.hdisplay = 1536,
+	.hsync_start = 1536 + 140,
+	.hsync_end = 1536 + 140 + 10,
+	.htotal = 1536 + 140 + 10 + 10,
+	.vdisplay = 2048,
+	.vsync_start = 2048 + 20,
+	.vsync_end = 2048 + 20 + 2,
+	.vtotal = 2048 + 20 + 2 + 10,
+	.vrefresh = 60,
+};
+
+static const struct panel_init_cmd innolux_p097pfg_ssd2858_init_cmds[] = {
+	/* SSD2858 config */
+	_INIT_CMD(0xff, 0x00),
+	/* LOCKCNT=0x1f4, MRX=0, POSTDIV=1 (/2), MULT=0x49
+	 * 27 Mhz => 985.5 Mhz */
+	_INIT_CMD(0x00, 0x08, 0x01, 0xf4, 0x01, 0x49),
+	/* MTXDIV=1, SYSDIV=3 (=> 4) */
+	_INIT_CMD(0x00, 0x0c, 0x00, 0x00, 0x00, 0x03),
+	/* MTXVPF=24bpp, MRXLS=4 lanes, MRXVB=bypass, MRXECC=1, MRXEOT=1
+	 * MRXEE=1 */
+	_INIT_CMD(0x00, 0x14, 0x0c, 0x3d, 0x80, 0x0f),
+	_INIT_CMD(0x00, 0x20, 0x15, 0x92, 0x56, 0x7d),
+	_INIT_CMD(0x00, 0x24, 0x00, 0x00, 0x30, 0x00),
+
+	_INIT_CMD(0x10, 0x08, 0x01, 0x20, 0x08, 0x45),
+	_INIT_CMD(0x10, 0x1c, 0x00, 0x00, 0x00, 0x00),
+	_INIT_CMD(0x20, 0x0c, 0x00, 0x00, 0x00, 0x04),
+	/* Pixel clock 985.5 Mhz * 0x49/0x4b = 959 Mhz */
+	_INIT_CMD(0x20, 0x10, 0x00, 0x4b, 0x00, 0x49),
+	_INIT_CMD(0x20, 0xa0, 0x00, 0x00, 0x00, 0x00),
+	/* EOT=1, LPE = 0, LSOUT=4 lanes, LPD=25 */
+	_INIT_CMD(0x60, 0x08, 0x00, 0xd9, 0x00, 0x08),
+	_INIT_CMD(0x60, 0x14, 0x01, 0x00, 0x01, 0x06),
+	/* DSI0 enable (default: probably not needed) */
+	_INIT_CMD(0x60, 0x80, 0x00, 0x00, 0x00, 0x0f),
+	/* DSI1 enable */
+	_INIT_CMD(0x60, 0xa0, 0x00, 0x00, 0x00, 0x0f),
+
+	/* HSA=0x18, VSA=0x02, HBP=0x50, VBP=0x0c */
+	_INIT_CMD(0x60, 0x0c, 0x0c, 0x50, 0x02, 0x18),
+	/* VACT= 0x800 (2048), VFP= 0x14, HFP=0x50 */
+	_INIT_CMD(0x60, 0x10, 0x08, 0x00, 0x14, 0x50),
+	/* HACT=0x300 (768) */
+	_INIT_CMD(0x60, 0x84, 0x00, 0x00, 0x03, 0x00),
+	_INIT_CMD(0x60, 0xa4, 0x00, 0x00, 0x03, 0x00),
+
+	/* Take panel out of sleep. */
+	_INIT_CMD(0xff, 0x01),
+	_INIT_CMD(0x11),
+	_INIT_CMD(0x29),
+	_INIT_CMD(0xff, 0x00),
+
+	{},
+};
+
+static const struct panel_desc innolux_p097pfg_ssd2858_panel_desc = {
+	.mode = &innolux_p097pfg_ssd2858_mode,
+	.bpc = 8,
+	.size = {
+		.width = 147,
+		.height = 196,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+		 MIPI_DSI_MODE_LPM,
+	.format = MIPI_DSI_FMT_RGB888,
+	.init_cmds = innolux_p097pfg_ssd2858_init_cmds,
+	.lanes = 4,
+	.supply_names = innolux_p097pfg_ssd2858_supply_names,
+	.num_supplies = ARRAY_SIZE(innolux_p097pfg_ssd2858_supply_names),
+	.sleep_mode_delay = 100, /* T15 */
+};
+
 static int innolux_panel_get_modes(struct drm_panel *panel)
 {
 	struct innolux_panel *innolux = to_innolux_panel(panel);
@@ -446,6 +550,9 @@ static const struct of_device_id innolux_of_match[] = {
 	{ .compatible = "innolux,p097pfg",
 	  .data = &innolux_p097pfg_panel_desc
 	},
+	{ .compatible = "innolux,p097pfg_ssd2858",
+	  .data = &innolux_p097pfg_ssd2858_panel_desc
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(of, innolux_of_match);
@@ -477,12 +584,14 @@ static int innolux_panel_add(struct mipi_dsi_device *dsi,
 	if (err < 0)
 		return err;
 
-	innolux->enable_gpio = devm_gpiod_get_optional(dev, "enable",
-						       GPIOD_OUT_HIGH);
-	if (IS_ERR(innolux->enable_gpio)) {
-		err = PTR_ERR(innolux->enable_gpio);
-		dev_dbg(dev, "failed to get enable gpio: %d\n", err);
-		innolux->enable_gpio = NULL;
+	for (i = 0; i < ARRAY_SIZE(innolux->enable_gpio); i++) {
+		innolux->enable_gpio[i] = devm_gpiod_get_index_optional(dev,
+						"enable", i, GPIOD_OUT_HIGH);
+		if (IS_ERR(innolux->enable_gpio[i])) {
+			err = PTR_ERR(innolux->enable_gpio[i]);
+			dev_err(dev, "failed to get enable gpio: %d\n", err);
+			innolux->enable_gpio[i] = NULL;
+		}
 	}
 
 	innolux->backlight = devm_of_find_backlight(dev);
diff --git a/drivers/iio/adc/mt6577_auxadc.c b/drivers/iio/adc/mt6577_auxadc.c
index 95d76abb64ec..e30d9736b1a5 100644
--- a/drivers/iio/adc/mt6577_auxadc.c
+++ b/drivers/iio/adc/mt6577_auxadc.c
@@ -17,12 +17,14 @@
 #include <linux/err.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/nvmem-consumer.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/iopoll.h>
 #include <linux/io.h>
 #include <linux/iio/iio.h>
+#include <linux/slab.h>
 
 /* Register definitions */
 #define MT6577_AUXADC_CON0                    0x00
@@ -42,6 +44,13 @@
 #define MT6577_AUXADC_POWER_READY_MS          1
 #define MT6577_AUXADC_SAMPLE_READY_US         25
 
+#define ADC_GE_A_SHIFT      10
+#define ADC_GE_A_MASK       (0x3ff << ADC_GE_A_SHIFT)
+#define ADC_OE_A_SHIFT      0
+#define ADC_OE_A_MASK       (0x3ff << ADC_OE_A_SHIFT)
+#define ADC_CALI_EN_A_SHIFT 20
+#define ADC_CALI_EN_A_MASK  (0x1 << ADC_CALI_EN_A_SHIFT)
+
 struct mt6577_auxadc_device {
 	void __iomem *reg_base;
 	struct clk *adc_clk;
@@ -74,6 +83,64 @@ static const struct iio_chan_spec mt6577_auxadc_iio_channels[] = {
 	MT6577_AUXADC_CHANNEL(15),
 };
 
+s32 cali_oe;
+s32 cali_ge;
+struct adc_cali_info {
+	u32 cali_ge_a;
+	u32 cali_oe_a;
+	u32 gain;
+};
+static struct adc_cali_info adc_cali;
+
+static int mt6577_auxadc_update_cali(struct device *dev)
+{
+	struct nvmem_cell *cell;
+	u32 *buf;
+	size_t len;
+	int ret = 0;
+
+	cali_oe = 0;
+	cali_ge = 0;
+
+	cell = nvmem_cell_get(dev, "calibration-data");
+	if (IS_ERR(cell)) {
+		if (PTR_ERR(cell) == -EPROBE_DEFER)
+			return PTR_ERR(cell);
+		return 0;
+	}
+
+	buf = (u32 *)nvmem_cell_read(cell, &len);
+
+	nvmem_cell_put(cell);
+
+	if (IS_ERR(buf))
+		return PTR_ERR(buf);
+
+	if (len < sizeof(u32)) {
+		dev_warn(dev, "invalid calibration data\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (((buf[0] & ADC_CALI_EN_A_MASK) >> ADC_CALI_EN_A_SHIFT) != 0) {
+		adc_cali.cali_oe_a =
+			(buf[0] & ADC_OE_A_MASK) >> ADC_OE_A_SHIFT;
+		adc_cali.cali_ge_a =
+			((buf[0] & ADC_GE_A_MASK) >> ADC_GE_A_SHIFT);
+
+		cali_ge = adc_cali.cali_ge_a - 512;
+		cali_oe = adc_cali.cali_oe_a - 512;
+		adc_cali.gain = 1 + cali_ge;
+	}  else {
+		dev_info(dev, "Device not calibrated, using default calibration values\n");
+	}
+
+out:
+	kfree(buf);
+
+	return ret;
+}
+
 static inline void mt6577_auxadc_mod_reg(void __iomem *reg,
 					 u32 or_mask, u32 and_mask)
 {
@@ -274,6 +341,10 @@ static int mt6577_auxadc_probe(struct platform_device *pdev)
 		goto err_power_off;
 	}
 
+	ret = mt6577_auxadc_update_cali(&pdev->dev);
+	if (ret)
+		return ret;
+
 	return 0;
 
 err_power_off:
diff --git a/drivers/iommu/mtk_iommu.c b/drivers/iommu/mtk_iommu.c
index 803084c86124..aaaee91c528c 100644
--- a/drivers/iommu/mtk_iommu.c
+++ b/drivers/iommu/mtk_iommu.c
@@ -175,8 +175,7 @@ static void mtk_iommu_tlb_add_flush_nosync(unsigned long iova, size_t size,
 		writel_relaxed(iova, data->base + REG_MMU_INVLD_START_A);
 		writel_relaxed(iova + size - 1,
 			       data->base + REG_MMU_INVLD_END_A);
-		writel_relaxed(F_MMU_INV_RANGE,
-			       data->base + REG_MMU_INVALIDATE);
+		writel(F_MMU_INV_RANGE, data->base + REG_MMU_INVALIDATE);
 		data->tlb_flush_active = true;
 	}
 }
@@ -262,6 +261,7 @@ static void mtk_iommu_config(struct mtk_iommu_data *data,
 	struct mtk_smi_larb_iommu    *larb_mmu;
 	unsigned int                 larbid, portid;
 	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+	struct device_link *link;
 	int i;
 
 	for (i = 0; i < fwspec->num_ids; ++i) {
@@ -272,10 +272,20 @@ static void mtk_iommu_config(struct mtk_iommu_data *data,
 		dev_dbg(dev, "%s iommu port: %d\n",
 			enable ? "enable" : "disable", portid);
 
-		if (enable)
+		if (enable) {
 			larb_mmu->mmu |= MTK_SMI_MMU_EN(portid);
-		else
+			/* Link the consumer with the larb device(supplier) */
+			link = device_link_add(dev, larb_mmu->dev,
+					       DL_FLAG_PM_RUNTIME |
+					       DL_FLAG_AUTOREMOVE_CONSUMER);
+			if (!link) {
+				dev_err(dev, "Unable to link %s\n",
+					dev_name(larb_mmu->dev));
+				return;
+			}
+		} else {
 			larb_mmu->mmu &= ~MTK_SMI_MMU_EN(portid);
+		}
 	}
 }
 
@@ -662,7 +672,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 			id = i;
 
 		plarbdev = of_find_device_by_node(larbnode);
-		if (!plarbdev)
+		if (!plarbdev || !plarbdev->dev.driver)
 			return -EPROBE_DEFER;
 		data->smi_imu.larb_imu[id].dev = &plarbdev->dev;
 
@@ -696,7 +706,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 	return component_master_add_with_match(dev, &mtk_iommu_com_ops, match);
 }
 
-static int mtk_iommu_remove(struct platform_device *pdev)
+static void mtk_iommu_shutdown(struct platform_device *pdev)
 {
 	struct mtk_iommu_data *data = platform_get_drvdata(pdev);
 
@@ -709,12 +719,6 @@ static int mtk_iommu_remove(struct platform_device *pdev)
 	clk_disable_unprepare(data->bclk);
 	devm_free_irq(&pdev->dev, data->irq, data);
 	component_master_del(&pdev->dev, &mtk_iommu_com_ops);
-	return 0;
-}
-
-static void mtk_iommu_shutdown(struct platform_device *pdev)
-{
-	mtk_iommu_remove(pdev);
 }
 
 static int __maybe_unused mtk_iommu_suspend(struct device *dev)
@@ -797,7 +801,6 @@ static const struct of_device_id mtk_iommu_of_ids[] = {
 
 static struct platform_driver mtk_iommu_driver = {
 	.probe	= mtk_iommu_probe,
-	.remove	= mtk_iommu_remove,
 	.shutdown = mtk_iommu_shutdown,
 	.driver	= {
 		.name = "mtk-iommu",
@@ -805,16 +808,4 @@ static struct platform_driver mtk_iommu_driver = {
 		.pm = &mtk_iommu_pm_ops,
 	}
 };
-
-static int __init mtk_iommu_init(void)
-{
-	int ret;
-
-	ret = platform_driver_register(&mtk_iommu_driver);
-	if (ret != 0)
-		pr_err("Failed to register MTK IOMMU driver\n");
-
-	return ret;
-}
-
-subsys_initcall(mtk_iommu_init)
+builtin_platform_driver(mtk_iommu_driver);
diff --git a/drivers/iommu/mtk_iommu_v1.c b/drivers/iommu/mtk_iommu_v1.c
index d70bdf64ab71..832ea99f7a16 100644
--- a/drivers/iommu/mtk_iommu_v1.c
+++ b/drivers/iommu/mtk_iommu_v1.c
@@ -201,6 +201,7 @@ static void mtk_iommu_config(struct mtk_iommu_data *data,
 	struct mtk_smi_larb_iommu    *larb_mmu;
 	unsigned int                 larbid, portid;
 	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+	struct device_link *link;
 	int i;
 
 	for (i = 0; i < fwspec->num_ids; ++i) {
@@ -211,10 +212,19 @@ static void mtk_iommu_config(struct mtk_iommu_data *data,
 		dev_dbg(dev, "%s iommu port: %d\n",
 			enable ? "enable" : "disable", portid);
 
-		if (enable)
+		if (enable) {
 			larb_mmu->mmu |= MTK_SMI_MMU_EN(portid);
-		else
+			link = device_link_add(dev, larb_mmu->dev,
+					       DL_FLAG_PM_RUNTIME |
+					       DL_FLAG_AUTOREMOVE_CONSUMER);
+			if (!link) {
+				dev_err(dev, "Unable to link %s\n",
+					dev_name(larb_mmu->dev));
+				return;
+			}
+		} else {
 			larb_mmu->mmu &= ~MTK_SMI_MMU_EN(portid);
+		}
 	}
 }
 
@@ -601,7 +611,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 			plarbdev = of_platform_device_create(
 						larb_spec.np, NULL,
 						platform_bus_type.dev_root);
-			if (!plarbdev) {
+			if (!plarbdev || !plarbdev->dev.driver) {
 				of_node_put(larb_spec.np);
 				return -EPROBE_DEFER;
 			}
@@ -636,7 +646,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 	return component_master_add_with_match(dev, &mtk_iommu_com_ops, match);
 }
 
-static int mtk_iommu_remove(struct platform_device *pdev)
+static void mtk_iommu_shutdown(struct platform_device *pdev)
 {
 	struct mtk_iommu_data *data = platform_get_drvdata(pdev);
 
@@ -649,12 +659,6 @@ static int mtk_iommu_remove(struct platform_device *pdev)
 	clk_disable_unprepare(data->bclk);
 	devm_free_irq(&pdev->dev, data->irq, data);
 	component_master_del(&pdev->dev, &mtk_iommu_com_ops);
-	return 0;
-}
-
-static void mtk_iommu_shutdown(struct platform_device *pdev)
-{
-	mtk_iommu_remove(pdev);
 }
 
 static int __maybe_unused mtk_iommu_suspend(struct device *dev)
@@ -693,7 +697,6 @@ static const struct dev_pm_ops mtk_iommu_pm_ops = {
 
 static struct platform_driver mtk_iommu_driver = {
 	.probe	= mtk_iommu_probe,
-	.remove	= mtk_iommu_remove,
 	.shutdown = mtk_iommu_shutdown,
 	.driver	= {
 		.name = "mtk-iommu-v1",
@@ -701,9 +704,4 @@ static struct platform_driver mtk_iommu_driver = {
 		.pm = &mtk_iommu_pm_ops,
 	}
 };
-
-static int __init m4u_init(void)
-{
-	return platform_driver_register(&mtk_iommu_driver);
-}
-subsys_initcall(m4u_init);
+builtin_platform_driver(mtk_iommu_driver);
diff --git a/drivers/mailbox/Kconfig b/drivers/mailbox/Kconfig
index 841c005d8ebb..31dc4c5e37e1 100644
--- a/drivers/mailbox/Kconfig
+++ b/drivers/mailbox/Kconfig
@@ -205,4 +205,22 @@ config MTK_CMDQ_MBOX
 	  mailbox driver. The CMDQ is used to help read/write registers with
 	  critical time limitation, such as updating display configuration
 	  during the vblank.
+
+config MTK_CMDQ_DEBUG
+	tristate "MediaTek CMDQ Mailbox Debug"
+	depends on MTK_CMDQ_MBOX
+	help
+	  Say yes here to add support for debugging CMDQ driver when timeout
+	  or irq status error happens. It will print some useful information
+	  for location problem, such as thread id, PC value and instructions
+	  of command queue buffer.
+
+config MTK_CMDQ_DEBUG_SOC
+	int "MediaTek CMDQ Mailbox Debug SOC"
+	depends on MTK_CMDQ_DEBUG
+	help
+	  Enter the SOC id that you want to debug CMDQ driver when timeout
+	  or irq status error happens.
+	  The SOC id is a decimal integer, e.g. 8173 for MT8173 SOC.
+	  You must enter the id.
 endif
diff --git a/drivers/mailbox/Makefile b/drivers/mailbox/Makefile
index c818b5d011ae..b356e36d8f2a 100644
--- a/drivers/mailbox/Makefile
+++ b/drivers/mailbox/Makefile
@@ -44,3 +44,4 @@ obj-$(CONFIG_TEGRA_HSP_MBOX)	+= tegra-hsp.o
 obj-$(CONFIG_STM32_IPCC) 	+= stm32-ipcc.o
 
 obj-$(CONFIG_MTK_CMDQ_MBOX)	+= mtk-cmdq-mailbox.o
+obj-$(CONFIG_MTK_CMDQ_DEBUG)	+= mtk-cmdq-debug.o
diff --git a/drivers/mailbox/mtk-cmdq-debug.c b/drivers/mailbox/mtk-cmdq-debug.c
new file mode 100644
index 000000000000..61985342d564
--- /dev/null
+++ b/drivers/mailbox/mtk-cmdq-debug.c
@@ -0,0 +1,582 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2018 MediaTek Inc.
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mailbox/mtk-cmdq-mailbox.h>
+#include <linux/workqueue.h>
+#include "mtk-cmdq-debug.h"
+#if CONFIG_MTK_CMDQ_DEBUG_SOC == 8173
+#include <dt-bindings/gce/mt8173-gce.h>
+#elif CONFIG_MTK_CMDQ_DEBUG_SOC == 8183
+#include <dt-bindings/gce/mt8183-gce.h>
+#else
+static int __error__[-1]; /* Complle error if SOC is not set. */
+#endif
+
+#define CMDQ_OP_CODE_MASK			(0xff << CMDQ_OP_CODE_SHIFT)
+#define CMDQ_NUM_CMD(t)				(t->cmd_buf_size / CMDQ_INST_SIZE)
+#define CMDQ_GET_32B_VALUE(arg_b, arg_c)	((u32)((arg_b) << 16) | (arg_c))
+#define CMDQ_REG_IDX_PREFIX(type)		((type) ? "" : "Reg Index ")
+
+struct cmdq_instruction {
+	s16 arg_c:16;
+	s16 arg_b:16;
+	s16 arg_a:16;
+	u8 s_op:5;
+	u8 arg_c_type:1;
+	u8 arg_b_type:1;
+	u8 arg_a_type:1;
+	u8 op:8;
+};
+
+void cmdq_buf_print_write(struct device *dev, u32 offset,
+			  struct cmdq_instruction *cmdq_inst)
+{
+	u32 addr = ((u32)(cmdq_inst->arg_a |
+		    (cmdq_inst->s_op << CMDQ_SUBSYS_SHIFT)));
+
+	dev_err(dev, "0x%08x [Write | Store] %s0x%08x = %s0x%08x\n",
+		offset, cmdq_inst->arg_a_type ? "*Reg Index " : "SubSys Reg ",
+		addr, CMDQ_REG_IDX_PREFIX(!cmdq_inst->arg_b_type),
+		cmdq_inst->arg_b_type ? cmdq_inst->arg_b :
+		CMDQ_GET_32B_VALUE(cmdq_inst->arg_b, cmdq_inst->arg_c));
+}
+
+static void cmdq_buf_print_wfe(struct device *dev, u32 offset,
+			       struct cmdq_instruction *cmdq_inst)
+{
+	const char *event_str;
+	u32 cmd = CMDQ_GET_32B_VALUE(cmdq_inst->arg_b, cmdq_inst->arg_c);
+
+	switch (cmdq_inst->arg_a) {
+#if CONFIG_MTK_CMDQ_DEBUG_SOC == 8173
+	case CMDQ_EVENT_DISP_OVL0_SOF:
+		event_str = "CMDQ_EVENT_DISP_OVL0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_OVL1_SOF:
+		event_str = "CMDQ_EVENT_DISP_OVL1_SOF";
+		break;
+	case CMDQ_EVENT_DISP_RDMA0_SOF:
+		event_str = "CMDQ_EVENT_DISP_RDMA0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_RDMA1_SOF:
+		event_str = "CMDQ_EVENT_DISP_RDMA1_SOF";
+		break;
+	case CMDQ_EVENT_DISP_RDMA2_SOF:
+		event_str = "CMDQ_EVENT_DISP_RDMA2_SOF";
+		break;
+	case CMDQ_EVENT_DISP_WDMA0_SOF:
+		event_str = "CMDQ_EVENT_DISP_WDMA0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_WDMA1_SOF:
+		event_str = "CMDQ_EVENT_DISP_WDMA1_SOF";
+		break;
+	case CMDQ_EVENT_DISP_OVL0_EOF:
+		event_str = "CMDQ_EVENT_DISP_OVL0_EOF";
+		break;
+	case CMDQ_EVENT_DISP_OVL1_EOF:
+		event_str = "CMDQ_EVENT_DISP_OVL1_EOF";
+		break;
+	case CMDQ_EVENT_DISP_RDMA0_EOF:
+		event_str = "CMDQ_EVENT_DISP_RDMA0_EOF";
+		break;
+	case CMDQ_EVENT_DISP_RDMA1_EOF:
+		event_str = "CMDQ_EVENT_DISP_RDMA1_EOF";
+		break;
+	case CMDQ_EVENT_DISP_RDMA2_EOF:
+		event_str = "CMDQ_EVENT_DISP_RDMA2_EOF";
+		break;
+	case CMDQ_EVENT_DISP_WDMA0_EOF:
+		event_str = "CMDQ_EVENT_DISP_WDMA0_EOF";
+		break;
+	case CMDQ_EVENT_DISP_WDMA1_EOF:
+		event_str = "CMDQ_EVENT_DISP_WDMA1_EOF";
+		break;
+	case CMDQ_EVENT_MUTEX0_STREAM_EOF:
+		event_str = "CMDQ_EVENT_MUTEX0_STREAM_EOF";
+		break;
+	case CMDQ_EVENT_MUTEX1_STREAM_EOF:
+		event_str = "CMDQ_EVENT_MUTEX1_STREAM_EOF";
+		break;
+	case CMDQ_EVENT_MUTEX2_STREAM_EOF:
+		event_str = "CMDQ_EVENT_MUTEX2_STREAM_EOF";
+		break;
+	case CMDQ_EVENT_MUTEX3_STREAM_EOF:
+		event_str = "CMDQ_EVENT_MUTEX3_STREAM_EOF";
+		break;
+	case CMDQ_EVENT_MUTEX4_STREAM_EOF:
+		event_str = "CMDQ_EVENT_MUTEX4_STREAM_EOF";
+		break;
+	case CMDQ_EVENT_DISP_RDMA0_UNDERRUN:
+		event_str = "CMDQ_EVENT_DISP_RDMA0_UNDERRUN";
+		break;
+	case CMDQ_EVENT_DISP_RDMA1_UNDERRUN:
+		event_str = "CMDQ_EVENT_DISP_RDMA1_UNDERRUN";
+		break;
+	case CMDQ_EVENT_DISP_RDMA2_UNDERRUN:
+		event_str = "CMDQ_EVENT_DISP_RDMA2_UNDERRUN";
+		break;
+#elif CONFIG_MTK_CMDQ_DEBUG_SOC == 8183
+	case CMDQ_EVENT_DISP_RDMA0_SOF:
+		event_str = "CMDQ_EVENT_DISP_RDMA0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_RDMA1_SOF:
+		event_str = "CMDQ_EVENT_DISP_RDMA1_SOF";
+		break;
+	case CMDQ_EVENT_MDP_RDMA0_SOF:
+		event_str = "CMDQ_EVENT_MDP_RDMA0_SOF";
+		break;
+	case CMDQ_EVENT_MDP_RSZ0_SOF:
+		event_str = "CMDQ_EVENT_MDP_RSZ0_SOF";
+		break;
+	case CMDQ_EVENT_MDP_RSZ1_SOF:
+		event_str = "CMDQ_EVENT_MDP_RSZ1_SOF";
+		break;
+	case CMDQ_EVENT_MDP_TDSHP_SOF:
+		event_str = "CMDQ_EVENT_MDP_TDSHP_SOF";
+		break;
+	case CMDQ_EVENT_MDP_WROT0_SOF:
+		event_str = "CMDQ_EVENT_MDP_WROT0_SOF";
+		break;
+	case CMDQ_EVENT_MDP_WDMA0_SOF:
+		event_str = "CMDQ_EVENT_MDP_WDMA0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_OVL0_SOF:
+		event_str = "CMDQ_EVENT_DISP_OVL0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_OVL0_2L_SOF:
+		event_str = "CMDQ_EVENT_DISP_OVL0_2L_SOF";
+		break;
+	case CMDQ_EVENT_DISP_OVL1_2L_SOF:
+		event_str = "CMDQ_EVENT_DISP_OVL1_2L_SOF";
+		break;
+	case CMDQ_EVENT_DISP_WDMA0_SOF:
+		event_str = "CMDQ_EVENT_DISP_WDMA0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_COLOR0_SOF:
+		event_str = "CMDQ_EVENT_DISP_COLOR0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_CCORR0_SOF:
+		event_str = "CMDQ_EVENT_DISP_CCORR0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_AAL0_SOF:
+		event_str = "CMDQ_EVENT_DISP_AAL0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_GAMMA0_SOF:
+		event_str = "CMDQ_EVENT_DISP_GAMMA0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_DITHER0_SOF:
+		event_str = "CMDQ_EVENT_DISP_DITHER0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_PWM0_SOF:
+		event_str = "CMDQ_EVENT_DISP_PWM0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_DSI0_SOF:
+		event_str = "CMDQ_EVENT_DISP_DSI0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_DPI0_SOF:
+		event_str = "CMDQ_EVENT_DISP_DPI0_SOF";
+		break;
+	case CMDQ_EVENT_DISP_RSZ_SOF:
+		event_str = "CMDQ_EVENT_DISP_RSZ_SOF";
+		break;
+	case CMDQ_EVENT_MDP_AAL_SOF:
+		event_str = "CMDQ_EVENT_MDP_AAL_SOF";
+		break;
+	case CMDQ_EVENT_MDP_CCORR_SOF:
+		event_str = "CMDQ_EVENT_MDP_CCORR_SOF";
+		break;
+	case CMDQ_EVENT_DISP_DBI_SOF:
+		event_str = "CMDQ_EVENT_DISP_DBI_SOF";
+		break;
+	case CMDQ_EVENT_DISP_RDMA0_EOF:
+		event_str = "CMDQ_EVENT_DISP_RDMA0_EOF";
+		break;
+	case CMDQ_EVENT_DISP_RDMA1_EOF:
+		event_str = "CMDQ_EVENT_DISP_RDMA1_EOF";
+		break;
+	case CMDQ_EVENT_MDP_RDMA0_EOF:
+		event_str = "CMDQ_EVENT_MDP_RDMA0_EOF";
+		break;
+	case CMDQ_EVENT_MDP_RSZ0_EOF:
+		event_str = "CMDQ_EVENT_MDP_RSZ0_EOF";
+		break;
+	case CMDQ_EVENT_MDP_RSZ1_EOF:
+		event_str = "CMDQ_EVENT_MDP_RSZ1_EOF";
+		break;
+	case CMDQ_EVENT_MDP_TDSHP_EOF:
+		event_str = "CMDQ_EVENT_MDP_TDSHP_EOF";
+		break;
+	case CMDQ_EVENT_MDP_WROT0_EOF:
+		event_str = "CMDQ_EVENT_MDP_WROT0_EOF";
+		break;
+	case CMDQ_EVENT_MDP_WDMA0_EOF:
+		event_str = "CMDQ_EVENT_MDP_WDMA0_EOF";
+		break;
+	case CMDQ_EVENT_DISP_OVL0_EOF:
+		event_str = "CMDQ_EVENT_DISP_OVL0_EOF";
+		break;
+	case CMDQ_EVENT_DISP_OVL0_2L_EOF:
+		event_str = "CMDQ_EVENT_DISP_OVL0_2L_EOF";
+		break;
+	case CMDQ_EVENT_DISP_OVL1_2L_EOF:
+		event_str = "CMDQ_EVENT_DISP_OVL1_2L_EOF";
+		break;
+	case CMDQ_EVENT_DISP_WDMA0_EOF:
+		event_str = "CMDQ_EVENT_DISP_WDMA0_EOF";
+		break;
+	case CMDQ_EVENT_DISP_COLOR0_EOF:
+		event_str = "CMDQ_EVENT_DISP_COLOR0_EOF";
+		break;
+	case CMDQ_EVENT_DISP_CCORR0_EOF:
+		event_str = "CMDQ_EVENT_DISP_CCORR0_EOF";
+		break;
+	case CMDQ_EVENT_DISP_AAL0_EOF:
+		event_str = "CMDQ_EVENT_DISP_AAL0_EOF";
+		break;
+	case CMDQ_EVENT_DISP_GAMMA0_EOF:
+		event_str = "CMDQ_EVENT_DISP_GAMMA0_EOF";
+		break;
+	case CMDQ_EVENT_DISP_DITHER0_EOF:
+		event_str = "CMDQ_EVENT_DISP_DITHER0_EOF";
+		break;
+	case CMDQ_EVENT_DSI0_EOF:
+		event_str = "CMDQ_EVENT_DSI0_EOF";
+		break;
+	case CMDQ_EVENT_DPI0_EOF:
+		event_str = "CMDQ_EVENT_DPI0_EOF";
+		break;
+	case CMDQ_EVENT_DISP_RSZ_EOF:
+		event_str = "CMDQ_EVENT_DISP_RSZ_EOF";
+		break;
+	case CMDQ_EVENT_MDP_AAL_EOF:
+		event_str = "CMDQ_EVENT_MDP_AAL_EOF";
+		break;
+	case CMDQ_EVENT_MDP_CCORR_EOF:
+		event_str = "CMDQ_EVENT_MDP_CCORR_EOF";
+		break;
+	case CMDQ_EVENT_DBI_EOF:
+		event_str = "CMDQ_EVENT_DBI_EOF";
+		break;
+	case CMDQ_EVENT_MUTEX_STREAM_DONE0:
+		event_str = "CMDQ_EVENT_MUTEX_STREAM_DONE0";
+		break;
+	case CMDQ_EVENT_MUTEX_STREAM_DONE1:
+		event_str = "CMDQ_EVENT_MUTEX_STREAM_DONE1";
+		break;
+	case CMDQ_EVENT_MUTEX_STREAM_DONE2:
+		event_str = "CMDQ_EVENT_MUTEX_STREAM_DONE2";
+		break;
+	case CMDQ_EVENT_MUTEX_STREAM_DONE3:
+		event_str = "CMDQ_EVENT_MUTEX_STREAM_DONE3";
+		break;
+	case CMDQ_EVENT_MUTEX_STREAM_DONE4:
+		event_str = "CMDQ_EVENT_MUTEX_STREAM_DONE4";
+		break;
+	case CMDQ_EVENT_MUTEX_STREAM_DONE5:
+		event_str = "CMDQ_EVENT_MUTEX_STREAM_DONE5";
+		break;
+	case CMDQ_EVENT_MUTEX_STREAM_DONE6:
+		event_str = "CMDQ_EVENT_MUTEX_STREAM_DONE6";
+		break;
+	case CMDQ_EVENT_MUTEX_STREAM_DONE7:
+		event_str = "CMDQ_EVENT_MUTEX_STREAM_DONE7";
+		break;
+	case CMDQ_EVENT_MUTEX_STREAM_DONE8:
+		event_str = "CMDQ_EVENT_MUTEX_STREAM_DONE8";
+		break;
+	case CMDQ_EVENT_MUTEX_STREAM_DONE9:
+		event_str = "CMDQ_EVENT_MUTEX_STREAM_DONE9";
+		break;
+	case CMDQ_EVENT_MUTEX_STREAM_DONE10:
+		event_str = "CMDQ_EVENT_MUTEX_STREAM_DONE10";
+		break;
+	case CMDQ_EVENT_MUTEX_STREAM_DONE11:
+		event_str = "CMDQ_EVENT_MUTEX_STREAM_DONE11";
+		break;
+	case CMDQ_EVENT_DISP_RDMA0_BUF_UNDERRUN_EVEN:
+		event_str = "CMDQ_EVENT_DISP_RDMA0_BUF_UNDERRUN_EVEN";
+		break;
+	case CMDQ_EVENT_DISP_RDMA1_BUF_UNDERRUN_EVEN:
+		event_str = "CMDQ_EVENT_DISP_RDMA1_BUF_UNDERRUN_EVEN";
+		break;
+	case CMDQ_EVENT_DSI0_TE_EVENT:
+		event_str = "CMDQ_EVENT_DSI0_TE_EVENT";
+		break;
+	case CMDQ_EVENT_DSI0_IRQ_EVENT:
+		event_str = "CMDQ_EVENT_DSI0_IRQ_EVENT";
+		break;
+	case CMDQ_EVENT_DSI0_DONE_EVENT:
+		event_str = "CMDQ_EVENT_DSI0_DONE_EVENT";
+		break;
+	case CMDQ_EVENT_DISP_WDMA0_SW_RST_DONE:
+		event_str = "CMDQ_EVENT_DISP_WDMA0_SW_RST_DONE";
+		break;
+	case CMDQ_EVENT_MDP_WDMA_SW_RST_DONE:
+		event_str = "CMDQ_EVENT_MDP_WDMA_SW_RST_DONE";
+		break;
+	case CMDQ_EVENT_MDP_WROT0_SW_RST_DONE:
+		event_str = "CMDQ_EVENT_MDP_WROT0_SW_RST_DONE";
+		break;
+	case CMDQ_EVENT_MDP_RDMA0_SW_RST_DONE:
+		event_str = "CMDQ_EVENT_MDP_RDMA0_SW_RST_DONE";
+		break;
+	case CMDQ_EVENT_DISP_OVL0_FRAME_RST_DONE_PULE:
+		event_str = "CMDQ_EVENT_DISP_OVL0_FRAME_RST_DONE_PULE";
+		break;
+	case CMDQ_EVENT_DISP_OVL0_2L_FRAME_RST_DONE_ULSE:
+		event_str = "CMDQ_EVENT_DISP_OVL0_2L_FRAME_RST_DONE_ULSE";
+		break;
+	case CMDQ_EVENT_DISP_OVL1_2L_FRAME_RST_DONE_ULSE:
+		event_str = "CMDQ_EVENT_DISP_OVL1_2L_FRAME_RST_DONE_ULSE";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_0:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_0";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_1:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_1";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_2:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_2";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_3:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_3";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_4:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_4";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_5:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_5";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_6:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_6";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_7:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_7";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_8:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_8";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_9:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_9";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_10:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_10";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_11:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_11";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_12:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_12";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_13:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_13";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_14:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_14";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_15:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_15";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_16:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_16";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_17:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_17";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_P2_18:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_P2_18";
+		break;
+	case CMDQ_EVENT_AMD_FRAME_DONE:
+		event_str = "CMDQ_EVENT_AMD_FRAME_DONE";
+		break;
+	case CMDQ_EVENT_DVE_DONE:
+		event_str = "CMDQ_EVENT_DVE_DONE";
+		break;
+	case CMDQ_EVENT_WMFE_DONE:
+		event_str = "CMDQ_EVENT_WMFE_DONE";
+		break;
+	case CMDQ_EVENT_RSC_DONE:
+		event_str = "CMDQ_EVENT_RSC_DONE";
+		break;
+	case CMDQ_EVENT_MFB_DONE:
+		event_str = "CMDQ_EVENT_MFB_DONE";
+		break;
+	case CMDQ_EVENT_WPE_A_DONE:
+		event_str = "CMDQ_EVENT_WPE_A_DONE";
+		break;
+	case CMDQ_EVENT_SPE_B_DONE:
+		event_str = "CMDQ_EVENT_SPE_B_DONE";
+		break;
+	case CMDQ_EVENT_OCC_DONE:
+		event_str = "CMDQ_EVENT_OCC_DONE";
+		break;
+	case CMDQ_EVENT_VENC_CMDQ_FRAME_DONE:
+		event_str = "CMDQ_EVENT_VENC_CMDQ_FRAME_DONE";
+		break;
+	case CMDQ_EVENT_JPG_ENC_CMDQ_DONE:
+		event_str = "CMDQ_EVENT_JPG_ENC_CMDQ_DONE";
+		break;
+	case CMDQ_EVENT_JPG_DEC_CMDQ_DONE:
+		event_str = "CMDQ_EVENT_JPG_DEC_CMDQ_DONE";
+		break;
+	case CMDQ_EVENT_VENC_CMDQ_MB_DONE:
+		event_str = "CMDQ_EVENT_VENC_CMDQ_MB_DONE";
+		break;
+	case CMDQ_EVENT_VENC_CMDQ_128BYTE_DONE:
+		event_str = "CMDQ_EVENT_VENC_CMDQ_128BYTE_DONE";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_A:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_A";
+		break;
+	case CMDQ_EVENT_ISP_FRAME_DONE_B:
+		event_str = "CMDQ_EVENT_ISP_FRAME_DONE_B";
+		break;
+	case CMDQ_EVENT_CAMSV0_PASS1_DONE:
+		event_str = "CMDQ_EVENT_CAMSV0_PASS1_DONE";
+		break;
+	case CMDQ_EVENT_CAMSV1_PASS1_DONE:
+		event_str = "CMDQ_EVENT_CAMSV1_PASS1_DONE";
+		break;
+	case CMDQ_EVENT_CAMSV2_PASS1_DONE:
+		event_str = "CMDQ_EVENT_CAMSV2_PASS1_DONE";
+		break;
+	case CMDQ_EVENT_TSF_DONE:
+		event_str = "CMDQ_EVENT_TSF_DONE";
+		break;
+	case CMDQ_EVENT_SENINF_CAM0_FIFO_FULL:
+		event_str = "CMDQ_EVENT_SENINF_CAM0_FIFO_FULL";
+		break;
+	case CMDQ_EVENT_SENINF_CAM1_FIFO_FULL:
+		event_str = "CMDQ_EVENT_SENINF_CAM1_FIFO_FULL";
+		break;
+	case CMDQ_EVENT_SENINF_CAM2_FIFO_FULL:
+		event_str = "CMDQ_EVENT_SENINF_CAM2_FIFO_FULL";
+		break;
+	case CMDQ_EVENT_SENINF_CAM3_FIFO_FULL:
+		event_str = "CMDQ_EVENT_SENINF_CAM3_FIFO_FULL";
+		break;
+	case CMDQ_EVENT_SENINF_CAM4_FIFO_FULL:
+		event_str = "CMDQ_EVENT_SENINF_CAM4_FIFO_FULL";
+		break;
+	case CMDQ_EVENT_SENINF_CAM5_FIFO_FULL:
+		event_str = "CMDQ_EVENT_SENINF_CAM5_FIFO_FULL";
+		break;
+	case CMDQ_EVENT_SENINF_CAM6_FIFO_FULL:
+		event_str = "CMDQ_EVENT_SENINF_CAM6_FIFO_FULL";
+		break;
+	case CMDQ_EVENT_SENINF_CAM7_FIFO_FULL:
+		event_str = "CMDQ_EVENT_SENINF_CAM7_FIFO_FULL";
+		break;
+	case CMDQ_EVENT_IPU_CORE0_DONE0:
+		event_str = "CMDQ_EVENT_IPU_CORE0_DONE0";
+		break;
+	case CMDQ_EVENT_IPU_CORE0_DONE1:
+		event_str = "CMDQ_EVENT_IPU_CORE0_DONE1";
+		break;
+	case CMDQ_EVENT_IPU_CORE0_DONE2:
+		event_str = "CMDQ_EVENT_IPU_CORE0_DONE2";
+		break;
+	case CMDQ_EVENT_IPU_CORE0_DONE3:
+		event_str = "CMDQ_EVENT_IPU_CORE0_DONE3";
+		break;
+	case CMDQ_EVENT_IPU_CORE1_DONE0:
+		event_str = "CMDQ_EVENT_IPU_CORE1_DONE0";
+		break;
+	case CMDQ_EVENT_IPU_CORE1_DONE1:
+		event_str = "CMDQ_EVENT_IPU_CORE1_DONE1";
+		break;
+	case CMDQ_EVENT_IPU_CORE1_DONE2:
+		event_str = "CMDQ_EVENT_IPU_CORE1_DONE2";
+		break;
+	case CMDQ_EVENT_IPU_CORE1_DONE3:
+		event_str = "CMDQ_EVENT_IPU_CORE1_DONE3";
+		break;
+#endif
+
+	default:
+		event_str = "UNKNOWN";
+		break;
+	}
+
+	dev_err(dev, "0x%08x %s event %u\n", offset,
+		(cmd && CMDQ_WFE_OPTION) ? "wait for" : "clear",
+		cmdq_inst->arg_a);
+}
+
+void cmdq_buf_print_mask(struct device *dev, u32 offset,
+			 struct cmdq_instruction *cmdq_inst)
+{
+	u32 mask = CMDQ_GET_32B_VALUE(cmdq_inst->arg_b, cmdq_inst->arg_c);
+
+	dev_err(dev, "0x%08x mask 0x%08x\n", offset, ~mask);
+}
+
+void cmdq_buf_print_misc(struct device *dev, u32 offset,
+			 struct cmdq_instruction *cmdq_inst)
+{
+	char *cmd_str;
+
+	switch (cmdq_inst->op) {
+	case CMDQ_CODE_JUMP:
+		cmd_str = "jump";
+		break;
+	case CMDQ_CODE_EOC:
+		cmd_str = "eoc";
+		break;
+	case CMDQ_CODE_POLL:
+		cmd_str = "polling";
+		break;
+	default:
+		cmd_str = "unknown";
+		break;
+	}
+
+	dev_err(dev, "0x%08x %s\n", offset, cmd_str);
+}
+
+void cmdq_debug_buf_dump_work(struct work_struct *work_item)
+{
+	struct cmdq_buf_dump *buf_dump = container_of(work_item,
+			struct cmdq_buf_dump, dump_work);
+	struct device *dev = buf_dump->dev;
+	struct cmdq_instruction *cmdq_inst =
+		(struct cmdq_instruction *)buf_dump->cmd_buf;
+	u32 i, offset = 0;
+
+	dev_err(dev, "dump %s task start ----------\n",
+		buf_dump->timeout ? "timeout" : "error");
+	for (i = 0; i < CMDQ_NUM_CMD(buf_dump); i++) {
+		if (offset == buf_dump->pa_offset)
+			dev_err(dev,
+				"\e[1;31;40m==========ERROR==========\e[0m\n");
+		switch (cmdq_inst[i].op) {
+		case CMDQ_CODE_WRITE:
+			cmdq_buf_print_write(dev, offset, &cmdq_inst[i]);
+			break;
+		case CMDQ_CODE_WFE:
+			cmdq_buf_print_wfe(dev, offset, &cmdq_inst[i]);
+			break;
+		case CMDQ_CODE_MASK:
+			cmdq_buf_print_mask(dev, offset, &cmdq_inst[i]);
+			break;
+		default:
+			cmdq_buf_print_misc(dev, offset, &cmdq_inst[i]);
+			break;
+		}
+		if (offset == buf_dump->pa_offset)
+			dev_err(dev,
+				"\e[1;31;40m==========ERROR==========\e[0m\n");
+		offset += CMDQ_INST_SIZE;
+	}
+	dev_err(dev, "dump %s task end   ----------\n",
+		buf_dump->timeout ? "timeout" : "error");
+
+	kfree(buf_dump->cmd_buf);
+	kfree(buf_dump);
+}
+EXPORT_SYMBOL(cmdq_debug_buf_dump_work);
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mailbox/mtk-cmdq-debug.h b/drivers/mailbox/mtk-cmdq-debug.h
new file mode 100644
index 000000000000..5392b00c9394
--- /dev/null
+++ b/drivers/mailbox/mtk-cmdq-debug.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ */
+
+#ifndef MTK_CMDQ_DEBUG_H
+#define MTK_CMDQ_DEBUG_H
+
+struct cmdq_buf_dump {
+	struct device		*dev; /* device of cmdq controller */
+	struct work_struct	dump_work;
+	bool			timeout; /* 0: error, 1: timeout */
+	void			*cmd_buf;
+	size_t			cmd_buf_size;
+	u32			pa_offset; /* pa_curr - pa_base */
+};
+
+void cmdq_debug_buf_dump_work(struct work_struct *work_item);
+
+#endif /* MTK_CMDQ_DEBUG_H */
diff --git a/drivers/mailbox/mtk-cmdq-mailbox.c b/drivers/mailbox/mtk-cmdq-mailbox.c
index a97f879af17e..653b9ff1a401 100644
--- a/drivers/mailbox/mtk-cmdq-mailbox.c
+++ b/drivers/mailbox/mtk-cmdq-mailbox.c
@@ -15,6 +15,9 @@
 #include <linux/mailbox_controller.h>
 #include <linux/mailbox/mtk-cmdq-mailbox.h>
 #include <linux/of_device.h>
+#ifdef CONFIG_MTK_CMDQ_DEBUG
+#include "mtk-cmdq-debug.h"
+#endif
 
 #define CMDQ_OP_CODE_MASK		(0xff << CMDQ_OP_CODE_SHIFT)
 #define CMDQ_NUM_CMD(t)			(t->cmd_buf_size / CMDQ_INST_SIZE)
@@ -75,8 +78,34 @@ struct cmdq {
 	struct cmdq_thread	*thread;
 	struct clk		*clock;
 	bool			suspended;
+#ifdef CONFIG_MTK_CMDQ_DEBUG
+	struct workqueue_struct *buf_dump_wq;
+#endif
 };
 
+#ifdef CONFIG_MTK_CMDQ_DEBUG
+static void cmdq_buf_dump_schedule(struct cmdq_task *task, bool timeout,
+				   u32 pa_curr)
+{
+	struct device *dev = task->cmdq->mbox.dev;
+	struct cmdq_buf_dump *buf_dump;
+
+	buf_dump = kmalloc(sizeof(*buf_dump), GFP_ATOMIC);
+	buf_dump->dev = dev;
+	buf_dump->timeout = timeout;
+	buf_dump->cmd_buf = kmalloc(task->pkt->cmd_buf_size, GFP_ATOMIC);
+	buf_dump->cmd_buf_size = task->pkt->cmd_buf_size;
+	buf_dump->pa_offset = pa_curr - task->pa_base;
+	dma_sync_single_for_cpu(dev, task->pa_base,
+				task->pkt->cmd_buf_size, DMA_TO_DEVICE);
+	memcpy(buf_dump->cmd_buf, task->pkt->va_base, task->pkt->cmd_buf_size);
+	dma_sync_single_for_device(dev, task->pa_base,
+				   task->pkt->cmd_buf_size, DMA_TO_DEVICE);
+	INIT_WORK(&buf_dump->dump_work, cmdq_debug_buf_dump_work);
+	queue_work(task->cmdq->buf_dump_wq, &buf_dump->dump_work);
+}
+#endif
+
 static int cmdq_thread_suspend(struct cmdq *cmdq, struct cmdq_thread *thread)
 {
 	u32 status;
@@ -216,12 +245,19 @@ static void cmdq_task_exec_done(struct cmdq_task *task, enum cmdq_cb_status sta)
 	list_del(&task->list_entry);
 }
 
+#ifdef CONFIG_MTK_CMDQ_DEBUG
+static void cmdq_task_handle_error(struct cmdq_task *task, u32 pa_curr)
+#else
 static void cmdq_task_handle_error(struct cmdq_task *task)
+#endif
 {
 	struct cmdq_thread *thread = task->thread;
 	struct cmdq_task *next_task;
 
 	dev_err(task->cmdq->mbox.dev, "task 0x%p error\n", task);
+#ifdef CONFIG_MTK_CMDQ_DEBUG
+	cmdq_buf_dump_schedule(task, false, pa_curr);
+#endif
 	WARN_ON(cmdq_thread_suspend(task->cmdq, thread) < 0);
 	next_task = list_first_entry_or_null(&thread->task_busy_list,
 			struct cmdq_task, list_entry);
@@ -269,7 +305,11 @@ static void cmdq_thread_irq_handler(struct cmdq *cmdq,
 			kfree(task);
 		} else if (err) {
 			cmdq_task_exec_done(task, CMDQ_CB_ERROR);
+#ifdef CONFIG_MTK_CMDQ_DEBUG
+			cmdq_task_handle_error(curr_task, curr_pa);
+#else
 			cmdq_task_handle_error(curr_task);
+#endif
 			kfree(task);
 		}
 
@@ -342,6 +382,9 @@ static int cmdq_remove(struct platform_device *pdev)
 {
 	struct cmdq *cmdq = platform_get_drvdata(pdev);
 
+#ifdef CONFIG_MTK_CMDQ_DEBUG
+	destroy_workqueue(cmdq->buf_dump_wq);
+#endif
 	mbox_controller_unregister(&cmdq->mbox);
 	clk_unprepare(cmdq->clock);
 
@@ -435,6 +478,36 @@ static int cmdq_mbox_startup(struct mbox_chan *chan)
 
 static void cmdq_mbox_shutdown(struct mbox_chan *chan)
 {
+#ifdef CONFIG_MTK_CMDQ_DEBUG
+	struct cmdq_thread *thread = (struct cmdq_thread *)chan->con_priv;
+	struct cmdq *cmdq = dev_get_drvdata(chan->mbox->dev);
+	struct cmdq_task *task, *tmp;
+	unsigned long flags;
+	bool first_task = true;
+
+	spin_lock_irqsave(&thread->chan->lock, flags);
+
+	if (list_empty(&thread->task_busy_list)) {
+		spin_unlock_irqrestore(&thread->chan->lock, flags);
+		return;
+	}
+
+	dev_err(cmdq->mbox.dev, "cmdq timeout\n");
+	list_for_each_entry_safe(task, tmp, &thread->task_busy_list,
+				 list_entry) {
+		if (first_task) {
+			cmdq_buf_dump_schedule(task, true, readl(
+					thread->base + CMDQ_THR_CURR_ADDR));
+			first_task = false;
+		}
+		cmdq_task_exec_done(task, CMDQ_CB_ERROR);
+		kfree(task);
+	}
+
+	cmdq_thread_disable(cmdq, thread);
+	clk_disable(cmdq->clock);
+	spin_unlock_irqrestore(&thread->chan->lock, flags);
+#endif
 }
 
 static const struct mbox_chan_ops cmdq_mbox_chan_ops = {
@@ -539,6 +612,14 @@ static int cmdq_probe(struct platform_device *pdev)
 
 	cmdq_init(cmdq);
 
+#ifdef CONFIG_MTK_CMDQ_DEBUG
+	cmdq->buf_dump_wq = alloc_ordered_workqueue(
+			"%s", WQ_MEM_RECLAIM | WQ_HIGHPRI,
+			"cmdq_buf_dump");
+#endif
+	for (i = 0; i <= CMDQ_MAX_EVENT; i++)
+		writel(i, cmdq->base + CMDQ_SYNC_TOKEN_UPDATE);
+
 	return 0;
 }
 
diff --git a/drivers/media/common/videobuf2/videobuf2-dma-contig.c b/drivers/media/common/videobuf2/videobuf2-dma-contig.c
index aff0ab7bf83d..be5c6d905a60 100644
--- a/drivers/media/common/videobuf2/videobuf2-dma-contig.c
+++ b/drivers/media/common/videobuf2/videobuf2-dma-contig.c
@@ -62,6 +62,29 @@ static unsigned long vb2_dc_get_contiguous_size(struct sg_table *sgt)
 	return size;
 }
 
+static struct sg_table *vb2_dc_get_base_sgt(struct vb2_dc_buf *buf)
+{
+	int ret;
+	struct sg_table *sgt;
+
+	sgt = kmalloc(sizeof(*sgt), GFP_KERNEL);
+	if (!sgt) {
+		dev_err(buf->dev, "failed to alloc sg table\n");
+		return NULL;
+	}
+
+	ret = dma_get_sgtable_attrs(buf->dev, sgt, buf->cookie, buf->dma_addr,
+		buf->size, buf->attrs);
+	if (ret < 0) {
+		dev_err(buf->dev, "failed to get scatterlist from DMA API\n");
+		kfree(sgt);
+		return NULL;
+	}
+
+	return sgt;
+}
+
+
 /*********************************************/
 /*         callbacks for all buffers         */
 /*********************************************/
@@ -130,6 +153,10 @@ static void vb2_dc_put(void *buf_priv)
 		sg_free_table(buf->sgt_base);
 		kfree(buf->sgt_base);
 	}
+	if (buf->dma_sgt) {
+		sg_free_table(buf->dma_sgt);
+		kfree(buf->dma_sgt);
+	}
 	dma_free_attrs(buf->dev, buf->size, buf->cookie, buf->dma_addr,
 		       buf->attrs);
 	put_device(buf->dev);
@@ -171,6 +198,10 @@ static void *vb2_dc_alloc(struct device *dev, unsigned long attrs,
 	buf->handler.put = vb2_dc_put;
 	buf->handler.arg = buf;
 
+	if (!(buf->attrs & DMA_ATTR_NO_KERNEL_MAPPING) &&
+	    (buf->attrs & DMA_ATTR_NON_CONSISTENT))
+		buf->dma_sgt = vb2_dc_get_base_sgt(buf);
+
 	refcount_set(&buf->refcount, 1);
 
 	return buf;
@@ -206,6 +237,11 @@ static int vb2_dc_mmap(void *buf_priv, struct vm_area_struct *vma)
 
 	vma->vm_ops->open(vma);
 
+	if ((buf->attrs & DMA_ATTR_NO_KERNEL_MAPPING) &&
+	    (buf->attrs & DMA_ATTR_NON_CONSISTENT) &&
+	    !buf->dma_sgt)
+		buf->dma_sgt = vb2_dc_get_base_sgt(buf);
+
 	pr_debug("%s: mapped dma addr 0x%08lx at 0x%08lx, size %ld\n",
 		__func__, (unsigned long)buf->dma_addr, vma->vm_start,
 		buf->size);
@@ -363,28 +399,6 @@ static const struct dma_buf_ops vb2_dc_dmabuf_ops = {
 	.release = vb2_dc_dmabuf_ops_release,
 };
 
-static struct sg_table *vb2_dc_get_base_sgt(struct vb2_dc_buf *buf)
-{
-	int ret;
-	struct sg_table *sgt;
-
-	sgt = kmalloc(sizeof(*sgt), GFP_KERNEL);
-	if (!sgt) {
-		dev_err(buf->dev, "failed to alloc sg table\n");
-		return NULL;
-	}
-
-	ret = dma_get_sgtable_attrs(buf->dev, sgt, buf->cookie, buf->dma_addr,
-		buf->size, buf->attrs);
-	if (ret < 0) {
-		dev_err(buf->dev, "failed to get scatterlist from DMA API\n");
-		kfree(sgt);
-		return NULL;
-	}
-
-	return sgt;
-}
-
 static struct dma_buf *vb2_dc_get_dmabuf(void *buf_priv, unsigned long flags)
 {
 	struct vb2_dc_buf *buf = buf_priv;
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 53a7c3407b43..286859e0f98f 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -347,6 +347,16 @@ config VIDEO_DW9714
 	  capability. This is designed for linear control of
 	  voice coil motors, controlled via I2C serial interface.
 
+config VIDEO_DW9768
+	tristate "DW9768 lens voice coil support"
+	depends on I2C && VIDEO_V4L2 && MEDIA_CONTROLLER
+	depends on VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This is a driver for the DW9768 camera lens voice coil.
+	  DW9768 is a 10 bit DAC with 120mA output current sink
+	  capability. This is designed for linear control of
+	  voice coil motors, controlled via I2C serial interface.
+
 config VIDEO_DW9807_VCM
 	tristate "DW9807 lens voice coil support"
 	depends on I2C && VIDEO_V4L2 && MEDIA_CONTROLLER
@@ -616,6 +626,18 @@ config VIDEO_IMX274
 	  This is a V4L2 sensor driver for the Sony IMX274
 	  CMOS image sensor.
 
+config VIDEO_OV02A10
+	tristate "OmniVision OV02A10 sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	depends on MEDIA_CAMERA_SUPPORT
+	select V4L2_FWNODE
+	---help---
+	  This is a Video4Linux2 sensor driver for the OmniVision
+	  OV02A10 camera.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ov02a10.
+
 config VIDEO_OV2640
 	tristate "OmniVision OV2640 sensor support"
 	depends on VIDEO_V4L2 && I2C
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index c21888a88dda..97bd756acc79 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -25,6 +25,7 @@ obj-$(CONFIG_VIDEO_SAA6752HS) += saa6752hs.o
 obj-$(CONFIG_VIDEO_AD5820)  += ad5820.o
 obj-$(CONFIG_VIDEO_AK7375)  += ak7375.o
 obj-$(CONFIG_VIDEO_DW9714)  += dw9714.o
+obj-$(CONFIG_VIDEO_DW9768)  += dw9768.o
 obj-$(CONFIG_VIDEO_DW9807_VCM)  += dw9807-vcm.o
 obj-$(CONFIG_VIDEO_ADV7170) += adv7170.o
 obj-$(CONFIG_VIDEO_ADV7175) += adv7175.o
@@ -72,6 +73,7 @@ obj-$(CONFIG_VIDEO_OV5645) += ov5645.o
 obj-$(CONFIG_VIDEO_OV5647) += ov5647.o
 obj-$(CONFIG_VIDEO_OV5670) += ov5670.o
 obj-$(CONFIG_VIDEO_OV5695) += ov5695.o
+obj-$(CONFIG_VIDEO_OV02A10) += ov02a10.o
 obj-$(CONFIG_VIDEO_OV6650) += ov6650.o
 obj-$(CONFIG_VIDEO_OV7251) += ov7251.o
 obj-$(CONFIG_VIDEO_OV7640) += ov7640.o
diff --git a/drivers/media/i2c/dw9768.c b/drivers/media/i2c/dw9768.c
new file mode 100644
index 000000000000..f5b5591eb140
--- /dev/null
+++ b/drivers/media/i2c/dw9768.c
@@ -0,0 +1,458 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pm_runtime.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+
+#define DW9768_VOLTAGE_ANALOG			2800000
+#define DW9768_NAME				"dw9768"
+#define DW9768_MAX_FOCUS_POS			1023
+/*
+ * This sets the minimum granularity for the focus positions.
+ * A value of 1 gives maximum accuracy for a desired focus position
+ */
+#define DW9768_FOCUS_STEPS			1
+
+#define DW9768_CTRL_DELAY_US			5000
+
+#define DW9768_REG_DAC_MSB			0x03
+#define DW9768_REG_DAC_LSB			0x04
+#define DW9768_REG_NULL				0xff
+
+#define DW9768_DAC_SHIFT			8
+
+#define DW9768_REG_VALUE_16BIT			2
+
+/* dw9768 device structure */
+struct dw9768_device {
+	struct v4l2_ctrl_handler ctrls;
+	struct v4l2_subdev sd;
+	struct regulator *analog_regulator;
+	/*
+	 * Serialize control access, get/set format, get selection
+	 * and start streaming.
+	 */
+	struct mutex power_lock;
+
+	int power_count;
+	bool standby;
+};
+
+static inline struct dw9768_device *to_dw9768_vcm(struct v4l2_ctrl *ctrl)
+{
+	return container_of(ctrl->handler, struct dw9768_device, ctrls);
+}
+
+static inline struct dw9768_device *sd_to_dw9768_vcm(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct dw9768_device, sd);
+}
+
+static int dw9768_i2c_write(struct dw9768_device *dw9768_dev, u8 *data,
+			    int size)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dw9768_dev->sd);
+	struct i2c_msg msg;
+	u8 *w_buf = NULL;
+	u8 retry_cnt = 3;
+	int ret;
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	if (size != 1 && size != 2)
+		return -EINVAL;
+
+	memset(&msg, 0, sizeof(struct i2c_msg));
+
+	w_buf = kzalloc(size, GFP_KERNEL);
+	if (!w_buf)
+		return -1;
+
+	memcpy(w_buf, data, size);
+
+	msg.addr  = client->addr;
+	msg.flags = 0;
+	msg.len   = size;
+	msg.buf   = w_buf;
+
+	do {
+		ret = i2c_transfer(client->adapter, &msg, 1);
+		if (ret != 1)
+			dev_err(&client->dev, "write fail, ret:%d, retry:%d\n",
+				ret, retry_cnt);
+		else
+			break;
+		retry_cnt--;
+	} while (retry_cnt != 0);
+
+	if (retry_cnt == 0)	{
+		dev_err(&client->dev, "i2c write fail(%d)\n", ret);
+		return -EIO;
+	}
+
+	kfree(w_buf);
+
+	return 0;
+}
+
+static int dw9768_release(struct dw9768_device *dw9768_dev)
+{
+	unsigned char i;
+	int ret;
+
+	char puSendCmdArray[4][2] = {
+		{0x02, 0x00}, {DW9768_REG_NULL, DW9768_REG_NULL},
+		{0x01, 0x00}, {DW9768_REG_NULL, DW9768_REG_NULL},
+	};
+
+	for (i = 0; i < (sizeof(puSendCmdArray) / sizeof(char)) /
+	     (sizeof(puSendCmdArray[0]) / sizeof(char)); i++) {
+		if (puSendCmdArray[i][0] != DW9768_REG_NULL) {
+			ret = dw9768_i2c_write(dw9768_dev, puSendCmdArray[i],
+					       DW9768_REG_VALUE_16BIT);
+			if (ret < 0)
+				return ret;
+		} else {
+			usleep_range(DW9768_CTRL_DELAY_US,
+				     DW9768_CTRL_DELAY_US + 100);
+		}
+	}
+
+	return 0;
+}
+
+static int dw9768_init(struct dw9768_device *dw9768_dev)
+{
+	unsigned char i;
+	int ret;
+
+	char puSendCmdArray[5][2] = {
+		{0x02, 0x02}, {DW9768_REG_NULL, DW9768_REG_NULL},
+		{0x06, 0x41}, {0x07, 0x39}, {DW9768_REG_NULL, DW9768_REG_NULL},
+	};
+
+	for (i = 0; i < (sizeof(puSendCmdArray) / sizeof(char)) /
+	     (sizeof(puSendCmdArray[0]) / sizeof(char)); i++) {
+		if (puSendCmdArray[i][0] != DW9768_REG_NULL) {
+			ret = dw9768_i2c_write(dw9768_dev, puSendCmdArray[i],
+					       DW9768_REG_VALUE_16BIT);
+			if (ret < 0)
+				return ret;
+		} else {
+			usleep_range(DW9768_CTRL_DELAY_US,
+				     DW9768_CTRL_DELAY_US + 100);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Power handling
+ */
+static int dw9768_power_off(struct dw9768_device *dw9768_dev, bool standby)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dw9768_dev->sd);
+	int ret;
+
+	/*
+	 * Go to standby first as real power off my be denied by the hardware
+	 * (single power line control for both dw9768_dev and sensor).
+	 */
+	if (standby) {
+		dw9768_dev->standby = true;
+		ret = dw9768_release(dw9768_dev);
+		if (ret)
+			dev_err(&client->dev, "dw9768_release failed!\n");
+	}
+	ret = regulator_disable(dw9768_dev->analog_regulator);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int dw9768_power_on(struct dw9768_device *dw9768_dev, bool restore)
+{
+	int ret;
+
+	ret = regulator_enable(dw9768_dev->analog_regulator);
+	if (ret < 0)
+		return ret;
+
+	if (restore) {
+		/* Restore the hardware settings. */
+		dw9768_dev->standby = false;
+		ret = dw9768_init(dw9768_dev);
+		if (ret < 0)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dw9768_dev->standby = true;
+	regulator_disable(dw9768_dev->analog_regulator);
+
+	return ret;
+}
+
+/*
+ * Calculate status word and write it to the device based on current
+ * values of V4L2 controls. It is assumed that the stored V4L2 control
+ * values are properly limited and rounded.
+ */
+static int dw9768_update_hw(struct dw9768_device *dw9768_dev, u16 val)
+{
+	unsigned char i;
+	int ret;
+
+	char puSendCmdArray[2][2] = {
+		{DW9768_REG_DAC_MSB, (char)(val >> DW9768_DAC_SHIFT)},
+		{DW9768_REG_DAC_LSB, (char)(val & 0xFF)},
+	};
+
+	for (i = 0; i < (sizeof(puSendCmdArray) / sizeof(char)) /
+	     (sizeof(puSendCmdArray[0]) / sizeof(char)); i++) {
+		ret = dw9768_i2c_write(dw9768_dev, puSendCmdArray[i],
+				       DW9768_REG_VALUE_16BIT);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int dw9768_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct dw9768_device *dw9768_dev = to_dw9768_vcm(ctrl);
+
+	if (ctrl->id == V4L2_CID_FOCUS_ABSOLUTE)
+		return dw9768_update_hw(dw9768_dev, ctrl->val);
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops dw9768_vcm_ctrl_ops = {
+	.s_ctrl = dw9768_set_ctrl,
+};
+
+static int
+dw9768_set_power(struct v4l2_subdev *subdev, int on)
+{
+	struct dw9768_device *dw9768_dev = sd_to_dw9768_vcm(subdev);
+	int ret = 0;
+
+	mutex_lock(&dw9768_dev->power_lock);
+
+	/*
+	 * If the power count is modified from 0 to != 0 or from != 0 to 0,
+	 * update the power state.
+	 */
+	if (dw9768_dev->power_count == !on) {
+		ret = on ? dw9768_power_on(dw9768_dev, true) :
+			dw9768_power_off(dw9768_dev, true);
+		if (ret < 0)
+			goto done;
+	}
+
+	/* Update the power count. */
+	dw9768_dev->power_count += on ? 1 : -1;
+	WARN_ON(dw9768_dev->power_count < 0);
+
+done:
+	mutex_unlock(&dw9768_dev->power_lock);
+	return ret;
+}
+
+static int dw9768_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return dw9768_set_power(sd, 1);
+}
+
+static int dw9768_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return dw9768_set_power(sd, 0);
+}
+
+static const struct v4l2_subdev_internal_ops dw9768_int_ops = {
+	.open = dw9768_open,
+	.close = dw9768_close,
+};
+
+static const struct v4l2_subdev_ops dw9768_ops = { };
+
+static void dw9768_subdev_cleanup(struct dw9768_device *dw9768_dev)
+{
+	v4l2_async_unregister_subdev(&dw9768_dev->sd);
+	v4l2_ctrl_handler_free(&dw9768_dev->ctrls);
+	media_entity_cleanup(&dw9768_dev->sd.entity);
+}
+
+static int dw9768_init_controls(struct dw9768_device *dw9768_dev)
+{
+	struct v4l2_ctrl_handler *hdl = &dw9768_dev->ctrls;
+	const struct v4l2_ctrl_ops *ops = &dw9768_vcm_ctrl_ops;
+
+	v4l2_ctrl_handler_init(hdl, 1);
+
+	v4l2_ctrl_new_std(hdl, ops, V4L2_CID_FOCUS_ABSOLUTE,
+			  0, DW9768_MAX_FOCUS_POS, DW9768_FOCUS_STEPS, 0);
+
+	if (hdl->error) {
+		dev_err(dw9768_dev->sd.dev, "%s fail error: 0x%x\n",
+			__func__, hdl->error);
+		return hdl->error;
+	}
+
+	dw9768_dev->sd.ctrl_handler = hdl;
+
+	return 0;
+}
+
+static int dw9768_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct dw9768_device *dw9768_dev;
+	int rval;
+
+	dw9768_dev = devm_kzalloc(&client->dev, sizeof(*dw9768_dev),
+				  GFP_KERNEL);
+	if (!dw9768_dev)
+		return -ENOMEM;
+
+	dw9768_dev->analog_regulator = devm_regulator_get(dev, "afvdd");
+	if (IS_ERR(dw9768_dev->analog_regulator)) {
+		dev_err(dev, "cannot get analog regulator\n");
+		return PTR_ERR(dw9768_dev->analog_regulator);
+	}
+
+	rval = regulator_set_voltage(dw9768_dev->analog_regulator,
+				     DW9768_VOLTAGE_ANALOG,
+				     DW9768_VOLTAGE_ANALOG);
+	if (rval < 0) {
+		dev_err(dev, "cannot set analog voltage\n");
+		return rval;
+	}
+
+	mutex_init(&dw9768_dev->power_lock);
+
+	v4l2_i2c_subdev_init(&dw9768_dev->sd, client, &dw9768_ops);
+	dw9768_dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dw9768_dev->sd.internal_ops = &dw9768_int_ops;
+
+	rval = dw9768_init_controls(dw9768_dev);
+	if (rval)
+		goto err_cleanup;
+
+	rval = media_entity_pads_init(&dw9768_dev->sd.entity, 0, NULL);
+	if (rval < 0)
+		goto err_cleanup;
+
+	dw9768_dev->sd.entity.function = MEDIA_ENT_F_LENS;
+
+	rval = v4l2_async_register_subdev(&dw9768_dev->sd);
+	if (rval < 0)
+		goto err_cleanup;
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	return 0;
+
+err_cleanup:
+	mutex_destroy(&dw9768_dev->power_lock);
+	dw9768_subdev_cleanup(dw9768_dev);
+	dev_err(dev, "Probe failed: %d\n", rval);
+	return rval;
+}
+
+static int dw9768_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct dw9768_device *dw9768_dev = sd_to_dw9768_vcm(sd);
+
+	pm_runtime_disable(&client->dev);
+	dw9768_subdev_cleanup(dw9768_dev);
+
+	return 0;
+}
+
+/*
+ * This function sets the vcm position, so it consumes least current
+ * The lens position is gradually moved in units of DW9768_CTRL_STEPS,
+ * to make the movements smoothly.
+ */
+static int __maybe_unused dw9768_vcm_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct dw9768_device *dw9768_dev = sd_to_dw9768_vcm(sd);
+
+	if (!dw9768_dev->power_count)
+		return 0;
+
+	return dw9768_power_off(dw9768_dev, false);
+}
+
+/*
+ * This function sets the vcm position to the value set by the user
+ * through v4l2_ctrl_ops s_ctrl handler
+ * The lens position is gradually moved in units of DW9768_CTRL_STEPS,
+ * to make the movements smoothly.
+ */
+static int __maybe_unused dw9768_vcm_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct dw9768_device *dw9768_dev = sd_to_dw9768_vcm(sd);
+
+	if (!dw9768_dev->power_count)
+		return 0;
+
+	return dw9768_power_on(dw9768_dev, true);
+}
+
+static const struct i2c_device_id dw9768_id_table[] = {
+	{ DW9768_NAME, 0 },
+	{ { 0 } }
+};
+MODULE_DEVICE_TABLE(i2c, dw9768_id_table);
+
+static const struct of_device_id dw9768_of_table[] = {
+	{ .compatible = "dongwoon,dw9768" },
+	{ { 0 } }
+};
+MODULE_DEVICE_TABLE(of, dw9768_of_table);
+
+static const struct dev_pm_ops dw9768_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(dw9768_vcm_suspend, dw9768_vcm_resume)
+	SET_RUNTIME_PM_OPS(dw9768_vcm_suspend, dw9768_vcm_resume, NULL)
+};
+
+static struct i2c_driver dw9768_i2c_driver = {
+	.driver = {
+		.name = DW9768_NAME,
+		.pm = &dw9768_pm_ops,
+		.of_match_table = dw9768_of_table,
+	},
+	.probe_new  = dw9768_probe,
+	.remove = dw9768_remove,
+	.id_table = dw9768_id_table,
+};
+
+module_i2c_driver(dw9768_i2c_driver);
+
+MODULE_AUTHOR("Dongchun Zhu <dongchun.zhu@mediatek.com>");
+MODULE_DESCRIPTION("DW9768 VCM driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/ov02a10.c b/drivers/media/i2c/ov02a10.c
new file mode 100644
index 000000000000..67d55a4428c6
--- /dev/null
+++ b/drivers/media/i2c/ov02a10.c
@@ -0,0 +1,1019 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <media/media-entity.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+#define CHIP_ID                                         0x2509
+#define OV02A10_REG_CHIP_ID_H                           0x02
+#define OV02A10_REG_CHIP_ID_L                           0x03
+#define OV02A10_ID(_msb, _lsb)                          ((_msb) << 8 | (_lsb))
+
+/* bit[1] vertical upside down */
+/* bit[0] horizontal mirror */
+#define REG_MIRROR_FLIP_CONTROL                         0x3f
+
+/* Orientation */
+#define REG_CONFIG_MIRROR_FLIP		                0x03
+
+#define REG_PAGE_SWITCH                                 0xfd
+#define REG_GLOBAL_EFFECTIVE                            0x01
+#define REG_ENABLE                                      BIT(0)
+
+#define REG_SC_CTRL_MODE                                0xac
+#define SC_CTRL_MODE_STANDBY                            0x00
+#define SC_CTRL_MODE_STREAMING                          0x01
+
+#define OV02A10_REG_EXPOSURE_H                          0x03
+#define OV02A10_REG_EXPOSURE_L                          0x04
+#define	OV02A10_EXPOSURE_MIN                            4
+#define	OV02A10_EXPOSURE_STEP                           1
+
+#define OV02A10_REG_VTS_H                               0x05
+#define OV02A10_REG_VTS_L                               0x06
+#define OV02A10_VTS_MAX                                 0x209f
+#define OV02A10_VTS_MIN                                 0x04cf
+
+#define OV02A10_REG_GAIN                                0x24
+#define OV02A10_GAIN_MIN                                0x10
+#define OV02A10_GAIN_MAX                                0xf8
+#define OV02A10_GAIN_STEP                               0x01
+#define OV02A10_GAIN_DEFAULT                            0x40
+
+#define REG_NULL                                        0xff
+
+#define OV02A10_LANES                                   1
+#define OV02A10_BITS_PER_SAMPLE                         10
+
+static const char * const ov02a10_supply_names[] = {
+	"dovdd",	/* Digital I/O power */
+	"avdd",		/* Analog power */
+	"dvdd",		/* Digital core power */
+};
+
+#define OV02A10_NUM_SUPPLIES ARRAY_SIZE(ov02a10_supply_names)
+
+struct regval {
+	u16 addr;
+	u8 val;
+};
+
+struct ov02a10_mode {
+	u32 width;
+	u32 height;
+	u32 exp_def;
+	u32 hts_def;
+	u32 vts_def;
+	const struct regval *reg_list;
+};
+
+struct ov02a10 {
+	struct clk		*xvclk;
+	struct gpio_desc	*pwdn_gpio;
+	struct gpio_desc	*reset_gpio;
+	struct regulator_bulk_data supplies[OV02A10_NUM_SUPPLIES];
+
+	bool			streaming;
+	bool			upside_down;
+
+	/*
+	 * Serialize control access, get/set format, get selection
+	 * and start streaming.
+	 */
+	struct mutex		mutex;
+	struct v4l2_subdev	subdev;
+	struct media_pad	pad;
+	struct v4l2_ctrl	*anal_gain;
+	struct v4l2_ctrl	*exposure;
+	struct v4l2_ctrl	*hblank;
+	struct v4l2_ctrl	*vblank;
+	struct v4l2_ctrl	*hflip;
+	struct v4l2_ctrl	*vflip;
+	struct v4l2_ctrl	*test_pattern;
+	struct v4l2_mbus_framefmt	fmt;
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	const struct ov02a10_mode *cur_mode;
+};
+
+#define to_ov02a10(sd) container_of(sd, struct ov02a10, subdev)
+
+static inline void msleep_range(unsigned int delay_base)
+{
+	usleep_range(delay_base * 1000, delay_base * 1000 + 500);
+}
+
+/* MIPI color bar enable output */
+static const struct regval ov02a10_test_pattern_enable_regs[] = {
+	{0xfd, 0x01},
+	{0x0d, 0x00},
+	{0xb6, 0x01},
+	{0x01, 0x01},
+	{0xfd, 0x01},
+	{0xac, 0x01},
+	{REG_NULL, 0x00}
+};
+
+/* MIPI color bar disable output */
+static const struct regval ov02a10_test_pattern_disable_regs[] = {
+	{0xfd, 0x01},
+	{0x0d, 0x00},
+	{0xb6, 0x00},
+	{0x01, 0x01},
+	{0xfd, 0x01},
+	{0xac, 0x01},
+	{REG_NULL, 0x00}
+};
+
+/*
+ * Xclk 24Mhz
+ * Pclk 39Mhz
+ * linelength 934(0x3a6)
+ * framelength 1390(0x56E)
+ * grabwindow_width 1600
+ * grabwindow_height 1200
+ * max_framerate 30fps
+ * mipi_datarate per lane 780Mbps
+ */
+static const struct regval ov02a10_1600x1200_regs[] = {
+	{0xfd, 0x01},
+	{0xac, 0x00},
+	{0xfd, 0x00},
+	{0x2f, 0x29},
+	{0x34, 0x00},
+	{0x35, 0x21},
+	{0x30, 0x15},
+	{0x33, 0x01},
+	{0xfd, 0x01},
+	{0x44, 0x00},
+	{0x2a, 0x4c},
+	{0x2b, 0x1e},
+	{0x2c, 0x60},
+	{0x25, 0x11},
+	{0x03, 0x01},
+	{0x04, 0xae},
+	{0x09, 0x00},
+	{0x0a, 0x02},
+	{0x06, 0xa6},
+	{0x31, 0x00},
+	{0x24, 0x40},
+	{0x01, 0x01},
+	{0xfb, 0x73},
+	{0xfd, 0x01},
+	{0x16, 0x04},
+	{0x1c, 0x09},
+	{0x21, 0x42},
+	{0x12, 0x04},
+	{0x13, 0x10},
+	{0x11, 0x40},
+	{0x33, 0x81},
+	{0xd0, 0x00},
+	{0xd1, 0x01},
+	{0xd2, 0x00},
+	{0x50, 0x10},
+	{0x51, 0x23},
+	{0x52, 0x20},
+	{0x53, 0x10},
+	{0x54, 0x02},
+	{0x55, 0x20},
+	{0x56, 0x02},
+	{0x58, 0x48},
+	{0x5d, 0x15},
+	{0x5e, 0x05},
+	{0x66, 0x66},
+	{0x68, 0x68},
+	{0x6b, 0x00},
+	{0x6c, 0x00},
+	{0x6f, 0x40},
+	{0x70, 0x40},
+	{0x71, 0x0a},
+	{0x72, 0xf0},
+	{0x73, 0x10},
+	{0x75, 0x80},
+	{0x76, 0x10},
+	{0x84, 0x00},
+	{0x85, 0x10},
+	{0x86, 0x10},
+	{0x87, 0x00},
+	{0x8a, 0x22},
+	{0x8b, 0x22},
+	{0x19, 0xf1},
+	{0x29, 0x01},
+	{0xfd, 0x01},
+	{0x9d, 0xd6},
+	{0xa0, 0x29},
+	{0xa1, 0x03},
+	{0xad, 0x62},
+	{0xae, 0x00},
+	{0xaf, 0x85},
+	{0xb1, 0x01},
+	{0x8e, 0x06},
+	{0x8f, 0x40},
+	{0x90, 0x04},
+	{0x91, 0xb0},
+	{0x45, 0x01},
+	{0x46, 0x00},
+	{0x47, 0x6c},
+	{0x48, 0x03},
+	{0x49, 0x8b},
+	{0x4a, 0x00},
+	{0x4b, 0x07},
+	{0x4c, 0x04},
+	{0x4d, 0xb7},
+	{0xf0, 0x40},
+	{0xf1, 0x40},
+	{0xf2, 0x40},
+	{0xf3, 0x40},
+	{0x3f, 0x00},
+	{0xfd, 0x01},
+	{0x05, 0x00},
+	{0x06, 0xa6},
+	{0xfd, 0x01},
+	{REG_NULL, 0x00}
+};
+
+#define OV02A10_LINK_FREQ_390MHZ		390000000
+static const s64 link_freq_menu_items[] = {
+	OV02A10_LINK_FREQ_390MHZ
+};
+
+static const char * const ov02a10_test_pattern_menu[] = {
+	"Disabled",
+	"Color Bar",
+};
+
+static const struct ov02a10_mode supported_modes[] = {
+	{
+		.width = 1600,
+		.height = 1200,
+		.exp_def = 0x01ae,
+		.hts_def = 0x03a6,
+		.vts_def = 0x056e,
+		.reg_list = ov02a10_1600x1200_regs,
+	},
+};
+
+/* write a register */
+static int ov02a10_write_reg(struct ov02a10 *ov02a10, u8 addr, u8 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);
+	u8 buf[2] = {addr, val};
+	int ret;
+
+	ret = i2c_master_send(client, buf, 2);
+
+	if (ret != 2) {
+		dev_err(&client->dev, "%s: error: reg=%x, val=%x\n",
+			__func__, addr, val);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int ov02a10_write_array(struct ov02a10 *ov02a10,
+			       const struct regval *regs)
+{
+	u32 i;
+	int ret;
+
+	for (i = 0; regs[i].addr != REG_NULL; i++) {
+		ret = ov02a10_write_reg(ov02a10, regs[i].addr, regs[i].val);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+/* read a register */
+static int ov02a10_read_reg(struct ov02a10 *ov02a10, u8 reg, u8 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);
+	u8 data = reg;
+	struct i2c_msg msg = {
+		.addr	= client->addr,
+		.flags	= 0,
+		.len	= 1,
+		.buf	= &data,
+	};
+	int ret;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0)
+		goto err_wr;
+
+	msg.flags = I2C_M_RD;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0)
+		goto err_rd;
+
+	*val = data;
+	return 0;
+
+err_rd:
+	dev_err(&client->dev, "i2c_transfer --I2C_M_RD failed\n");
+err_wr:
+	dev_err(&client->dev, "read error: reg=0x%02x: %d\n", reg, ret);
+	return ret;
+}
+static void ov02a10_fill_fmt(const struct ov02a10_mode *mode,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->width = mode->width;
+	fmt->height = mode->height;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int ov02a10_set_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct ov02a10 *ov02a10 = to_ov02a10(sd);
+	struct v4l2_mbus_framefmt *mbus_fmt = &fmt->format;
+	int ret = 0;
+
+	mutex_lock(&ov02a10->mutex);
+
+	if (ov02a10->streaming) {
+		ret = -EBUSY;
+		goto unlock;
+	}
+
+	/* only one mode supported */
+	mbus_fmt->code = ov02a10->fmt.code;
+	ov02a10_fill_fmt(ov02a10->cur_mode, mbus_fmt);
+	ov02a10->fmt = fmt->format;
+
+unlock:
+	mutex_unlock(&ov02a10->mutex);
+
+	return ret;
+
+}
+
+static int ov02a10_get_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct ov02a10 *ov02a10 = to_ov02a10(sd);
+	struct v4l2_mbus_framefmt *mbus_fmt = &fmt->format;
+
+	mutex_lock(&ov02a10->mutex);
+
+	fmt->format = ov02a10->fmt;
+	mbus_fmt->code = ov02a10->fmt.code;
+	ov02a10_fill_fmt(ov02a10->cur_mode, mbus_fmt);
+
+	mutex_unlock(&ov02a10->mutex);
+
+	return 0;
+}
+
+static int ov02a10_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct ov02a10 *ov02a10 = to_ov02a10(sd);
+
+	if (code->index >= ARRAY_SIZE(supported_modes) || !(code->index))
+		return -EINVAL;
+
+	code->code = ov02a10->fmt.code;
+
+	return 0;
+}
+
+static int ov02a10_enum_frame_sizes(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_pad_config *cfg,
+				    struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes) || !(fse->index))
+		return -EINVAL;
+
+	fse->min_width  = supported_modes[fse->index].width;
+	fse->max_width  = supported_modes[fse->index].width;
+	fse->max_height = supported_modes[fse->index].height;
+	fse->min_height = supported_modes[fse->index].height;
+
+	return 0;
+}
+
+static int __ov02a10_power_on(struct ov02a10 *ov02a10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);
+	struct device *dev = &client->dev;
+	int ret;
+
+	ret = clk_prepare_enable(ov02a10->xvclk);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable xvclk\n");
+		return ret;
+	}
+
+	/* note: set 0 is high, set 1 is low */
+	gpiod_set_value_cansleep(ov02a10->reset_gpio, 1);
+	gpiod_set_value_cansleep(ov02a10->pwdn_gpio, 0);
+
+	ret = regulator_bulk_enable(OV02A10_NUM_SUPPLIES, ov02a10->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators\n");
+		goto disable_clk;
+	}
+	msleep_range(7);
+
+	gpiod_set_value_cansleep(ov02a10->pwdn_gpio, 1);
+	msleep_range(10);
+
+	gpiod_set_value_cansleep(ov02a10->reset_gpio, 0);
+	msleep_range(10);
+
+	return 0;
+
+disable_clk:
+	clk_disable_unprepare(ov02a10->xvclk);
+
+	return ret;
+}
+
+static void __ov02a10_power_off(struct ov02a10 *ov02a10)
+{
+	clk_disable_unprepare(ov02a10->xvclk);
+	gpiod_set_value_cansleep(ov02a10->reset_gpio, 1);
+	gpiod_set_value_cansleep(ov02a10->pwdn_gpio, 1);
+	regulator_bulk_disable(OV02A10_NUM_SUPPLIES, ov02a10->supplies);
+}
+
+static int __ov02a10_start_stream(struct ov02a10 *ov02a10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);
+	int ret;
+
+	/* Apply default values of current mode */
+	ret = ov02a10_write_array(ov02a10, ov02a10->cur_mode->reg_list);
+	if (ret)
+		return ret;
+
+	/* Apply customized values from user */
+	ret = __v4l2_ctrl_handler_setup(ov02a10->subdev.ctrl_handler);
+	if (ret)
+		return ret;
+
+	/* Set Orientation be 180 degree */
+	if (ov02a10->upside_down) {
+		ret = ov02a10_write_reg(ov02a10, REG_MIRROR_FLIP_CONTROL,
+								REG_CONFIG_MIRROR_FLIP);
+		if (ret) {
+			dev_err(&client->dev, "%s failed to set orientation\n",
+					__func__);
+			return ret;
+		}
+		ret = ov02a10_write_reg(ov02a10, REG_GLOBAL_EFFECTIVE,
+					REG_ENABLE);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* set stream on register */
+	return ov02a10_write_reg(ov02a10,
+				 REG_SC_CTRL_MODE, SC_CTRL_MODE_STREAMING);
+}
+
+static int __ov02a10_stop_stream(struct ov02a10 *ov02a10)
+{
+	return ov02a10_write_reg(ov02a10,
+				 REG_SC_CTRL_MODE, SC_CTRL_MODE_STANDBY);
+}
+
+static int ov02a10_entity_init_cfg(struct v4l2_subdev *subdev,
+				   struct v4l2_subdev_pad_config *cfg)
+{
+	struct v4l2_subdev_format fmt = { 0 };
+
+	fmt.which = cfg ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.format.width = 1600;
+	fmt.format.height = 1200;
+
+	ov02a10_set_fmt(subdev, cfg, &fmt);
+
+	return 0;
+}
+
+static int ov02a10_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct ov02a10 *ov02a10 = to_ov02a10(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);
+	int ret = 0;
+
+	dev_dbg(&client->dev, "ov02a10 s_stream (%d)\n", on);
+	mutex_lock(&ov02a10->mutex);
+
+	if (ov02a10->streaming == on)
+		goto unlock_and_return;
+
+	if (on) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			goto unlock_and_return;
+		}
+
+		ret = __ov02a10_start_stream(ov02a10);
+		if (ret) {
+			__ov02a10_stop_stream(ov02a10);
+			ov02a10->streaming = !on;
+			goto err_rpm_put;
+		}
+	} else {
+		__ov02a10_stop_stream(ov02a10);
+		pm_runtime_put(&client->dev);
+	}
+
+	ov02a10->streaming = on;
+	mutex_unlock(&ov02a10->mutex);
+
+	return ret;
+
+err_rpm_put:
+	pm_runtime_put(&client->dev);
+unlock_and_return:
+	mutex_unlock(&ov02a10->mutex);
+
+	return ret;
+}
+
+static int ov02a10_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ov02a10 *ov02a10 = to_ov02a10(sd);
+	struct v4l2_mbus_framefmt *try_fmt = v4l2_subdev_get_try_format(sd,
+									fh->pad,
+									0);
+
+	mutex_lock(&ov02a10->mutex);
+	/* Initialize try_fmt */
+	try_fmt->code = ov02a10->fmt.code;
+	ov02a10_fill_fmt(&supported_modes[0], try_fmt);
+
+	mutex_unlock(&ov02a10->mutex);
+
+	return 0;
+}
+
+static int __maybe_unused ov02a10_runtime_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov02a10 *ov02a10 = to_ov02a10(sd);
+
+	return __ov02a10_power_on(ov02a10);
+}
+
+static int __maybe_unused ov02a10_runtime_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov02a10 *ov02a10 = to_ov02a10(sd);
+
+	__ov02a10_power_off(ov02a10);
+
+	return 0;
+}
+
+static const struct dev_pm_ops ov02a10_pm_ops = {
+	SET_RUNTIME_PM_OPS(ov02a10_runtime_suspend,
+			   ov02a10_runtime_resume, NULL)
+};
+
+static int ov02a10_set_test_pattern(struct ov02a10 *ov02a10, s32 value)
+{
+	if (value)
+		return ov02a10_write_array(ov02a10,
+					   ov02a10_test_pattern_enable_regs);
+
+	return ov02a10_write_array(ov02a10,
+		ov02a10_test_pattern_disable_regs);
+}
+
+static int ov02a10_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov02a10 *ov02a10 = container_of(ctrl->handler,
+					     struct ov02a10, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);
+	s64 max_expo;
+	int ret;
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		max_expo = ov02a10->cur_mode->height + ctrl->val - 4;
+		__v4l2_ctrl_modify_range(ov02a10->exposure,
+					 ov02a10->exposure->minimum, max_expo,
+					 ov02a10->exposure->step,
+					 ov02a10->exposure->default_value);
+	}
+
+	/* V4L2 controls values will be applied only when power is already up */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE:
+		ret = ov02a10_write_reg(ov02a10, REG_PAGE_SWITCH, REG_ENABLE);
+		if (ret < 0)
+			return ret;
+		ret = ov02a10_write_reg(ov02a10, OV02A10_REG_EXPOSURE_H,
+					((ctrl->val >> 8) & 0xFF));
+		if (!ret) {
+			ret = ov02a10_write_reg(ov02a10, OV02A10_REG_EXPOSURE_L,
+						(ctrl->val & 0xFF));
+			if (ret < 0)
+				return ret;
+		}
+		ret = ov02a10_write_reg(ov02a10, REG_GLOBAL_EFFECTIVE,
+					REG_ENABLE);
+		if (ret < 0)
+			return ret;
+		break;
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov02a10_write_reg(ov02a10, REG_PAGE_SWITCH, REG_ENABLE);
+		if (ret < 0)
+			return ret;
+		ret = ov02a10_write_reg(ov02a10, OV02A10_REG_GAIN,
+					(ctrl->val & 0xFF));
+		if (ret < 0)
+			return ret;
+		ret = ov02a10_write_reg(ov02a10, REG_GLOBAL_EFFECTIVE,
+					REG_ENABLE);
+		if (ret < 0)
+			return ret;
+		break;
+	case V4L2_CID_VBLANK:
+		ret = ov02a10_write_reg(ov02a10, REG_PAGE_SWITCH, REG_ENABLE);
+		if (ret < 0)
+			return ret;
+		ret = ov02a10_write_reg(ov02a10, OV02A10_REG_VTS_H,
+					(((ctrl->val +
+					ov02a10->cur_mode->height - 1224) >> 8)
+					& 0xFF));
+		if (!ret) {
+			ret = ov02a10_write_reg(ov02a10, OV02A10_REG_VTS_L,
+						((ctrl->val +
+						ov02a10->cur_mode->height -
+						1224) & 0xFF));
+			if (ret < 0)
+				return ret;
+		}
+		ret = ov02a10_write_reg(ov02a10, REG_GLOBAL_EFFECTIVE,
+					REG_ENABLE);
+		if (ret < 0)
+			return ret;
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = ov02a10_set_test_pattern(ov02a10, ctrl->val);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		dev_warn(&client->dev, "%s Unhandled id:0x%x, val:0x%x\n",
+			 __func__, ctrl->id, ctrl->val);
+		ret = -EINVAL;
+		break;
+	};
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops ov02a10_video_ops = {
+	.s_stream = ov02a10_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov02a10_pad_ops = {
+	.init_cfg = ov02a10_entity_init_cfg,
+	.enum_mbus_code = ov02a10_enum_mbus_code,
+	.enum_frame_size = ov02a10_enum_frame_sizes,
+	.get_fmt = ov02a10_get_fmt,
+	.set_fmt = ov02a10_set_fmt,
+};
+
+static const struct v4l2_subdev_ops ov02a10_subdev_ops = {
+	.video	= &ov02a10_video_ops,
+	.pad	= &ov02a10_pad_ops,
+};
+
+static const struct media_entity_operations ov02a10_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops ov02a10_internal_ops = {
+	.open = ov02a10_open,
+};
+
+static const struct v4l2_ctrl_ops ov02a10_ctrl_ops = {
+	.s_ctrl = ov02a10_set_ctrl,
+};
+
+static int ov02a10_initialize_controls(struct ov02a10 *ov02a10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);
+	const struct ov02a10_mode *mode;
+	struct v4l2_ctrl_handler *handler;
+	struct v4l2_ctrl *ctrl;
+	u64 exposure_max;
+	u32 pixel_rate, h_blank;
+	int ret;
+
+	handler = &ov02a10->ctrl_handler;
+	mode = ov02a10->cur_mode;
+	ret = v4l2_ctrl_handler_init(handler, 10);
+	if (ret)
+		return ret;
+	handler->lock = &ov02a10->mutex;
+
+	ctrl = v4l2_ctrl_new_int_menu(handler, NULL, V4L2_CID_LINK_FREQ,
+				      0, 0, link_freq_menu_items);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	pixel_rate = (link_freq_menu_items[0] * 2 * OV02A10_LANES) /
+		     OV02A10_BITS_PER_SAMPLE;
+	v4l2_ctrl_new_std(handler, NULL, V4L2_CID_PIXEL_RATE,
+			  0, pixel_rate, 1, pixel_rate);
+
+	h_blank = mode->hts_def - mode->width;
+	ov02a10->hblank = v4l2_ctrl_new_std(handler, NULL, V4L2_CID_HBLANK,
+					    h_blank, h_blank, 1, h_blank);
+	if (ov02a10->hblank)
+		ov02a10->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ov02a10->vblank = v4l2_ctrl_new_std(handler, &ov02a10_ctrl_ops,
+					    V4L2_CID_VBLANK, mode->vts_def -
+					    mode->height,
+					    OV02A10_VTS_MAX - mode->height, 1,
+					    mode->vts_def - mode->height);
+
+	exposure_max = mode->vts_def - 4;
+	ov02a10->exposure = v4l2_ctrl_new_std(handler, &ov02a10_ctrl_ops,
+					      V4L2_CID_EXPOSURE,
+					      OV02A10_EXPOSURE_MIN,
+					      exposure_max,
+					      OV02A10_EXPOSURE_STEP,
+					      mode->exp_def);
+
+	ov02a10->anal_gain = v4l2_ctrl_new_std(handler, &ov02a10_ctrl_ops,
+					       V4L2_CID_ANALOGUE_GAIN,
+					       OV02A10_GAIN_MIN,
+					       OV02A10_GAIN_MAX,
+					       OV02A10_GAIN_STEP,
+					       OV02A10_GAIN_DEFAULT);
+
+	ov02a10->test_pattern =
+	   v4l2_ctrl_new_std_menu_items(handler,
+					&ov02a10_ctrl_ops,
+					V4L2_CID_TEST_PATTERN,
+					ARRAY_SIZE(ov02a10_test_pattern_menu) -
+					1, 0, 0, ov02a10_test_pattern_menu);
+
+	if (handler->error) {
+		ret = handler->error;
+		dev_err(&client->dev,
+			"Failed to init controls(%d)\n", ret);
+		goto err_free_handler;
+	}
+
+	ov02a10->subdev.ctrl_handler = handler;
+
+	return 0;
+
+err_free_handler:
+	v4l2_ctrl_handler_free(handler);
+
+	return ret;
+}
+
+static int ov02a10_check_sensor_id(struct ov02a10 *ov02a10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);
+	u16 id;
+	u8 pid = 0;
+	u8 ver = 0;
+	int ret;
+
+	/* Check sensor revision */
+	ret = ov02a10_read_reg(ov02a10, OV02A10_REG_CHIP_ID_H, &pid);
+	if (ret)
+		return ret;
+
+	ret = ov02a10_read_reg(ov02a10, OV02A10_REG_CHIP_ID_L, &ver);
+	if (ret)
+		return ret;
+
+	id = OV02A10_ID(pid, ver);
+	if (id != CHIP_ID) {
+		dev_err(&client->dev, "Unexpected sensor id(%04x)\n", id);
+		return ret;
+	}
+
+	dev_info(&client->dev, "Detected OV%04X sensor\n", id);
+
+	return 0;
+}
+
+static int ov02a10_configure_regulators(struct ov02a10 *ov02a10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);
+	unsigned int i;
+
+	for (i = 0; i < OV02A10_NUM_SUPPLIES; i++)
+		ov02a10->supplies[i].supply = ov02a10_supply_names[i];
+
+	return devm_regulator_bulk_get(&client->dev,
+				       OV02A10_NUM_SUPPLIES,
+				       ov02a10->supplies);
+}
+
+static int ov02a10_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct ov02a10 *ov02a10;
+	u32 rotation;
+	u32 xclk_freq;
+	int ret;
+
+	dev_info(dev, "ov02a10 probe ++\n");
+	ov02a10 = devm_kzalloc(dev, sizeof(*ov02a10), GFP_KERNEL);
+	if (!ov02a10)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&ov02a10->subdev, client, &ov02a10_subdev_ops);
+	ov02a10->fmt.code = MEDIA_BUS_FMT_SBGGR10_1X10;
+
+	/* optional indication of physical rotation of sensor */
+	ret = fwnode_property_read_u32(dev_fwnode(dev), "rotation",
+				       &rotation);
+	if (!ret) {
+		switch (rotation) {
+		case 180:
+			ov02a10->upside_down = true;
+			ov02a10->fmt.code = MEDIA_BUS_FMT_SRGGB10_1X10;
+			break;
+		case 0:
+			break;
+		default:
+			dev_warn(dev, "%u degrees rotation is not supported, ignoring...\n",
+				 rotation);
+		}
+	}
+
+	/* get system clock (xvclk) */
+	ov02a10->xvclk = devm_clk_get(dev, "xvclk");
+	if (IS_ERR(ov02a10->xvclk)) {
+		dev_err(dev, "Failed to get xvclk\n");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "clock-frequency", &xclk_freq);
+	if (ret) {
+		dev_err(dev, "Failed to get xclk frequency\n");
+		return ret;
+	}
+
+	/* external clock must be 24MHz, allow 1% tolerance */
+	if (xclk_freq < 23760000 || xclk_freq > 24240000) {
+		dev_err(dev, "external clock frequency %u is not supported\n",
+			xclk_freq);
+		return -EINVAL;
+	}
+	dev_dbg(dev, "external clock frequency %u\n", xclk_freq);
+
+	ret = clk_set_rate(ov02a10->xvclk, xclk_freq);
+	if (ret) {
+		dev_err(dev, "Failed to set xvclk frequency (24MHz)\n");
+		return ret;
+	}
+
+	ov02a10->pwdn_gpio = devm_gpiod_get(dev, "pwdn", GPIOD_OUT_LOW);
+	if (IS_ERR(ov02a10->pwdn_gpio)) {
+		dev_err(dev, "Failed to get powerdown-gpios\n");
+		return -EINVAL;
+	}
+
+	ov02a10->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ov02a10->reset_gpio)) {
+		dev_err(dev, "Failed to get reset-gpios\n");
+		return -EINVAL;
+	}
+
+	ret = ov02a10_configure_regulators(ov02a10);
+	if (ret) {
+		dev_err(dev, "Failed to get power regulators\n");
+		return ret;
+	}
+
+	mutex_init(&ov02a10->mutex);
+	ov02a10->cur_mode = &supported_modes[0];
+	ret = ov02a10_initialize_controls(ov02a10);
+	if (ret) {
+		dev_err(dev, "Failed to initialize controls\n");
+		goto err_destroy_mutex;
+	}
+
+	ret = __ov02a10_power_on(ov02a10);
+	if (ret)
+		goto err_free_handler;
+
+	ret = ov02a10_check_sensor_id(ov02a10);
+	if (ret)
+		goto err_power_off;
+
+	ov02a10->subdev.internal_ops = &ov02a10_internal_ops;
+	ov02a10->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	ov02a10->subdev.entity.ops = &ov02a10_subdev_entity_ops;
+	ov02a10->subdev.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ov02a10->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&ov02a10->subdev.entity, 1, &ov02a10->pad);
+	if (ret < 0) {
+		dev_err(dev, "failed to init entity pads: %d", ret);
+		goto err_power_off;
+	}
+
+	ret = v4l2_async_register_subdev(&ov02a10->subdev);
+	if (ret) {
+		dev_err(dev, "failed to register V4L2 subdev: %d",
+			ret);
+		goto err_clean_entity;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	dev_info(dev, "ov02a10 probe --\n");
+	return 0;
+
+err_clean_entity:
+	media_entity_cleanup(&ov02a10->subdev.entity);
+err_power_off:
+	__ov02a10_power_off(ov02a10);
+err_free_handler:
+	v4l2_ctrl_handler_free(ov02a10->subdev.ctrl_handler);
+err_destroy_mutex:
+	mutex_destroy(&ov02a10->mutex);
+
+	return ret;
+}
+
+static int ov02a10_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov02a10 *ov02a10 = to_ov02a10(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	pm_runtime_disable(&client->dev);
+	if (!pm_runtime_status_suspended(&client->dev))
+		__ov02a10_power_off(ov02a10);
+	pm_runtime_set_suspended(&client->dev);
+	mutex_destroy(&ov02a10->mutex);
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_OF)
+static const struct of_device_id ov02a10_of_match[] = {
+	{ .compatible = "ovti,ov02a10" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ov02a10_of_match);
+#endif
+
+static struct i2c_driver ov02a10_i2c_driver = {
+	.driver = {
+		.name = "ov02a10",
+		.pm = &ov02a10_pm_ops,
+		.of_match_table = ov02a10_of_match,
+	},
+	.probe_new	= &ov02a10_probe,
+	.remove		= &ov02a10_remove,
+};
+
+module_i2c_driver(ov02a10_i2c_driver);
+
+MODULE_AUTHOR("Dongchun Zhu <dongchun.zhu@mediatek.com>");
+MODULE_DESCRIPTION("OmniVision OV02A10 sensor driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/media/i2c/ov2685.c b/drivers/media/i2c/ov2685.c
index 385c1886a947..fcd85ffd7c09 100644
--- a/drivers/media/i2c/ov2685.c
+++ b/drivers/media/i2c/ov2685.c
@@ -17,6 +17,7 @@
 #include <media/media-entity.h>
 #include <media/v4l2-async.h>
 #include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
 #include <media/v4l2-subdev.h>
 
 #define CHIP_ID				0x2685
@@ -105,10 +106,9 @@ struct ov2685 {
 /* PLL settings bases on 24M xvclk */
 static struct regval ov2685_1600x1200_regs[] = {
 	{0x0103, 0x01},
-	{0x0100, 0x00},
 	{0x3002, 0x00},
 	{0x3016, 0x1c},
-	{0x3018, 0x44},
+	{0x3018, 0x84},
 	{0x301d, 0xf0},
 	{0x3020, 0x00},
 	{0x3082, 0x37},
@@ -116,10 +116,10 @@ static struct regval ov2685_1600x1200_regs[] = {
 	{0x3084, 0x09},
 	{0x3085, 0x04},
 	{0x3086, 0x00},
-	{0x3087, 0x00},
+	{0x3087, 0x01},
 	{0x3501, 0x4e},
 	{0x3502, 0xe0},
-	{0x3503, 0x27},
+	{0x3503, 0x03},
 	{0x350b, 0x36},
 	{0x3600, 0xb4},
 	{0x3603, 0x35},
@@ -196,14 +196,7 @@ static struct regval ov2685_1600x1200_regs[] = {
 	{0x5003, 0x04},
 	{0x5004, 0x00},
 	{0x5005, 0x0c},
-	{0x5280, 0x15},
-	{0x5281, 0x06},
-	{0x5282, 0x06},
-	{0x5283, 0x08},
-	{0x5284, 0x1c},
-	{0x5285, 0x1c},
-	{0x5286, 0x20},
-	{0x5287, 0x10},
+	{0x0100, 0x01},
 	{REG_NULL, 0x00}
 };
 
@@ -249,6 +242,8 @@ static int ov2685_write_reg(struct i2c_client *client, u16 reg,
 	u8 buf[6];
 	u8 *val_p;
 	__be32 val_be;
+	u32 ret;
+	u8 retry_cnt = 5;
 
 	if (len > 4)
 		return -EINVAL;
@@ -264,8 +259,20 @@ static int ov2685_write_reg(struct i2c_client *client, u16 reg,
 	while (val_i < 4)
 		buf[buf_i++] = val_p[val_i++];
 
-	if (i2c_master_send(client, buf, len + 2) != len + 2)
+	do {
+		ret = i2c_master_send(client, buf, len + 2);
+		if (ret != len + 2)
+			pr_err("i2c_master_send fail:%d retry:%d\n",
+			       ret, retry_cnt);
+		else
+			break;
+		retry_cnt--;
+	} while (retry_cnt != 0);
+
+	if (retry_cnt == 0)	{
+		pr_err("i2c write fail(%d)\n", ret);
 		return -EIO;
+	}
 
 	return 0;
 }
@@ -318,6 +325,18 @@ static int ov2685_read_reg(struct i2c_client *client, u16 reg,
 	return 0;
 }
 
+static int ov2685_subscribe_event(struct v4l2_subdev *sd,
+				  struct v4l2_fh *fh,
+				  struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_CTRL:
+		return v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);
+	default:
+		return -EINVAL;
+	}
+}
+
 static void ov2685_fill_fmt(const struct ov2685_mode *mode,
 			    struct v4l2_mbus_framefmt *fmt)
 {
@@ -325,6 +344,10 @@ static void ov2685_fill_fmt(const struct ov2685_mode *mode,
 	fmt->width = mode->width;
 	fmt->height = mode->height;
 	fmt->field = V4L2_FIELD_NONE;
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->xfer_func = V4L2_XFER_FUNC_DEFAULT;
+	fmt->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	fmt->quantization = V4L2_QUANTIZATION_DEFAULT;
 }
 
 static int ov2685_set_fmt(struct v4l2_subdev *sd,
@@ -413,7 +436,7 @@ static int __ov2685_power_on(struct ov2685 *ov2685)
 	gpiod_set_value_cansleep(ov2685->reset_gpio, 0);
 	/* 8192 xvclk cycles prior to the first SCCB transaction */
 	delay_us = ov2685_cal_delay(8192);
-	usleep_range(delay_us, delay_us * 2);
+	usleep_range(delay_us * 2, delay_us * 4);
 
 	/* HACK: ov2685 would output messy data after reset(R0103),
 	 * writing register before .s_stream() as a workaround
@@ -455,6 +478,7 @@ static int ov2685_s_stream(struct v4l2_subdev *sd, int on)
 	if (on == ov2685->streaming)
 		goto unlock_and_return;
 
+	pr_info("%s %d\n", __func__, on);
 	if (on) {
 		ret = pm_runtime_get_sync(&ov2685->client->dev);
 		if (ret < 0) {
@@ -467,14 +491,16 @@ static int ov2685_s_stream(struct v4l2_subdev *sd, int on)
 			goto unlock_and_return;
 		}
 		ret = ov2685_write_reg(client, REG_SC_CTRL_MODE,
-				OV2685_REG_VALUE_08BIT, SC_CTRL_MODE_STREAMING);
+				       OV2685_REG_VALUE_08BIT,
+				       SC_CTRL_MODE_STREAMING);
 		if (ret) {
 			pm_runtime_put(&client->dev);
 			goto unlock_and_return;
 		}
 	} else {
 		ov2685_write_reg(client, REG_SC_CTRL_MODE,
-				OV2685_REG_VALUE_08BIT, SC_CTRL_MODE_STANDBY);
+				 OV2685_REG_VALUE_08BIT,
+				 SC_CTRL_MODE_STANDBY);
 		pm_runtime_put(&ov2685->client->dev);
 	}
 
@@ -519,6 +545,11 @@ static int __maybe_unused ov2685_runtime_suspend(struct device *dev)
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct ov2685 *ov2685 = to_ov2685(sd);
 
+	if (ov2685->streaming == 1) {
+		ov2685_write_reg(ov2685->client, REG_SC_CTRL_MODE,
+				 OV2685_REG_VALUE_08BIT, SC_CTRL_MODE_STANDBY);
+		ov2685->streaming = 0;
+	}
 	__ov2685_power_off(ov2685);
 
 	return 0;
@@ -583,6 +614,11 @@ static int ov2685_set_ctrl(struct v4l2_ctrl *ctrl)
 	return ret;
 }
 
+static const struct v4l2_subdev_core_ops ov2685_core_ops = {
+	.subscribe_event = ov2685_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
 static const struct v4l2_subdev_video_ops ov2685_video_ops = {
 	.s_stream = ov2685_s_stream,
 };
@@ -595,6 +631,7 @@ static const struct v4l2_subdev_pad_ops ov2685_pad_ops = {
 };
 
 static const struct v4l2_subdev_ops ov2685_subdev_ops = {
+	.core	= &ov2685_core_ops,
 	.video	= &ov2685_video_ops,
 	.pad	= &ov2685_pad_ops,
 };
@@ -637,30 +674,44 @@ static int ov2685_initialize_controls(struct ov2685 *ov2685)
 
 	h_blank = mode->hts_def - mode->width;
 	ov2685->hblank = v4l2_ctrl_new_std(handler, NULL, V4L2_CID_HBLANK,
-				h_blank, h_blank, 1, h_blank);
+					   h_blank, h_blank, 1, h_blank);
 	if (ov2685->hblank)
 		ov2685->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
 
-	ov2685->vblank = v4l2_ctrl_new_std(handler, &ov2685_ctrl_ops,
-				V4L2_CID_VBLANK, mode->vts_def - mode->height,
-				OV2685_VTS_MAX - mode->height, 1,
-				mode->vts_def - mode->height);
+	ov2685->vblank = v4l2_ctrl_new_std(handler,
+					   &ov2685_ctrl_ops,
+					   V4L2_CID_VBLANK,
+					   mode->vts_def - mode->height,
+					   OV2685_VTS_MAX - mode->height,
+					   1,
+					   mode->vts_def - mode->height);
 
 	exposure_max = mode->vts_def - 4;
-	ov2685->exposure = v4l2_ctrl_new_std(handler, &ov2685_ctrl_ops,
-				V4L2_CID_EXPOSURE, OV2685_EXPOSURE_MIN,
-				exposure_max, OV2685_EXPOSURE_STEP,
-				mode->exp_def);
-
-	ov2685->anal_gain = v4l2_ctrl_new_std(handler, &ov2685_ctrl_ops,
-				V4L2_CID_ANALOGUE_GAIN, OV2685_GAIN_MIN,
-				OV2685_GAIN_MAX, OV2685_GAIN_STEP,
-				OV2685_GAIN_DEFAULT);
-
-	ov2685->test_pattern = v4l2_ctrl_new_std_menu_items(handler,
-				&ov2685_ctrl_ops, V4L2_CID_TEST_PATTERN,
-				ARRAY_SIZE(ov2685_test_pattern_menu) - 1,
-				0, 0, ov2685_test_pattern_menu);
+	ov2685->exposure = v4l2_ctrl_new_std(handler,
+					     &ov2685_ctrl_ops,
+					     V4L2_CID_EXPOSURE,
+					     OV2685_EXPOSURE_MIN,
+					     exposure_max,
+					     OV2685_EXPOSURE_STEP,
+					     mode->exp_def);
+
+	ov2685->anal_gain = v4l2_ctrl_new_std(handler,
+					      &ov2685_ctrl_ops,
+					      V4L2_CID_ANALOGUE_GAIN,
+					      OV2685_GAIN_MIN,
+					      OV2685_GAIN_MAX,
+					      OV2685_GAIN_STEP,
+					      OV2685_GAIN_DEFAULT);
+
+	ov2685->test_pattern =
+		v4l2_ctrl_new_std_menu_items
+			(handler,
+			 &ov2685_ctrl_ops,
+			 V4L2_CID_TEST_PATTERN,
+			 ARRAY_SIZE(ov2685_test_pattern_menu) - 1,
+			 0,
+			 0,
+			 ov2685_test_pattern_menu);
 
 	if (handler->error) {
 		ret = handler->error;
@@ -717,6 +768,7 @@ static int ov2685_probe(struct i2c_client *client,
 	struct ov2685 *ov2685;
 	int ret;
 
+	dev_info(dev, "ov2685 probe\n");
 	ov2685 = devm_kzalloc(dev, sizeof(*ov2685), GFP_KERNEL);
 	if (!ov2685)
 		return -ENOMEM;
@@ -766,6 +818,7 @@ static int ov2685_probe(struct i2c_client *client,
 #ifdef CONFIG_VIDEO_V4L2_SUBDEV_API
 	ov2685->subdev.internal_ops = &ov2685_internal_ops;
 	ov2685->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	ov2685->subdev.flags |= V4L2_SUBDEV_FL_HAS_EVENTS;
 #endif
 #if defined(CONFIG_MEDIA_CONTROLLER)
 	ov2685->pad.flags = MEDIA_PAD_FL_SOURCE;
diff --git a/drivers/media/i2c/ov5695.c b/drivers/media/i2c/ov5695.c
index 9a80decd93d3..ee4cbc36db0c 100644
--- a/drivers/media/i2c/ov5695.c
+++ b/drivers/media/i2c/ov5695.c
@@ -17,6 +17,7 @@
 #include <media/media-entity.h>
 #include <media/v4l2-async.h>
 #include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
 #include <media/v4l2-subdev.h>
 
 #ifndef V4L2_CID_DIGITAL_GAIN
@@ -709,6 +710,8 @@ static int ov5695_write_reg(struct i2c_client *client, u16 reg,
 	u8 buf[6];
 	u8 *val_p;
 	__be32 val_be;
+	u32 ret;
+	u8 retry_cnt = 5;
 
 	if (len > 4)
 		return -EINVAL;
@@ -724,8 +727,20 @@ static int ov5695_write_reg(struct i2c_client *client, u16 reg,
 	while (val_i < 4)
 		buf[buf_i++] = val_p[val_i++];
 
-	if (i2c_master_send(client, buf, len + 2) != len + 2)
+	do {
+		ret = i2c_master_send(client, buf, len + 2);
+		if (ret != len + 2)
+			pr_err("i2c_master_send fail:%d retry:%d\n",
+			       ret, retry_cnt);
+		else
+			break;
+		retry_cnt--;
+	} while (retry_cnt != 0);
+
+	if (retry_cnt == 0)	{
+		pr_err("i2c write fail(%d) len(%d)\n", ret, len + 2);
 		return -EIO;
+	}
 
 	return 0;
 }
@@ -805,6 +820,18 @@ ov5695_find_best_fit(struct v4l2_subdev_format *fmt)
 	return &supported_modes[cur_best_fit];
 }
 
+static int ov5695_subscribe_event(struct v4l2_subdev *sd,
+				  struct v4l2_fh *fh,
+				  struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_CTRL:
+		return v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);
+	default:
+		return -EINVAL;
+	}
+}
+
 static int ov5695_set_fmt(struct v4l2_subdev *sd,
 			  struct v4l2_subdev_pad_config *cfg,
 			  struct v4l2_subdev_format *fmt)
@@ -820,6 +847,10 @@ static int ov5695_set_fmt(struct v4l2_subdev *sd,
 	fmt->format.width = mode->width;
 	fmt->format.height = mode->height;
 	fmt->format.field = V4L2_FIELD_NONE;
+	fmt->format.colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->format.xfer_func = V4L2_XFER_FUNC_DEFAULT;
+	fmt->format.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	fmt->format.quantization = V4L2_QUANTIZATION_DEFAULT;
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
 #ifdef CONFIG_VIDEO_V4L2_SUBDEV_API
 		*v4l2_subdev_get_try_format(sd, cfg, fmt->pad) = fmt->format;
@@ -854,6 +885,10 @@ static int ov5695_get_fmt(struct v4l2_subdev *sd,
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
 #ifdef CONFIG_VIDEO_V4L2_SUBDEV_API
 		fmt->format = *v4l2_subdev_get_try_format(sd, cfg, fmt->pad);
+		fmt->format.colorspace = V4L2_COLORSPACE_SRGB;
+		fmt->format.xfer_func = V4L2_XFER_FUNC_DEFAULT;
+		fmt->format.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+		fmt->format.quantization = V4L2_QUANTIZATION_DEFAULT;
 #else
 		mutex_unlock(&ov5695->mutex);
 		return -ENOTTY;
@@ -863,6 +898,10 @@ static int ov5695_get_fmt(struct v4l2_subdev *sd,
 		fmt->format.height = mode->height;
 		fmt->format.code = MEDIA_BUS_FMT_SBGGR10_1X10;
 		fmt->format.field = V4L2_FIELD_NONE;
+		fmt->format.colorspace = V4L2_COLORSPACE_SRGB;
+		fmt->format.xfer_func = V4L2_XFER_FUNC_DEFAULT;
+		fmt->format.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+		fmt->format.quantization = V4L2_QUANTIZATION_DEFAULT;
 	}
 	mutex_unlock(&ov5695->mutex);
 
@@ -924,9 +963,10 @@ static int __ov5695_start_stream(struct ov5695 *ov5695)
 
 	/* In case these controls are set before streaming */
 	ret = __v4l2_ctrl_handler_setup(&ov5695->ctrl_handler);
-	if (ret)
+	if (ret) {
+		pr_err("__v4l2_ctrl_handler_setup fail %d\n", ret);
 		return ret;
-
+	}
 	return ov5695_write_reg(ov5695->client, OV5695_REG_CTRL_MODE,
 				OV5695_REG_VALUE_08BIT, OV5695_MODE_STREAMING);
 }
@@ -943,6 +983,7 @@ static int ov5695_s_stream(struct v4l2_subdev *sd, int on)
 	struct i2c_client *client = ov5695->client;
 	int ret = 0;
 
+	pr_info("ov5695 s_stream-%d\n", on);
 	mutex_lock(&ov5695->mutex);
 	on = !!on;
 	if (on == ov5695->streaming)
@@ -1004,7 +1045,7 @@ static int __ov5695_power_on(struct ov5695 *ov5695)
 
 	/* 8192 cycles prior to first SCCB transaction */
 	delay_us = ov5695_cal_delay(8192);
-	usleep_range(delay_us, delay_us * 2);
+	usleep_range(delay_us  * 2, delay_us * 4);
 
 	return 0;
 
@@ -1036,6 +1077,10 @@ static int __maybe_unused ov5695_runtime_suspend(struct device *dev)
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct ov5695 *ov5695 = to_ov5695(sd);
 
+	if (ov5695->streaming == 1) {
+		__ov5695_stop_stream(ov5695);
+		ov5695->streaming = 0;
+	}
 	__ov5695_power_off(ov5695);
 
 	return 0;
@@ -1074,6 +1119,11 @@ static const struct v4l2_subdev_internal_ops ov5695_internal_ops = {
 };
 #endif
 
+static const struct v4l2_subdev_core_ops ov5695_core_ops = {
+	.subscribe_event = ov5695_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
 static const struct v4l2_subdev_video_ops ov5695_video_ops = {
 	.s_stream = ov5695_s_stream,
 };
@@ -1086,6 +1136,7 @@ static const struct v4l2_subdev_pad_ops ov5695_pad_ops = {
 };
 
 static const struct v4l2_subdev_ops ov5695_subdev_ops = {
+	.core	= &ov5695_core_ops,
 	.video	= &ov5695_video_ops,
 	.pad	= &ov5695_pad_ops,
 };
@@ -1180,37 +1231,54 @@ static int ov5695_initialize_controls(struct ov5695 *ov5695)
 
 	h_blank = mode->hts_def - mode->width;
 	ov5695->hblank = v4l2_ctrl_new_std(handler, NULL, V4L2_CID_HBLANK,
-				h_blank, h_blank, 1, h_blank);
+					   h_blank, h_blank, 1, h_blank);
 	if (ov5695->hblank)
 		ov5695->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
 
 	vblank_def = mode->vts_def - mode->height;
-	ov5695->vblank = v4l2_ctrl_new_std(handler, &ov5695_ctrl_ops,
-				V4L2_CID_VBLANK, vblank_def,
-				OV5695_VTS_MAX - mode->height,
-				1, vblank_def);
+	ov5695->vblank = v4l2_ctrl_new_std(handler,
+					   &ov5695_ctrl_ops,
+					   V4L2_CID_VBLANK,
+					   vblank_def,
+					   OV5695_VTS_MAX - mode->height,
+					   1,
+					   vblank_def);
 
 	exposure_max = mode->vts_def - 4;
-	ov5695->exposure = v4l2_ctrl_new_std(handler, &ov5695_ctrl_ops,
-				V4L2_CID_EXPOSURE, OV5695_EXPOSURE_MIN,
-				exposure_max, OV5695_EXPOSURE_STEP,
-				mode->exp_def);
-
-	ov5695->anal_gain = v4l2_ctrl_new_std(handler, &ov5695_ctrl_ops,
-				V4L2_CID_ANALOGUE_GAIN, ANALOG_GAIN_MIN,
-				ANALOG_GAIN_MAX, ANALOG_GAIN_STEP,
-				ANALOG_GAIN_DEFAULT);
+	ov5695->exposure = v4l2_ctrl_new_std(handler,
+					     &ov5695_ctrl_ops,
+					     V4L2_CID_EXPOSURE,
+					     OV5695_EXPOSURE_MIN,
+					     exposure_max,
+					     OV5695_EXPOSURE_STEP,
+					     mode->exp_def);
+
+	ov5695->anal_gain = v4l2_ctrl_new_std(handler,
+					      &ov5695_ctrl_ops,
+					      V4L2_CID_ANALOGUE_GAIN,
+					      ANALOG_GAIN_MIN,
+					      ANALOG_GAIN_MAX,
+					      ANALOG_GAIN_STEP,
+					      ANALOG_GAIN_DEFAULT);
 
 	/* Digital gain */
-	ov5695->digi_gain = v4l2_ctrl_new_std(handler, &ov5695_ctrl_ops,
-				V4L2_CID_DIGITAL_GAIN, OV5695_DIGI_GAIN_MIN,
-				OV5695_DIGI_GAIN_MAX, OV5695_DIGI_GAIN_STEP,
-				OV5695_DIGI_GAIN_DEFAULT);
-
-	ov5695->test_pattern = v4l2_ctrl_new_std_menu_items(handler,
-				&ov5695_ctrl_ops, V4L2_CID_TEST_PATTERN,
-				ARRAY_SIZE(ov5695_test_pattern_menu) - 1,
-				0, 0, ov5695_test_pattern_menu);
+	ov5695->digi_gain = v4l2_ctrl_new_std(handler,
+					      &ov5695_ctrl_ops,
+					      V4L2_CID_DIGITAL_GAIN,
+					      OV5695_DIGI_GAIN_MIN,
+					      OV5695_DIGI_GAIN_MAX,
+					      OV5695_DIGI_GAIN_STEP,
+					      OV5695_DIGI_GAIN_DEFAULT);
+
+	ov5695->test_pattern =
+		v4l2_ctrl_new_std_menu_items
+			(handler,
+			 &ov5695_ctrl_ops,
+			 V4L2_CID_TEST_PATTERN,
+			 ARRAY_SIZE(ov5695_test_pattern_menu) - 1,
+			 0,
+			 0,
+			 ov5695_test_pattern_menu);
 
 	if (handler->error) {
 		ret = handler->error;
@@ -1268,10 +1336,12 @@ static int ov5695_probe(struct i2c_client *client,
 	struct v4l2_subdev *sd;
 	int ret;
 
+	dev_info(dev, "ov5695 probe\n");
 	ov5695 = devm_kzalloc(dev, sizeof(*ov5695), GFP_KERNEL);
 	if (!ov5695)
 		return -ENOMEM;
 
+	ov5695->streaming = 0;
 	ov5695->client = client;
 	ov5695->cur_mode = &supported_modes[0];
 
@@ -1280,6 +1350,7 @@ static int ov5695_probe(struct i2c_client *client,
 		dev_err(dev, "Failed to get xvclk\n");
 		return -EINVAL;
 	}
+
 	ret = clk_set_rate(ov5695->xvclk, OV5695_XVCLK_FREQ);
 	if (ret < 0) {
 		dev_err(dev, "Failed to set xvclk rate (24MHz)\n");
@@ -1319,6 +1390,7 @@ static int ov5695_probe(struct i2c_client *client,
 #ifdef CONFIG_VIDEO_V4L2_SUBDEV_API
 	sd->internal_ops = &ov5695_internal_ops;
 	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS;
 #endif
 #if defined(CONFIG_MEDIA_CONTROLLER)
 	ov5695->pad.flags = MEDIA_PAD_FL_SOURCE;
diff --git a/drivers/media/i2c/ov8856.c b/drivers/media/i2c/ov8856.c
index dbf1095b9440..16222deb48f3 100644
--- a/drivers/media/i2c/ov8856.c
+++ b/drivers/media/i2c/ov8856.c
@@ -1,12 +1,15 @@
 // SPDX-License-Identifier: GPL-2.0
 // Copyright (c) 2019 Intel Corporation.
 
+#include <linux/clk.h>
 #include <asm/unaligned.h>
 #include <linux/acpi.h>
 #include <linux/delay.h>
+#include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-fwnode.h>
@@ -19,6 +22,7 @@
 #define OV8856_LINK_FREQ_180MHZ		180000000ULL
 #define OV8856_SCLK			144000000ULL
 #define OV8856_MCLK			19200000
+#define OV8856_XVCLK_FREQ		24000000
 #define OV8856_DATA_LANES		4
 #define OV8856_RGB_DEPTH		10
 
@@ -64,6 +68,14 @@
 
 #define to_ov8856(_sd)			container_of(_sd, struct ov8856, sd)
 
+static const char * const ov8856_supply_names[] = {
+	"dovdd",	/* Digital I/O power */
+	"avdd",		/* Analog power */
+	"dvdd",		/* Digital core power */
+};
+
+#define OV8856_NUM_SUPPLIES ARRAY_SIZE(ov8856_supply_names)
+
 enum {
 	OV8856_LINK_FREQ_720MBPS,
 	OV8856_LINK_FREQ_360MBPS,
@@ -316,6 +328,208 @@ static const struct ov8856_reg mode_3280x2464_regs[] = {
 	{0x5e00, 0x00}
 };
 
+static const struct ov8856_reg mode_3264x2448_regs[] = {
+	{0x0103, 0x01},
+	{0x0302, 0x3c},
+	{0x0303, 0x01},
+	{0x031e, 0x0c},
+	{0x3000, 0x00},
+	{0x300e, 0x00},
+	{0x3010, 0x00},
+	{0x3015, 0x84},
+	{0x3018, 0x72},
+	{0x3021, 0x23},
+	{0x3033, 0x24},
+	{0x3500, 0x00},
+	{0x3501, 0x9a},
+	{0x3502, 0x20},
+	{0x3503, 0x08},
+	{0x3505, 0x83},
+	{0x3508, 0x01},
+	{0x3509, 0x80},
+	{0x350c, 0x00},
+	{0x350d, 0x80},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x72},
+	{0x3601, 0x40},
+	{0x3602, 0x30},
+	{0x3610, 0xc5},
+	{0x3611, 0x58},
+	{0x3612, 0x5c},
+	{0x3613, 0xca},
+	{0x3614, 0x60},
+	{0x3628, 0xff},
+	{0x3629, 0xff},
+	{0x362a, 0xff},
+	{0x3633, 0x10},
+	{0x3634, 0x10},
+	{0x3635, 0x10},
+	{0x3636, 0x10},
+	{0x3663, 0x08},
+	{0x3669, 0x34},
+	{0x366d, 0x00},
+	{0x366e, 0x10},
+	{0x3706, 0x86},
+	{0x370b, 0x7e},
+	{0x3714, 0x23},
+	{0x3730, 0x12},
+	{0x3733, 0x10},
+	{0x3764, 0x00},
+	{0x3765, 0x00},
+	{0x3769, 0x62},
+	{0x376a, 0x2a},
+	{0x376b, 0x30},
+	{0x3780, 0x00},
+	{0x3781, 0x24},
+	{0x3782, 0x00},
+	{0x3783, 0x23},
+	{0x3798, 0x2f},
+	{0x37a1, 0x60},
+	{0x37a8, 0x6a},
+	{0x37ab, 0x3f},
+	{0x37c2, 0x04},
+	{0x37c3, 0xf1},
+	{0x37c9, 0x80},
+	{0x37cb, 0x16},
+	{0x37cc, 0x16},
+	{0x37cd, 0x16},
+	{0x37ce, 0x16},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x0c},
+	{0x3804, 0x0c},
+	{0x3805, 0xdf},
+	{0x3806, 0x09},
+	{0x3807, 0xa3},
+	{0x3808, 0x0c},
+	{0x3809, 0xc0},
+	{0x380a, 0x09},
+	{0x380b, 0x90},
+	{0x380c, 0x07},
+	{0x380d, 0x8c},
+	{0x380e, 0x09},
+	{0x380f, 0xb2},
+	{0x3810, 0x00},
+	{0x3811, 0x04},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x80},
+	{0x3821, 0x46},
+	{0x382a, 0x01},
+	{0x382b, 0x01},
+	{0x3830, 0x06},
+	{0x3836, 0x02},
+	{0x3862, 0x04},
+	{0x3863, 0x08},
+	{0x3cc0, 0x33},
+	{0x3d85, 0x17},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xde},
+	{0x4001, 0xe0},
+	{0x4003, 0x40},
+	{0x4008, 0x00},
+	{0x4009, 0x0b},
+	{0x400a, 0x00},
+	{0x400b, 0x84},
+	{0x400f, 0x80},
+	{0x4010, 0xf0},
+	{0x4011, 0xff},
+	{0x4012, 0x02},
+	{0x4013, 0x01},
+	{0x4014, 0x01},
+	{0x4015, 0x01},
+	{0x4042, 0x00},
+	{0x4043, 0x80},
+	{0x4044, 0x00},
+	{0x4045, 0x80},
+	{0x4046, 0x00},
+	{0x4047, 0x80},
+	{0x4048, 0x00},
+	{0x4049, 0x80},
+	{0x4041, 0x03},
+	{0x404c, 0x20},
+	{0x404d, 0x00},
+	{0x404e, 0x20},
+	{0x4203, 0x80},
+	{0x4307, 0x30},
+	{0x4317, 0x00},
+	{0x4502, 0x50},
+	{0x4503, 0x08},
+	{0x4601, 0x80},
+	{0x4800, 0x44},
+	{0x4816, 0x53},
+	{0x481b, 0x50},
+	{0x481f, 0x27},
+	{0x4823, 0x3c},
+	{0x482b, 0x00},
+	{0x4831, 0x66},
+	{0x4837, 0x16},
+	{0x483c, 0x0f},
+	{0x484b, 0x05},
+	{0x5000, 0x77},
+	{0x5001, 0x0a},
+	{0x5003, 0xc8},
+	{0x5004, 0x04},
+	{0x5006, 0x00},
+	{0x5007, 0x00},
+	{0x502e, 0x03},
+	{0x5030, 0x41},
+	{0x5780, 0x14},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x04},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x5795, 0x02},
+	{0x5796, 0x20},
+	{0x5797, 0x20},
+	{0x5798, 0xd5},
+	{0x5799, 0xd5},
+	{0x579a, 0x00},
+	{0x579b, 0x50},
+	{0x579c, 0x00},
+	{0x579d, 0x2c},
+	{0x579e, 0x0c},
+	{0x579f, 0x40},
+	{0x57a0, 0x09},
+	{0x57a1, 0x40},
+	{0x59f8, 0x3d},
+	{0x5a08, 0x02},
+	{0x5b00, 0x02},
+	{0x5b01, 0x10},
+	{0x5b02, 0x03},
+	{0x5b03, 0xcf},
+	{0x5b05, 0x6c},
+	{0x5e00, 0x00},
+	{0x5e10, 0xfc}
+};
+
 static const struct ov8856_reg mode_1640x1232_regs[] = {
 	{0x3000, 0x20},
 	{0x3003, 0x08},
@@ -506,6 +720,208 @@ static const struct ov8856_reg mode_1640x1232_regs[] = {
 	{0x5e00, 0x00}
 };
 
+static const struct ov8856_reg mode_1632x1224_regs[] = {
+	{0x0103, 0x01},
+	{0x0302, 0x3c},
+	{0x0303, 0x01},
+	{0x031e, 0x0c},
+	{0x3000, 0x00},
+	{0x300e, 0x00},
+	{0x3010, 0x00},
+	{0x3015, 0x84},
+	{0x3018, 0x72},
+	{0x3021, 0x23},
+	{0x3033, 0x24},
+	{0x3500, 0x00},
+	{0x3501, 0x4c},
+	{0x3502, 0xe0},
+	{0x3503, 0x08},
+	{0x3505, 0x83},
+	{0x3508, 0x01},
+	{0x3509, 0x80},
+	{0x350c, 0x00},
+	{0x350d, 0x80},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x72},
+	{0x3601, 0x40},
+	{0x3602, 0x30},
+	{0x3610, 0xc5},
+	{0x3611, 0x58},
+	{0x3612, 0x5c},
+	{0x3613, 0xca},
+	{0x3614, 0x60},
+	{0x3628, 0xff},
+	{0x3629, 0xff},
+	{0x362a, 0xff},
+	{0x3633, 0x10},
+	{0x3634, 0x10},
+	{0x3635, 0x10},
+	{0x3636, 0x10},
+	{0x3663, 0x08},
+	{0x3669, 0x34},
+	{0x366d, 0x00},
+	{0x366e, 0x08},
+	{0x3706, 0x86},
+	{0x370b, 0x7e},
+	{0x3714, 0x27},
+	{0x3730, 0x12},
+	{0x3733, 0x10},
+	{0x3764, 0x00},
+	{0x3765, 0x00},
+	{0x3769, 0x62},
+	{0x376a, 0x2a},
+	{0x376b, 0x30},
+	{0x3780, 0x00},
+	{0x3781, 0x24},
+	{0x3782, 0x00},
+	{0x3783, 0x23},
+	{0x3798, 0x2f},
+	{0x37a1, 0x60},
+	{0x37a8, 0x6a},
+	{0x37ab, 0x3f},
+	{0x37c2, 0x14},
+	{0x37c3, 0xf1},
+	{0x37c9, 0x80},
+	{0x37cb, 0x16},
+	{0x37cc, 0x16},
+	{0x37cd, 0x16},
+	{0x37ce, 0x16},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x0c},
+	{0x3804, 0x0c},
+	{0x3805, 0xdf},
+	{0x3806, 0x09},
+	{0x3807, 0xa3},
+	{0x3808, 0x06},
+	{0x3809, 0x60},
+	{0x380a, 0x04},
+	{0x380b, 0xc8},
+	{0x380c, 0x07},
+	{0x380d, 0x8c},
+	{0x380e, 0x09},
+	{0x380f, 0xb2},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x03},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x80},
+	{0x3821, 0x47},
+	{0x382a, 0x03},
+	{0x382b, 0x01},
+	{0x3830, 0x06},
+	{0x3836, 0x02},
+	{0x3862, 0x04},
+	{0x3863, 0x08},
+	{0x3cc0, 0x33},
+	{0x3d85, 0x17},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xde},
+	{0x4001, 0xe0},
+	{0x4003, 0x40},
+	{0x4008, 0x00},
+	{0x4009, 0x05},
+	{0x400a, 0x00},
+	{0x400b, 0x84},
+	{0x400f, 0x80},
+	{0x4010, 0xf0},
+	{0x4011, 0xff},
+	{0x4012, 0x02},
+	{0x4013, 0x01},
+	{0x4014, 0x01},
+	{0x4015, 0x01},
+	{0x4042, 0x00},
+	{0x4043, 0x80},
+	{0x4044, 0x00},
+	{0x4045, 0x80},
+	{0x4046, 0x00},
+	{0x4047, 0x80},
+	{0x4048, 0x00},
+	{0x4049, 0x80},
+	{0x4041, 0x03},
+	{0x404c, 0x20},
+	{0x404d, 0x00},
+	{0x404e, 0x20},
+	{0x4203, 0x80},
+	{0x4307, 0x30},
+	{0x4317, 0x00},
+	{0x4502, 0x50},
+	{0x4503, 0x08},
+	{0x4601, 0x80},
+	{0x4800, 0x44},
+	{0x4816, 0x53},
+	{0x481b, 0x50},
+	{0x481f, 0x27},
+	{0x4823, 0x3c},
+	{0x482b, 0x00},
+	{0x4831, 0x66},
+	{0x4837, 0x16},
+	{0x483c, 0x0f},
+	{0x484b, 0x05},
+	{0x5000, 0x77},
+	{0x5001, 0x0a},
+	{0x5003, 0xc8},
+	{0x5004, 0x04},
+	{0x5006, 0x00},
+	{0x5007, 0x00},
+	{0x502e, 0x03},
+	{0x5030, 0x41},
+	{0x5795, 0x00},
+	{0x5796, 0x10},
+	{0x5797, 0x10},
+	{0x5798, 0x73},
+	{0x5799, 0x73},
+	{0x579a, 0x00},
+	{0x579b, 0x28},
+	{0x579c, 0x00},
+	{0x579d, 0x16},
+	{0x579e, 0x06},
+	{0x579f, 0x20},
+	{0x57a0, 0x04},
+	{0x57a1, 0xa0},
+	{0x5780, 0x14},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x04},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x59f8, 0x3d},
+	{0x5a08, 0x02},
+	{0x5b00, 0x02},
+	{0x5b01, 0x10},
+	{0x5b02, 0x03},
+	{0x5b03, 0xcf},
+	{0x5b05, 0x6c},
+	{0x5e00, 0x00},
+	{0x5e10, 0xfc}
+};
+
 static const char * const ov8856_test_pattern_menu[] = {
 	"Disabled",
 	"Standard Color Bar",
@@ -547,6 +963,18 @@ static const struct ov8856_mode supported_modes[] = {
 		},
 		.link_freq_index = OV8856_LINK_FREQ_720MBPS,
 	},
+	{
+		.width    = 3264,
+		.height   = 2448,
+		.hts      = 1932,
+		.vts_def  = 2482,
+		.vts_min  = 2482,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_3264x2448_regs),
+			.regs = mode_3264x2448_regs,
+		},
+		.link_freq_index = OV8856_LINK_FREQ_720MBPS,
+	},
 	{
 		.width = 1640,
 		.height = 1232,
@@ -558,6 +986,18 @@ static const struct ov8856_mode supported_modes[] = {
 			.regs = mode_1640x1232_regs,
 		},
 		.link_freq_index = OV8856_LINK_FREQ_360MBPS,
+	},
+	{
+		.width    = 1632,
+		.height   = 1224,
+		.hts      = 1932,
+		.vts_def  = 2482,
+		.vts_min  = 2482,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1632x1224_regs),
+			.regs = mode_1632x1224_regs,
+		},
+		.link_freq_index = OV8856_LINK_FREQ_360MBPS,
 	}
 };
 
@@ -566,6 +1006,10 @@ struct ov8856 {
 	struct media_pad pad;
 	struct v4l2_ctrl_handler ctrl_handler;
 
+	struct clk		*xvclk;
+	struct gpio_desc	*reset_gpio;
+	struct regulator_bulk_data supplies[OV8856_NUM_SUPPLIES];
+
 	/* V4L2 Controls */
 	struct v4l2_ctrl *link_freq;
 	struct v4l2_ctrl *pixel_rate;
@@ -825,7 +1269,13 @@ static void ov8856_update_pad_format(const struct ov8856_mode *mode,
 {
 	fmt->width = mode->width;
 	fmt->height = mode->height;
-	fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	/* choose bayer order from image resolution */
+	if (fmt->width == 3264 || fmt->width == 1632)
+		fmt->code = MEDIA_BUS_FMT_SBGGR10_1X10;
+	else
+		fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
 	fmt->field = V4L2_FIELD_NONE;
 }
 
@@ -836,6 +1286,7 @@ static int ov8856_start_streaming(struct ov8856 *ov8856)
 	int link_freq_index, ret;
 
 	link_freq_index = ov8856->cur_mode->link_freq_index;
+	dev_info(&client->dev, "%s link_freq_index %d\n", __func__, link_freq_index);
 	reg_list = &link_freq_configs[link_freq_index].reg_list;
 	ret = ov8856_write_reg_list(ov8856, reg_list);
 	if (ret) {
@@ -879,6 +1330,8 @@ static int ov8856_set_stream(struct v4l2_subdev *sd, int enable)
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret = 0;
 
+	dev_info(&client->dev, "ov8856 s_stream (%d)\n", enable);
+
 	if (ov8856->streaming == enable)
 		return 0;
 
@@ -908,6 +1361,54 @@ static int ov8856_set_stream(struct v4l2_subdev *sd, int enable)
 	return ret;
 }
 
+/* Calculate the delay in us by clock rate and clock cycles */
+static inline u32 ov8856_cal_delay(u32 cycles)
+{
+	return DIV_ROUND_UP(cycles, OV8856_XVCLK_FREQ / 1000 / 1000);
+}
+
+static int __ov8856_power_on(struct ov8856 *ov8856)
+{
+	int ret;
+	u32 delay_us;
+	struct i2c_client *client = v4l2_get_subdevdata(&ov8856->sd);
+
+	ret = clk_prepare_enable(ov8856->xvclk);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to enable xvclk\n");
+		return ret;
+	}
+
+	gpiod_set_value_cansleep(ov8856->reset_gpio, 1);
+
+	ret = regulator_bulk_enable(OV8856_NUM_SUPPLIES, ov8856->supplies);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to enable regulators\n");
+		goto disable_clk;
+	}
+
+	gpiod_set_value_cansleep(ov8856->reset_gpio, 0);
+
+	/* 8192 cycles prior to first SCCB transaction */
+	delay_us = ov8856_cal_delay(8192);
+	usleep_range(delay_us  * 2, delay_us * 4);
+
+	return 0;
+
+disable_clk:
+	clk_disable_unprepare(ov8856->xvclk);
+
+	return ret;
+}
+
+static void __ov8856_power_off(struct ov8856 *ov8856)
+{
+	clk_disable_unprepare(ov8856->xvclk);
+	gpiod_set_value_cansleep(ov8856->reset_gpio, 1);
+
+	regulator_bulk_disable(OV8856_NUM_SUPPLIES, ov8856->supplies);
+}
+
 static int __maybe_unused ov8856_suspend(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
@@ -915,8 +1416,8 @@ static int __maybe_unused ov8856_suspend(struct device *dev)
 	struct ov8856 *ov8856 = to_ov8856(sd);
 
 	mutex_lock(&ov8856->mutex);
-	if (ov8856->streaming)
-		ov8856_stop_streaming(ov8856);
+
+	__ov8856_power_off(ov8856);
 
 	mutex_unlock(&ov8856->mutex);
 
@@ -1089,6 +1590,8 @@ static int ov8856_identify_module(struct ov8856 *ov8856)
 		return -ENXIO;
 	}
 
+	dev_info(&client->dev, "Detected OV%04X sensor\n", val);
+
 	return 0;
 }
 
@@ -1164,16 +1667,34 @@ static int ov8856_remove(struct i2c_client *client)
 	media_entity_cleanup(&sd->entity);
 	v4l2_ctrl_handler_free(sd->ctrl_handler);
 	pm_runtime_disable(&client->dev);
+	if (!pm_runtime_status_suspended(&client->dev))
+		__ov8856_power_off(ov8856);
+	pm_runtime_set_suspended(&client->dev);
 	mutex_destroy(&ov8856->mutex);
 
 	return 0;
 }
 
+static int ov8856_configure_regulators(struct ov8856 *ov8856)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov8856->sd);
+	int i;
+
+	for (i = 0; i < OV8856_NUM_SUPPLIES; i++)
+		ov8856->supplies[i].supply = ov8856_supply_names[i];
+
+	return devm_regulator_bulk_get(&client->dev,
+				       OV8856_NUM_SUPPLIES,
+				       ov8856->supplies);
+}
+
 static int ov8856_probe(struct i2c_client *client)
 {
 	struct ov8856 *ov8856;
 	int ret;
 
+	dev_info(&client->dev, "ov8856 probe ++\n");
+
 	ret = ov8856_check_hwcfg(&client->dev);
 	if (ret) {
 		dev_err(&client->dev, "failed to check HW configuration: %d",
@@ -1186,6 +1707,37 @@ static int ov8856_probe(struct i2c_client *client)
 		return -ENOMEM;
 
 	v4l2_i2c_subdev_init(&ov8856->sd, client, &ov8856_subdev_ops);
+
+	ov8856->xvclk = devm_clk_get(&client->dev, "xvclk");
+	if (IS_ERR(ov8856->xvclk)) {
+		dev_err(&client->dev, "Failed to get xvclk\n");
+		return -EINVAL;
+	}
+
+	ret = clk_set_rate(ov8856->xvclk, OV8856_XVCLK_FREQ);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to set xvclk rate (24MHz)\n");
+		return ret;
+	}
+	if (clk_get_rate(ov8856->xvclk) != OV8856_XVCLK_FREQ)
+		dev_warn(&client->dev, "xvclk mismatched, modes are based on 24MHz\n");
+
+	ov8856->reset_gpio = devm_gpiod_get(&client->dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ov8856->reset_gpio)) {
+		dev_err(&client->dev, "Failed to get reset-gpios\n");
+		return -EINVAL;
+	}
+
+	ret = ov8856_configure_regulators(ov8856);
+	if (ret) {
+		dev_err(&client->dev, "Failed to get power regulators\n");
+		return ret;
+	}
+
+	ret = __ov8856_power_on(ov8856);
+	if (ret)
+		goto probe_error_v4l2_ctrl_handler_free;
+
 	ret = ov8856_identify_module(ov8856);
 	if (ret) {
 		dev_err(&client->dev, "failed to find sensor: %d", ret);
@@ -1226,6 +1778,8 @@ static int ov8856_probe(struct i2c_client *client)
 	pm_runtime_enable(&client->dev);
 	pm_runtime_idle(&client->dev);
 
+	dev_info(&client->dev, "ov8856 probe --\n");
+
 	return 0;
 
 probe_error_media_entity_cleanup:
@@ -1251,11 +1805,21 @@ static const struct acpi_device_id ov8856_acpi_ids[] = {
 MODULE_DEVICE_TABLE(acpi, ov8856_acpi_ids);
 #endif
 
+#if IS_ENABLED(CONFIG_OF)
+static const struct of_device_id ov8856_of_match[] = {
+	{ .compatible = "ovti,ov8856" },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, ov8856_of_match);
+#endif
+
 static struct i2c_driver ov8856_i2c_driver = {
 	.driver = {
 		.name = "ov8856",
 		.pm = &ov8856_pm_ops,
 		.acpi_match_table = ACPI_PTR(ov8856_acpi_ids),
+		.of_match_table = of_match_ptr(ov8856_of_match),
 	},
 	.probe_new = ov8856_probe,
 	.remove = ov8856_remove,
diff --git a/drivers/media/media-device.c b/drivers/media/media-device.c
index b8ec88612df7..6893843edada 100644
--- a/drivers/media/media-device.c
+++ b/drivers/media/media-device.c
@@ -502,6 +502,7 @@ static long media_device_enum_links32(struct media_device *mdev,
 {
 	struct media_links_enum links;
 	compat_uptr_t pads_ptr, links_ptr;
+	int ret;
 
 	memset(&links, 0, sizeof(links));
 
@@ -513,7 +514,13 @@ static long media_device_enum_links32(struct media_device *mdev,
 	links.pads = compat_ptr(pads_ptr);
 	links.links = compat_ptr(links_ptr);
 
-	return media_device_enum_links(mdev, &links);
+	ret = media_device_enum_links(mdev, &links);
+	if (ret)
+		return ret;
+
+	memset(ulinks->reserved, 0, sizeof(ulinks->reserved));
+
+	return 0;
 }
 
 #define MEDIA_IOC_ENUM_LINKS32		_IOWR('|', 0x02, struct media_links_enum32)
diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 0dfb22114c49..919129eef895 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -32,6 +32,8 @@ source "drivers/media/platform/davinci/Kconfig"
 
 source "drivers/media/platform/omap/Kconfig"
 
+source "drivers/media/platform/mtk-isp/Kconfig"
+
 config VIDEO_SH_VOU
 	tristate "SuperH VOU video output driver"
 	depends on MEDIA_CAMERA_SUPPORT
@@ -224,6 +226,24 @@ config VIDEO_MEDIATEK_MDP
 	    To compile this driver as a module, choose M here: the
 	    module will be called mtk-mdp.
 
+config VIDEO_MEDIATEK_MDP3
+	tristate "Mediatek MDP v3 driver"
+	depends on MTK_IOMMU || COMPILE_TEST
+	depends on VIDEO_DEV && VIDEO_V4L2
+	depends on ARCH_MEDIATEK || COMPILE_TEST
+	depends on HAS_DMA
+	select VIDEOBUF2_DMA_CONTIG
+	select V4L2_MEM2MEM_DEV
+	select VIDEO_MEDIATEK_VPU
+	select MTK_CMDQ
+	default n
+	help
+	    It is a v4l2 driver and present in Mediatek MT8183 SoC.
+	    The driver supports for scaling and color space conversion.
+
+	    To compile this driver as a module, choose M here: the
+	    module will be called mtk-mdp3.
+
 config VIDEO_MEDIATEK_VCODEC
 	tristate "Mediatek Video Codec driver"
 	depends on MTK_IOMMU || COMPILE_TEST
diff --git a/drivers/media/platform/Makefile b/drivers/media/platform/Makefile
index 41322ab65802..bb29deb0d1f2 100644
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -70,6 +70,8 @@ obj-$(CONFIG_VIDEO_ROCKCHIP_RGA)	+= rockchip/rga/
 
 obj-y	+= omap/
 
+obj-y	+= mtk-isp/
+
 obj-$(CONFIG_VIDEO_AM437X_VPFE)		+= am437x/
 
 obj-$(CONFIG_VIDEO_XILINX)		+= xilinx/
@@ -86,6 +88,7 @@ obj-$(CONFIG_VIDEO_MEDIATEK_VPU)	+= mtk-vpu/
 obj-$(CONFIG_VIDEO_MEDIATEK_VCODEC)	+= mtk-vcodec/
 
 obj-$(CONFIG_VIDEO_MEDIATEK_MDP)	+= mtk-mdp/
+obj-$(CONFIG_VIDEO_MEDIATEK_MDP3)	+= mtk-mdp3/
 
 obj-$(CONFIG_VIDEO_MEDIATEK_JPEG)	+= mtk-jpeg/
 
diff --git a/drivers/media/platform/mtk-isp/Kconfig b/drivers/media/platform/mtk-isp/Kconfig
new file mode 100644
index 000000000000..f6f8550991a3
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/Kconfig
@@ -0,0 +1,73 @@
+config VIDEO_MEDIATEK_FD_SUPPORT
+	bool "Mediatek face detection processing function"
+	select DMA_SHARED_BUFFER
+	select VIDEO_V4L2_SUBDEV_API
+	select VIDEOBUF2_DMA_CONTIG
+	select VIDEOBUF2_CORE
+	select VIDEOBUF2_V4L2
+	select VIDEOBUF2_MEMOPS
+	select VIDEOBUF2_VMALLOC
+	select MEDIA_CONTROLLER
+
+	default n
+	help
+		Support the basic Face Detectioin (FD) feature.
+
+		FD driver provide face detection function, it can detect
+		faces of Rotation-in-Plane from -180 degrees to +180 degrees
+		and Rotation-off-Plane from -90 degrees to +90 degrees.
+
+config VIDEO_MEDIATEK_ISP_DIP_SUPPORT
+	bool "Mediatek Digital Image Processing function"
+	select DMA_SHARED_BUFFER
+	select VIDEO_V4L2_SUBDEV_API
+	select VIDEOBUF2_DMA_CONTIG
+	select VIDEOBUF2_CORE
+	select VIDEOBUF2_V4L2
+	select VIDEOBUF2_MEMOPS
+	select VIDEOBUF2_VMALLOC
+	select MEDIA_CONTROLLER
+
+	default n
+	help
+	    Support the basic Digital Image Processing (DIP) driver.
+
+	    DIP driver provides image format conversion, resizing,
+	    and rotation function through the low power hardware.
+	    DIP also supports multiple output feature. It can
+	    generate two or more output image with different effect
+	    based on a single input image at the same time.
+
+config VIDEO_MEDIATEK_ISP_PASS1
+	bool "Mediatek Pass 1 image processing function"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	depends on MEDIA_CONTROLLER && VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	select VIDEOBUF2_DMA_CONTIG
+	default n
+	help
+		Pass 1 driver controls 3A (auto-focus, exposure,
+		and white balance) with tuning feature and outputs
+		the captured image buffers in Mediatek's camera system.
+
+		Choose y if you want to use Mediatek SoCs to create image
+		captured application such as video recording and still image
+		capturing.
+
+config MTK_SENINF
+	bool "Mediatek mipi csi2 driver"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	depends on MEDIA_CAMERA_SUPPORT
+	select V4L2_FWNODE
+
+	default n
+	help
+	    This driver provides a mipi-csi2 host driver used as a
+	    interface to connect camera with Mediatek's
+	    MT8183 SOCs. It is able to handle multiple cameras
+	    at the same time.
+
+	    Choose y if you want to use Mediatek SoCs to create image
+	    capture application such as video recording and still image
+	    capture.
+
diff --git a/drivers/media/platform/mtk-isp/Makefile b/drivers/media/platform/mtk-isp/Makefile
new file mode 100644
index 000000000000..ccb1334b223b
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+
+obj-y += isp_50/
+
+ifeq ($(CONFIG_VIDEO_MEDIATEK_FD_SUPPORT),y)
+obj-y += fd/
+endif
diff --git a/drivers/media/platform/mtk-isp/fd/Makefile b/drivers/media/platform/mtk-isp/fd/Makefile
new file mode 100644
index 000000000000..f2b64cf53da9
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/fd/Makefile
@@ -0,0 +1,25 @@
+#
+# Copyright (C) 2018 MediaTek Inc.
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+$(info $(srctree))
+ccflags-y += -I$(srctree)/drivers/media/platform/mtk-mdp3
+
+obj-y += mtk_fd_40.o
+obj-y += mtk_fd-v4l2.o
+
+# To provide alloc context managing memory shared
+# between CPU and camera coprocessor
+obj-y += mtk_fd-smem.o
+
+# Utilits to provide frame-based streaming model
+# with v4l2 user interfaces
+obj-y += mtk_fd-dev.o
diff --git a/drivers/media/platform/mtk-isp/fd/mtk_fd-dev.c b/drivers/media/platform/mtk-isp/fd/mtk_fd-dev.c
new file mode 100644
index 000000000000..f7d5de7b410a
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/fd/mtk_fd-dev.c
@@ -0,0 +1,754 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/platform_device.h>
+#include <media/videobuf2-dma-contig.h>
+#include "mtk_fd-dev.h"
+#include "mtk_fd-smem.h"
+#include "mtk-mdp3-regs.h"
+
+int mtk_fd_pipe_init(struct mtk_fd_pipe *fd_pipe,
+		     struct mtk_fd_dev *fd_dev,
+		     struct mtk_fd_pipe_desc *setting,
+		     struct media_device *media_dev,
+		     struct v4l2_device *v4l2_dev,
+		     struct device *smem_alloc_dev)
+{
+	int ret, i;
+
+	fd_pipe->fd_dev = fd_dev;
+	fd_pipe->desc = setting;
+	fd_pipe->smem_alloc_dev = smem_alloc_dev;
+
+	atomic_set(&fd_pipe->pipe_job_sequence, 0);
+	spin_lock_init(&fd_pipe->job_lock);
+	mutex_init(&fd_pipe->lock);
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev, "init pipe(%s,%d)\n",
+		fd_pipe->desc->name,
+		fd_pipe->desc->id);
+
+	fd_pipe->num_nodes = MTK_FD_VIDEO_NODE_ID_TOTAL_NUM;
+
+	for (i = 0; i < MTK_FD_VIDEO_NODE_ID_OUT_TOTAL_NUM; i++) {
+		fd_pipe->nodes[i].desc =
+			&fd_pipe->desc->output_queue_descs[i];
+		fd_pipe->nodes[i].immutable = 0;
+		fd_pipe->nodes[i].enabled =
+			fd_pipe->nodes[i].desc->default_enable;
+		atomic_set(&fd_pipe->nodes[i].sequence, 0);
+
+		dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+			"%s: init node(%s,%d)\n",
+			fd_pipe->desc->name,
+			fd_pipe->nodes[i].desc->name, i);
+	}
+
+	for (i = MTK_FD_VIDEO_NODE_ID_OUT_TOTAL_NUM;
+	     i < MTK_FD_VIDEO_NODE_ID_TOTAL_NUM; i++) {
+		int cap_idx = i - MTK_FD_VIDEO_NODE_ID_OUT_TOTAL_NUM;
+
+		fd_pipe->nodes[i].desc =
+			&fd_pipe->desc->capture_queue_descs[cap_idx];
+		fd_pipe->nodes[i].immutable = 0;
+		fd_pipe->nodes[i].enabled =
+			fd_pipe->nodes[i].desc->default_enable;
+		atomic_set(&fd_pipe->nodes[i].sequence, 0);
+
+		dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+			"%s: init node(%s,%d)\n",
+			fd_pipe->desc->name,
+			fd_pipe->nodes[i].desc->name, i);
+	}
+
+	if (fd_pipe->desc->master >= 0 &&
+	    fd_pipe->desc->master < MTK_FD_VIDEO_NODE_ID_TOTAL_NUM) {
+		fd_pipe->nodes[fd_pipe->desc->master].immutable = 1;
+		fd_pipe->nodes[fd_pipe->desc->master].enabled = 1;
+	}
+
+	ret = mtk_fd_pipe_v4l2_register(fd_pipe, media_dev, v4l2_dev);
+
+	if (ret) {
+		dev_err(&fd_pipe->fd_dev->pdev->dev,
+			"%s: failed(%d) to create V4L2 devices\n",
+			fd_pipe->desc->name, ret);
+		goto failed_pipe;
+	}
+
+	return 0;
+
+failed_pipe:
+	mutex_destroy(&fd_pipe->lock);
+	return ret;
+}
+
+static int mtk_fd_pipe_next_job_id(struct mtk_fd_pipe *fd_pipe)
+{
+	int global_job_id =
+		atomic_inc_return(&fd_pipe->pipe_job_sequence);
+
+	global_job_id =
+		(global_job_id & 0x0000FFFF) |
+		(fd_pipe->desc->id << 16);
+
+	return global_job_id;
+}
+
+int mtk_fd_pipe_init_job_infos(struct mtk_fd_pipe *fd_pipe)
+{
+	int i;
+
+	spin_lock(&fd_pipe->job_lock);
+
+	fd_pipe->num_pipe_job_infos = ARRAY_SIZE(fd_pipe->pipe_job_infos);
+	INIT_LIST_HEAD(&fd_pipe->pipe_job_running_list);
+	INIT_LIST_HEAD(&fd_pipe->pipe_job_free_list);
+
+	for (i = 0; i < fd_pipe->num_pipe_job_infos; i++) {
+		struct mtk_fd_pipe_job_info *pipe_job_info =
+			&fd_pipe->pipe_job_infos[i];
+		list_add_tail(&pipe_job_info->list,
+			      &fd_pipe->pipe_job_free_list);
+	}
+
+	spin_unlock(&fd_pipe->job_lock);
+
+	return 0;
+}
+
+static int
+mtk_fd_pipe_process_pipe_job_info(struct mtk_fd_pipe *fd_pipe,
+				  struct mtk_fd_pipe_job_info *pipe_job_info)
+{
+	spin_lock(&fd_pipe->job_lock);
+
+	list_del(&pipe_job_info->list);
+	list_add_tail(&pipe_job_info->list, &fd_pipe->pipe_job_running_list);
+
+	spin_unlock(&fd_pipe->job_lock);
+	return 0;
+}
+
+struct mtk_fd_pipe_job_info *
+mtk_fd_pipe_get_running_job_info(struct mtk_fd_pipe *fd_pipe,
+				 int pipe_job_id)
+{
+	struct mtk_fd_pipe_job_info *pipe_job_info = NULL;
+
+	spin_lock(&fd_pipe->job_lock);
+
+	list_for_each_entry(pipe_job_info,
+			    &fd_pipe->pipe_job_running_list, list) {
+		if (pipe_job_info->id == pipe_job_id) {
+			spin_unlock(&fd_pipe->job_lock);
+			return pipe_job_info;
+		}
+	}
+
+	spin_unlock(&fd_pipe->job_lock);
+
+	return NULL;
+}
+
+static int
+mtk_fd_pipe_free_job_info(struct mtk_fd_pipe *fd_pipe,
+			  struct mtk_fd_pipe_job_info *pipe_job_info)
+{
+	spin_lock(&fd_pipe->job_lock);
+
+	list_del(&pipe_job_info->list);
+	list_add_tail(&pipe_job_info->list, &fd_pipe->pipe_job_free_list);
+
+	spin_unlock(&fd_pipe->job_lock);
+
+	return 0;
+}
+
+static struct mtk_fd_pipe_job_info *
+mtk_fd_pipe_get_free_job_info(struct mtk_fd_pipe *fd_pipe)
+{
+	struct mtk_fd_pipe_job_info *pipe_job_info = NULL;
+
+	spin_lock(&fd_pipe->job_lock);
+	list_for_each_entry(pipe_job_info,
+			    &fd_pipe->pipe_job_free_list, list) {
+		dev_dbg(&fd_pipe->fd_dev->pdev->dev, "Found free pipe job\n");
+		spin_unlock(&fd_pipe->job_lock);
+		return pipe_job_info;
+	}
+	spin_unlock(&fd_pipe->job_lock);
+
+	dev_err(&fd_pipe->fd_dev->pdev->dev,
+		"%s: can't found free pipe job\n",
+		fd_pipe->desc->name);
+
+	return NULL;
+}
+
+static void
+mtk_fd_pipe_update_job_info(struct mtk_fd_pipe *fd_pipe,
+			    struct mtk_fd_pipe_job_info *pipe_job_info,
+			    struct mtk_fd_video_device *node,
+			    struct mtk_fd_dev_buffer *dev_buf)
+{
+	if (!pipe_job_info || !dev_buf || !node) {
+		dev_err(&fd_pipe->fd_dev->pdev->dev,
+			"%s: update pipe-job(%p) failed, buf(%p),node(%p)\n",
+			fd_pipe->desc->name,
+			pipe_job_info, dev_buf, node);
+		return;
+	}
+
+	if (pipe_job_info->buf_map[node->desc->id])
+		dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+			"%s:%s: buf overwrite\n",
+			 fd_pipe->desc->name,
+			 node->desc->name);
+
+	if (node->desc->buf_type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		pipe_job_info->num_img_capture_bufs++;
+
+	if (node->desc->buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		pipe_job_info->num_img_output_bufs++;
+
+	if (node->desc->buf_type == V4L2_BUF_TYPE_META_OUTPUT)
+		pipe_job_info->num_meta_output_bufs++;
+
+	if (node->desc->buf_type == V4L2_BUF_TYPE_META_CAPTURE)
+		pipe_job_info->num_meta_capture_bufs++;
+
+	pipe_job_info->buf_map[node->desc->id] = dev_buf;
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s:%s: added buf(%p) to pipe-job(%p)\n",
+		fd_pipe->desc->name, node->desc->name, dev_buf,
+		pipe_job_info);
+}
+
+static void mtk_fd_pipe_debug_job(struct mtk_fd_pipe *fd_pipe,
+				  struct mtk_fd_pipe_job_info *pipe_job_info)
+{
+	int i;
+
+	if (!fd_pipe || !pipe_job_info)
+		return;
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s: pipe-job(%p),id(%d),req(%p)buf nums(%d,%d,%d,%d)\n",
+		fd_pipe->desc->name,
+		pipe_job_info,
+		pipe_job_info->id,
+		pipe_job_info->req,
+		pipe_job_info->num_img_capture_bufs,
+		pipe_job_info->num_img_output_bufs,
+		pipe_job_info->num_meta_capture_bufs,
+		pipe_job_info->num_meta_output_bufs);
+
+	for (i = 0; i < MTK_FD_VIDEO_NODE_ID_TOTAL_NUM ; i++) {
+		if (pipe_job_info->buf_map[i])
+			dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+				"Node(%s,%d), buf(%p)\n",
+				fd_pipe->nodes[i].desc->name, i,
+				pipe_job_info->buf_map[i]);
+	}
+}
+
+int mtk_fd_pipe_job_finish(struct mtk_fd_pipe *fd_pipe,
+			   unsigned int pipe_job_info_id,
+			   enum vb2_buffer_state vbf_state)
+{
+	int i;
+	struct mtk_fd_pipe_job_info *job_info = NULL;
+	const int pipe_id =
+		mtk_fd_pipe_get_pipe_from_job_id(pipe_job_info_id);
+	u64 timestamp = 0;
+
+	if (!fd_pipe)
+		pr_err("%s: pipe-job id(%d) release failed, fd_pipe is null\n",
+		       __func__, pipe_job_info_id);
+
+	job_info = mtk_fd_pipe_get_running_job_info(fd_pipe,
+						    pipe_job_info_id);
+
+	if (!job_info) {
+		dev_err(&fd_pipe->fd_dev->pdev->dev,
+			"%s:%s: can't find pipe-job id(%d)\n",
+			__func__, fd_pipe->desc->name, pipe_id);
+		return -EINVAL;
+	}
+
+	timestamp = ktime_get_ns();
+
+	for (i = 0; i < MTK_FD_VIDEO_NODE_ID_TOTAL_NUM; i++) {
+		struct mtk_fd_dev_buffer *dev_buf = job_info->buf_map[i];
+
+		if (!dev_buf) {
+			continue;
+		} else {
+			dev_buf->vbb.vb2_buf.timestamp = ktime_get_ns();
+			mtk_fd_v4l2_buffer_done(&dev_buf->vbb.vb2_buf,
+						vbf_state);
+		}
+	}
+
+	mtk_fd_pipe_free_job_info(fd_pipe, job_info);
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s:%s: finish pipe-job, id(%d), vb state(%d)\n",
+		__func__, fd_pipe->desc->name, pipe_id,
+		pipe_job_info_id, vbf_state);
+
+	return 0;
+}
+
+static void mtk_fd_dev_buf_fill_info(struct mtk_fd_pipe *fd_pipe,
+				     struct mtk_fd_dev_buffer *dev_buf)
+{
+	struct vb2_v4l2_buffer *b;
+	struct mtk_fd_video_device *node;
+	struct mtk_fd_video_device_desc *desc;
+
+	b = &dev_buf->vbb;
+	node = mtk_fd_vbq_to_node(b->vb2_buf.vb2_queue);
+	desc = node->desc;
+	dev_buf->fmt = node->vdev_fmt;
+	dev_buf->dev_fmt = node->dev_q.dev_fmt;
+	dev_buf->isp_daddr =
+		vb2_dma_contig_plane_dma_addr(&b->vb2_buf, 0);
+	dev_buf->vaddr = vb2_plane_vaddr(&b->vb2_buf, 0);
+	dev_buf->buffer_usage = node->dev_q.buffer_usage;
+	dev_buf->rotation = node->dev_q.rotation;
+
+	if (desc->smem_alloc) {
+		dev_buf->scp_daddr =
+			mtk_fd_smem_iova_to_phys
+			(fd_pipe->smem_alloc_dev,
+			 dev_buf->isp_daddr);
+	} else {
+		dev_buf->scp_daddr = 0;
+	}
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s:%s: buf type(%d), idx(%d), mem(%d), isp_daddr(%p), scp_daddr(%p)\n",
+		fd_pipe->desc->name,
+		desc->name,
+		b->vb2_buf.type,
+		b->vb2_buf.index,
+		b->vb2_buf.memory,
+		dev_buf->isp_daddr,
+		dev_buf->scp_daddr);
+}
+
+int mtk_fd_pipe_queue_buffers(struct media_request *req,
+			      int initial)
+{
+	struct media_request_object *obj;
+	struct mtk_fd_pipe *fd_pipe;
+	struct mtk_fd_pipe_job_info *pipe_job_info = NULL;
+
+	list_for_each_entry(obj, &req->objects, list) {
+		struct vb2_buffer *vb;
+
+		if (vb2_request_object_is_buffer(obj)) {
+			struct mtk_fd_dev_buffer *buf;
+			struct mtk_fd_dev_buffer *dev_buf;
+			struct mtk_fd_video_device *node;
+
+			vb = container_of(obj, struct vb2_buffer, req_obj);
+			node = mtk_fd_vbq_to_node(vb->vb2_queue);
+			fd_pipe = vb2_get_drv_priv(vb->vb2_queue);
+			dev_buf = mtk_fd_vb2_buf_to_dev_buf(vb);
+			buf = dev_buf;
+
+			if (!pipe_job_info) {
+				pipe_job_info = mtk_fd_pipe_get_free_job_info
+					(fd_pipe);
+
+				if (!pipe_job_info)
+					goto FAILE_JOB_NOT_TRIGGER;
+
+				memset(pipe_job_info->buf_map, 0,
+				       sizeof(pipe_job_info->buf_map));
+				pipe_job_info->req = req;
+				pipe_job_info->num_img_capture_bufs = 0;
+				pipe_job_info->num_img_output_bufs = 0;
+				pipe_job_info->num_meta_capture_bufs = 0;
+				pipe_job_info->num_meta_output_bufs = 0;
+			}
+
+			mtk_fd_dev_buf_fill_info(fd_pipe,
+						 buf);
+
+			mtk_fd_pipe_update_job_info(fd_pipe,
+						    pipe_job_info,
+						     node,
+						     buf);
+		}
+	}
+
+	if (!pipe_job_info)
+		return -EINVAL;
+
+	pipe_job_info->id =
+		mtk_fd_pipe_next_job_id(fd_pipe);
+
+	mtk_fd_pipe_debug_job(fd_pipe, pipe_job_info);
+
+	mutex_lock(&fd_pipe->lock);
+
+	if (!fd_pipe->streaming) {
+		dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+			"%s:%s:  stream is off, no hw enqueue triggered\n",
+			__func__, fd_pipe->desc->name);
+		mutex_unlock(&fd_pipe->lock);
+		return 0;
+	}
+
+	if (mtk_fd_pipe_process_pipe_job_info(fd_pipe, pipe_job_info)) {
+		dev_err(&fd_pipe->fd_dev->pdev->dev,
+			"%s:%s: can't start to run pipe job id(%d)\n",
+			__func__, fd_pipe->desc->name,
+			pipe_job_info->id);
+		mutex_unlock(&fd_pipe->lock);
+		goto FAILE_JOB_NOT_TRIGGER;
+	}
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s: trigger pipe job, id(%d)\n",
+		fd_pipe->desc->name,
+		fd_pipe->desc->id);
+
+	if (mtk_fd_pipe_job_start(fd_pipe, pipe_job_info)) {
+		mutex_unlock(&fd_pipe->lock);
+		goto FAILE_JOB_NOT_TRIGGER;
+	}
+
+	mutex_unlock(&fd_pipe->lock);
+
+	return 0;
+
+FAILE_JOB_NOT_TRIGGER:
+	if (initial)
+		return 0;
+
+	mtk_fd_pipe_job_finish(fd_pipe, pipe_job_info->id,
+			       VB2_BUF_STATE_ERROR);
+
+	return -EINVAL;
+}
+
+int mtk_fd_pipe_release(struct mtk_fd_pipe *fd_pipe)
+{
+	mtk_fd_pipe_v4l2_unregister(fd_pipe);
+	mutex_destroy(&fd_pipe->lock);
+
+	return 0;
+}
+
+static void set_img_fmt(struct v4l2_pix_format_mplane *mfmt_to_fill,
+			struct mtk_fd_dev_format *dev_fmt)
+{
+	int i;
+
+	mfmt_to_fill->pixelformat = dev_fmt->fmt.img.pixelformat;
+	mfmt_to_fill->num_planes = dev_fmt->fmt.img.num_planes;
+	mfmt_to_fill->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	mfmt_to_fill->quantization = V4L2_QUANTIZATION_DEFAULT;
+	mfmt_to_fill->colorspace = dev_fmt->fmt.img.colorspace;
+
+	memset(mfmt_to_fill->reserved, 0, sizeof(mfmt_to_fill->reserved));
+
+	pr_debug("%s: Fmt(%d),w(%d),h(%d),f(%d)\n",
+		 __func__,
+		 mfmt_to_fill->pixelformat,
+		 mfmt_to_fill->width,
+		 mfmt_to_fill->height,
+		 mfmt_to_fill->field);
+
+	for (i = 0 ; i < mfmt_to_fill->num_planes; ++i) {
+		int bpl = (mfmt_to_fill->width *
+			dev_fmt->fmt.img.row_depth[i]) / 8;
+		int sizeimage = (mfmt_to_fill->width * mfmt_to_fill->height *
+			dev_fmt->fmt.img.depth[i]) / 8;
+
+		mfmt_to_fill->plane_fmt[i].bytesperline = bpl;
+		mfmt_to_fill->plane_fmt[i].sizeimage = sizeimage;
+		memset(mfmt_to_fill->plane_fmt[i].reserved,
+		       0, sizeof(mfmt_to_fill->plane_fmt[i].reserved));
+
+		pr_debug("plane(%d):bpl(%d),sizeimage(%u)\n",
+			 i, bpl,
+			 mfmt_to_fill->plane_fmt[i].sizeimage);
+	}
+}
+
+static void set_meta_fmt(struct v4l2_meta_format *metafmt_to_fill,
+			 struct mtk_fd_dev_format *dev_fmt)
+{
+	metafmt_to_fill->dataformat = dev_fmt->fmt.meta.dataformat;
+
+	if (dev_fmt->fmt.meta.max_buffer_size <= 0) {
+		pr_debug("Invalid meta buf size(%u), use default(%u)\n",
+			 dev_fmt->fmt.meta.max_buffer_size,
+			 MTK_FD_DEV_META_BUF_DEFAULT_SIZE);
+		metafmt_to_fill->buffersize = MTK_FD_DEV_META_BUF_DEFAULT_SIZE;
+	} else {
+		pr_debug("Use meta size(%u)\n",
+			 dev_fmt->fmt.meta.max_buffer_size);
+		metafmt_to_fill->buffersize = dev_fmt->fmt.meta.max_buffer_size;
+	}
+}
+
+void mtk_fd_pipe_load_default_fmt(struct mtk_fd_pipe *fd_pipe,
+				  struct mtk_fd_video_device *node,
+				  struct v4l2_format *fmt_to_fill)
+{
+	struct mtk_fd_dev_format *dev_fmt;
+	struct mtk_fd_video_device_desc *desc = node->desc;
+
+	if (desc->num_fmts == 0) {
+		pr_err("%s:%s: desc->num_fmts is 0, no format support list\n",
+		       __func__, desc->name);
+		return;
+	}
+
+	if (desc->default_fmt_idx >= desc->num_fmts) {
+		pr_debug("%s:%s: invalid idx(%d), must < num_fmts(%d)\n",
+			 __func__, desc->name, desc->default_fmt_idx,
+			desc->num_fmts);
+		desc->default_fmt_idx = 0;
+	}
+
+	dev_fmt	= &desc->fmts[desc->default_fmt_idx];
+	fmt_to_fill->type = desc->buf_type;
+	if (mtk_fd_buf_is_meta(desc->buf_type)) {
+		set_meta_fmt(&fmt_to_fill->fmt.meta, dev_fmt);
+	} else {
+		fmt_to_fill->fmt.pix_mp.width = desc->default_width;
+		fmt_to_fill->fmt.pix_mp.height = desc->default_height;
+		fmt_to_fill->fmt.pix_mp.field = V4L2_FIELD_NONE;
+
+		set_img_fmt(&fmt_to_fill->fmt.pix_mp, dev_fmt);
+	}
+}
+
+struct mtk_fd_dev_format *
+mtk_fd_pipe_find_fmt(struct mtk_fd_pipe *fd_pipe,
+		     struct mtk_fd_video_device *node,
+		     u32 format)
+{
+	int i;
+	struct mtk_fd_dev_format *dev_fmt;
+
+	struct mtk_fd_video_device_desc *desc = node->desc;
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev, "fmt to find(%x)\n", format);
+
+	for (i = 0; i < desc->num_fmts; i++) {
+		dev_fmt = &desc->fmts[i];
+		if (!mtk_fd_buf_is_meta(desc->buf_type)) {
+			if (dev_fmt->fmt.img.pixelformat == format)
+				return dev_fmt;
+		} else {
+			if (dev_fmt->fmt.meta.dataformat == format)
+				return dev_fmt;
+		}
+	}
+
+	return NULL;
+}
+
+int mtk_fd_pipe_set_meta_fmt(struct mtk_fd_pipe *fd_pipe,
+			     struct mtk_fd_video_device *node,
+			     struct v4l2_meta_format *user_fmt,
+			     struct v4l2_meta_format *node_fmt)
+{
+	struct mtk_fd_dev_format *dev_fmt;
+
+	if (!user_fmt || !node_fmt)
+		return -EINVAL;
+
+	dev_fmt = mtk_fd_pipe_find_fmt(fd_pipe, node,
+				       user_fmt->dataformat);
+
+	if (!dev_fmt)
+		return -EINVAL;
+
+	node->dev_q.dev_fmt = dev_fmt;
+	set_meta_fmt(node_fmt, dev_fmt);
+	*user_fmt = *node_fmt;
+
+	return 0;
+}
+
+int mtk_fd_pipe_set_img_fmt(struct mtk_fd_pipe *fd_pipe,
+			    struct mtk_fd_video_device *node,
+			    struct v4l2_pix_format_mplane *user_fmt,
+			    struct v4l2_pix_format_mplane *dest_fmt)
+{
+	struct mtk_fd_dev_format *dev_fmt;
+
+	if (!user_fmt || !dest_fmt)
+		return -EINVAL;
+
+	dev_fmt = mtk_fd_pipe_find_fmt(fd_pipe, node,
+				       user_fmt->pixelformat);
+
+	if (!dev_fmt) {
+		pr_debug("%s:%s:%s: dev_fmt(%d) not found\n",
+			 __func__, fd_pipe->desc->name,
+			 node->desc->name, user_fmt->pixelformat);
+		return -EINVAL;
+	}
+
+	node->dev_q.dev_fmt = dev_fmt;
+	dest_fmt->width = user_fmt->width;
+	dest_fmt->height = user_fmt->height;
+	dest_fmt->field = V4L2_FIELD_NONE;
+
+	set_img_fmt(dest_fmt, dev_fmt);
+
+	return 0;
+}
+
+int mtk_fd_pipe_streamon(struct mtk_fd_pipe *fd_pipe)
+{
+	struct mtk_fd_dev *fd_dev;
+
+	if (!fd_pipe)
+		return -EINVAL;
+
+	fd_dev = dev_get_drvdata(&fd_pipe->fd_dev->pdev->dev);
+
+	mutex_lock(&fd_pipe->lock);
+	fd_pipe->streaming = 1;
+	mutex_unlock(&fd_pipe->lock);
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s:%s:%d: start stream\n",
+		__func__, fd_pipe->desc->name,
+		fd_pipe->desc->id);
+
+	return 0;
+}
+
+int mtk_fd_pipe_streamoff(struct mtk_fd_pipe *fd_pipe)
+{
+	struct mtk_fd_dev *fd_dev;
+
+	if (!fd_pipe)
+		return -EINVAL;
+
+	fd_dev = dev_get_drvdata(&fd_pipe->fd_dev->pdev->dev);
+
+	mutex_lock(&fd_pipe->lock);
+	fd_pipe->streaming = 0;
+	mutex_unlock(&fd_pipe->lock);
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s:%s:%d: stop stream\n",
+		__func__, fd_pipe->desc->name,
+		fd_pipe->desc->id);
+
+	return 0;
+}
+
+int mtk_fd_pipe_job_start(struct mtk_fd_pipe *fd_pipe,
+			  struct mtk_fd_pipe_job_info *pipe_job_info)
+{
+	struct platform_device *pdev = fd_pipe->fd_dev->pdev;
+	int ret;
+	struct fd_hw_param fd_param;
+	struct mtk_fd_dev_buffer *dev_buf_yuv_in = NULL;
+	struct mtk_fd_dev_buffer *dev_buf_meta_in = NULL;
+	struct mtk_fd_dev_buffer *dev_buf_meta_out = NULL;
+
+	if (!pipe_job_info) {
+		dev_err(&pdev->dev,
+			"pipe_job_info(%p) in start can't be NULL\n",
+			pipe_job_info);
+		return -EINVAL;
+	}
+
+	/* We need all the 3 buffers to trigger a FD job */
+	if (!pipe_job_info->buf_map[MTK_FD_VIDEO_NODE_ID_YUV_OUT] ||
+	    !pipe_job_info->buf_map[MTK_FD_VIDEO_NODE_ID_CONFIG_OUT] ||
+	    !pipe_job_info->buf_map[MTK_FD_VIDEO_NODE_ID_CAPTURE]){
+		struct mtk_fd_dev_buffer **map = pipe_job_info->buf_map;
+
+		dev_dbg(&pdev->dev,
+			"can't trigger job: yuv_out(%p), config_out(%p), capture(%p)\n",
+			map[MTK_FD_VIDEO_NODE_ID_YUV_OUT],
+			map[MTK_FD_VIDEO_NODE_ID_CONFIG_OUT],
+			map[MTK_FD_VIDEO_NODE_ID_CAPTURE]);
+		return -EINVAL;
+	}
+
+	dev_dbg(&pdev->dev,
+		"%s:%s: pipe-job id(%d)\n",
+		__func__, fd_pipe->desc->name,
+		pipe_job_info->id);
+
+	memset(&fd_param, 0, sizeof(struct fd_hw_param));
+	fd_param.frame_id = pipe_job_info->id;
+
+	/* yuv_out buffer */
+	dev_buf_yuv_in = pipe_job_info->buf_map[MTK_FD_VIDEO_NODE_ID_YUV_OUT];
+	if (dev_buf_yuv_in) {
+		fd_param.src_img.iova =	(uint32_t)dev_buf_yuv_in->isp_daddr;
+		fd_param.src_img.va = (uint64_t)dev_buf_yuv_in->vaddr;
+		fd_param.src_img_h =
+			(uint16_t)dev_buf_yuv_in->fmt.fmt.pix_mp.height;
+		fd_param.src_img_w =
+			(uint16_t)dev_buf_yuv_in->fmt.fmt.pix_mp.width;
+	}
+
+	/* config_out */
+	dev_buf_meta_in =
+		pipe_job_info->buf_map[MTK_FD_VIDEO_NODE_ID_CONFIG_OUT];
+	if (dev_buf_meta_in) {
+		fd_param.fd_user_param.va = (uint64_t)dev_buf_meta_in->vaddr;
+		fd_param.fd_user_param.pa =
+			(uint32_t)dev_buf_meta_in->scp_daddr;
+		fd_param.fd_user_param.iova =
+			(uint32_t)dev_buf_meta_in->isp_daddr;
+	}
+
+	/* capture */
+	dev_buf_meta_out =
+		pipe_job_info->buf_map[MTK_FD_VIDEO_NODE_ID_CAPTURE];
+	if (dev_buf_meta_out) {
+		fd_param.fd_user_result.va = (uint64_t)dev_buf_meta_out->vaddr;
+		fd_param.fd_user_result.pa =
+			(uint32_t)dev_buf_meta_out->scp_daddr;
+		fd_param.fd_user_result.iova =
+			(uint32_t)dev_buf_meta_out->isp_daddr;
+	}
+
+	dev_dbg(&pdev->dev, "%s:%s: Send pipe job(%d) to fd hw\n",
+		__func__, fd_pipe->desc->name, pipe_job_info->id);
+
+	ret = mtk_fd_hw_job_exec(&fd_pipe->fd_dev->fd_hw, &fd_param);
+
+	if (ret) {
+		dev_dbg(&pdev->dev,
+			"%s:%s: enqueue job(%d) to HW failed(%d)\n",
+			 __func__, fd_pipe->desc->name, pipe_job_info->id, ret);
+		return -EBUSY;
+	}
+
+	return ret;
+}
diff --git a/drivers/media/platform/mtk-isp/fd/mtk_fd-dev.h b/drivers/media/platform/mtk-isp/fd/mtk_fd-dev.h
new file mode 100644
index 000000000000..94ec6f1f56fa
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/fd/mtk_fd-dev.h
@@ -0,0 +1,314 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _MTK_FD_DEV_H_
+#define _MTK_FD_DEV_H_
+
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <media/v4l2-device.h>
+#include <media/videobuf2-v4l2.h>
+
+#include "mtk_fd-hw.h"
+
+#define MTK_FD_PIPE_ID_STREAM_0				0
+#define MTK_FD_PIPE_ID_STREAM_1				1
+#define MTK_FD_PIPE_ID_TOTAL_NUM			2
+
+#define MTK_FD_VIDEO_NODE_ID_YUV_OUT			0
+#define MTK_FD_VIDEO_NODE_ID_CONFIG_OUT			1
+#define MTK_FD_VIDEO_NODE_ID_OUT_TOTAL_NUM		2
+#define MTK_FD_VIDEO_NODE_ID_CAPTURE			2
+#define MTK_FD_VIDEO_NODE_ID_CAPTURE_TOTAL_NUM		1
+#define MTK_FD_VIDEO_NODE_ID_TOTAL_NUM \
+	(MTK_FD_VIDEO_NODE_ID_OUT_TOTAL_NUM + \
+	MTK_FD_VIDEO_NODE_ID_CAPTURE_TOTAL_NUM)
+
+#define MTK_FD_VIDEO_NODE_ID_NO_MASTER			-1
+
+#define MTK_FD_OUTPUT_MIN_WIDTH				2U
+#define MTK_FD_OUTPUT_MIN_HEIGHT			2U
+#define MTK_FD_OUTPUT_MAX_WIDTH				5376U
+#define MTK_FD_OUTPUT_MAX_HEIGHT			4032U
+#define MTK_FD_CAPTURE_MIN_WIDTH			2U
+#define MTK_FD_CAPTURE_MIN_HEIGHT			2U
+#define MTK_FD_CAPTURE_MAX_WIDTH			5376U
+#define MTK_FD_CAPTURE_MAX_HEIGHT			4032U
+
+#define MTK_FD_PIPE_MEDIA_MODEL_NAME	"MTK-FD-V4L2"
+#define MTK_FD_PIPE_NAME_STREAM_0	MTK_FD_PIPE_MEDIA_MODEL_NAME
+#define MTK_FD_PIPE_NAME_STREAM_1	"MTK-FD-V4L2-STREAM-1"
+
+#define MTK_FD_DEV_META_BUF_DEFAULT_SIZE		(1110 * 1024)
+
+/*
+ * Supported format and the information used for
+ * size calculation
+ */
+struct mtk_fd_dev_meta_format {
+	u32 dataformat;
+	u32 max_buffer_size;
+	u8 flags;
+};
+
+/* MDP part private format definitation */
+struct mtk_fd_dev_mdp_format {
+	u32 pixelformat;
+	u32 mdp_color;
+	u32 colorspace;
+	u8 depth[VIDEO_MAX_PLANES];
+	u8 row_depth[VIDEO_MAX_PLANES];
+	u8 num_planes;
+	u8 walign;
+	u8 halign;
+	u8 salign;
+	u32 flags;
+};
+
+struct mtk_fd_dev_format {
+	union {
+		struct mtk_fd_dev_meta_format meta;
+		struct mtk_fd_dev_mdp_format img;
+	} fmt;
+};
+
+struct mtk_fd_pipe_job_info {
+	struct media_request *req;
+	int id;
+	struct mtk_fd_dev_buffer*
+		buf_map[MTK_FD_VIDEO_NODE_ID_TOTAL_NUM];
+	int num_img_capture_bufs;
+	int num_img_output_bufs;
+	int num_meta_capture_bufs;
+	int num_meta_output_bufs;
+	struct list_head list;
+};
+
+struct mtk_fd_dev_buffer {
+	struct vb2_v4l2_buffer vbb;
+	struct v4l2_format fmt;
+	struct mtk_fd_dev_format *dev_fmt;
+	int pipe_job_id;
+	void *vaddr;
+	dma_addr_t isp_daddr;
+	dma_addr_t scp_daddr;
+	unsigned int buffer_usage;
+	int rotation;
+	struct list_head list;
+};
+
+struct mtk_fd_pipe_desc {
+	char *name;
+	int master;
+	int id;
+	struct mtk_fd_video_device_desc *output_queue_descs;
+	int total_output_queues;
+	struct mtk_fd_video_device_desc *capture_queue_descs;
+	int total_capture_queues;
+};
+
+struct mtk_fd_video_device_desc {
+	int id;
+	char *name;
+	u32 buf_type;
+	u32 cap;
+	int smem_alloc;
+	int dynamic;
+	int default_enable;
+	struct mtk_fd_dev_format *fmts;
+	int num_fmts;
+	char *description;
+	int default_width;
+	int default_height;
+	const struct v4l2_ioctl_ops *ops;
+	int default_fmt_idx;
+};
+
+struct mtk_fd_dev_queue {
+	struct vb2_queue vbq;
+	/* Serializes vb2 queue and video device operations */
+	struct mutex lock;
+	struct mtk_fd_dev_format *dev_fmt;
+	/* Firmware uses buffer_usage to select suitable DMA ports */
+	unsigned int buffer_usage;
+	int rotation;
+};
+
+struct mtk_fd_video_device {
+	struct video_device vdev;
+	struct mtk_fd_dev_queue dev_q;
+	struct v4l2_format vdev_fmt;
+	struct media_pad vdev_pad;
+	struct v4l2_mbus_framefmt pad_fmt;
+	int immutable;
+	int enabled;
+	struct mtk_fd_video_device_desc *desc;
+	atomic_t sequence;
+};
+
+struct mtk_fd_pipe {
+	struct mtk_fd_dev *fd_dev;
+	struct mtk_fd_video_device nodes[MTK_FD_VIDEO_NODE_ID_TOTAL_NUM];
+	int num_nodes;
+	int streaming;
+	struct media_pad *subdev_pads;
+	struct media_pipeline pipeline;
+	struct v4l2_subdev subdev;
+	struct v4l2_subdev_fh *fh;
+	struct device *smem_alloc_dev;
+	atomic_t pipe_job_sequence;
+	struct mtk_fd_pipe_job_info pipe_job_infos[VB2_MAX_FRAME];
+	int num_pipe_job_infos;
+	struct list_head pipe_job_running_list;
+	struct list_head pipe_job_free_list;
+	/* Serializes pipe's stream on/off and buffers enqueue operations */
+	struct mutex lock;
+	spinlock_t job_lock; /* protect the pipe job list */
+	struct mtk_fd_pipe_desc *desc;
+};
+
+struct mtk_fd_dev {
+	struct platform_device *pdev;
+	struct media_device mdev;
+	struct v4l2_device v4l2_dev;
+	struct mtk_fd_pipe fd_pipe[MTK_FD_PIPE_ID_TOTAL_NUM];
+	struct device *smem_alloc_dev;
+	struct mtk_fd_hw fd_hw;
+};
+
+int mtk_fd_dev_media_register(struct device *dev,
+			      struct media_device *media_dev,
+			      const char *model);
+
+int mtk_fd_dev_v4l2_init(struct mtk_fd_dev *fd_dev);
+
+void mtk_fd_dev_v4l2_release(struct mtk_fd_dev *fd_dev);
+
+int mtk_fd_dev_v4l2_register(struct device *dev,
+			     struct media_device *media_dev,
+			     struct v4l2_device *v4l2_dev);
+
+int mtk_fd_pipe_v4l2_register(struct mtk_fd_pipe *fd_pipe,
+			      struct media_device *media_dev,
+			      struct v4l2_device *v4l2_dev);
+
+int mtk_fd_pipe_v4l2_unregister(struct mtk_fd_pipe *fd_pipe);
+
+void mtk_fd_v4l2_buffer_done(struct vb2_buffer *vb,
+			     enum vb2_buffer_state state);
+
+int mtk_fd_pipe_queue_buffers(struct media_request *req, int initial);
+
+int mtk_fd_pipe_init(struct mtk_fd_pipe *fd_pipe,
+		     struct mtk_fd_dev *fd_dev,
+		     struct mtk_fd_pipe_desc *setting,
+		     struct media_device *media_dev,
+		     struct v4l2_device *v4l2_dev,
+		     struct device *smem_alloc_dev);
+
+int mtk_fd_pipe_release(struct mtk_fd_pipe *fd_pipe);
+
+int mtk_fd_pipe_job_finish(struct mtk_fd_pipe *fd_pipe,
+			   unsigned int pipe_job_info_id,
+			   enum vb2_buffer_state state);
+
+int mtk_fd_pipe_job_start(struct mtk_fd_pipe *fd_pipe,
+			  struct mtk_fd_pipe_job_info *pipe_job_info);
+
+int mtk_fd_pipe_init_job_infos(struct mtk_fd_pipe *fd_pipe);
+
+struct mtk_fd_dev_format *
+mtk_fd_pipe_find_fmt(struct mtk_fd_pipe *fd_pipe,
+		     struct mtk_fd_video_device *node,
+		     u32 format);
+
+int mtk_fd_pipe_set_img_fmt(struct mtk_fd_pipe *fd_pipe,
+			    struct mtk_fd_video_device *node,
+			    struct v4l2_pix_format_mplane *user_fmt,
+			    struct v4l2_pix_format_mplane *node_fmt);
+
+int mtk_fd_pipe_set_meta_fmt(struct mtk_fd_pipe *fd_pipe,
+			     struct mtk_fd_video_device *node,
+			     struct v4l2_meta_format *user_fmt,
+			     struct v4l2_meta_format *node_fmt);
+
+void mtk_fd_pipe_load_default_fmt(struct mtk_fd_pipe *fd_pipe,
+				  struct mtk_fd_video_device *node,
+				  struct v4l2_format *fmt_to_fill);
+
+int mtk_fd_pipe_streamon(struct mtk_fd_pipe *fd_pipe);
+
+int mtk_fd_pipe_streamoff(struct mtk_fd_pipe *fd_pipe);
+
+static inline struct mtk_fd_video_device *
+mtk_fd_file_to_node(struct file *file)
+{
+	return container_of(video_devdata(file),
+			    struct mtk_fd_video_device, vdev);
+}
+
+static inline struct mtk_fd_pipe *
+mtk_fd_subdev_to_pipe(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct mtk_fd_pipe, subdev);
+}
+
+static inline struct mtk_fd_video_device *
+mtk_fd_vbq_to_node(struct vb2_queue *vq)
+{
+	return container_of(vq, struct mtk_fd_video_device, dev_q.vbq);
+}
+
+static inline struct mtk_fd_dev_buffer *
+mtk_fd_vb2_buf_to_dev_buf(struct vb2_buffer *vb)
+{
+	return container_of(vb, struct mtk_fd_dev_buffer, vbb.vb2_buf);
+}
+
+static inline struct mtk_fd_dev *mtk_fd_hw_to_dev(struct mtk_fd_hw *fd_hw)
+{
+	return container_of(fd_hw, struct mtk_fd_dev, fd_hw);
+}
+
+static inline struct mtk_fd_hw *get_fd_hw_device(struct device *dev)
+{
+	struct mtk_fd_dev *drv_data =
+		dev_get_drvdata(dev);
+	if (drv_data)
+		return &drv_data->fd_hw;
+	else
+		return NULL;
+}
+
+static inline int mtk_fd_buf_is_meta(u32 type)
+{
+	return type == V4L2_BUF_TYPE_META_CAPTURE ||
+		type == V4L2_BUF_TYPE_META_OUTPUT;
+}
+
+static inline int mtk_fd_pipe_get_pipe_from_job_id(int pipe_job_id)
+{
+	return (pipe_job_id >> 16) & 0x0000FFFF;
+}
+
+static inline struct mtk_fd_pipe *
+mtk_fd_dev_get_pipe(struct mtk_fd_dev *fd_dev, unsigned int pipe_id)
+{
+	if (pipe_id < 0 && pipe_id >= MTK_FD_PIPE_ID_TOTAL_NUM)
+		return NULL;
+	return &fd_dev->fd_pipe[pipe_id];
+}
+
+#endif /* _MTK_FD_DEV_H_ */
diff --git a/drivers/media/platform/mtk-isp/fd/mtk_fd-hw.h b/drivers/media/platform/mtk-isp/fd/mtk_fd-hw.h
new file mode 100644
index 000000000000..7a02720fcdc6
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/fd/mtk_fd-hw.h
@@ -0,0 +1,156 @@
+/* SPDX-License-Identifier: GPL-2.0
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_FD_HW_H__
+#define __MTK_FD_HW_H__
+
+#include <linux/io.h>
+#define SIG_ERESTARTSYS 512
+
+#define FD_WR32(v, a) \
+do { \
+	__raw_writel((v), (void __force __iomem *)((a))); \
+	mb(); /* ensure written */ \
+} while (0)
+
+#define FD_RD32(addr) ioread32((void *)addr)
+
+#define FD_INT_EN		0x15c
+#define FD_INT			0x168
+#define FD_RESULT		0x178
+#define FD_IRQ_MASK		0x001
+
+#define RS_BUF_SIZE_MAX		2288788
+#define VA_OFFSET		0xffff000000000000
+
+#define MTK_FD_MAX_NO		1024
+#define MAX_FACE_SEL_NUM	(MTK_FD_MAX_NO + 2)
+
+/* The max number of face sizes could be detected, for feature scaling */
+#define FACE_SIZE_NUM_MAX	14
+
+/* FACE_SIZE_NUM_MAX + 1, first scale for input image W/H */
+#define FD_SCALE_NUM		15
+
+/* Number of Learning data sets */
+#define LEARNDATA_NUM		18
+
+#define mtk_fd_us_to_jiffies(us) \
+	((((unsigned long)(us) / 1000) * HZ + 512) >> 10)
+
+enum fd_irq {
+	FD_IRQ_IDX = 0,
+	FD_IRQ_IDX_NUM
+};
+
+enum fd_state {
+	FD_INI,
+	FD_ENQ,
+	FD_CBD,
+};
+
+enum stream_stat {
+	STREAM_OFF,
+	STREAM_ON,
+};
+
+struct fd_buffer {
+	__u64 va;	/* used by APMCU access */
+	__u32 pa;	/* used by CM4 access */
+	__u32 iova;	/* used by HW access */
+} __packed;
+
+struct ipi_fd_enq_param {
+	u8 source_img_fmt;
+	struct fd_buffer output_addr;
+	struct fd_buffer src_y;
+	struct fd_buffer src_uv;
+	struct fd_buffer config_addr;
+} __packed;
+
+struct fd_manager_ctx {
+	struct fd_buffer learn_data_buf[2][LEARNDATA_NUM];
+	struct fd_buffer fd_config;
+	struct fd_buffer rs_config;
+	struct fd_buffer fd_result;
+	struct fd_buffer rs_result;
+	struct fd_buffer src_img;
+} __packed;
+
+enum fd_img_format {
+	FMT_VYUY = 2,
+	FMT_UYVY,
+	FMT_YVYU,
+	FMT_YUYV,
+};
+
+enum fd_scp_cmd {
+	FD_CMD_INIT,
+	FD_CMD_ENQ,
+	FD_CMD_EXIT,
+};
+
+struct fd_face_result {
+	__u64 face_idx:12, type:1, x0:10, y0:10, x1:10, y1:10,
+		fcv:18, rip_dir:4, rop_dir:3, det_size:5;
+};
+
+struct fd_user_output {
+	struct fd_face_result face[MAX_FACE_SEL_NUM];
+	__u16 face_number;
+};
+
+struct fd_hw_param {
+	u32 frame_id;
+	u16 src_img_h;
+	u16 src_img_w;
+	struct fd_buffer src_img;
+	struct fd_buffer fd_user_param;
+	struct fd_buffer fd_user_result;
+} __packed;
+
+struct ipi_message {
+	u8 cmd_id;
+	union {
+		struct fd_buffer fd_manager;
+		struct fd_hw_param fd_param;
+	};
+} __packed;
+
+struct mtk_fd_hw {
+	dev_t fd_devno;
+	struct clk *fd_clk;
+	enum fd_state state;
+	wait_queue_head_t wq;
+	u32 fd_irq_result;
+	void __iomem *fd_base;
+	struct sg_table sgtable;
+	struct platform_device *scp_pdev;
+	struct rproc *rproc_handle;
+	atomic_t fd_user_cnt;
+	/* Ensure only one job in hw */
+	struct mutex fd_hw_lock;
+};
+
+int mtk_fd_hw_job_exec(struct mtk_fd_hw *fd_hw,
+		       struct fd_hw_param *fd_param);
+
+int mtk_fd_hw_connect(struct mtk_fd_hw *fd_hw);
+
+int mtk_fd_hw_disconnect(struct mtk_fd_hw *fd_hw);
+
+int mtk_fd_hw_streamon(struct mtk_fd_hw *fd_hw);
+
+int mtk_fd_hw_streamoff(struct mtk_fd_hw *fd_hw);
+
+#endif/*__MTK_FD_HW_H__*/
diff --git a/drivers/media/platform/mtk-isp/fd/mtk_fd-smem.c b/drivers/media/platform/mtk-isp/fd/mtk_fd-smem.c
new file mode 100644
index 000000000000..dcc99cfb2d91
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/fd/mtk_fd-smem.c
@@ -0,0 +1,366 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/cacheflush.h>
+#include <linux/iommu.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_fdt.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/mtk_scp.h>
+#include <linux/slab.h>
+#include <media/videobuf2-dma-contig.h>
+#include "mtk_fd-smem.h"
+
+static struct dma_map_ops smem_dma_ops;
+
+struct mtk_fd_smem_dev {
+	struct device *dev;
+	struct sg_table sgt;
+	struct page **smem_pages;
+	int num_smem_pages;
+	phys_addr_t smem_base;
+	dma_addr_t smem_dma_base;
+	int smem_size;
+	struct dma_map_ops smem_dma_ops;
+};
+
+struct dma_coherent_mem {
+	void		*virt_base;
+	dma_addr_t	device_base;
+	unsigned long	pfn_base;
+	int		size;
+	int		flags;
+	unsigned long	*bitmap;
+	spinlock_t	spinlock; /* protect dma_coherent_mem member */
+	bool		use_dev_dma_pfn_offset;
+};
+
+static struct dma_coherent_mem *dev_get_coherent_memory(struct device *dev)
+{
+	if (dev && dev->dma_mem)
+		return dev->dma_mem;
+	return NULL;
+}
+
+phys_addr_t mtk_fd_smem_iova_to_phys(struct device *dev, dma_addr_t iova)
+{
+	struct iommu_domain *domain;
+	phys_addr_t addr;
+	phys_addr_t limit;
+	struct mtk_fd_smem_dev *smem_dev = dev_get_drvdata(dev);
+
+	domain = iommu_get_domain_for_dev(dev);
+	if (!domain) {
+		dev_warn(dev, "No iommu group domain\n");
+		return 0;
+	}
+
+	addr = iommu_iova_to_phys(domain, iova);
+	limit = smem_dev->smem_base + smem_dev->smem_size;
+	if (addr < smem_dev->smem_base || addr >= limit) {
+		dev_err(smem_dev->dev,
+			"Unexpected scp_daddr %pa (must >= %pa and <%pa)\n",
+			&addr, &smem_dev->smem_base, &limit);
+		return 0;
+	}
+	dev_dbg(smem_dev->dev, "Pa verifcation pass: %pa(>=%pa, <%pa)\n",
+		&addr, &smem_dev->smem_base, &limit);
+	return addr;
+}
+
+/********************************************
+ * MTK FD SMEM DMA ops *
+ ********************************************/
+static int mtk_fd_smem_get_sgtable(struct device *dev,
+				   struct sg_table *sgt,
+				    void *cpu_addr,
+				    dma_addr_t dma_addr,
+				    size_t size, unsigned long attrs)
+{
+	struct mtk_fd_smem_dev *smem_dev = dev_get_drvdata(dev);
+	int n_pages_align;
+	int size_align;
+	int page_start;
+	unsigned long long offset_p;
+
+	phys_addr_t paddr = mtk_fd_smem_iova_to_phys(smem_dev->dev, dma_addr);
+
+	offset_p = (unsigned long long)paddr -
+		(unsigned long long)smem_dev->smem_base;
+
+	dev_dbg(dev, "%s: dma_addr(%pad), cpu_addr(%p), pa(%pa), size(%d)\n",
+		__func__, &dma_addr, cpu_addr, &paddr, size);
+
+	size_align = round_up(size, PAGE_SIZE);
+	n_pages_align = size_align >> PAGE_SHIFT;
+	page_start = offset_p >> PAGE_SHIFT;
+
+	dev_dbg(dev, "%s: page_start(%d), page pa(%llx), pa(%pa), aligned size(%d)\n",
+		__func__,
+		page_start,
+		page_to_phys(*(smem_dev->smem_pages + page_start)),
+		&paddr,
+		size_align
+		);
+
+	if (!smem_dev) {
+		dev_err(dev, "can't get sgtable from smem_dev\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "%s: get sgt of the smem: %d pages\n", __func__,
+		n_pages_align);
+
+	return sg_alloc_table_from_pages(sgt,
+					 smem_dev->smem_pages + page_start,
+					 n_pages_align,
+					 0, size_align, GFP_KERNEL);
+}
+
+static void *mtk_fd_smem_get_cpu_addr(struct mtk_fd_smem_dev *smem_dev,
+				      struct scatterlist *sg)
+{
+	struct device *dev = smem_dev->dev;
+	struct dma_coherent_mem *dma_mem =
+		dev_get_coherent_memory(dev);
+
+	phys_addr_t addr = (phys_addr_t)sg_phys(sg);
+
+	if (addr < smem_dev->smem_base ||
+	    addr > smem_dev->smem_base + smem_dev->smem_size) {
+		dev_err(dev, "%s: Invalid paddr %pa from sg\n",
+			__func__, &addr);
+		return NULL;
+	}
+
+	return dma_mem->virt_base + (addr - smem_dev->smem_base);
+}
+
+static void mtk_fd_smem_sync_sg_for_cpu(struct device *dev,
+					struct scatterlist *sgl,
+					 int nelems,
+					 enum dma_data_direction dir)
+{
+	struct mtk_fd_smem_dev *smem_dev =
+		dev_get_drvdata(dev);
+	void *cpu_addr;
+
+	cpu_addr = mtk_fd_smem_get_cpu_addr(smem_dev, sgl);
+
+	dev_dbg(dev, "%s: paddr(%p),vaddr(%p),size(%d)\n",
+		__func__, sg_phys(sgl), cpu_addr, sgl->length);
+
+	if (cpu_addr)
+		__dma_unmap_area(cpu_addr, sgl->length, dir);
+}
+
+static void mtk_fd_smem_sync_sg_for_device(struct device *dev,
+					   struct scatterlist *sgl,
+					    int nelems,
+					    enum dma_data_direction dir)
+{
+	struct mtk_fd_smem_dev *smem_dev =
+			dev_get_drvdata(dev);
+	void *cpu_addr;
+
+	cpu_addr = mtk_fd_smem_get_cpu_addr(smem_dev, sgl);
+
+	dev_dbg(dev, "%s: pa(%p),va(%p),size(%d),dir(%d)\n",
+		__func__, sg_phys(sgl), cpu_addr, sgl->length, dir);
+
+	if (cpu_addr)
+		__dma_map_area(cpu_addr, sgl->length, dir);
+}
+
+static void mtk_fd_smem_setup_dma_ops(struct device *dev,
+				       struct dma_map_ops *smem_ops)
+{
+	memcpy((void *)smem_ops, dev->dma_ops, sizeof(*smem_ops));
+	smem_ops->get_sgtable = mtk_fd_smem_get_sgtable;
+	smem_ops->sync_sg_for_device = mtk_fd_smem_sync_sg_for_device;
+	smem_ops->sync_sg_for_cpu = mtk_fd_smem_sync_sg_for_cpu;
+	set_dma_ops(dev, smem_ops);
+}
+
+
+void mtk_fd_smem_alloc_dev_release(struct device *smem_dev)
+{
+	device_unregister(smem_dev);
+}
+
+static int __init mtk_fd_smem_dma_setup(struct reserved_mem *rmem)
+{
+	unsigned long node = rmem->fdt_node;
+
+	if (of_get_flat_dt_prop(node, "reusable", NULL))
+		return -EINVAL;
+
+	if (!of_get_flat_dt_prop(node, "no-map", NULL)) {
+		pr_err("Reserved memory: regions without no-map are not yet supported\n");
+		return -EINVAL;
+	}
+
+	pr_debug("Reserved memory: created DMA memory pool at %pa, size %ld MiB\n",
+		 &rmem->base, (unsigned long)rmem->size / SZ_1M);
+	return 0;
+}
+
+static int mtk_fd_reserved_drm_sg_init(struct mtk_fd_smem_dev *smem_dev)
+{
+	u32 size_align, n_pages;
+	struct device *dev = smem_dev->dev;
+	struct sg_table *sgt = &smem_dev->sgt;
+	struct page **pages;
+	dma_addr_t dma_addr;
+	unsigned int i;
+	int ret;
+
+	smem_dev->smem_base = scp_get_reserve_mem_phys(SCP_FD_MEM2_ID);
+	smem_dev->smem_size = scp_get_reserve_mem_size(SCP_FD_MEM2_ID);
+	if (!smem_dev->smem_base || !smem_dev->smem_size)
+		return -EPROBE_DEFER;
+
+	dev_info(dev, "%s dev:0x%pK base:%pad size:%u MiB\n",
+		 __func__,
+		 smem_dev->dev,
+		 &smem_dev->smem_base,
+		 (smem_dev->smem_size / SZ_1M));
+
+	size_align = PAGE_ALIGN(smem_dev->smem_size);
+	n_pages = size_align >> PAGE_SHIFT;
+
+	pages = kmalloc_array(n_pages, sizeof(struct page *), GFP_KERNEL);
+	if (!pages)
+		return -ENOMEM;
+
+	for (i = 0; i < n_pages; i++)
+		pages[i] = phys_to_page(smem_dev->smem_base + i * PAGE_SIZE);
+
+	ret = sg_alloc_table_from_pages(sgt, pages, n_pages, 0,
+					size_align, GFP_KERNEL);
+	if (ret) {
+		dev_err(dev, "failed to alloca sg table:%d\n", ret);
+		goto fail_table_alloc;
+	}
+	sgt->nents = dma_map_sg_attrs(dev, sgt->sgl, sgt->orig_nents,
+				      DMA_BIDIRECTIONAL,
+				      DMA_ATTR_SKIP_CPU_SYNC);
+	if (!sgt->nents) {
+		dev_err(dev, "failed to dma sg map\n");
+		goto fail_map;
+	}
+
+	dma_addr = sg_dma_address(sgt->sgl);
+	ret = dma_declare_coherent_memory(dev, smem_dev->smem_base,
+					  dma_addr, size_align,
+					  DMA_MEMORY_EXCLUSIVE);
+	if (ret) {
+		dev_err(dev, "Unable to declare smem  memory:%d\n", ret);
+		goto fail_map;
+	}
+
+	dev_info(dev, "Coherent mem pa:%pad/%pad, size:%d\n",
+		 &smem_dev->smem_base, &dma_addr, size_align);
+
+	smem_dev->smem_size = size_align;
+	smem_dev->smem_pages = pages;
+	smem_dev->smem_dma_base = dma_addr;
+
+	return 0;
+
+fail_map:
+	sg_free_table(sgt);
+fail_table_alloc:
+	while (n_pages--)
+		__free_page(pages[n_pages]);
+	kfree(pages);
+
+	return -ENOMEM;
+}
+
+/* DMA memory related helper functions */
+static void mtk_fd_memdev_release(struct device *dev)
+{
+	vb2_dma_contig_clear_max_seg_size(dev);
+}
+
+static struct device *mtk_fd_alloc_smem_dev(struct device *dev,
+					     const char *name)
+{
+	struct device *child;
+	int ret;
+
+	child = devm_kzalloc(dev, sizeof(*child), GFP_KERNEL);
+	if (!child)
+		return NULL;
+
+	child->parent = dev;
+	child->iommu_group = dev->iommu_group;
+	child->release = mtk_fd_memdev_release;
+	dev_set_name(child, name);
+	set_dma_ops(child, get_dma_ops(dev));
+	child->dma_mask = dev->dma_mask;
+	ret = dma_set_coherent_mask(child, DMA_BIT_MASK(32));
+	if (ret)
+		return NULL;
+
+	vb2_dma_contig_set_max_seg_size(child, DMA_BIT_MASK(32));
+
+	if (device_register(child)) {
+		device_del(child);
+		return NULL;
+	}
+
+	return child;
+}
+
+int mtk_fd_reserved_memory_init(struct mtk_fd_dev *fd_dev)
+{
+	struct device *dev = &fd_dev->pdev->dev;
+	struct mtk_fd_smem_dev *smem_dev;
+	int ret;
+
+	/* Allocate context */
+	smem_dev = devm_kzalloc(dev, sizeof(*smem_dev), GFP_KERNEL);
+	if (!smem_dev)
+		return -ENOMEM;
+
+	smem_dev->dev = mtk_fd_alloc_smem_dev(dev, "fd-smem");
+	if (!smem_dev->dev) {
+		dev_err(dev, "failed to alloc smem device\n");
+		return -ENODEV;
+	}
+	dev_set_drvdata(smem_dev->dev, smem_dev);
+	fd_dev->smem_alloc_dev = smem_dev->dev;
+
+	ret = mtk_fd_reserved_drm_sg_init(smem_dev);
+	if (ret)
+		return ret;
+
+	mtk_fd_smem_setup_dma_ops(smem_dev->dev, &smem_dma_ops);
+
+	return 0;
+}
+
+RESERVEDMEM_OF_DECLARE(mtk_fd_smem,
+		       "mediatek,reserve-memory-fd_smem",
+		       mtk_fd_smem_dma_setup);
+
+MODULE_AUTHOR("Frederic Chen <frederic.chen@mediatek.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Mediatek Camera FD shared memory alloc device");
+
diff --git a/drivers/media/platform/mtk-isp/fd/mtk_fd-smem.h b/drivers/media/platform/mtk-isp/fd/mtk_fd-smem.h
new file mode 100644
index 000000000000..4ab5ad549d59
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/fd/mtk_fd-smem.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _MTK_FD_SMEM_H_
+#define _MTK_FD_SMEM_H_
+
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include "mtk_fd-dev.h"
+
+phys_addr_t mtk_fd_smem_iova_to_phys(struct device *dev, dma_addr_t iova);
+int mtk_fd_reserved_memory_init(struct mtk_fd_dev *fd_dev);
+void mtk_fd_smem_alloc_dev_release(struct device *smem_dev);
+
+#endif /*_MTK_FD_SMEM_H_*/
+
diff --git a/drivers/media/platform/mtk-isp/fd/mtk_fd-v4l2.c b/drivers/media/platform/mtk-isp/fd/mtk_fd-v4l2.c
new file mode 100644
index 000000000000..d0db3ef88eff
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/fd/mtk_fd-v4l2.c
@@ -0,0 +1,1170 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/platform_device.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/videobuf2-v4l2.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-ctrls.h>
+#include "mtk_fd-dev.h"
+#include "mtk_fd-hw.h"
+#include "mtk-mdp3-regs.h"
+#include "mtk_fd-smem.h"
+
+static int mtk_fd_subdev_open(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_fh *fh)
+{
+	struct mtk_fd_pipe *fd_pipe = mtk_fd_subdev_to_pipe(sd);
+	struct mtk_fd_dev *fd_dev =
+		dev_get_drvdata(&fd_pipe->fd_dev->pdev->dev);
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s:%s: pipe(%d) connects to fd_hw\n",
+		__func__, fd_pipe->desc->name,
+		fd_pipe->desc->id);
+
+	fd_pipe->fh = fh;
+
+	mtk_fd_pipe_init_job_infos(fd_pipe);
+
+	return mtk_fd_hw_connect(&fd_dev->fd_hw);
+}
+
+static int mtk_fd_subdev_close(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_fh *fh)
+{
+	struct mtk_fd_pipe *fd_pipe = mtk_fd_subdev_to_pipe(sd);
+	struct mtk_fd_dev *fd_dev =
+		dev_get_drvdata(&fd_pipe->fd_dev->pdev->dev);
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s:%s: pipe(%d) disconnect to fd_hw\n",
+		__func__, fd_pipe->desc->name,
+		fd_pipe->desc->id);
+
+	return mtk_fd_hw_disconnect(&fd_dev->fd_hw);
+}
+
+static int mtk_fd_subdev_s_stream(struct v4l2_subdev *sd,
+				  int enable)
+{
+	struct mtk_fd_pipe *fd_pipe = mtk_fd_subdev_to_pipe(sd);
+	int ret;
+
+	if (enable)
+		ret = mtk_fd_pipe_streamon(fd_pipe);
+	else
+		ret = mtk_fd_pipe_streamoff(fd_pipe);
+
+	return ret;
+}
+
+static int mtk_fd_link_setup(struct media_entity *entity,
+			     const struct media_pad *local,
+			     const struct media_pad *remote, u32 flags)
+{
+	struct mtk_fd_pipe *fd_pipe =
+		container_of(entity, struct mtk_fd_pipe, subdev.entity);
+	u32 pad = local->index;
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s: link setup, flags(0x%x), (%s)%d -->(%s)%d\n",
+		fd_pipe->desc->name,
+		flags,
+		local->entity->name,
+		local->index,
+		remote->entity->name,
+		remote->index);
+
+	WARN_ON(entity->obj_type != MEDIA_ENTITY_TYPE_V4L2_SUBDEV);
+
+	WARN_ON(pad >= fd_pipe->num_nodes);
+
+	fd_pipe->nodes[pad].enabled = !!(flags & MEDIA_LNK_FL_ENABLED);
+
+	return 0;
+}
+
+static int mtk_fd_vb2_buf_prepare(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+
+	v4l2_buf->field = V4L2_FIELD_NONE;
+	return 0;
+}
+
+static int mtk_fd_vb2_buf_out_validate(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+
+	v4l2_buf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static void mtk_fd_vb2_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+
+	v4l2_buf->field = V4L2_FIELD_NONE;
+}
+
+static int mtk_fd_vb2_queue_setup(struct vb2_queue *vq,
+				  unsigned int *num_buffers,
+				  unsigned int *num_planes,
+				  unsigned int sizes[],
+				  struct device *alloc_devs[])
+{
+	struct mtk_fd_pipe *fd_pipe = vb2_get_drv_priv(vq);
+	struct mtk_fd_video_device *node =
+		mtk_fd_vbq_to_node(vq);
+	struct device *dev = &fd_pipe->fd_dev->pdev->dev;
+	struct device *buf_alloc_ctx;
+
+	/* Get V4L2 format with the following method */
+	const struct v4l2_format *fmt = &node->vdev_fmt;
+	unsigned int size;
+
+	*num_buffers = clamp_val(*num_buffers, 1, VB2_MAX_FRAME);
+
+	if (node->desc->smem_alloc) {
+		buf_alloc_ctx = fd_pipe->smem_alloc_dev;
+		dev_dbg(dev, "%s:%s: select smem_vb2_alloc_ctx(%p)\n",
+			fd_pipe->desc->name,
+			node->desc->name,
+			buf_alloc_ctx);
+	} else {
+		buf_alloc_ctx = &fd_pipe->fd_dev->pdev->dev;
+		dev_dbg(dev, "%s:%s: select default_vb2_alloc_ctx(%p)\n",
+			fd_pipe->desc->name,
+			node->desc->name,
+			buf_alloc_ctx);
+	}
+
+	alloc_devs[0] = buf_alloc_ctx;
+
+	if (vq->type == V4L2_BUF_TYPE_META_CAPTURE ||
+	    vq->type == V4L2_BUF_TYPE_META_OUTPUT)
+		size = fmt->fmt.meta.buffersize;
+	else
+		size = fmt->fmt.pix_mp.plane_fmt[0].sizeimage;
+
+	if (*num_planes) {
+		if (sizes[0] < size) {
+			dev_dbg(dev, "%s:%s:%s: size error(user:%d, max:%d)\n",
+				__func__, fd_pipe->desc->name,
+				node->desc->name, sizes[0], size);
+			return -EINVAL;
+		}
+	} else {
+		*num_planes = 1;
+		sizes[0] = size;
+	}
+
+	dev_dbg(dev, "%s:%s:%s: n_planes(%d), n_bufs(%d), size(%d)\n",
+		__func__, fd_pipe->desc->name,
+		node->desc->name, *num_planes, *num_buffers, sizes[0]);
+
+	return 0;
+}
+
+static int
+	mtk_fd_all_nodes_streaming(struct mtk_fd_pipe *fd_pipe,
+				   struct mtk_fd_video_device *except)
+{
+	int i;
+
+	for (i = 0; i < fd_pipe->num_nodes; i++) {
+		struct mtk_fd_video_device *node = &fd_pipe->nodes[i];
+
+		if (node == except)
+			continue;
+		if (node->enabled &&
+		    !vb2_start_streaming_called(&node->dev_q.vbq))
+			return 0;
+	}
+
+	return 1;
+}
+
+static void mtk_fd_return_all_buffers(struct mtk_fd_pipe *fd_pipe,
+				      struct mtk_fd_video_device *node,
+				      enum vb2_buffer_state state)
+{
+	int i;
+
+	for (i = 0; i < node->dev_q.vbq.num_buffers; i++) {
+		if (node->dev_q.vbq.bufs[i]->state ==
+			VB2_BUF_STATE_ACTIVE)
+			vb2_buffer_done(node->dev_q.vbq.bufs[i],
+					state);
+	}
+}
+
+static int mtk_fd_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	struct mtk_fd_pipe *fd_pipe = vb2_get_drv_priv(vq);
+	struct mtk_fd_video_device *node =
+		mtk_fd_vbq_to_node(vq);
+	int ret;
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s:%s:%s\n",
+		fd_pipe->desc->name, node->desc->name,
+		__func__);
+
+	if (!node->enabled) {
+		dev_err(&fd_pipe->fd_dev->pdev->dev,
+			"%s:%s: stream on failed, node is not enabled\n",
+			fd_pipe->desc->name, node->desc->name);
+		ret = -EINVAL;
+		goto fail_return_bufs;
+	}
+
+	ret = media_pipeline_start(&node->vdev.entity, &fd_pipe->pipeline);
+
+	if (ret < 0) {
+		dev_err(&fd_pipe->fd_dev->pdev->dev,
+			"%s:%s: media_pipeline_start failed(%d)\n",
+			fd_pipe->desc->name, node->desc->name,
+			ret);
+		goto fail_return_bufs;
+	}
+
+	if (!mtk_fd_all_nodes_streaming(fd_pipe, node))
+		return 0;
+
+	/* Start streaming of the whole pipeline */
+	ret = v4l2_subdev_call(&fd_pipe->subdev, video, s_stream, 1);
+	if (ret < 0) {
+		dev_err(&fd_pipe->fd_dev->pdev->dev,
+			"%s:%s: sub dev s_stream(1) failed(%d)\n",
+			fd_pipe->desc->name, node->desc->name,
+			ret);
+		goto fail_stop_pipeline;
+	}
+	return 0;
+
+fail_stop_pipeline:
+	media_pipeline_stop(&node->vdev.entity);
+fail_return_bufs:
+	mtk_fd_return_all_buffers(fd_pipe, node, VB2_BUF_STATE_QUEUED);
+
+	return ret;
+}
+
+static void mtk_fd_vb2_stop_streaming(struct vb2_queue *vq)
+{
+	struct mtk_fd_pipe *fd_pipe = vb2_get_drv_priv(vq);
+	struct mtk_fd_video_device *node =
+		mtk_fd_vbq_to_node(vq);
+	int ret;
+
+	WARN_ON(!node->enabled);
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s:%s:%s\n",
+		fd_pipe->desc->name, node->desc->name,
+		__func__);
+
+	if (mtk_fd_all_nodes_streaming(fd_pipe, node)) {
+		ret = v4l2_subdev_call(&fd_pipe->subdev, video, s_stream, 0);
+
+	if (ret)
+		dev_err(&fd_pipe->fd_dev->pdev->dev,
+			"%s:%s: sub dev s_stream(0) failed(%d)\n",
+			fd_pipe->desc->name, node->desc->name,
+			ret);
+	}
+
+	mtk_fd_return_all_buffers(fd_pipe, node, VB2_BUF_STATE_ERROR);
+	media_pipeline_stop(&node->vdev.entity);
+}
+
+static void mtk_fd_vb2_request_complete(struct vb2_buffer *vb)
+{
+	struct mtk_fd_video_device *node =
+		mtk_fd_vbq_to_node(vb->vb2_queue);
+
+	v4l2_ctrl_request_complete(vb->req_obj.req,
+				   node->vdev.ctrl_handler);
+}
+
+static int mtk_fd_videoc_querycap(struct file *file, void *fh,
+				  struct v4l2_capability *cap)
+{
+	struct mtk_fd_pipe *fd_pipe = video_drvdata(file);
+
+	strlcpy(cap->driver, fd_pipe->desc->name,
+		sizeof(cap->driver));
+	strlcpy(cap->card, fd_pipe->desc->name,
+		sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info),
+		 "platform:%s", dev_name(fd_pipe->fd_dev->mdev.dev));
+
+	return 0;
+}
+
+static int mtk_fd_videoc_try_fmt(struct file *file,
+				 void *fh,
+				 struct v4l2_format *f)
+{
+	struct mtk_fd_pipe *fd_pipe = video_drvdata(file);
+	struct mtk_fd_video_device *node = mtk_fd_file_to_node(file);
+	struct v4l2_format try_fmt;
+	int ret;
+
+	memset(&try_fmt, 0, sizeof(try_fmt));
+
+	try_fmt.type = node->dev_q.vbq.type;
+
+	ret = mtk_fd_pipe_set_img_fmt(fd_pipe, node, &f->fmt.pix_mp,
+				      &try_fmt.fmt.pix_mp);
+
+	if (ret)
+		mtk_fd_pipe_load_default_fmt(fd_pipe, node, &try_fmt);
+
+	*f = try_fmt;
+
+	return 0;
+}
+
+static int mtk_fd_videoc_g_fmt(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct mtk_fd_video_device *node = mtk_fd_file_to_node(file);
+
+	*f = node->vdev_fmt;
+
+	return 0;
+}
+
+static int mtk_fd_videoc_s_fmt(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct mtk_fd_video_device *node = mtk_fd_file_to_node(file);
+	struct mtk_fd_pipe *fd_pipe = video_drvdata(file);
+
+	int ret;
+
+	if (fd_pipe->streaming)
+		return -EBUSY;
+
+	ret = mtk_fd_videoc_try_fmt(file, fh, f);
+
+	if (!ret)
+		node->vdev_fmt = *f;
+
+	return 0;
+}
+
+static int mtk_fd_videoc_enum_framesizes(struct file *file,
+					 void *priv,
+					 struct v4l2_frmsizeenum *sizes)
+{
+	struct mtk_fd_pipe *fd_pipe = video_drvdata(file);
+	struct mtk_fd_video_device *node = mtk_fd_file_to_node(file);
+	struct mtk_fd_dev_format *dev_fmt;
+
+	dev_fmt = mtk_fd_pipe_find_fmt(fd_pipe, node, sizes->pixel_format);
+
+	if (!dev_fmt || sizes->index)
+		return -EINVAL;
+
+	sizes->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
+
+	if (V4L2_TYPE_IS_OUTPUT(node->desc->buf_type)) {
+		sizes->stepwise.max_width = MTK_FD_OUTPUT_MAX_WIDTH;
+		sizes->stepwise.min_width = MTK_FD_OUTPUT_MIN_WIDTH;
+		sizes->stepwise.max_height = MTK_FD_OUTPUT_MAX_HEIGHT;
+		sizes->stepwise.min_height = MTK_FD_OUTPUT_MIN_HEIGHT;
+		sizes->stepwise.step_height = 1;
+		sizes->stepwise.step_width = 1;
+	} else {
+		sizes->stepwise.max_width = MTK_FD_CAPTURE_MAX_WIDTH;
+		sizes->stepwise.min_width = MTK_FD_CAPTURE_MIN_WIDTH;
+		sizes->stepwise.max_height = MTK_FD_CAPTURE_MAX_HEIGHT;
+		sizes->stepwise.min_height = MTK_FD_CAPTURE_MIN_HEIGHT;
+		sizes->stepwise.step_height = 1;
+		sizes->stepwise.step_width = 1;
+	}
+
+	return 0;
+}
+
+static int mtk_fd_videoc_enum_fmt(struct file *file, void *fh,
+				  struct v4l2_fmtdesc *f)
+{
+	struct mtk_fd_video_device *node = mtk_fd_file_to_node(file);
+
+	if (f->index > node->desc->num_fmts ||
+	    f->type != node->dev_q.vbq.type)
+		return -EINVAL;
+
+	strscpy(f->description, node->desc->description,
+		sizeof(f->description));
+
+	f->pixelformat = node->desc->fmts[f->index].fmt.img.pixelformat;
+	f->flags = 0;
+
+	return 0;
+}
+
+static int mtk_fd_meta_enum_format(struct file *file,
+				   void *fh, struct v4l2_fmtdesc *f)
+{
+	struct mtk_fd_video_device *node = mtk_fd_file_to_node(file);
+
+	if (f->index > 0 || f->type != node->dev_q.vbq.type)
+		return -EINVAL;
+
+	strscpy(f->description, node->desc->description,
+		sizeof(f->description));
+
+	f->pixelformat = node->vdev_fmt.fmt.meta.dataformat;
+
+	return 0;
+}
+
+static int mtk_fd_videoc_g_meta_fmt(struct file *file,
+				    void *fh, struct v4l2_format *f)
+{
+	struct mtk_fd_video_device *node = mtk_fd_file_to_node(file);
+	*f = node->vdev_fmt;
+
+	return 0;
+}
+
+static int
+mtk_fd_vidioc_subscribe_event(struct v4l2_fh *fh,
+			      const struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_CTRL:
+		return v4l2_ctrl_subscribe_event(fh, sub);
+	default:
+		return -EINVAL;
+	}
+}
+
+/******************** function pointers ********************/
+
+/* subdev internal operations */
+static const struct v4l2_subdev_internal_ops mtk_fd_subdev_internal_ops = {
+	.open = mtk_fd_subdev_open,
+	.close = mtk_fd_subdev_close,
+};
+
+static const struct v4l2_subdev_video_ops mtk_fd_subdev_video_ops = {
+	.s_stream = mtk_fd_subdev_s_stream,
+};
+
+static const struct v4l2_subdev_ops mtk_fd_subdev_ops = {
+	.video = &mtk_fd_subdev_video_ops,
+};
+
+static const struct media_entity_operations mtk_fd_media_ops = {
+	.link_setup = mtk_fd_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int mtk_fd_request_buf_validate(struct media_request *req,
+				       int all_enable_node_need_buf)
+{
+	struct media_request_object *obj;
+	struct mtk_fd_pipe *fd_pipe;
+	struct mtk_fd_pipe *fd_dev_first;
+	struct vb2_buffer *vbs[MTK_FD_VIDEO_NODE_ID_TOTAL_NUM] = {};
+	int count = 0;
+
+	if (!all_enable_node_need_buf)
+		return	vb2_request_validate(req);
+
+	list_for_each_entry(obj, &req->objects, list) {
+		struct vb2_buffer *vb;
+
+		if (vb2_request_object_is_buffer(obj)) {
+			struct mtk_fd_video_device *node;
+
+			vb = container_of(obj, struct vb2_buffer, req_obj);
+			node = mtk_fd_vbq_to_node(vb->vb2_queue);
+			fd_pipe = vb2_get_drv_priv(vb->vb2_queue);
+			vbs[node->desc->id] = vb;
+
+			if (count == 0)
+				fd_dev_first = fd_pipe;
+
+			if (fd_dev_first != fd_pipe) {
+				pr_err("Req(%p):found buf of different pipes(%p,%p)",
+				       req, fd_dev_first, fd_pipe);
+				return -EINVAL;
+			}
+		}
+	}
+
+	if (!fd_pipe) {
+		pr_debug("No fd pipe found for the request\n");
+		return -EINVAL;
+	}
+
+	for (count = 0; count < MTK_FD_VIDEO_NODE_ID_TOTAL_NUM; count++) {
+		if (fd_pipe->nodes[count].enabled) {
+			pr_debug("Node(%d:%s): vb(0x%x)\n",
+				 count, fd_pipe->nodes[count].desc->name,
+				 vbs[count]);
+
+			if (!vbs[count]) {
+				pr_debug("Node(%s) enable and no buf enqueue\n",
+					 fd_pipe->nodes[count].desc->name);
+				return -EINVAL;
+			}
+		}
+	}
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s:%s: all bufs found, ready for req(%p) enqueue\n",
+		__func__, fd_pipe->desc->name, req);
+
+	return vb2_request_validate(req);
+}
+
+static int mtk_fd_vb2_request_validate(struct media_request *req)
+{
+	return mtk_fd_request_buf_validate(req, 0);
+}
+
+static void mtk_fd_vb2_request_queue(struct media_request *req)
+{
+	vb2_request_queue(req);
+	mtk_fd_pipe_queue_buffers(req, 0);
+}
+
+static const struct media_device_ops mtk_fd_media_req_ops = {
+	.req_validate = mtk_fd_vb2_request_validate,
+	.req_queue = mtk_fd_vb2_request_queue,
+};
+
+static const struct vb2_ops mtk_fd_vb2_ops = {
+	.buf_queue = mtk_fd_vb2_buf_queue,
+	.queue_setup = mtk_fd_vb2_queue_setup,
+	.buf_prepare  = mtk_fd_vb2_buf_prepare,
+	.buf_out_validate = mtk_fd_vb2_buf_out_validate,
+	.start_streaming = mtk_fd_vb2_start_streaming,
+	.stop_streaming = mtk_fd_vb2_stop_streaming,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.buf_request_complete = mtk_fd_vb2_request_complete,
+};
+
+static const struct v4l2_file_operations mtk_fd_v4l2_fops = {
+	.unlocked_ioctl = video_ioctl2,
+	.open = v4l2_fh_open,
+	.release = vb2_fop_release,
+	.poll = vb2_fop_poll,
+	.mmap = vb2_fop_mmap,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl32 = v4l2_compat_ioctl32,
+#endif
+};
+
+static void mtk_fd_node_to_v4l2(struct mtk_fd_pipe *fd_pipe,
+				u32 idx,
+				 struct video_device *vdev,
+				 struct v4l2_format *f)
+{
+	struct mtk_fd_video_device *node = &fd_pipe->nodes[idx];
+
+	vdev->ioctl_ops = node->desc->ops;
+	vdev->device_caps = V4L2_CAP_STREAMING | node->desc->cap;
+	f->type = node->desc->buf_type;
+	mtk_fd_pipe_load_default_fmt(fd_pipe, node, f);
+}
+
+int mtk_fd_dev_media_register(struct device *dev,
+			      struct media_device *media_dev,
+			      const char *model)
+{
+	int ret = 0;
+
+	media_dev->dev = dev;
+	dev_dbg(dev, "setup media_dev.dev: %p\n",
+		media_dev->dev);
+
+	strlcpy(media_dev->model, model,
+		sizeof(media_dev->model));
+	dev_dbg(dev, "setup media_dev.model: %s\n",
+		media_dev->model);
+
+	snprintf(media_dev->bus_info, sizeof(media_dev->bus_info),
+		 "platform:%s", dev_name(dev));
+	dev_dbg(dev, "setup media_dev.bus_info: %s\n",
+		media_dev->bus_info);
+
+	media_dev->hw_revision = 0;
+	dev_dbg(dev, "setup media_dev.hw_revision: %d\n",
+		media_dev->hw_revision);
+
+	media_dev->ops = &mtk_fd_media_req_ops;
+
+	dev_dbg(dev, "media_device_init: media_dev:%p\n",
+		media_dev);
+	media_device_init(media_dev);
+
+	pr_debug("Register media device: %s, %p",
+		 media_dev->model,
+		media_dev);
+
+	ret = media_device_register(media_dev);
+
+	if (ret) {
+		dev_err(dev, "failed to register media device (%d)\n", ret);
+		goto fail_media_dev;
+	}
+	return 0;
+
+fail_media_dev:
+	media_device_unregister(media_dev);
+	media_device_cleanup(media_dev);
+
+	return ret;
+}
+
+int mtk_fd_dev_v4l2_register(struct device *dev,
+			     struct media_device *media_dev,
+			     struct v4l2_device *v4l2_dev)
+{
+	int ret = 0;
+	/* Set up v4l2 device */
+	v4l2_dev->mdev = media_dev;
+	dev_dbg(dev, "setup v4l2_dev->mdev: %p",
+		v4l2_dev->mdev);
+	v4l2_dev->ctrl_handler = NULL;
+	dev_dbg(dev, "setup v4l2_dev->ctrl_handler: %p",
+		v4l2_dev->ctrl_handler);
+
+	pr_debug("Register v4l2 device: %p",
+		 v4l2_dev);
+
+	ret = v4l2_device_register(dev, v4l2_dev);
+
+	if (ret) {
+		dev_err(dev, "failed to register V4L2 device (%d)\n", ret);
+		goto fail_v4l2_dev;
+	}
+
+	return 0;
+
+fail_v4l2_dev:
+	media_device_unregister(media_dev);
+	media_device_cleanup(media_dev);
+
+	return ret;
+}
+
+int mtk_fd_pipe_v4l2_register(struct mtk_fd_pipe *fd_pipe,
+			      struct media_device *media_dev,
+			      struct v4l2_device *v4l2_dev)
+{
+	int i, ret;
+
+	/* Initialize miscellaneous variables */
+	fd_pipe->streaming = 0;
+
+	/* Initialize subdev media entity */
+	fd_pipe->subdev_pads = kcalloc(fd_pipe->num_nodes,
+				       sizeof(*fd_pipe->subdev_pads),
+					GFP_KERNEL);
+	if (!fd_pipe->subdev_pads) {
+		ret = -ENOMEM;
+		goto fail_subdev_pads;
+	}
+
+	ret = media_entity_pads_init(&fd_pipe->subdev.entity,
+				     fd_pipe->num_nodes,
+				     fd_pipe->subdev_pads);
+	if (ret) {
+		dev_err(&fd_pipe->fd_dev->pdev->dev,
+			"failed initialize subdev media entity (%d)\n", ret);
+		goto fail_media_entity;
+	}
+
+	/* Initialize subdev */
+	v4l2_subdev_init(&fd_pipe->subdev, &mtk_fd_subdev_ops);
+
+	fd_pipe->subdev.entity.function =
+		MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;
+
+	fd_pipe->subdev.entity.ops = &mtk_fd_media_ops;
+
+	for (i = 0; i < fd_pipe->num_nodes; i++) {
+		struct mtk_fd_video_device_desc *desc =
+			fd_pipe->nodes[i].desc;
+
+		fd_pipe->subdev_pads[i].flags =
+			V4L2_TYPE_IS_OUTPUT(desc->buf_type) ?
+			MEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;
+	}
+
+	fd_pipe->subdev.flags =
+		V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+	snprintf(fd_pipe->subdev.name, sizeof(fd_pipe->subdev.name),
+		 "%s", fd_pipe->desc->name);
+	v4l2_set_subdevdata(&fd_pipe->subdev, fd_pipe);
+	fd_pipe->subdev.ctrl_handler = NULL;
+	fd_pipe->subdev.internal_ops = &mtk_fd_subdev_internal_ops;
+
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"register subdev: %s, ctrl_handler %p\n",
+		 fd_pipe->subdev.name, fd_pipe->subdev.ctrl_handler);
+	ret = v4l2_device_register_subdev(&fd_pipe->fd_dev->v4l2_dev,
+					  &fd_pipe->subdev);
+	if (ret) {
+		dev_err(&fd_pipe->fd_dev->pdev->dev,
+			"failed initialize subdev (%d)\n", ret);
+		goto fail_subdev;
+	}
+
+	ret = v4l2_device_register_subdev_nodes(&fd_pipe->fd_dev->v4l2_dev);
+	if (ret) {
+		dev_err(&fd_pipe->fd_dev->pdev->dev,
+			"failed to register subdevs (%d)\n", ret);
+		goto fail_subdevs;
+	}
+
+	/* Create video nodes and links */
+	for (i = 0; i < fd_pipe->num_nodes; i++) {
+		struct mtk_fd_video_device *node = &fd_pipe->nodes[i];
+		struct video_device *vdev = &node->vdev;
+		struct vb2_queue *vbq = &node->dev_q.vbq;
+		struct mtk_fd_video_device_desc *desc = node->desc;
+		u32 flags;
+
+		/* Initialize miscellaneous variables */
+		mutex_init(&node->dev_q.lock);
+
+		/* Initialize formats to default values */
+		mtk_fd_node_to_v4l2(fd_pipe, i, vdev, &node->vdev_fmt);
+
+		/* Initialize media entities */
+		ret = media_entity_pads_init(&vdev->entity, 1, &node->vdev_pad);
+		if (ret) {
+			dev_err(&fd_pipe->fd_dev->pdev->dev,
+				"failed initialize media entity (%d)\n", ret);
+			goto fail_vdev_media_entity;
+		}
+
+		node->vdev_pad.flags = V4L2_TYPE_IS_OUTPUT(desc->buf_type) ?
+			MEDIA_PAD_FL_SOURCE : MEDIA_PAD_FL_SINK;
+		vdev->entity.ops = NULL;
+
+		/* Initialize vbq */
+		vbq->type = node->vdev_fmt.type;
+		vbq->io_modes = VB2_MMAP | VB2_DMABUF;
+		vbq->ops = &mtk_fd_vb2_ops;
+		vbq->mem_ops = &vb2_dma_contig_memops;
+		vbq->supports_requests = true;
+		vbq->buf_struct_size = sizeof(struct mtk_fd_dev_buffer);
+		vbq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+		vbq->min_buffers_needed = 0;
+		/* Put the process hub sub device in the vb2 private data*/
+		vbq->drv_priv = fd_pipe;
+		vbq->lock = &node->dev_q.lock;
+		ret = vb2_queue_init(vbq);
+		if (ret) {
+			dev_err(&fd_pipe->fd_dev->pdev->dev,
+				"failed to initialize video queue (%d)\n", ret);
+			goto fail_vdev;
+		}
+
+		/* Initialize vdev */
+		snprintf(vdev->name, sizeof(vdev->name), "%s %s",
+			 fd_pipe->desc->name,
+			 node->desc->name);
+		vdev->release = video_device_release_empty;
+		vdev->fops = &mtk_fd_v4l2_fops;
+		vdev->lock = &node->dev_q.lock;
+		vdev->ctrl_handler = NULL;
+		vdev->v4l2_dev = &fd_pipe->fd_dev->v4l2_dev;
+		vdev->queue = &node->dev_q.vbq;
+		vdev->vfl_dir = V4L2_TYPE_IS_OUTPUT(desc->buf_type) ?
+			VFL_DIR_TX : VFL_DIR_RX;
+		video_set_drvdata(vdev, fd_pipe);
+		pr_debug("register vdev: %s\n", vdev->name);
+		ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+		if (ret) {
+			dev_err(&fd_pipe->fd_dev->pdev->dev,
+				"failed to register video device (%d)\n", ret);
+			goto fail_vdev;
+		}
+
+		/* Create link between video node and the subdev pad */
+		flags = 0;
+		if (desc->dynamic)
+			flags |= MEDIA_LNK_FL_DYNAMIC;
+		if (node->enabled)
+			flags |= MEDIA_LNK_FL_ENABLED;
+		if (node->immutable)
+			flags |= MEDIA_LNK_FL_IMMUTABLE;
+
+		if (V4L2_TYPE_IS_OUTPUT(desc->buf_type))
+			ret = media_create_pad_link(&vdev->entity, 0,
+						    &fd_pipe->subdev.entity,
+						    i, flags);
+		else
+			ret = media_create_pad_link(&fd_pipe->subdev.entity,
+						    i, &vdev->entity, 0,
+						    flags);
+
+		if (ret)
+			goto fail_link;
+	}
+
+	return 0;
+
+	for (; i >= 0; i--) {
+fail_link:
+		video_unregister_device(&fd_pipe->nodes[i].vdev);
+fail_vdev:
+		vb2_queue_release(&fd_pipe->nodes[i].dev_q.vbq);
+		media_entity_cleanup(&fd_pipe->nodes[i].vdev.entity);
+fail_vdev_media_entity:
+		mutex_destroy(&fd_pipe->nodes[i].dev_q.lock);
+	}
+fail_subdevs:
+	v4l2_device_unregister_subdev(&fd_pipe->subdev);
+fail_subdev:
+	media_entity_cleanup(&fd_pipe->subdev.entity);
+fail_media_entity:
+	kfree(fd_pipe->subdev_pads);
+fail_subdev_pads:
+	v4l2_device_unregister(&fd_pipe->fd_dev->v4l2_dev);
+	pr_err("fail_v4l2_dev: media_device_unregister and clenaup:%p",
+	       &fd_pipe->fd_dev->mdev);
+	media_device_unregister(&fd_pipe->fd_dev->mdev);
+	media_device_cleanup(&fd_pipe->fd_dev->mdev);
+
+	return ret;
+}
+
+int mtk_fd_pipe_v4l2_unregister(struct mtk_fd_pipe *fd_pipe)
+{
+	unsigned int i;
+
+	for (i = 0; i < fd_pipe->num_nodes; i++) {
+		video_unregister_device(&fd_pipe->nodes[i].vdev);
+		vb2_queue_release(&fd_pipe->nodes[i].dev_q.vbq);
+		media_entity_cleanup(&fd_pipe->nodes[i].vdev.entity);
+		mutex_destroy(&fd_pipe->nodes[i].dev_q.lock);
+	}
+
+	v4l2_device_unregister_subdev(&fd_pipe->subdev);
+	media_entity_cleanup(&fd_pipe->subdev.entity);
+	kfree(fd_pipe->subdev_pads);
+	v4l2_device_unregister(&fd_pipe->fd_dev->v4l2_dev);
+	media_device_unregister(&fd_pipe->fd_dev->mdev);
+	media_device_cleanup(&fd_pipe->fd_dev->mdev);
+
+	return 0;
+}
+
+void mtk_fd_v4l2_buffer_done(struct vb2_buffer *vb,
+			     enum vb2_buffer_state state)
+{
+	struct mtk_fd_pipe *fd_pipe;
+	struct mtk_fd_video_device *node;
+
+	fd_pipe = vb2_get_drv_priv(vb->vb2_queue);
+	node = mtk_fd_vbq_to_node(vb->vb2_queue);
+	dev_dbg(&fd_pipe->fd_dev->pdev->dev,
+		"%s:%s: return buf, idx(%d), state(%d)\n",
+		fd_pipe->desc->name, node->desc->name,
+		vb->index, state);
+	vb2_buffer_done(vb, state);
+}
+
+/********************************************
+ * MTK FD V4L2 Settings *
+ ********************************************/
+
+static const struct v4l2_ioctl_ops mtk_fd_v4l2_video_out_ioctl_ops = {
+	.vidioc_querycap = mtk_fd_videoc_querycap,
+	.vidioc_enum_framesizes = mtk_fd_videoc_enum_framesizes,
+	.vidioc_enum_fmt_vid_cap = mtk_fd_videoc_enum_fmt,
+	.vidioc_g_fmt_vid_cap_mplane = mtk_fd_videoc_g_fmt,
+	.vidioc_s_fmt_vid_cap_mplane = mtk_fd_videoc_s_fmt,
+	.vidioc_try_fmt_vid_cap_mplane = mtk_fd_videoc_try_fmt,
+	.vidioc_enum_fmt_vid_out = mtk_fd_videoc_enum_fmt,
+	.vidioc_g_fmt_vid_out_mplane = mtk_fd_videoc_g_fmt,
+	.vidioc_s_fmt_vid_out_mplane = mtk_fd_videoc_s_fmt,
+	.vidioc_try_fmt_vid_out_mplane = mtk_fd_videoc_try_fmt,
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_subscribe_event = mtk_fd_vidioc_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+
+};
+
+static const struct v4l2_ioctl_ops mtk_fd_v4l2_video_cap_ioctl_ops = {
+	.vidioc_querycap = mtk_fd_videoc_querycap,
+	.vidioc_enum_framesizes = mtk_fd_videoc_enum_framesizes,
+	.vidioc_enum_fmt_vid_cap = mtk_fd_videoc_enum_fmt,
+	.vidioc_g_fmt_vid_cap_mplane = mtk_fd_videoc_g_fmt,
+	.vidioc_s_fmt_vid_cap_mplane = mtk_fd_videoc_s_fmt,
+	.vidioc_try_fmt_vid_cap_mplane = mtk_fd_videoc_try_fmt,
+	.vidioc_enum_fmt_vid_out = mtk_fd_videoc_enum_fmt,
+	.vidioc_g_fmt_vid_out_mplane = mtk_fd_videoc_g_fmt,
+	.vidioc_s_fmt_vid_out_mplane = mtk_fd_videoc_s_fmt,
+	.vidioc_try_fmt_vid_out_mplane = mtk_fd_videoc_try_fmt,
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_subscribe_event = mtk_fd_vidioc_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+
+};
+
+static const struct v4l2_ioctl_ops mtk_fd_v4l2_meta_out_ioctl_ops = {
+	.vidioc_querycap = mtk_fd_videoc_querycap,
+
+	.vidioc_enum_fmt_meta_cap = mtk_fd_meta_enum_format,
+	.vidioc_g_fmt_meta_cap = mtk_fd_videoc_g_meta_fmt,
+	.vidioc_s_fmt_meta_cap = mtk_fd_videoc_g_meta_fmt,
+	.vidioc_try_fmt_meta_cap = mtk_fd_videoc_g_meta_fmt,
+
+	.vidioc_enum_fmt_meta_out = mtk_fd_meta_enum_format,
+	.vidioc_g_fmt_meta_out = mtk_fd_videoc_g_meta_fmt,
+	.vidioc_s_fmt_meta_out = mtk_fd_videoc_g_meta_fmt,
+	.vidioc_try_fmt_meta_out = mtk_fd_videoc_g_meta_fmt,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+};
+
+static const struct v4l2_ioctl_ops mtk_fd_v4l2_meta_cap_ioctl_ops = {
+	.vidioc_querycap = mtk_fd_videoc_querycap,
+
+	.vidioc_enum_fmt_meta_cap = mtk_fd_meta_enum_format,
+	.vidioc_g_fmt_meta_cap = mtk_fd_videoc_g_meta_fmt,
+	.vidioc_s_fmt_meta_cap = mtk_fd_videoc_g_meta_fmt,
+	.vidioc_try_fmt_meta_cap = mtk_fd_videoc_g_meta_fmt,
+
+	.vidioc_enum_fmt_meta_out = mtk_fd_meta_enum_format,
+	.vidioc_g_fmt_meta_out = mtk_fd_videoc_g_meta_fmt,
+	.vidioc_s_fmt_meta_out = mtk_fd_videoc_g_meta_fmt,
+	.vidioc_try_fmt_meta_out = mtk_fd_videoc_g_meta_fmt,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+};
+
+static struct mtk_fd_dev_format fw_param_fmts[] = {
+	{
+		.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_PARAMS,
+			.max_buffer_size = 1024 * 30,
+		},
+	},
+};
+
+static struct mtk_fd_dev_format in_fmts[] = {
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_VYUY,
+			.mdp_color = MDP_COLOR_VYUY,
+			.colorspace = V4L2_COLORSPACE_BT2020,
+			.depth	 = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_YUYV,
+			.mdp_color = MDP_COLOR_YUYV,
+			.colorspace = V4L2_COLORSPACE_BT2020,
+			.depth	 = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_YVYU,
+			.mdp_color = MDP_COLOR_YVYU,
+			.colorspace = V4L2_COLORSPACE_BT2020,
+			.depth	 = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_UYVY,
+			.mdp_color = MDP_COLOR_UYVY,
+			.colorspace = V4L2_COLORSPACE_BT2020,
+			.depth	 = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+};
+
+static struct mtk_fd_video_device_desc
+	output_queues_setting[MTK_FD_VIDEO_NODE_ID_OUT_TOTAL_NUM] = {
+	{
+		.id = MTK_FD_VIDEO_NODE_ID_YUV_OUT,
+		.name = "FDInput",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.dynamic = 0,
+		.smem_alloc = 0,
+		.default_enable = 1,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_FD_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_FD_CAPTURE_MAX_HEIGHT,
+		.ops = &mtk_fd_v4l2_video_out_ioctl_ops,
+		.description = "YUV source image",
+	},
+	{
+		.id = MTK_FD_VIDEO_NODE_ID_CONFIG_OUT,
+		.name = "FDConfig",
+		.cap = V4L2_CAP_META_OUTPUT,
+		.buf_type = V4L2_BUF_TYPE_META_OUTPUT,
+		.dynamic = 0,
+		.smem_alloc = 1,
+		.default_enable = 1,
+		.fmts = fw_param_fmts,
+		.num_fmts = ARRAY_SIZE(fw_param_fmts),
+		.default_fmt_idx = 0,
+		.ops = &mtk_fd_v4l2_meta_out_ioctl_ops,
+		.description = "Face detection configuration",
+	},
+};
+
+static struct mtk_fd_video_device_desc
+	capture_queues_setting[MTK_FD_VIDEO_NODE_ID_CAPTURE_TOTAL_NUM] = {
+	{
+		.id = MTK_FD_VIDEO_NODE_ID_CAPTURE,
+		.name = "FDOutput",
+		.cap = V4L2_CAP_META_CAPTURE,
+		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
+		.dynamic = 0,
+		.smem_alloc = 1,
+		.default_enable = 1,
+		.fmts = fw_param_fmts,
+		.num_fmts = ARRAY_SIZE(fw_param_fmts),
+		.default_fmt_idx = 0,
+		.ops = &mtk_fd_v4l2_meta_cap_ioctl_ops,
+		.description = "Face detection result",
+	},
+};
+
+static struct mtk_fd_pipe_desc
+	pipe_settings[MTK_FD_PIPE_ID_TOTAL_NUM] = {
+	{
+		.name = MTK_FD_PIPE_NAME_STREAM_0,
+		.id = MTK_FD_PIPE_ID_STREAM_0,
+		.master = MTK_FD_VIDEO_NODE_ID_NO_MASTER,
+		.output_queue_descs = output_queues_setting,
+		.total_output_queues = MTK_FD_VIDEO_NODE_ID_OUT_TOTAL_NUM,
+		.capture_queue_descs = capture_queues_setting,
+		.total_capture_queues = MTK_FD_VIDEO_NODE_ID_CAPTURE_TOTAL_NUM,
+	},
+	{
+		.name = MTK_FD_PIPE_NAME_STREAM_1,
+		.id = MTK_FD_PIPE_ID_STREAM_1,
+		.master = MTK_FD_VIDEO_NODE_ID_NO_MASTER,
+		.output_queue_descs = output_queues_setting,
+		.total_output_queues = MTK_FD_VIDEO_NODE_ID_OUT_TOTAL_NUM,
+		.capture_queue_descs = capture_queues_setting,
+		.total_capture_queues = MTK_FD_VIDEO_NODE_ID_CAPTURE_TOTAL_NUM,
+	},
+};
+
+int mtk_fd_dev_v4l2_init(struct mtk_fd_dev *fd_dev)
+{
+	struct media_device *media_dev;
+	struct v4l2_device *v4l2_dev;
+	int i;
+	int ret = 0;
+
+	media_dev = &fd_dev->mdev;
+	v4l2_dev = &fd_dev->v4l2_dev;
+
+	ret = mtk_fd_dev_media_register(&fd_dev->pdev->dev,
+					media_dev,
+					 MTK_FD_PIPE_MEDIA_MODEL_NAME);
+
+	ret = mtk_fd_dev_v4l2_register(&fd_dev->pdev->dev,
+				       media_dev,
+					v4l2_dev);
+
+	for (i = 0; i < MTK_FD_PIPE_ID_TOTAL_NUM; i++) {
+		ret = mtk_fd_pipe_init(&fd_dev->fd_pipe[i], fd_dev,
+				       &pipe_settings[i],
+					media_dev, v4l2_dev,
+					fd_dev->smem_alloc_dev);
+		if (ret) {
+			dev_err(&fd_dev->pdev->dev,
+				"%s: Pipe id(%d) init failed(%d)\n",
+				fd_dev->fd_pipe[i].desc->name,
+				i, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+void mtk_fd_dev_v4l2_release(struct mtk_fd_dev *fd_dev)
+{
+	int i = 0;
+
+	if (fd_dev)
+		for (i = 0; i < MTK_FD_PIPE_ID_TOTAL_NUM; i++)
+			mtk_fd_pipe_release(&fd_dev->fd_pipe[i]);
+
+	mtk_fd_smem_alloc_dev_release(fd_dev->smem_alloc_dev);
+}
+
diff --git a/drivers/media/platform/mtk-isp/fd/mtk_fd_40.c b/drivers/media/platform/mtk-isp/fd/mtk_fd_40.c
new file mode 100644
index 000000000000..4f238facaeb8
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/fd/mtk_fd_40.c
@@ -0,0 +1,544 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/platform_data/mtk_scp.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include <linux/wait.h>
+
+#ifdef CONFIG_PM_WAKELOCKS
+#include <linux/pm_wakeup.h>
+#else
+#include <linux/wakelock.h>
+#endif
+
+#include "mtk_fd-dev.h"
+#include "mtk_fd-smem.h"
+
+#define FD_DRVNAME	"mtk-fd-4.0"
+
+static int mtk_fd_wait_irq(struct mtk_fd_hw *fd_hw)
+{
+	int timeout;
+	struct mtk_fd_dev *fd_dev = mtk_fd_hw_to_dev(fd_hw);
+
+	timeout = wait_event_interruptible_timeout
+		(fd_hw->wq,
+		 (fd_hw->fd_irq_result & FD_IRQ_MASK),
+		 mtk_fd_us_to_jiffies(1 * 1000000));
+
+	if (timeout == 0) {
+		dev_err(&fd_dev->pdev->dev,
+			"%s timeout, %d\n",
+			__func__, fd_hw->fd_irq_result);
+		return -EAGAIN;
+	}
+
+	dev_dbg(&fd_dev->pdev->dev, "irq_res: 0x%8x\n",
+		fd_hw->fd_irq_result);
+
+	if (timeout != 0 && !(fd_hw->fd_irq_result & FD_IRQ_MASK)) {
+		dev_err(&fd_dev->pdev->dev,
+			"%s interrupted by system signal, return value(%d)\n",
+			__func__, timeout);
+		return -ERESTARTSYS;
+	}
+
+	if (!(fd_hw->fd_irq_result & FD_IRQ_MASK)) {
+		dev_err(&fd_dev->pdev->dev,
+			"%s Not FD, %d\n",
+			__func__, fd_hw->fd_irq_result);
+		return -EINVAL;
+	}
+
+	fd_hw->fd_irq_result = 0;
+
+	return 0;
+}
+
+static irqreturn_t mtk_fd_irq(int irq, void *dev_addr)
+{
+	struct mtk_fd_hw *fd_hw;
+
+	fd_hw = (struct mtk_fd_hw *)dev_addr;
+	fd_hw->fd_irq_result = FD_RD32(fd_hw->fd_base + FD_INT);
+	wake_up_interruptible(&fd_hw->wq);
+
+	return IRQ_HANDLED;
+}
+
+static int mtk_fd_hw_job_finish(struct mtk_fd_hw *fd_hw,
+				struct fd_hw_param *fd_param,
+				enum vb2_buffer_state vbf_state)
+{
+	struct mtk_fd_pipe *fd_pipe;
+	int ret;
+	int pipe_id;
+	struct mtk_fd_dev *fd_dev = mtk_fd_hw_to_dev(fd_hw);
+
+	if (!fd_param)
+		return -EINVAL;
+
+	pipe_id = mtk_fd_pipe_get_pipe_from_job_id(fd_param->frame_id);
+	fd_pipe = mtk_fd_dev_get_pipe(fd_dev, pipe_id);
+
+	dev_dbg(&fd_dev->pdev->dev,
+		"%s: ready to return buffers, pipe(%d), pipe_job_id(%d)\n",
+		__func__, pipe_id, fd_param->frame_id);
+
+	ret = mtk_fd_pipe_job_finish(fd_pipe, fd_param->frame_id, vbf_state);
+
+	if (ret)
+		dev_err(&fd_dev->pdev->dev, "%s: finish CB failed(%d)\n",
+			__func__, ret);
+
+	return ret;
+}
+
+static dma_addr_t mtk_fd_hw_alloc_rs_buf(struct mtk_fd_hw *fd_hw)
+{
+	u64 va;
+	struct mtk_fd_dev *fd_dev = mtk_fd_hw_to_dev(fd_hw);
+
+	dma_addr_t dma_handle;
+	u32 size = RS_BUF_SIZE_MAX;
+
+	va = (uint64_t)dma_alloc_coherent(&fd_dev->pdev->dev, size, &dma_handle,
+					  GFP_KERNEL);
+	if (va == 0) {
+		dev_err(&fd_dev->pdev->dev, "dma_alloc null va!\n");
+		return va;
+	}
+
+	memset((uint8_t *)va, 0, size);
+
+	return dma_handle;
+}
+
+static int mtk_fd_hw_get_scp_mem(struct mtk_fd_hw *fd_hw,
+				 struct fd_buffer *scp_mem)
+{
+	struct mtk_fd_dev *fd_dev = mtk_fd_hw_to_dev(fd_hw);
+	struct device *dev = &fd_dev->pdev->dev;
+	u32 size;
+	dma_addr_t addr;
+
+	scp_mem->va = scp_get_reserve_mem_virt(SCP_FD_MEM_ID);
+	scp_mem->pa = scp_get_reserve_mem_phys(SCP_FD_MEM_ID);
+	size = PAGE_ALIGN(scp_get_reserve_mem_size(SCP_FD_MEM_ID));
+
+	if (scp_mem->va != 0 && size > 0)
+		memset((void *)scp_mem->va, 0, size);
+	else
+		return -ENOMEM;
+
+	/* get iova address */
+	addr = dma_map_page_attrs(dev, phys_to_page(scp_mem->pa), 0,
+				  size, DMA_BIDIRECTIONAL,
+				  DMA_ATTR_SKIP_CPU_SYNC);
+	if (dma_mapping_error(dev, addr)) {
+		scp_mem->pa = 0;
+		dev_err(dev, "Failed to map scp iova\n");
+		return -ENOMEM;
+	}
+	scp_mem->iova = addr;
+	return 0;
+}
+
+static int mtk_fd_send_ipi_init(struct mtk_fd_hw *fd_hw,
+				struct platform_device *pdev)
+{
+	struct ipi_message fd_init_msg;
+	struct fd_manager_ctx *fd_manager;
+	struct fd_buffer scp_mem;
+	dma_addr_t fd_resize_workbuf;
+	int ret;
+
+	fd_init_msg.cmd_id = FD_CMD_INIT;
+
+	ret = mtk_fd_hw_get_scp_mem(fd_hw, &scp_mem);
+	if (ret)
+		return ret;
+
+	fd_init_msg.fd_manager = scp_mem;
+	fd_manager = (struct fd_manager_ctx *)fd_init_msg.fd_manager.va;
+
+	fd_resize_workbuf = mtk_fd_hw_alloc_rs_buf(fd_hw);
+	if (!fd_resize_workbuf)
+		return -EINVAL;
+
+	fd_manager->rs_result.iova = fd_resize_workbuf;
+
+	return scp_ipi_send(pdev, SCP_IPI_FD_CMD, &fd_init_msg,
+			    sizeof(fd_init_msg), 0);
+}
+
+static int mtk_fd_send_ipi_cmd(struct platform_device *pdev,
+			       struct fd_hw_param *fd_param)
+{
+	struct ipi_message fd_ipi_msg;
+
+	fd_ipi_msg.cmd_id = FD_CMD_ENQ;
+	fd_ipi_msg.fd_param = *fd_param;
+
+	return scp_ipi_send(pdev, SCP_IPI_FD_CMD, &fd_ipi_msg,
+			    sizeof(fd_ipi_msg), 0);
+}
+
+static int mtk_fd_load_scp(struct mtk_fd_hw *fd_hw)
+{
+	int ret;
+	phandle rproc_phandle;
+	struct mtk_fd_dev *fd_dev = mtk_fd_hw_to_dev(fd_hw);
+
+	/* init scp */
+	fd_hw->scp_pdev = scp_get_pdev(fd_dev->pdev);
+
+	if (!fd_hw->scp_pdev) {
+		dev_err(&fd_dev->pdev->dev,
+			"Failed to get scp device\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32(fd_dev->pdev->dev.of_node,
+				 "mediatek,scp", &rproc_phandle)) {
+		dev_err(&fd_dev->pdev->dev,
+			"Could not get scp device\n");
+		return -EINVAL;
+	}
+
+	fd_hw->rproc_handle = rproc_get_by_phandle(rproc_phandle);
+
+	if (!fd_hw->rproc_handle) {
+		dev_err(&fd_dev->pdev->dev,
+			"Could not get FD's rproc_handle\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(&fd_dev->pdev->dev, "FD rproc_phandle: %p",
+		fd_hw->rproc_handle);
+
+	ret = rproc_boot(fd_hw->rproc_handle);
+	if (ret < 0) {
+		/**
+		 * Return 0 if downloading firmware successfully,
+		 * otherwise it is failed
+		 */
+		dev_err(&fd_dev->pdev->dev,
+			"rproc_boot failed!");
+		return -EINVAL;
+	}
+	return ret;
+}
+
+static int mtk_fd_hw_enable(struct mtk_fd_hw *fd_hw)
+{
+	int ret;
+
+	ret = mtk_fd_load_scp(fd_hw);
+	if (ret)
+		return ret;
+
+	ret = mtk_fd_send_ipi_init(fd_hw, fd_hw->scp_pdev);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+int mtk_fd_hw_connect(struct mtk_fd_hw *fd_hw)
+{
+	s32 usercount;
+	struct mtk_fd_dev *fd_dev;
+
+	fd_dev = mtk_fd_hw_to_dev(fd_hw);
+	fd_hw = &fd_dev->fd_hw;
+	mutex_lock(&fd_hw->fd_hw_lock);
+
+	dev_dbg(&fd_dev->pdev->dev, "open fd_hw = 0x%p\n", fd_hw);
+
+	usercount = atomic_inc_return(&fd_hw->fd_user_cnt);
+
+	if (usercount == 1) {
+		dev_dbg(&fd_dev->pdev->dev,
+			"%s: mtk_fd_hw_enable\n", __func__);
+
+		pm_runtime_get_sync(&fd_dev->pdev->dev);
+		if (mtk_fd_hw_enable(fd_hw)) {
+			pm_runtime_put_sync(&fd_dev->pdev->dev);
+			atomic_dec_return(&fd_hw->fd_user_cnt);
+			mutex_unlock(&fd_hw->fd_hw_lock);
+			return -EINVAL;
+		}
+		fd_hw->state = FD_INI;
+	}
+
+	dev_dbg(&fd_dev->pdev->dev, "%s: usercount = %d",
+		__func__, atomic_read(&fd_hw->fd_user_cnt));
+	mutex_unlock(&fd_hw->fd_hw_lock);
+
+	return 0;
+}
+
+int mtk_fd_hw_job_exec(struct mtk_fd_hw *fd_hw, struct fd_hw_param *fd_param)
+{
+	struct mtk_fd_dev *fd_dev;
+	struct fd_user_output *fd_output;
+	int ret;
+	u32 num;
+
+	fd_dev = mtk_fd_hw_to_dev(fd_hw);
+	mutex_lock(&fd_hw->fd_hw_lock);
+
+	fd_hw->state = FD_ENQ;
+	ret = mtk_fd_send_ipi_cmd(fd_hw->scp_pdev, fd_param);
+	if (ret) {
+		mutex_unlock(&fd_hw->fd_hw_lock);
+		dev_err(&fd_dev->pdev->dev, "Failed to send FD ipi command\n");
+		mtk_fd_hw_job_finish(fd_hw, fd_param, VB2_BUF_STATE_ERROR);
+		return ret;
+	}
+
+	ret = mtk_fd_wait_irq(fd_hw);
+	if (ret) {
+		mutex_unlock(&fd_hw->fd_hw_lock);
+		mtk_fd_hw_job_finish(fd_hw, fd_param, VB2_BUF_STATE_ERROR);
+		return ret;
+	}
+
+	num = FD_RD32(fd_hw->fd_base + FD_RESULT);
+	FD_WR32(0x0, fd_hw->fd_base + FD_INT_EN);
+	fd_output = (struct fd_user_output *)fd_param->fd_user_result.va;
+	fd_output->face_number = num;
+	fd_hw->state = FD_CBD;
+
+	mutex_unlock(&fd_hw->fd_hw_lock);
+
+	return mtk_fd_hw_job_finish(fd_hw, fd_param, VB2_BUF_STATE_DONE);
+}
+
+int mtk_fd_hw_disconnect(struct mtk_fd_hw *fd_hw)
+{
+	struct mtk_fd_dev *fd_dev;
+	s32 usercount;
+
+	fd_dev = mtk_fd_hw_to_dev(fd_hw);
+	mutex_lock(&fd_hw->fd_hw_lock);
+
+	dev_dbg(&fd_dev->pdev->dev, "release fd_hw: 0x%p\n", fd_hw);
+
+	usercount = atomic_read(&fd_hw->fd_user_cnt);
+	dev_dbg(&fd_dev->pdev->dev, "%s: usercount = %d\n",
+		__func__, atomic_read(&fd_hw->fd_user_cnt));
+
+	if (usercount == 1) {
+		dev_dbg(&fd_dev->pdev->dev,
+			"%s: mtk_fd_hw_disable\n", __func__);
+		if (fd_hw->state == FD_ENQ)
+			mtk_fd_wait_irq(fd_hw);
+
+		sg_free_table(&fd_hw->sgtable);
+		pm_runtime_put_sync(&fd_dev->pdev->dev);
+	}
+	atomic_dec_return(&fd_hw->fd_user_cnt);
+
+	dev_dbg(&fd_dev->pdev->dev, "%s: usercount = %d\n",
+		__func__, atomic_read(&fd_hw->fd_user_cnt));
+	mutex_unlock(&fd_hw->fd_hw_lock);
+
+	return 0;
+}
+
+static int mtk_fd_probe(struct platform_device *pdev)
+{
+	struct mtk_fd_dev *fd_dev;
+	struct mtk_fd_hw *fd_hw;
+	struct device_node *node;
+	int irq_num;
+	int ret;
+
+	fd_dev = devm_kzalloc(&pdev->dev, sizeof(*fd_dev), GFP_KERNEL);
+
+	if (!fd_dev)
+		return -ENOMEM;
+
+	dev_set_drvdata(&pdev->dev, fd_dev);
+	fd_hw = &fd_dev->fd_hw;
+
+	if (!fd_hw) {
+		dev_err(&pdev->dev, "Unable to allocate fd_hw\n");
+		return -ENOMEM;
+	}
+
+	fd_dev->pdev = pdev;
+
+	irq_num = irq_of_parse_and_map(pdev->dev.of_node, FD_IRQ_IDX);
+	ret = request_irq(irq_num, (irq_handler_t)mtk_fd_irq,
+			  IRQF_TRIGGER_NONE, FD_DRVNAME, fd_hw);
+	if (ret) {
+		dev_err(&pdev->dev, "%s request_irq fail, irq=%d\n",
+			__func__, irq_num);
+		return ret;
+	}
+	dev_dbg(&pdev->dev, "irq_num=%d\n", irq_num);
+
+	node = pdev->dev.of_node;
+	if (!node) {
+		dev_err(&pdev->dev, "find fd node failed!!!\n");
+		return -ENODEV;
+	}
+
+	fd_hw->fd_base = of_iomap(node, 0);
+
+	if (!fd_hw->fd_base) {
+		dev_err(&pdev->dev, "unable to map fd node!!!\n");
+		return -ENODEV;
+	}
+
+	dev_dbg(&pdev->dev, "fd_hw->fd_base: %lx\n",
+		(unsigned long)fd_hw->fd_base);
+
+	fd_hw->fd_clk = devm_clk_get(&pdev->dev, "FD_CLK_IMG_FD");
+	if (IS_ERR(fd_hw->fd_clk)) {
+		dev_err(&pdev->dev, "cannot get FD_CLK_IMG_FD clock\n");
+		return PTR_ERR(fd_hw->fd_clk);
+	}
+
+	pm_runtime_enable(&pdev->dev);
+	atomic_set(&fd_hw->fd_user_cnt, 0);
+	init_waitqueue_head(&fd_hw->wq);
+	mutex_init(&fd_hw->fd_hw_lock);
+	fd_hw->fd_irq_result = 0;
+
+	ret = mtk_fd_reserved_memory_init(fd_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "memory init failed: %d\n", ret);
+		goto err_init;
+	}
+
+	ret = mtk_fd_dev_v4l2_init(fd_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "v4l2 init failed: %d\n", ret);
+		goto err_init;
+	}
+
+	dev_dbg(&pdev->dev, "Mediatek Camera FD driver probe.\n");
+
+	return 0;
+
+err_init:
+	if (fd_dev->smem_alloc_dev)
+		device_unregister(fd_dev->smem_alloc_dev);
+
+	return ret;
+}
+
+static int mtk_fd_remove(struct platform_device *pdev)
+{
+	int irq_i4;
+	struct mtk_fd_dev *fd_dev = dev_get_drvdata(&pdev->dev);
+
+	if (fd_dev) {
+		mtk_fd_dev_v4l2_release(fd_dev);
+	} else {
+		dev_err(&pdev->dev, "Can't find fd driver data\n");
+		return -EINVAL;
+	}
+
+	mutex_destroy(&fd_dev->fd_hw.fd_hw_lock);
+	pm_runtime_disable(&pdev->dev);
+
+	irq_i4 = platform_get_irq(pdev, 0);
+	free_irq(irq_i4, NULL);
+	kfree(fd_dev);
+
+	return 0;
+}
+
+static int mtk_fd_suspend(struct device *dev)
+{
+	struct mtk_fd_dev *fd_dev;
+
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	fd_dev = dev_get_drvdata(dev);
+	dev_dbg(&fd_dev->pdev->dev, "%s: usercount = %d",
+		__func__, atomic_read(&fd_dev->fd_hw.fd_user_cnt));
+
+	if (atomic_read(&fd_dev->fd_hw.fd_user_cnt) > 0) {
+		dev_dbg(&fd_dev->pdev->dev, "%s: close clock\n", __func__);
+		clk_disable_unprepare(fd_dev->fd_hw.fd_clk);
+	}
+	return 0;
+}
+
+static int mtk_fd_resume(struct device *dev)
+{
+	struct mtk_fd_dev *fd_dev;
+	int ret;
+
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	fd_dev = dev_get_drvdata(dev);
+	dev_dbg(&fd_dev->pdev->dev, "%s: usercount = %d",
+		__func__, atomic_read(&fd_dev->fd_hw.fd_user_cnt));
+
+	if (atomic_read(&fd_dev->fd_hw.fd_user_cnt) > 0) {
+		dev_dbg(&fd_dev->pdev->dev, "%s: open clock\n", __func__);
+
+		ret = clk_prepare_enable(fd_dev->fd_hw.fd_clk);
+		if (ret < 0) {
+			dev_dbg(&fd_dev->pdev->dev, "open fd clk failed\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops mtk_fd_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mtk_fd_suspend, mtk_fd_resume)
+	SET_RUNTIME_PM_OPS(mtk_fd_suspend, mtk_fd_resume, NULL)
+};
+
+static const struct of_device_id mtk_fd_of_ids[] = {
+	{ .compatible = "mediatek,mt8183-fd", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, mtk_fd_of_ids);
+
+static struct platform_driver mtk_fd_driver = {
+	.probe   = mtk_fd_probe,
+	.remove  = mtk_fd_remove,
+	.driver  = {
+		.name  = FD_DRVNAME,
+		.of_match_table = mtk_fd_of_ids,
+		.pm = &mtk_fd_pm_ops,
+	}
+};
+module_platform_driver(mtk_fd_driver);
+
+MODULE_DESCRIPTION("Mediatek FD driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/mtk-isp/isp_50/Makefile b/drivers/media/platform/mtk-isp/isp_50/Makefile
new file mode 100644
index 000000000000..da36c7888c0c
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/Makefile
@@ -0,0 +1,13 @@
+# SPDX-License-Identifier: GPL-2.0
+
+ifeq ($(CONFIG_VIDEO_MEDIATEK_ISP_DIP_SUPPORT),y)
+obj-y += dip/
+endif
+
+ifeq ($(CONFIG_VIDEO_MEDIATEK_ISP_PASS1),y)
+obj-y += cam/
+endif
+
+ifeq ($(CONFIG_MTK_SENINF),y)
+obj-y += seninf/
+endif
diff --git a/drivers/media/platform/mtk-isp/isp_50/cam/Makefile b/drivers/media/platform/mtk-isp/isp_50/cam/Makefile
new file mode 100644
index 000000000000..d545ca6f09c5
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/cam/Makefile
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0
+
+mtk-cam-isp-objs += mtk_cam-ctrl.o
+mtk-cam-isp-objs += mtk_cam-v4l2-util.o
+mtk-cam-isp-objs += mtk_cam.o
+mtk-cam-isp-objs += mtk_cam-scp.o
+mtk-cam-isp-objs += mtk_cam-smem.o
+
+obj-$(CONFIG_VIDEO_MEDIATEK_ISP_PASS1) += mtk-cam-isp.o
\ No newline at end of file
diff --git a/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-ctrl.c b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-ctrl.c
new file mode 100644
index 000000000000..ca469592b549
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-ctrl.c
@@ -0,0 +1,138 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2018 MediaTek Inc.
+
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+#include "mtk_cam-ctrl.h"
+#include "mtk_cam.h"
+
+static int handle_ctrl_get_bin_info(struct v4l2_ctrl *ctrl, int is_width)
+{
+	struct mtk_cam_dev *cam_dev = ctrl->priv;
+	struct v4l2_format *fmt;
+
+	fmt = &cam_dev->vdev_nodes[MTK_CAM_P1_MAIN_STREAM_OUT].vdev_fmt;
+
+	dev_dbg(cam_dev->dev, "Get bin info w*h:%d*%d is_width:%d",
+		fmt->fmt.pix_mp.width, fmt->fmt.pix_mp.height, is_width);
+
+	if (is_width)
+		ctrl->val = fmt->fmt.pix_mp.width;
+	else
+		ctrl->val = fmt->fmt.pix_mp.height;
+
+	return 0;
+}
+
+static int handle_ctrl_get_process_raw(struct v4l2_ctrl *ctrl)
+{
+	struct mtk_cam_dev *cam_dev = ctrl->priv;
+	struct isp_p1_device *p1_dev = get_p1_device(cam_dev->dev);
+
+	ctrl->val = (p1_dev->isp_ctx.isp_raw_path == ISP_PROCESS_RAW_PATH);
+
+	dev_dbg(cam_dev->dev, "Get process raw:%d", ctrl->val);
+
+	return 0;
+}
+
+static int handle_ctrl_set_process_raw(struct v4l2_ctrl *ctrl)
+{
+	struct mtk_cam_dev *cam_dev = ctrl->priv;
+	struct isp_p1_device *p1_dev = get_p1_device(cam_dev->dev);
+
+	p1_dev->isp_ctx.isp_raw_path = (ctrl->val) ?
+		ISP_PROCESS_RAW_PATH : ISP_PURE_RAW_PATH;
+	dev_dbg(cam_dev->dev, "Set process raw:%d", ctrl->val);
+	return 0;
+}
+
+static int mtk_cam_dev_g_ctrl(struct v4l2_ctrl *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_MTK_PROCESSING_RAW:
+		handle_ctrl_get_process_raw(ctrl);
+		break;
+	case V4L2_CID_MTK_GET_BIN_WIDTH:
+		handle_ctrl_get_bin_info(ctrl, 1);
+		break;
+	case V4L2_CID_MTK_GET_BIN_HEIGTH:
+		handle_ctrl_get_bin_info(ctrl, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int mtk_cam_dev_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_MTK_PROCESSING_RAW:
+		return handle_ctrl_set_process_raw(ctrl);
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct v4l2_ctrl_ops mtk_cam_dev_ctrl_ops = {
+	.g_volatile_ctrl = mtk_cam_dev_g_ctrl,
+	.s_ctrl = mtk_cam_dev_s_ctrl,
+};
+
+struct v4l2_ctrl_config mtk_cam_controls[] = {
+	{
+	.ops = &mtk_cam_dev_ctrl_ops,
+	.id = V4L2_CID_MTK_PROCESSING_RAW,
+	.name = "MTK CAM PROCESSING RAW",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+	},
+	{
+	.ops = &mtk_cam_dev_ctrl_ops,
+	.id = V4L2_CID_MTK_GET_BIN_WIDTH,
+	.name = "MTK CAM GET BIN WIDTH",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = IMG_MIN_WIDTH,
+	.max = IMG_MAX_WIDTH,
+	.step = 1,
+	.def = IMG_MAX_WIDTH,
+	.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	},
+	{
+	.ops = &mtk_cam_dev_ctrl_ops,
+	.id = V4L2_CID_MTK_GET_BIN_HEIGTH,
+	.name = "MTK CAM GET BIN HEIGHT",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = IMG_MIN_HEIGHT,
+	.max = IMG_MAX_HEIGHT,
+	.step = 1,
+	.def = IMG_MAX_HEIGHT,
+	.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	},
+};
+
+int mtk_cam_ctrl_init(struct mtk_cam_dev *cam_dev,
+		      struct v4l2_ctrl_handler *hdl)
+{
+	unsigned int i;
+
+	/* Initialized HW controls, allow V4L2_CID_MTK_CAM_MAX ctrls */
+	v4l2_ctrl_handler_init(hdl, V4L2_CID_MTK_CAM_MAX);
+	if (hdl->error) {
+		v4l2_ctrl_handler_free(hdl);
+		return hdl->error;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(mtk_cam_controls); i++)
+		v4l2_ctrl_new_custom(hdl, &mtk_cam_controls[i], cam_dev);
+
+	dev_dbg(cam_dev->dev, "%s done", __func__);
+
+	return 0;
+}
diff --git a/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-ctrl.h b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-ctrl.h
new file mode 100644
index 000000000000..0f9349ae0b07
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-ctrl.h
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_CTRL_H__
+#define __MTK_CAM_CTRL_H__
+
+#include <media/v4l2-ctrls.h>
+
+#include "mtk_cam-v4l2-util.h"
+
+/* The base for the MTK Camera ISP P1 driver controls.
+ * We reserve 16 controls for this driver.
+ */
+#define V4L2_CID_MTK_CAM_BASE			V4L2_CID_USER_MTK_CAM_BASE
+
+/* Control MTK ISP P1 main stream to process raw image data or not.
+ * The default value is 0 which outputs the pure raw bayer data from sensor,
+ * without image processing in ISP HW.
+ */
+#define V4L2_CID_MTK_PROCESSING_RAW		(V4L2_CID_MTK_CAM_BASE + 1)
+
+/* MTK ISP P1 HW supports frontal binning function.
+ * If this function is enabled, the 3A algo. may get the new image resolution
+ * which is binned by ISP P1. If this function is disabled or no supported,
+ * the image resolution will be equal to configured image format.
+ * For this control, it is read only.
+ */
+#define V4L2_CID_MTK_GET_BIN_WIDTH		(V4L2_CID_MTK_CAM_BASE + 2)
+#define V4L2_CID_MTK_GET_BIN_HEIGTH		(V4L2_CID_MTK_CAM_BASE + 3)
+
+#define V4L2_CID_MTK_CAM_MAX			16
+
+int mtk_cam_ctrl_init(struct mtk_cam_dev *cam_dev,
+		      struct v4l2_ctrl_handler *hdl);
+
+#endif /* __MTK_CAM_CTRL_H__ */
diff --git a/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-regs.h b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-regs.h
new file mode 100644
index 000000000000..9e59a6bfc6b7
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-regs.h
@@ -0,0 +1,126 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ */
+
+#ifndef _CAM_REGS_H
+#define _CAM_REGS_H
+
+/* TG Bit Mask */
+#define VFDATA_EN_BIT			BIT(0)
+#define CMOS_EN_BIT			BIT(0)
+
+/* normal signal bit */
+#define VS_INT_ST			BIT(0)
+#define HW_PASS1_DON_ST			BIT(11)
+#define SOF_INT_ST			BIT(12)
+#define SW_PASS1_DON_ST			BIT(30)
+
+/* err status bit */
+#define TG_ERR_ST			BIT(4)
+#define TG_GBERR_ST			BIT(5)
+#define CQ_CODE_ERR_ST			BIT(6)
+#define CQ_APB_ERR_ST			BIT(7)
+#define CQ_VS_ERR_ST			BIT(8)
+#define AMX_ERR_ST			BIT(15)
+#define RMX_ERR_ST			BIT(16)
+#define BMX_ERR_ST			BIT(17)
+#define RRZO_ERR_ST			BIT(18)
+#define AFO_ERR_ST			BIT(19)
+#define IMGO_ERR_ST			BIT(20)
+#define AAO_ERR_ST			BIT(21)
+#define PSO_ERR_ST			BIT(22)
+#define LCSO_ERR_ST			BIT(23)
+#define BNR_ERR_ST			BIT(24)
+#define LSCI_ERR_ST			BIT(25)
+#define DMA_ERR_ST			BIT(29)
+
+/* CAM DMA done status */
+#define FLKO_DONE_ST			BIT(4)
+#define AFO_DONE_ST			BIT(5)
+#define AAO_DONE_ST			BIT(7)
+#define PSO_DONE_ST			BIT(14)
+
+/* IRQ signal mask */
+#define INT_ST_MASK_CAM			( \
+					VS_INT_ST |\
+					SOF_INT_ST |\
+					HW_PASS1_DON_ST |\
+					SW_PASS1_DON_ST)
+
+/* IRQ Error Mask */
+#define INT_ST_MASK_CAM_ERR		( \
+					TG_ERR_ST |\
+					TG_GBERR_ST |\
+					CQ_CODE_ERR_ST |\
+					CQ_APB_ERR_ST |\
+					CQ_VS_ERR_ST |\
+					BNR_ERR_ST |\
+					RMX_ERR_ST |\
+					BMX_ERR_ST |\
+					BNR_ERR_ST |\
+					LSCI_ERR_ST |\
+					DMA_ERR_ST)
+
+/* IRQ Signal Log Mask */
+#define INT_ST_LOG_MASK_CAM		( \
+					SOF_INT_ST |\
+					SW_PASS1_DON_ST |\
+					HW_PASS1_DON_ST |\
+					VS_INT_ST |\
+					TG_ERR_ST |\
+					TG_GBERR_ST |\
+					RRZO_ERR_ST |\
+					AFO_ERR_ST |\
+					IMGO_ERR_ST |\
+					AAO_ERR_ST |\
+					DMA_ERR_ST)
+
+/* DMA Event Notification Mask */
+#define DMA_ST_MASK_CAM			( \
+					AAO_DONE_ST |\
+					AFO_DONE_ST)
+
+/* Status check */
+#define REG_CTL_EN			0x0004
+#define REG_CTL_DMA_EN			0x0008
+#define REG_CTL_FMT_SEL			0x0010
+#define REG_CTL_EN2			0x0018
+#define REG_CTL_RAW_INT_EN		0x0020
+#define REG_CTL_RAW_INT_STAT		0x0024
+#define REG_CTL_RAW_INT2_STAT		0x0034
+
+#define REG_TG_SEN_MODE			0x0230
+#define REG_TG_VF_CON			0x0234
+
+#define REG_IMGO_BASE_ADDR		0x1020
+#define REG_RRZO_BASE_ADDR		0x1050
+
+/* Error status log */
+#define REG_IMGO_ERR_STAT		0x1360
+#define REG_RRZO_ERR_STAT		0x1364
+#define REG_AAO_ERR_STAT		0x1368
+#define REG_AFO_ERR_STAT		0x136c
+#define REG_LCSO_ERR_STAT		0x1370
+#define REG_UFEO_ERR_STAT		0x1374
+#define REG_PDO_ERR_STAT		0x1378
+#define REG_BPCI_ERR_STAT		0x137c
+#define REG_LSCI_ERR_STAT		0x1384
+#define REG_PDI_ERR_STAT		0x138c
+#define REG_LMVO_ERR_STAT		0x1390
+#define REG_FLKO_ERR_STAT		0x1394
+#define REG_PSO_ERR_STAT		0x13a0
+
+/* ISP command */
+#define REG_CQ_THR0_BASEADDR		0x0198
+#define REG_HW_FRAME_NUM		0x13b8
+
+/* META */
+#define REG_META0_VB2_INDEX		0x14dc
+#define REG_META1_VB2_INDEX		0x151c
+
+/* FBC */
+#define REG_AAO_FBC_STATUS		0x013c
+#define REG_AFO_FBC_STATUS		0x0134
+
+#endif	/* _CAM_REGS_H */
diff --git a/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-scp.c b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-scp.c
new file mode 100644
index 000000000000..47a411633d7f
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-scp.c
@@ -0,0 +1,368 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2018 MediaTek Inc.
+
+#include <linux/atomic.h>
+#include <linux/kthread.h>
+#include <linux/platform_data/mtk_scp.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/vmalloc.h>
+
+#include "mtk_cam.h"
+
+static void isp_composer_deinit(struct mtk_isp_p1_ctx *isp_ctx)
+{
+	struct mtk_isp_queue_work *ipi_job, *tmp_ipi_job;
+
+	atomic_set(&isp_ctx->cmd_queued, 0);
+	atomic_set(&isp_ctx->composer_txlist.queue_cnt, 0);
+	atomic_set(&isp_ctx->composing_frame, 0);
+	atomic_set(&isp_ctx->ipi_occupied, 0);
+
+	spin_lock(&isp_ctx->composer_txlist.lock);
+	list_for_each_entry_safe(ipi_job, tmp_ipi_job,
+				 &isp_ctx->composer_txlist.queue,
+				 list_entry) {
+		list_del(&ipi_job->list_entry);
+		kfree(ipi_job);
+	}
+	atomic_set(&isp_ctx->composer_txlist.queue_cnt, 0);
+	spin_unlock(&isp_ctx->composer_txlist.lock);
+
+	mutex_lock(&isp_ctx->lock);
+	if (isp_ctx->composer_tx_thread.thread) {
+		kthread_stop(isp_ctx->composer_tx_thread.thread);
+		wake_up_interruptible(&isp_ctx->composer_tx_thread.wq);
+		isp_ctx->composer_tx_thread.thread = NULL;
+	}
+
+	if (isp_ctx->composer_deinit_thread.thread) {
+		wake_up(&isp_ctx->composer_deinit_thread.wq);
+		isp_ctx->composer_deinit_thread.thread = NULL;
+	}
+	mutex_unlock(&isp_ctx->lock);
+}
+
+/*
+ * Two kinds of flow control in isp_composer_tx_work.
+ *
+ * Case 1: IPI commands flow control. The maximum number of command queues is 3.
+ * There are two types of IPI commands (SCP_ISP_CMD/SCP_ISP_FRAME) in P1 driver.
+ * It is controlled by ipi_occupied.
+ * The priority of SCP_ISP_CMD is higher than SCP_ISP_FRAME.
+ *
+ * Case 2: Frame buffers flow control. The maximum number of frame buffers is 3.
+ * It is controlled by composing_frame.
+ * Frame buffer is sent by SCP_ISP_FRAME command.
+ */
+static int isp_composer_tx_work(void *data)
+{
+	struct mtk_isp_p1_ctx *isp_ctx = (struct mtk_isp_p1_ctx *)data;
+	struct isp_p1_device *p1_dev = p1_ctx_to_dev(isp_ctx);
+	struct device *dev = &p1_dev->pdev->dev;
+	struct mtk_isp_queue_work *isp_composer_work, *tmp_ipi_job;
+	struct isp_queue *composer_txlist = &isp_ctx->composer_txlist;
+	int ret;
+
+	while (1) {
+		ret = wait_event_interruptible
+			(isp_ctx->composer_tx_thread.wq,
+			 (atomic_read(&composer_txlist->queue_cnt) > 0 &&
+			 atomic_read(&isp_ctx->ipi_occupied)
+				< ISP_COMPOSING_MAX_NUM &&
+			 atomic_read(&isp_ctx->composing_frame)
+				< ISP_FRAME_COMPOSING_MAX_NUM) ||
+			 (atomic_read(&isp_ctx->cmd_queued) > 0 &&
+			 atomic_read(&isp_ctx->ipi_occupied)
+				< ISP_COMPOSING_MAX_NUM) ||
+			 kthread_should_stop());
+
+		if (kthread_should_stop())
+			break;
+
+		spin_lock(&composer_txlist->lock);
+		if (atomic_read(&isp_ctx->cmd_queued) > 0) {
+			list_for_each_entry_safe(isp_composer_work, tmp_ipi_job,
+						 &composer_txlist->queue,
+						 list_entry) {
+				if (isp_composer_work->type == SCP_ISP_CMD) {
+					dev_dbg(dev, "Found a cmd\n");
+					break;
+				}
+			}
+		} else {
+			if (atomic_read(&isp_ctx->composing_frame) >=
+				ISP_FRAME_COMPOSING_MAX_NUM) {
+				spin_unlock(&composer_txlist->lock);
+				continue;
+			}
+			isp_composer_work =
+			    list_first_entry_or_null
+				(&composer_txlist->queue,
+				 struct mtk_isp_queue_work,
+				 list_entry);
+		}
+
+		list_del(&isp_composer_work->list_entry);
+		atomic_dec(&composer_txlist->queue_cnt);
+		spin_unlock(&composer_txlist->lock);
+
+		if (isp_composer_work->type == SCP_ISP_CMD) {
+			scp_ipi_send
+				(p1_dev->scp_pdev,
+				 SCP_IPI_ISP_CMD,
+				 &isp_composer_work->cmd,
+				 sizeof(isp_composer_work->cmd),
+				 0);
+			atomic_dec(&isp_ctx->cmd_queued);
+			atomic_inc(&isp_ctx->ipi_occupied);
+			dev_dbg(dev,
+				"%s cmd id %d sent, %d ipi buf occupied",
+				__func__,
+				isp_composer_work->cmd.cmd_id,
+				atomic_read(&isp_ctx->ipi_occupied));
+		} else if (isp_composer_work->type == SCP_ISP_FRAME) {
+			scp_ipi_send
+				(p1_dev->scp_pdev,
+				 SCP_IPI_ISP_FRAME,
+				 &isp_composer_work->frameparams,
+				 sizeof(isp_composer_work->frameparams),
+				 0);
+			atomic_inc(&isp_ctx->ipi_occupied);
+			atomic_inc(&isp_ctx->composing_frame);
+			dev_dbg(dev,
+				"%s frame %d sent, %d ipi, %d CQ bufs occupied",
+				__func__,
+				isp_composer_work->frameparams.frame_seq_no,
+				atomic_read(&isp_ctx->ipi_occupied),
+				atomic_read(&isp_ctx->composing_frame));
+		} else {
+			dev_err(dev,
+				"ignore IPI type: %d!\n",
+				isp_composer_work->type);
+		}
+		kfree(isp_composer_work);
+	}
+	return ret;
+}
+
+static int isp_composer_deinit_work(void *data)
+{
+	struct mtk_isp_p1_ctx *isp_ctx = (struct mtk_isp_p1_ctx *)data;
+	struct isp_p1_device *p1_dev = p1_ctx_to_dev(data);
+	struct device *dev = &p1_dev->pdev->dev;
+
+	wait_event_interruptible(isp_ctx->composer_deinit_thread.wq,
+				 atomic_read(&isp_ctx->scp_state) == SCP_OFF ||
+				 kthread_should_stop());
+
+	dev_dbg(dev, "%s run deinit", __func__);
+	isp_composer_deinit(isp_ctx);
+
+	return 0;
+}
+
+static void isp_composer_handler(void *data, unsigned int len, void *priv)
+{
+	struct mtk_isp_p1_ctx *isp_ctx = (struct mtk_isp_p1_ctx *)priv;
+	struct isp_p1_device *p1_dev = p1_ctx_to_dev(isp_ctx);
+	struct device *dev = &p1_dev->pdev->dev;
+	struct mtk_isp_scp_p1_cmd *ipi_msg;
+
+	ipi_msg = (struct mtk_isp_scp_p1_cmd *)data;
+
+	if (ipi_msg->cmd_id != ISP_CMD_ACK)
+		return;
+
+	if (ipi_msg->ack_info.cmd_id == ISP_CMD_FRAME_ACK) {
+		atomic_set(&isp_ctx->composed_frame_id,
+			   ipi_msg->ack_info.frame_seq_no);
+		dev_dbg(dev, "ack frame_num:%d",
+			ipi_msg->ack_info.frame_seq_no);
+	} else if (ipi_msg->ack_info.cmd_id == ISP_CMD_DEINIT) {
+		dev_dbg(dev, "ISP_CMD_DEINIT is acked");
+		atomic_set(&isp_ctx->scp_state, SCP_OFF);
+		wake_up_interruptible(&isp_ctx->composer_deinit_thread.wq);
+	}
+
+	atomic_dec_return(&isp_ctx->ipi_occupied);
+	wake_up_interruptible(&isp_ctx->composer_tx_thread.wq);
+}
+
+int isp_composer_init(struct device *dev)
+{
+	struct isp_p1_device *p1_dev = get_p1_device(dev);
+	struct mtk_isp_p1_ctx *isp_ctx = &p1_dev->isp_ctx;
+	int ret;
+
+	ret = scp_ipi_register(p1_dev->scp_pdev,
+			       SCP_IPI_ISP_CMD,
+			       isp_composer_handler,
+			       isp_ctx);
+	if (ret)
+		return ret;
+
+	atomic_set(&isp_ctx->cmd_queued, 0);
+	atomic_set(&isp_ctx->composer_txlist.queue_cnt, 0);
+	atomic_set(&isp_ctx->composing_frame, 0);
+	atomic_set(&isp_ctx->ipi_occupied, 0);
+	atomic_set(&isp_ctx->scp_state, SCP_ON);
+
+	mutex_lock(&isp_ctx->lock);
+	if (!isp_ctx->composer_tx_thread.thread) {
+		init_waitqueue_head(&isp_ctx->composer_tx_thread.wq);
+		INIT_LIST_HEAD(&isp_ctx->composer_txlist.queue);
+		spin_lock_init(&isp_ctx->composer_txlist.lock);
+		isp_ctx->composer_tx_thread.thread =
+			kthread_run(isp_composer_tx_work, isp_ctx,
+				    "isp_composer_tx");
+		if (IS_ERR(isp_ctx->composer_tx_thread.thread)) {
+			dev_err(dev, "unable to start kthread\n");
+			isp_ctx->composer_tx_thread.thread = NULL;
+			goto nomem;
+		}
+	} else {
+		dev_warn(dev, "old tx thread is existed\n");
+	}
+
+	if (!isp_ctx->composer_deinit_thread.thread) {
+		init_waitqueue_head(&isp_ctx->composer_deinit_thread.wq);
+		isp_ctx->composer_deinit_thread.thread =
+			kthread_run(isp_composer_deinit_work, isp_ctx,
+				    "isp_composer_deinit_work");
+		if (IS_ERR(isp_ctx->composer_deinit_thread.thread)) {
+			dev_err(dev, "unable to start kthread\n");
+			isp_ctx->composer_deinit_thread.thread = NULL;
+			goto nomem;
+		}
+	} else {
+		dev_warn(dev, "old rx thread is existed\n");
+	}
+	mutex_unlock(&isp_ctx->lock);
+
+	return 0;
+
+nomem:
+	mutex_unlock(&isp_ctx->lock);
+
+	return -ENOMEM;
+}
+
+void isp_composer_enqueue(struct device *dev,
+			  void *data,
+			  enum mtk_isp_scp_type type)
+{
+	struct mtk_isp_queue_work *isp_composer_work;
+	struct isp_p1_device *p1_dev = get_p1_device(dev);
+	struct mtk_isp_p1_ctx *isp_ctx = &p1_dev->isp_ctx;
+
+	isp_composer_work = kzalloc(sizeof(*isp_composer_work), GFP_KERNEL);
+	isp_composer_work->type = type;
+
+	switch (type) {
+	case SCP_ISP_CMD:
+		memcpy(&isp_composer_work->cmd, data,
+		       sizeof(isp_composer_work->cmd));
+		dev_dbg(dev, "Enq ipi cmd id:%d\n",
+			isp_composer_work->cmd.cmd_id);
+
+		spin_lock(&isp_ctx->composer_txlist.lock);
+		list_add_tail(&isp_composer_work->list_entry,
+			      &isp_ctx->composer_txlist.queue);
+		atomic_inc(&isp_ctx->composer_txlist.queue_cnt);
+		spin_unlock(&isp_ctx->composer_txlist.lock);
+
+		atomic_inc(&isp_ctx->cmd_queued);
+		wake_up_interruptible(&isp_ctx->composer_tx_thread.wq);
+		break;
+	case SCP_ISP_FRAME:
+		memcpy(&isp_composer_work->frameparams, data,
+		       sizeof(isp_composer_work->frameparams));
+		dev_dbg(dev, "Enq ipi frame_num:%d\n",
+			isp_composer_work->frameparams.frame_seq_no);
+
+		spin_lock(&isp_ctx->composer_txlist.lock);
+		list_add_tail(&isp_composer_work->list_entry,
+			      &isp_ctx->composer_txlist.queue);
+		atomic_inc(&isp_ctx->composer_txlist.queue_cnt);
+		spin_unlock(&isp_ctx->composer_txlist.lock);
+
+		wake_up_interruptible(&isp_ctx->composer_tx_thread.wq);
+		break;
+	default:
+		break;
+	}
+}
+
+void isp_composer_hw_init(struct device *dev)
+{
+	struct mtk_isp_scp_p1_cmd composer_tx_cmd;
+	struct isp_p1_device *p1_dev = get_p1_device(dev);
+	struct mtk_isp_p1_ctx *isp_ctx = &p1_dev->isp_ctx;
+
+	memset(&composer_tx_cmd, 0, sizeof(composer_tx_cmd));
+	composer_tx_cmd.cmd_id = ISP_CMD_INIT;
+	composer_tx_cmd.frameparam.hw_module = isp_ctx->isp_hw_module;
+	composer_tx_cmd.frameparam.cq_addr.iova = isp_ctx->scp_mem_iova;
+	composer_tx_cmd.frameparam.cq_addr.scp_addr = isp_ctx->scp_mem_pa;
+	isp_composer_enqueue(dev, &composer_tx_cmd, SCP_ISP_CMD);
+}
+
+void isp_composer_meta_config(struct device *dev,
+			      unsigned int dma)
+{
+	struct mtk_isp_scp_p1_cmd composer_tx_cmd;
+
+	memset(&composer_tx_cmd, 0, sizeof(composer_tx_cmd));
+	composer_tx_cmd.cmd_id = ISP_CMD_CONFIG_META;
+	composer_tx_cmd.cfg_meta_out_param.enabled_meta_dmas = dma;
+	isp_composer_enqueue(dev, &composer_tx_cmd, SCP_ISP_CMD);
+}
+
+void isp_composer_hw_config(struct device *dev,
+			    struct p1_config_param *config_param)
+{
+	struct mtk_isp_scp_p1_cmd composer_tx_cmd;
+
+	memset(&composer_tx_cmd, 0, sizeof(composer_tx_cmd));
+	composer_tx_cmd.cmd_id = ISP_CMD_CONFIG;
+	memcpy(&composer_tx_cmd.config_param, config_param,
+	       sizeof(*config_param));
+	isp_composer_enqueue(dev, &composer_tx_cmd, SCP_ISP_CMD);
+}
+
+void isp_composer_stream(struct device *dev, int on)
+{
+	struct mtk_isp_scp_p1_cmd composer_tx_cmd;
+
+	memset(&composer_tx_cmd, 0, sizeof(composer_tx_cmd));
+	composer_tx_cmd.cmd_id = ISP_CMD_STREAM;
+	composer_tx_cmd.is_stream_on = on;
+	isp_composer_enqueue(dev, &composer_tx_cmd, SCP_ISP_CMD);
+}
+
+void isp_composer_hw_deinit(struct device *dev)
+{
+	struct mtk_isp_scp_p1_cmd composer_tx_cmd;
+	struct isp_p1_device *p1_dev = get_p1_device(dev);
+	struct mtk_isp_p1_ctx *isp_ctx = &p1_dev->isp_ctx;
+	int ret;
+
+	memset(&composer_tx_cmd, 0, sizeof(composer_tx_cmd));
+	composer_tx_cmd.cmd_id = ISP_CMD_DEINIT;
+	isp_composer_enqueue(dev, &composer_tx_cmd, SCP_ISP_CMD);
+
+	/* Wait for ISP_CMD_DEINIT command is handled done */
+	ret = wait_event_timeout(isp_ctx->composer_deinit_thread.wq,
+				 atomic_read(&isp_ctx->scp_state) == SCP_OFF,
+				 msecs_to_jiffies(2000));
+	if (ret)
+		return;
+
+	dev_warn(dev, "Timeout & local de-init\n");
+	isp_composer_deinit(isp_ctx);
+}
diff --git a/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-scp.h b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-scp.h
new file mode 100644
index 000000000000..fbd8593e9c2d
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-scp.h
@@ -0,0 +1,207 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ */
+
+#ifndef _MTK_ISP_SCP_H
+#define _MTK_ISP_SCP_H
+
+#include <linux/types.h>
+
+#include "mtk_cam-v4l2-util.h"
+
+/*
+ * struct img_size - image size information.
+ *
+ * @w: image width, the unit is pixel
+ * @h: image height, the unit is pixel
+ * @xsize: bytes per line based on width.
+ * @stride: bytes per line when changing line.
+ *          Normally, calculate new STRIDE based on
+ *          xsize + HW constrain(page or align).
+ *
+ */
+struct img_size {
+	__u32 w;
+	__u32 h;
+	__u32 xsize;
+	__u32 stride;
+} __packed;
+
+/*
+ * struct img_buffer - buffer address information.
+ *
+ * @iova: DMA address for external devices.
+ * @scp_addr: SCP address for external co-process unit.
+ *
+ */
+struct img_buffer {
+	__u32 iova;
+	__u32 scp_addr;
+} __packed;
+
+struct p1_img_crop {
+	__u32 left;
+	__u32 top;
+	__u32 width;
+	__u32 height;
+} __packed;
+
+struct p1_img_output {
+	struct img_buffer buffer;
+	struct img_size size;
+	struct p1_img_crop crop;
+	__u8 pixel_byte;
+	__u32 img_fmt;
+} __packed;
+
+/*
+ * struct cfg_in_param - image input parameters structure.
+ *                       Normally, it comes from sensor information.
+ *
+ * @continuous: indicate the sensor mode.
+ *              1: continuous
+ *              0: single
+ * @subsample: indicate to enables SOF subsample or not.
+ * @pixel_mode: describe 1/2/4 pixels per clock cycle.
+ * @data_pattern: describe input data pattern.
+ * @raw_pixel_id: bayer sequence.
+ * @tg_fps: the fps rate of TG (time generator).
+ * @img_fmt: the image format of input source.
+ * @p1_img_crop: the crop configuration of input source.
+ *
+ */
+struct cfg_in_param {
+	__u8 continuous;
+	__u8 subsample;
+	__u8 pixel_mode;
+	__u8 data_pattern;
+	__u8 raw_pixel_id;
+	__u16 tg_fps;
+	__u32 img_fmt;
+	struct p1_img_crop crop;
+} __packed;
+
+/*
+ * struct cfg_main_out_param - the image output parameters of main stream.
+ *
+ * @bypass: indicate this device is enabled or disabled or not .
+ * @pure_raw: indicate the image path control.
+ *            1: pure raw
+ *            0: processing raw
+ * @pure_raw_pack: indicate the image is packed or not.
+ *                 1: packed mode
+ *                 0: unpacked mode
+ * @p1_img_output: the output image information.
+ *
+ */
+struct cfg_main_out_param {
+	/* Bypass main out parameters */
+	__u8 bypass;
+	/* Control HW image raw path */
+	__u8 pure_raw;
+	/* Control HW image pack function */
+	__u8 pure_raw_pack;
+	struct p1_img_output output;
+} __packed;
+
+/*
+ * struct cfg_resize_out_param - the image output parameters of
+ *                               packed out stream.
+ *
+ * @bypass: indicate this device is enabled or disabled or not .
+ * @p1_img_output: the output image information.
+ *
+ */
+struct cfg_resize_out_param {
+	/* Bypass resize parameters */
+	__u8 bypass;
+	struct p1_img_output output;
+} __packed;
+
+/*
+ * struct cfg_meta_out_param - output meta information.
+ *
+ * @enabled_meta_dmas: indicate which meta DMAs are enabled.
+ *
+ */
+struct cfg_meta_out_param {
+	__u32 enabled_meta_dmas;
+} __packed;
+
+struct p1_config_param {
+	/* Sensor/TG info */
+	struct cfg_in_param cfg_in_param;
+	/* IMGO DMA */
+	struct cfg_main_out_param cfg_main_param;
+	/* RRZO DMA */
+	struct cfg_resize_out_param cfg_resize_param;
+	/* 3A DMAs and other. */
+	struct cfg_meta_out_param cfg_meta_param;
+} __packed;
+
+struct p1_frame_param {
+	/* frame sequence number */
+	__u32 frame_seq_no;
+	/* SOF index */
+	__u32 sof_idx;
+	/* The memory address of tuning buffer from user space */
+	struct img_buffer dma_buffers[MTK_CAM_P1_TOTAL_NODES];
+} __packed;
+
+struct P1_meta_frame {
+	__u32 enabled_dma;
+	__u32 vb_index;
+	struct img_buffer meta_addr;
+} __packed;
+
+struct isp_init_info {
+	__u8 hw_module;
+	struct img_buffer cq_addr;
+} __packed;
+
+struct isp_ack_info {
+	__u8 cmd_id;
+	__u32 frame_seq_no;
+} __packed;
+
+enum mtk_isp_scp_cmds {
+	ISP_CMD_INIT,
+	ISP_CMD_CONFIG,
+	ISP_CMD_STREAM,
+	ISP_CMD_DEINIT,
+	ISP_CMD_ACK,
+	ISP_CMD_FRAME_ACK,
+	ISP_CMD_CONFIG_META,
+	ISP_CMD_ENQUEUE_META,
+	ISP_CMD_RESERVED,
+};
+
+struct mtk_isp_scp_p1_cmd {
+	__u8 cmd_id;
+	union {
+		struct isp_init_info frameparam;
+		struct p1_config_param config_param;
+		struct cfg_meta_out_param cfg_meta_out_param;
+		struct P1_meta_frame meta_frame;
+		__u8 is_stream_on;
+		struct isp_ack_info ack_info;
+	};
+} __packed;
+
+enum mtk_isp_scp_type {
+	SCP_ISP_CMD = 0,
+	SCP_ISP_FRAME,
+};
+
+int isp_composer_init(struct device *dev);
+void isp_composer_enqueue(struct device *dev, void *data,
+			  enum mtk_isp_scp_type type);
+void isp_composer_hw_init(struct device *dev);
+void isp_composer_hw_config(struct device *dev,
+			    struct p1_config_param *config_param);
+void isp_composer_hw_deinit(struct device *dev);
+void isp_composer_meta_config(struct device *dev, unsigned int dma);
+void isp_composer_stream(struct device *dev, int on);
+
+#endif /* _MTK_ISP_SCP_H */
diff --git a/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-smem.c b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-smem.c
new file mode 100644
index 000000000000..a9845668ce10
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-smem.c
@@ -0,0 +1,304 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2018 MediaTek Inc.
+
+#include <asm/cacheflush.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/iommu.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/mtk_scp.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "mtk_cam-smem.h"
+
+static struct dma_map_ops smem_dma_ops;
+
+struct mtk_cam_smem_dev {
+	struct device *dev;
+	struct sg_table sgt;
+	struct page **smem_pages;
+	dma_addr_t smem_base;
+	dma_addr_t smem_dma_base;
+	int smem_size;
+};
+
+struct dma_coherent_mem {
+	void		*virt_base;
+	dma_addr_t	device_base;
+	unsigned long	pfn_base;
+	int		size;
+	int		flags;
+	unsigned long	*bitmap;
+	spinlock_t	spinlock; /* dma_coherent_mem attributes protection */
+	bool		use_dev_dma_pfn_offset;
+};
+
+dma_addr_t mtk_cam_smem_iova_to_scp_addr(struct device *dev,
+					 dma_addr_t iova)
+{
+	struct iommu_domain *domain;
+	dma_addr_t addr, limit;
+	struct mtk_cam_smem_dev *smem_dev = dev_get_drvdata(dev);
+
+	domain = iommu_get_domain_for_dev(dev);
+	if (!domain) {
+		dev_warn(dev, "No iommu group domain\n");
+		return 0;
+	}
+
+	addr = iommu_iova_to_phys(domain, iova);
+	limit = smem_dev->smem_base + smem_dev->smem_size;
+	if (addr < smem_dev->smem_base || addr >= limit) {
+		dev_err(dev,
+			"Unexpected scp_addr:%pad must >= %pad and < %pad)\n",
+			&addr, &smem_dev->smem_base, &limit);
+		return 0;
+	}
+	return addr;
+}
+
+static int mtk_cam_smem_get_sgtable(struct device *dev,
+				    struct sg_table *sgt,
+				    void *cpu_addr, dma_addr_t dma_addr,
+				    size_t size, unsigned long attrs)
+{
+	struct mtk_cam_smem_dev *smem_dev = dev_get_drvdata(dev);
+	size_t pages_count = PAGE_ALIGN(size) >> PAGE_SHIFT;
+	dma_addr_t scp_addr = mtk_cam_smem_iova_to_scp_addr(dev, dma_addr);
+	u32 pages_start = (scp_addr - smem_dev->smem_base) >> PAGE_SHIFT;
+
+	dev_dbg(dev,
+		"%s:page:%u va:%pK scp addr:%pad, aligned size:%zu pages:%zu\n",
+		__func__, pages_start, cpu_addr, &scp_addr, size, pages_count);
+
+	return sg_alloc_table_from_pages(sgt,
+		smem_dev->smem_pages + pages_start,
+		pages_count, 0, size, GFP_KERNEL);
+}
+
+static void *mtk_cam_smem_get_cpu_addr(struct mtk_cam_smem_dev *smem_dev,
+				       dma_addr_t addr)
+{
+	struct device *dev = smem_dev->dev;
+	struct dma_coherent_mem *dma_mem = dev->dma_mem;
+
+	if (addr < smem_dev->smem_base ||
+	    addr > smem_dev->smem_base + smem_dev->smem_size) {
+		dev_err(dev, "Invalid scp_addr %pad from sg\n", &addr);
+		return NULL;
+	}
+	return dma_mem->virt_base + (addr - smem_dev->smem_base);
+}
+
+static void mtk_cam_smem_sync_sg_for_cpu(struct device *dev,
+					 struct scatterlist *sgl, int nelems,
+					 enum dma_data_direction dir)
+{
+	struct mtk_cam_smem_dev *smem_dev = dev_get_drvdata(dev);
+	dma_addr_t scp_addr = sg_phys(sgl);
+	void *cpu_addr = mtk_cam_smem_get_cpu_addr(smem_dev, scp_addr);
+
+	dev_dbg(dev,
+		"__dma_unmap_area:scp_addr:%pad,vaddr:%pK,size:%d,dir:%d\n",
+		&scp_addr, cpu_addr, sgl->length, dir);
+	__dma_unmap_area(cpu_addr, sgl->length, dir);
+}
+
+static void mtk_cam_smem_sync_sg_for_device(struct device *dev,
+					    struct scatterlist *sgl,
+					    int nelems,
+					    enum dma_data_direction dir)
+{
+	struct mtk_cam_smem_dev *smem_dev = dev_get_drvdata(dev);
+	dma_addr_t scp_addr = sg_phys(sgl);
+	void *cpu_addr = mtk_cam_smem_get_cpu_addr(smem_dev, scp_addr);
+
+	dev_dbg(dev,
+		"__dma_map_area:scp_addr:%pad,vaddr:%pK,size:%d,dir:%d\n",
+		&scp_addr, cpu_addr, sgl->length, dir);
+	__dma_map_area(cpu_addr, sgl->length, dir);
+}
+
+static void mtk_cam_smem_setup_dma_ops(struct device *dev,
+				       struct dma_map_ops *smem_ops)
+{
+	memcpy((void *)smem_ops, dev->dma_ops, sizeof(*smem_ops));
+	smem_ops->get_sgtable = mtk_cam_smem_get_sgtable;
+	smem_ops->sync_sg_for_device = mtk_cam_smem_sync_sg_for_device;
+	smem_ops->sync_sg_for_cpu = mtk_cam_smem_sync_sg_for_cpu;
+	set_dma_ops(dev, smem_ops);
+}
+
+static int mtk_cam_reserved_drm_sg_init(struct mtk_cam_smem_dev *smem_dev)
+{
+	u32 size_align, n_pages;
+	struct device *dev = smem_dev->dev;
+	struct sg_table *sgt = &smem_dev->sgt;
+	struct page **pages;
+	dma_addr_t dma_addr;
+	unsigned int i;
+	int ret;
+
+	smem_dev->smem_base = scp_get_reserve_mem_phys(SCP_ISP_MEM2_ID);
+	smem_dev->smem_size = scp_get_reserve_mem_size(SCP_ISP_MEM2_ID);
+	if (!smem_dev->smem_base || !smem_dev->smem_size)
+		return -EPROBE_DEFER;
+
+	dev_info(dev, "%s dev:0x%pK base:%pad size:%u MiB\n",
+		 __func__,
+		 smem_dev->dev,
+		 &smem_dev->smem_base,
+		 (smem_dev->smem_size / SZ_1M));
+
+	size_align = PAGE_ALIGN(smem_dev->smem_size);
+	n_pages = size_align >> PAGE_SHIFT;
+
+	pages = kmalloc_array(n_pages, sizeof(struct page *), GFP_KERNEL);
+	if (!pages)
+		return -ENOMEM;
+
+	for (i = 0; i < n_pages; i++)
+		pages[i] = phys_to_page(smem_dev->smem_base + i * PAGE_SIZE);
+
+	ret = sg_alloc_table_from_pages(sgt, pages, n_pages, 0,
+					size_align, GFP_KERNEL);
+	if (ret) {
+		dev_err(dev, "failed to alloca sg table:%d\n", ret);
+		goto fail_table_alloc;
+	}
+	sgt->nents = dma_map_sg_attrs(dev, sgt->sgl, sgt->orig_nents,
+				      DMA_BIDIRECTIONAL,
+				      DMA_ATTR_SKIP_CPU_SYNC);
+	if (!sgt->nents) {
+		dev_err(dev, "failed to dma sg map\n");
+		goto fail_map;
+	}
+
+	dma_addr = sg_dma_address(sgt->sgl);
+	ret = dma_declare_coherent_memory(dev, smem_dev->smem_base,
+					  dma_addr, size_align,
+					  DMA_MEMORY_EXCLUSIVE);
+	if (ret) {
+		dev_err(dev, "Unable to declare smem  memory:%d\n", ret);
+		goto fail_map;
+	}
+
+	dev_info(dev, "Coherent mem pa:%pad/%pad, size:%d\n",
+		 &smem_dev->smem_base, &dma_addr, size_align);
+
+	smem_dev->smem_size = size_align;
+	smem_dev->smem_pages = pages;
+	smem_dev->smem_dma_base = dma_addr;
+
+	return 0;
+
+fail_map:
+	sg_free_table(sgt);
+fail_table_alloc:
+	while (n_pages--)
+		__free_page(pages[n_pages]);
+	kfree(pages);
+
+	return -ENOMEM;
+}
+
+/* DMA memory related helper functions */
+static void mtk_cam_memdev_release(struct device *dev)
+{
+	vb2_dma_contig_clear_max_seg_size(dev);
+}
+
+static struct device *mtk_cam_alloc_smem_dev(struct device *dev,
+					     const char *name)
+{
+	struct device *child;
+	int ret;
+
+	child = devm_kzalloc(dev, sizeof(*child), GFP_KERNEL);
+	if (!child)
+		return NULL;
+
+	child->parent = dev;
+	child->iommu_group = dev->iommu_group;
+	child->release = mtk_cam_memdev_release;
+	dev_set_name(child, name);
+	set_dma_ops(child, get_dma_ops(dev));
+	child->dma_mask = dev->dma_mask;
+	ret = dma_set_coherent_mask(child, DMA_BIT_MASK(32));
+	if (ret)
+		return NULL;
+
+	vb2_dma_contig_set_max_seg_size(child, DMA_BIT_MASK(32));
+
+	if (device_register(child)) {
+		device_del(child);
+		return NULL;
+	}
+
+	return child;
+}
+
+static int mtk_cam_composer_dma_init(struct mtk_isp_p1_ctx *isp_ctx)
+{
+	struct isp_p1_device *p1_dev = p1_ctx_to_dev(isp_ctx);
+	struct device *dev = &p1_dev->pdev->dev;
+	u32 size;
+	dma_addr_t addr;
+
+	isp_ctx->scp_mem_pa = scp_get_reserve_mem_phys(SCP_ISP_MEM_ID);
+	size = PAGE_ALIGN(scp_get_reserve_mem_size(SCP_ISP_MEM_ID));
+	if (!isp_ctx->scp_mem_pa || !size)
+		return -EPROBE_DEFER;
+
+	dev_info(dev, "scp addr:%pad size:0x%x\n", &isp_ctx->scp_mem_pa, size);
+
+	/* get iova address */
+	addr = dma_map_page_attrs(dev, phys_to_page(isp_ctx->scp_mem_pa), 0,
+				  size, DMA_BIDIRECTIONAL,
+				  DMA_ATTR_SKIP_CPU_SYNC);
+	if (dma_mapping_error(dev, addr)) {
+		isp_ctx->scp_mem_pa = 0;
+		dev_err(dev, "Failed to map scp iova\n");
+		return -ENOMEM;
+	}
+
+	isp_ctx->scp_mem_iova = addr;
+
+	return 0;
+}
+
+int mtk_cam_reserved_memory_init(struct isp_p1_device *p1_dev)
+{
+	struct device *dev = &p1_dev->pdev->dev;
+	struct mtk_cam_smem_dev *smem_dev;
+	int ret;
+
+	ret = mtk_cam_composer_dma_init(&p1_dev->isp_ctx);
+	if (ret)
+		return ret;
+
+	/* Allocate context */
+	smem_dev = devm_kzalloc(dev, sizeof(*smem_dev), GFP_KERNEL);
+	if (!smem_dev)
+		return -ENOMEM;
+
+	smem_dev->dev = mtk_cam_alloc_smem_dev(dev, "cam-smem");
+	if (!smem_dev->dev) {
+		dev_err(dev, "failed to alloc smem device\n");
+		return -ENODEV;
+	}
+	dev_set_drvdata(smem_dev->dev, smem_dev);
+	p1_dev->cam_dev.smem_dev = smem_dev->dev;
+
+	ret = mtk_cam_reserved_drm_sg_init(smem_dev);
+	if (ret)
+		return ret;
+
+	mtk_cam_smem_setup_dma_ops(smem_dev->dev, &smem_dma_ops);
+
+	return 0;
+}
diff --git a/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-smem.h b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-smem.h
new file mode 100644
index 000000000000..981d47178e99
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-smem.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_ISP_SMEM_H
+#define __MTK_CAM_ISP_SMEM_H
+
+#include <linux/dma-mapping.h>
+
+#include "mtk_cam.h"
+
+int mtk_cam_reserved_memory_init(struct isp_p1_device *p1_dev);
+dma_addr_t mtk_cam_smem_iova_to_scp_addr(struct device *smem_dev,
+					 dma_addr_t iova);
+
+#endif
+
diff --git a/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-v4l2-util.c b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-v4l2-util.c
new file mode 100644
index 000000000000..e156e354f919
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-v4l2-util.c
@@ -0,0 +1,1943 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 Mediatek Corporation.
+ * Copyright (c) 2017 Intel Corporation.
+ *
+ * MTK_CAM-v4l2-util is highly based on Intel IPU3 ImgU driver.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/videodev2.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/of_platform.h>
+#include <media/media-entity.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mc.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "mtk_cam.h"
+#include "mtk_cam-ctrl.h"
+#include "mtk_cam-smem.h"
+#include "mtk_cam-v4l2-util.h"
+
+#define MTK_CAM_CIO_PAD_SRC			4
+#define MTK_CAM_CIO_PAD_SINK			11
+
+static inline struct mtk_cam_video_device *
+file_to_mtk_cam_node(struct file *__file)
+{
+	return container_of(video_devdata(__file),
+		struct mtk_cam_video_device, vdev);
+}
+
+static inline struct mtk_cam_dev *
+mtk_cam_subdev_to_dev(struct v4l2_subdev *__sd)
+{
+	return container_of(__sd,
+		struct mtk_cam_dev, subdev);
+}
+
+static inline struct mtk_cam_dev *
+mtk_cam_mdev_to_dev(struct media_device *__mdev)
+{
+	return container_of(__mdev,
+		struct mtk_cam_dev, media_dev);
+}
+
+static inline struct mtk_cam_video_device *
+mtk_cam_vbq_to_vdev(struct vb2_queue *__vq)
+{
+	return container_of(__vq,
+		struct mtk_cam_video_device, vbq);
+}
+
+static inline struct mtk_cam_dev_request *
+mtk_cam_req_to_dev_req(struct media_request *__req)
+{
+	return container_of(__req,
+		struct mtk_cam_dev_request, req);
+}
+
+static inline struct mtk_cam_dev_buffer *
+mtk_cam_vb2_buf_to_dev_buf(struct vb2_buffer *__vb)
+{
+	return container_of(__vb,
+		struct mtk_cam_dev_buffer, vbb.vb2_buf);
+}
+
+static void mtk_cam_req_try_isp_queue(struct mtk_cam_dev *cam_dev,
+				      struct media_request *new_req)
+{
+	struct mtk_cam_dev_request *req, *req_safe, *cam_dev_req;
+	struct device *dev = cam_dev->dev;
+
+	dev_dbg(dev, "%s new req:%d", __func__, !new_req);
+
+	if (!cam_dev->streaming) {
+		cam_dev_req = mtk_cam_req_to_dev_req(new_req);
+		spin_lock(&cam_dev->req_lock);
+		list_add_tail(&cam_dev_req->list, &cam_dev->req_list);
+		spin_unlock(&cam_dev->req_lock);
+		dev_dbg(dev, "%s:stream off, no enqueue\n", __func__);
+		return;
+	}
+
+	/* Normal enqueue flow */
+	if (new_req) {
+		mtk_isp_req_enqueue(dev, new_req);
+		return;
+	}
+
+	/* Flush all media requests wehen first stream on */
+	list_for_each_entry_safe(req, req_safe, &cam_dev->req_list, list) {
+		list_del(&req->list);
+		mtk_isp_req_enqueue(dev, &req->req);
+	}
+}
+
+static void mtk_cam_req_queue(struct media_request *req)
+{
+	struct mtk_cam_dev *cam_dev = mtk_cam_mdev_to_dev(req->mdev);
+
+	vb2_request_queue(req);
+	mtk_cam_req_try_isp_queue(cam_dev, req);
+}
+
+static struct media_request *mtk_cam_req_alloc(struct media_device *mdev)
+{
+	struct mtk_cam_dev_request *cam_dev_req;
+
+	cam_dev_req = kzalloc(sizeof(*cam_dev_req), GFP_KERNEL);
+
+	return &cam_dev_req->req;
+}
+
+static void mtk_cam_req_free(struct media_request *req)
+{
+	struct mtk_cam_dev_request *cam_dev_req = mtk_cam_req_to_dev_req(req);
+
+	kfree(cam_dev_req);
+}
+
+static __u32 img_get_pixel_byte_by_fmt(__u32 pix_fmt)
+{
+	switch (pix_fmt) {
+	case V4L2_PIX_FMT_MTISP_SBGGR8:
+	case V4L2_PIX_FMT_MTISP_SGBRG8:
+	case V4L2_PIX_FMT_MTISP_SGRBG8:
+	case V4L2_PIX_FMT_MTISP_SRGGB8:
+	case V4L2_PIX_FMT_MTISP_SBGGR8F:
+	case V4L2_PIX_FMT_MTISP_SGBRG8F:
+	case V4L2_PIX_FMT_MTISP_SGRBG8F:
+	case V4L2_PIX_FMT_MTISP_SRGGB8F:
+		return 8;
+	case V4L2_PIX_FMT_MTISP_SBGGR10:
+	case V4L2_PIX_FMT_MTISP_SGBRG10:
+	case V4L2_PIX_FMT_MTISP_SGRBG10:
+	case V4L2_PIX_FMT_MTISP_SRGGB10:
+	case V4L2_PIX_FMT_MTISP_SBGGR10F:
+	case V4L2_PIX_FMT_MTISP_SGBRG10F:
+	case V4L2_PIX_FMT_MTISP_SGRBG10F:
+	case V4L2_PIX_FMT_MTISP_SRGGB10F:
+		return 10;
+	case V4L2_PIX_FMT_MTISP_SBGGR12:
+	case V4L2_PIX_FMT_MTISP_SGBRG12:
+	case V4L2_PIX_FMT_MTISP_SGRBG12:
+	case V4L2_PIX_FMT_MTISP_SRGGB12:
+	case V4L2_PIX_FMT_MTISP_SBGGR12F:
+	case V4L2_PIX_FMT_MTISP_SGBRG12F:
+	case V4L2_PIX_FMT_MTISP_SGRBG12F:
+	case V4L2_PIX_FMT_MTISP_SRGGB12F:
+		return 12;
+	case V4L2_PIX_FMT_MTISP_SBGGR14:
+	case V4L2_PIX_FMT_MTISP_SGBRG14:
+	case V4L2_PIX_FMT_MTISP_SGRBG14:
+	case V4L2_PIX_FMT_MTISP_SRGGB14:
+	case V4L2_PIX_FMT_MTISP_SBGGR14F:
+	case V4L2_PIX_FMT_MTISP_SGBRG14F:
+	case V4L2_PIX_FMT_MTISP_SGRBG14F:
+	case V4L2_PIX_FMT_MTISP_SRGGB14F:
+		return 14;
+	default:
+		return 0;
+	}
+}
+
+static __u32 img_cal_main_stream_stride(struct device *dev, __u32 width,
+					__u32 pix_fmt)
+{
+	__u32 stride;
+	__u32 pixel_byte = img_get_pixel_byte_by_fmt(pix_fmt);
+
+	width = ALIGN(width, 4);
+	stride = ALIGN(DIV_ROUND_UP(width * pixel_byte, 8), 2);
+
+	dev_dbg(dev, "main width:%d, stride:%d\n", width, stride);
+
+	return stride;
+}
+
+static __u32 img_cal_packed_out_stride(struct device *dev, __u32 width,
+				       __u32 pix_fmt)
+{
+	__u32 stride;
+	__u32 pixel_byte = img_get_pixel_byte_by_fmt(pix_fmt);
+
+	width = ALIGN(width, 4);
+	stride = DIV_ROUND_UP(width * 3, 2);
+	stride = DIV_ROUND_UP(stride * pixel_byte, 8);
+
+	if (pix_fmt == V4L2_PIX_FMT_MTISP_SBGGR10F)
+		stride = ALIGN(stride, 4);
+
+	dev_dbg(dev, "packed width:%d, stride:%d\n", width, stride);
+
+	return stride;
+}
+
+static __u32 img_cal_stride(struct device *dev,
+			    int node_id,
+			    __u32 width,
+			    __u32 pix_fmt)
+{
+	__u32 bpl;
+
+	/* Currently, only support one_pixel_mode */
+	if (node_id == MTK_CAM_P1_MAIN_STREAM_OUT)
+		bpl = img_cal_main_stream_stride(dev, width, pix_fmt);
+	else if (node_id == MTK_CAM_P1_PACKED_BIN_OUT)
+		bpl = img_cal_packed_out_stride(dev, width, pix_fmt);
+
+	/* For DIP HW constrained, it needs 4 byte alignment */
+	bpl = ALIGN(bpl, 4);
+
+	return bpl;
+}
+
+static const struct v4l2_format *
+mtk_cam_dev_find_fmt(struct mtk_cam_dev_node_desc *desc, u32 format)
+{
+	unsigned int i;
+	const struct v4l2_format *dev_fmt;
+
+	for (i = 0; i < desc->num_fmts; i++) {
+		dev_fmt = &desc->fmts[i];
+		if (dev_fmt->fmt.pix_mp.pixelformat == format)
+			return dev_fmt;
+	}
+
+	return NULL;
+}
+
+/* Calculate mplane pix format */
+static void
+mtk_cam_dev_cal_mplane_fmt(struct device *dev,
+			   struct v4l2_pix_format_mplane *dest_fmt,
+			   unsigned int node_id)
+{
+	unsigned int i;
+	__u32 bpl, sizeimage, imagsize;
+
+	imagsize = 0;
+	for (i = 0 ; i < dest_fmt->num_planes; ++i) {
+		bpl = img_cal_stride(dev,
+				     node_id,
+				     dest_fmt->width,
+				     dest_fmt->pixelformat);
+		sizeimage = bpl * dest_fmt->height;
+		imagsize += sizeimage;
+		dest_fmt->plane_fmt[i].bytesperline = bpl;
+		dest_fmt->plane_fmt[i].sizeimage = sizeimage;
+		memset(dest_fmt->plane_fmt[i].reserved,
+		       0, sizeof(dest_fmt->plane_fmt[i].reserved));
+		dev_dbg(dev, "plane:%d,bpl:%d,sizeimage:%u\n",
+			i,  bpl, dest_fmt->plane_fmt[i].sizeimage);
+	}
+
+	if (dest_fmt->num_planes == 1)
+		dest_fmt->plane_fmt[0].sizeimage = imagsize;
+}
+
+static void
+mtk_cam_dev_set_img_fmt(struct device *dev,
+			struct v4l2_pix_format_mplane *dest_fmt,
+			const struct v4l2_pix_format_mplane *src_fmt,
+			unsigned int node_id)
+{
+	dest_fmt->width = src_fmt->width;
+	dest_fmt->height = src_fmt->height;
+	dest_fmt->pixelformat = src_fmt->pixelformat;
+	dest_fmt->field = src_fmt->field;
+	dest_fmt->colorspace = src_fmt->colorspace;
+	dest_fmt->num_planes = src_fmt->num_planes;
+	/* Use default */
+	dest_fmt->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	dest_fmt->quantization = V4L2_QUANTIZATION_DEFAULT;
+	dest_fmt->xfer_func =
+		V4L2_MAP_XFER_FUNC_DEFAULT(dest_fmt->colorspace);
+	memset(dest_fmt->reserved, 0, sizeof(dest_fmt->reserved));
+
+	dev_dbg(dev, "%s: Dest Fmt:%c%c%c%c, w*h:%d*%d\n",
+		__func__,
+		(dest_fmt->pixelformat & 0xFF),
+		(dest_fmt->pixelformat >> 8) & 0xFF,
+		(dest_fmt->pixelformat >> 16) & 0xFF,
+		(dest_fmt->pixelformat >> 24) & 0xFF,
+		dest_fmt->width,
+		dest_fmt->height);
+
+	mtk_cam_dev_cal_mplane_fmt(dev, dest_fmt, node_id);
+}
+
+/* Get the default format setting */
+static void
+mtk_cam_dev_load_default_fmt(struct device *dev,
+			     struct mtk_cam_dev_node_desc *queue_desc,
+			     struct v4l2_format *dest)
+{
+	const struct v4l2_format *default_fmt =
+		&queue_desc->fmts[queue_desc->default_fmt_idx];
+
+	dest->type = queue_desc->buf_type;
+
+	/* Configure default format based on node type */
+	if (queue_desc->image) {
+		mtk_cam_dev_set_img_fmt(dev,
+					&dest->fmt.pix_mp,
+					&default_fmt->fmt.pix_mp,
+					queue_desc->id);
+	} else {
+		dest->fmt.meta.dataformat = default_fmt->fmt.meta.dataformat;
+		dest->fmt.meta.buffersize = default_fmt->fmt.meta.buffersize;
+	}
+}
+
+static int mtk_cam_isp_open(struct file *file)
+{
+	struct mtk_cam_dev *cam_dev = video_drvdata(file);
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+	int ret;
+
+	mutex_lock(&cam_dev->lock);
+	ret = v4l2_fh_open(file);
+	if (ret)
+		goto unlock;
+
+	ret = v4l2_pipeline_pm_use(&node->vdev.entity, 1);
+	if (ret)
+		dev_err(cam_dev->dev, "%s fail:%d", __func__, ret);
+
+unlock:
+	mutex_unlock(&cam_dev->lock);
+
+	return ret;
+}
+
+static int mtk_cam_isp_release(struct file *file)
+{
+	struct mtk_cam_dev *cam_dev = video_drvdata(file);
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+
+	mutex_lock(&cam_dev->lock);
+	v4l2_pipeline_pm_use(&node->vdev.entity, 0);
+	vb2_fop_release(file);
+	mutex_unlock(&cam_dev->lock);
+
+	return 0;
+}
+
+static struct v4l2_subdev *
+mtk_cam_cio_get_active_sensor(struct mtk_cam_dev *cam_dev)
+{
+	struct media_device *mdev = cam_dev->seninf->entity.graph_obj.mdev;
+	struct device *dev = cam_dev->dev;
+	struct media_entity *entity;
+	struct v4l2_subdev *sensor;
+
+	media_device_for_each_entity(entity, mdev) {
+		dev_dbg(dev, "media entity: %s:0x%x\n",
+			entity->name, entity->function);
+		if (entity->function == MEDIA_ENT_F_CAM_SENSOR &&
+		    entity->stream_count) {
+			sensor = media_entity_to_v4l2_subdev(entity);
+			dev_dbg(dev, "sensor found: %s\n", entity->name);
+			break;
+		}
+	}
+
+	if (!sensor)
+		dev_err(dev, "Sensor is not connected\n");
+
+	return sensor;
+}
+
+static int mtk_cam_cio_stream_on(struct mtk_cam_dev *cam_dev)
+{
+	struct device *dev = cam_dev->dev;
+	int ret;
+
+	/* Align vb2_core_streamon design */
+	if (cam_dev->streaming) {
+		dev_warn(dev, "already streaming\n");
+		return 0;
+	}
+
+	if (!cam_dev->seninf) {
+		dev_err(dev, "no seninf connected\n");
+		return -EPERM;
+	}
+
+	/* Get active sensor from graph topology */
+	cam_dev->sensor = mtk_cam_cio_get_active_sensor(cam_dev);
+	if (!cam_dev->sensor)
+		return -EPERM;
+
+	/* Seninf must stream on first */
+	ret = v4l2_subdev_call(cam_dev->seninf, video, s_stream, 1);
+	if (ret) {
+		dev_err(dev, "%s stream on failed:%d\n",
+			cam_dev->seninf->entity.name, ret);
+		return -EPERM;
+	}
+
+	ret = v4l2_subdev_call(cam_dev->sensor, video, s_stream, 1);
+	if (ret) {
+		dev_err(dev, "%s stream on failed:%d\n",
+			cam_dev->sensor->entity.name, ret);
+		goto fail_sensor_on;
+	}
+
+	ret = mtk_isp_config(dev);
+	if (ret)
+		goto fail_config;
+
+	cam_dev->streaming = true;
+	mtk_cam_req_try_isp_queue(cam_dev, NULL);
+	isp_composer_stream(dev, 1);
+	dev_dbg(dev, "streamed on Pass 1\n");
+
+	return 0;
+
+fail_config:
+	v4l2_subdev_call(cam_dev->sensor, video, s_stream, 0);
+fail_sensor_on:
+	v4l2_subdev_call(cam_dev->seninf, video, s_stream, 0);
+
+	return -EPERM;
+}
+
+static int mtk_cam_cio_stream_off(struct mtk_cam_dev *cam_dev)
+{
+	struct device *dev = cam_dev->dev;
+	int ret;
+
+	if (!cam_dev->streaming) {
+		dev_warn(dev, "already stream off");
+		return 0;
+	}
+
+	ret = v4l2_subdev_call(cam_dev->sensor, video, s_stream, 0);
+	if (ret) {
+		dev_err(dev, "%s stream off failed:%d\n",
+			cam_dev->sensor->entity.name, ret);
+		return -EPERM;
+	}
+
+	ret = v4l2_subdev_call(cam_dev->seninf, video, s_stream, 0);
+	if (ret) {
+		dev_err(dev, "%s stream off failed:%d\n",
+			cam_dev->seninf->entity.name, ret);
+		return -EPERM;
+	}
+
+	isp_composer_stream(dev, 0);
+	cam_dev->streaming = false;
+	dev_dbg(dev, "streamed off Pass 1\n");
+
+	return 0;
+}
+
+static int mtk_cam_sd_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct mtk_cam_dev *cam_dev = mtk_cam_subdev_to_dev(sd);
+
+	if (enable)
+		return mtk_cam_cio_stream_on(cam_dev);
+	else
+		return mtk_cam_cio_stream_off(cam_dev);
+}
+
+static int mtk_cam_sd_subscribe_event(struct v4l2_subdev *subdev,
+				      struct v4l2_fh *fh,
+				      struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_FRAME_SYNC:
+		return v4l2_event_subscribe(fh, sub, 0, NULL);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int mtk_cam_sd_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct mtk_cam_dev *cam_dev = mtk_cam_subdev_to_dev(sd);
+	struct device *dev = cam_dev->dev;
+
+	dev_dbg(dev, "%s:%d", __func__, on);
+
+	return on ? mtk_isp_power_init(cam_dev) :
+		    mtk_isp_power_release(dev);
+}
+
+static int mtk_cam_media_link_setup(struct media_entity *entity,
+				    const struct media_pad *local,
+				    const struct media_pad *remote, u32 flags)
+{
+	struct mtk_cam_dev *cam_dev =
+		container_of(entity, struct mtk_cam_dev, subdev.entity);
+	u32 pad = local->index;
+
+	dev_dbg(cam_dev->dev, "%s: %d -> %d flags:0x%x\n",
+		__func__, pad, remote->index, flags);
+
+	if (pad < MTK_CAM_P1_TOTAL_NODES)
+		cam_dev->vdev_nodes[pad].enabled =
+			!!(flags & MEDIA_LNK_FL_ENABLED);
+
+	return 0;
+}
+
+static void mtk_cam_vb2_buf_queue(struct vb2_buffer *vb)
+{
+	struct mtk_cam_dev *cam_dev = vb2_get_drv_priv(vb->vb2_queue);
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vb->vb2_queue);
+	struct device *dev = cam_dev->dev;
+	struct mtk_cam_dev_buffer *buf;
+
+	buf = mtk_cam_vb2_buf_to_dev_buf(vb);
+
+	dev_dbg(dev, "%s: node:%d fd:%d idx:%d\n",
+		__func__,
+		node->id,
+		buf->vbb.request_fd,
+		buf->vbb.vb2_buf.index);
+
+	/* For request buffers en-queue, handled in mtk_cam_req_try_queue */
+	if (vb->vb2_queue->uses_requests)
+		return;
+
+	/* Added the buffer into the tracking list */
+	spin_lock(&node->slock);
+	list_add_tail(&buf->list, &node->pending_list);
+	spin_unlock(&node->slock);
+
+	mtk_isp_enqueue(dev, node->desc.dma_port, buf);
+}
+
+static int mtk_cam_vb2_buf_init(struct vb2_buffer *vb)
+{
+	struct mtk_cam_dev *cam_dev = vb2_get_drv_priv(vb->vb2_queue);
+	struct device *smem_dev = cam_dev->smem_dev;
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vb->vb2_queue);
+	struct mtk_cam_dev_buffer *buf;
+
+	buf = mtk_cam_vb2_buf_to_dev_buf(vb);
+	buf->node_id = node->id;
+	buf->daddr = vb2_dma_contig_plane_dma_addr(&buf->vbb.vb2_buf, 0);
+	buf->scp_addr = 0;
+
+	/* scp address is only valid for meta input buffer */
+	if (node->desc.smem_alloc)
+		buf->scp_addr = mtk_cam_smem_iova_to_scp_addr(smem_dev,
+							      buf->daddr);
+
+	return 0;
+}
+
+static int mtk_cam_vb2_buf_prepare(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vb->vb2_queue);
+	const struct v4l2_format *fmt = &node->vdev_fmt;
+	unsigned int size;
+
+	if (vb->vb2_queue->type == V4L2_BUF_TYPE_META_OUTPUT ||
+	    vb->vb2_queue->type == V4L2_BUF_TYPE_META_CAPTURE)
+		size = fmt->fmt.meta.buffersize;
+	else
+		size = fmt->fmt.pix_mp.plane_fmt[0].sizeimage;
+
+	if (vb2_plane_size(vb, 0) < size)
+		return -EINVAL;
+
+	v4l2_buf->field = V4L2_FIELD_NONE;
+	vb2_set_plane_payload(vb, 0, size);
+
+	return 0;
+}
+
+static int mtk_cam_vb2_queue_setup(struct vb2_queue *vq,
+				   unsigned int *num_buffers,
+				   unsigned int *num_planes,
+				   unsigned int sizes[],
+				   struct device *alloc_devs[])
+{
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vq);
+	unsigned int max_buffer_count = node->desc.max_buf_count;
+	const struct v4l2_format *fmt = &node->vdev_fmt;
+	unsigned int size;
+
+	/* Check the limitation of buffer size */
+	if (max_buffer_count)
+		*num_buffers = clamp_val(*num_buffers, 1, max_buffer_count);
+
+	vq->dma_attrs |= DMA_ATTR_NON_CONSISTENT;
+
+	if (vq->type == V4L2_BUF_TYPE_META_OUTPUT ||
+	    vq->type == V4L2_BUF_TYPE_META_CAPTURE)
+		size = fmt->fmt.meta.buffersize;
+	else
+		size = fmt->fmt.pix_mp.plane_fmt[0].sizeimage;
+
+	/* Add for q.create_bufs with fmt.g_sizeimage(p) / 2 test */
+	if (*num_planes) {
+		if (sizes[0] < size)
+			return -EINVAL;
+	} else {
+		*num_planes = 1;
+		sizes[0] = size;
+	}
+
+	return 0;
+}
+
+static void mtk_cam_vb2_return_all_buffers(struct mtk_cam_dev *cam_dev,
+					   struct mtk_cam_video_device *node,
+					   enum vb2_buffer_state state)
+{
+	struct device *dev = cam_dev->dev;
+	struct mtk_cam_dev_buffer *b, *b0;
+	struct mtk_cam_dev_request *req, *req0;
+	struct media_request_object *obj, *obj0;
+	struct vb2_buffer *vb;
+
+	dev_dbg(dev, "%s: node:%s", __func__, node->vdev.name);
+
+	/* Return all buffers */
+	spin_lock(&node->slock);
+	list_for_each_entry_safe(b, b0, &node->pending_list, list) {
+		vb = &b->vbb.vb2_buf;
+		if (vb->state == VB2_BUF_STATE_ACTIVE)
+			vb2_buffer_done(vb, state);
+		list_del(&b->list);
+	}
+	spin_unlock(&node->slock);
+
+	spin_lock(&cam_dev->req_lock);
+	list_for_each_entry_safe(req, req0, &cam_dev->req_list, list) {
+		list_for_each_entry_safe(obj, obj0, &req->req.objects, list) {
+			vb = container_of(obj, struct vb2_buffer, req_obj);
+			if (vb->state == VB2_BUF_STATE_ACTIVE)
+				vb2_buffer_done(vb, state);
+		}
+		list_del(&req->list);
+	}
+	spin_unlock(&cam_dev->req_lock);
+
+	if (node->vbq.uses_requests)
+		mtk_isp_req_flush_buffers(dev);
+}
+
+static int mtk_cam_vb2_start_streaming(struct vb2_queue *vq,
+				       unsigned int count)
+{
+	struct mtk_cam_dev *cam_dev = vb2_get_drv_priv(vq);
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vq);
+	struct device *dev = cam_dev->dev;
+	unsigned int node_count = cam_dev->subdev.entity.use_count;
+	int ret;
+
+	if (!node->enabled) {
+		dev_err(dev, "Node:%d is not enable\n", node->id);
+		ret = -ENOLINK;
+		goto fail_no_link;
+	}
+
+	dev_dbg(dev, "%s: count info:%d:%d", __func__,
+		atomic_read(&cam_dev->streamed_node_count), node_count);
+
+	if (atomic_inc_return(&cam_dev->streamed_node_count) < node_count)
+		return 0;
+
+	/* Start streaming of the whole pipeline now */
+	ret = media_pipeline_start(&node->vdev.entity, &cam_dev->pipeline);
+	if (ret) {
+		dev_err(dev, "%s: Node:%d failed\n", __func__, node->id);
+		goto fail_start_pipeline;
+	}
+
+	/* Stream on sub-devices node */
+	ret = v4l2_subdev_call(&cam_dev->subdev, video, s_stream, 1);
+	if (ret) {
+		dev_err(dev, "Node:%d s_stream on failed:%d\n", node->id, ret);
+		goto fail_stream_on;
+	}
+
+	return 0;
+
+fail_stream_on:
+	media_pipeline_stop(&node->vdev.entity);
+fail_start_pipeline:
+	atomic_dec(&cam_dev->streamed_node_count);
+fail_no_link:
+	mtk_cam_vb2_return_all_buffers(cam_dev, node, VB2_BUF_STATE_QUEUED);
+
+	return ret;
+}
+
+static void mtk_cam_vb2_stop_streaming(struct vb2_queue *vq)
+{
+	struct mtk_cam_dev *cam_dev = vb2_get_drv_priv(vq);
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vq);
+	struct device *dev = cam_dev->dev;
+
+	if (!node->enabled)
+		return;
+
+	mtk_cam_vb2_return_all_buffers(cam_dev, node, VB2_BUF_STATE_ERROR);
+
+	dev_dbg(dev, "%s: count info:%d", __func__,
+		cam_dev->subdev.entity.stream_count);
+
+	/* Check the first node to stream-off */
+	if (!cam_dev->subdev.entity.stream_count)
+		return;
+
+	media_pipeline_stop(&node->vdev.entity);
+
+	if (v4l2_subdev_call(&cam_dev->subdev, video, s_stream, 0))
+		dev_err(dev, "failed to stop streaming\n");
+}
+
+static void mtk_cam_vb2_buf_request_complete(struct vb2_buffer *vb)
+{
+	struct mtk_cam_dev *dev = vb2_get_drv_priv(vb->vb2_queue);
+
+	v4l2_ctrl_request_complete(vb->req_obj.req,
+				   dev->v4l2_dev.ctrl_handler);
+}
+
+static int mtk_cam_vidioc_querycap(struct file *file, void *fh,
+				   struct v4l2_capability *cap)
+{
+	struct mtk_cam_dev *cam_dev = video_drvdata(file);
+
+	strscpy(cap->driver, MTK_CAM_DEV_P1_NAME, sizeof(cap->driver));
+	strscpy(cap->card, MTK_CAM_DEV_P1_NAME, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",
+		 dev_name(cam_dev->media_dev.dev));
+
+	return 0;
+}
+
+static int mtk_cam_vidioc_enum_fmt(struct file *file, void *fh,
+				   struct v4l2_fmtdesc *f)
+{
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+
+	if (f->index >= node->desc.num_fmts)
+		return -EINVAL;
+
+	f->pixelformat = node->desc.fmts[f->index].fmt.pix_mp.pixelformat;
+	f->flags = 0;
+
+	return 0;
+}
+
+static int mtk_cam_vidioc_g_fmt(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+
+	if (!node->desc.num_fmts)
+		return -EINVAL;
+
+	f->fmt = node->vdev_fmt.fmt;
+
+	return 0;
+}
+
+static int mtk_cam_vidioc_try_fmt(struct file *file, void *fh,
+				  struct v4l2_format *in_fmt)
+{
+	struct mtk_cam_dev *cam_dev = video_drvdata(file);
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+	struct device *dev = cam_dev->dev;
+	const struct v4l2_format *dev_fmt;
+	__u32  width, height;
+
+	dev_dbg(dev, "%s: fmt:%c%c%c%c, w*h:%u*%u\n",
+		__func__,
+		(in_fmt->fmt.pix_mp.pixelformat & 0xFF),
+		(in_fmt->fmt.pix_mp.pixelformat >> 8) & 0xFF,
+		(in_fmt->fmt.pix_mp.pixelformat >> 16) & 0xFF,
+		(in_fmt->fmt.pix_mp.pixelformat >> 24) & 0xFF,
+		in_fmt->fmt.pix_mp.width, in_fmt->fmt.pix_mp.height);
+
+	width = in_fmt->fmt.pix_mp.width;
+	height = in_fmt->fmt.pix_mp.height;
+
+	dev_fmt = mtk_cam_dev_find_fmt(&node->desc,
+				       in_fmt->fmt.pix_mp.pixelformat);
+	if (dev_fmt)
+		mtk_cam_dev_set_img_fmt(dev,
+					&in_fmt->fmt.pix_mp,
+					&dev_fmt->fmt.pix_mp,
+					node->id);
+	else
+		mtk_cam_dev_load_default_fmt(dev, &node->desc, in_fmt);
+
+	in_fmt->fmt.pix_mp.width = clamp_t(u32,
+					   width,
+					   CAM_MIN_WIDTH,
+					   in_fmt->fmt.pix_mp.width);
+	in_fmt->fmt.pix_mp.height = clamp_t(u32,
+					    height,
+					    CAM_MIN_HEIGHT,
+					    in_fmt->fmt.pix_mp.height);
+	mtk_cam_dev_cal_mplane_fmt(dev, &in_fmt->fmt.pix_mp, node->id);
+
+	return 0;
+}
+
+static int mtk_cam_vidioc_s_fmt(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct mtk_cam_dev *cam_dev = video_drvdata(file);
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+
+	if (cam_dev->streaming)
+		return -EBUSY;
+
+	/* Get the valid format */
+	mtk_cam_vidioc_try_fmt(file, fh, f);
+
+	/* Configure to video device */
+	mtk_cam_dev_set_img_fmt(cam_dev->dev,
+				&node->vdev_fmt.fmt.pix_mp,
+				&f->fmt.pix_mp,
+				node->id);
+
+	return 0;
+}
+
+static int mtk_cam_vidioc_enum_input(struct file *file, void *fh,
+				     struct v4l2_input *input)
+{
+	if (input->index)
+		return -EINVAL;
+
+	strscpy(input->name, "camera", sizeof(input->name));
+	input->type = V4L2_INPUT_TYPE_CAMERA;
+
+	return 0;
+}
+
+static int mtk_cam_vidioc_g_input(struct file *file, void *fh,
+				  unsigned int *input)
+{
+	*input = 0;
+
+	return 0;
+}
+
+static int mtk_cam_vidioc_s_input(struct file *file,
+				  void *fh, unsigned int input)
+{
+	return input == 0 ? 0 : -EINVAL;
+}
+
+static int mtk_cam_vidioc_enum_framesizes(struct file *filp, void *priv,
+					  struct v4l2_frmsizeenum *sizes)
+{
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(filp);
+	const struct v4l2_format *dev_fmt;
+
+	dev_fmt = mtk_cam_dev_find_fmt(&node->desc, sizes->pixel_format);
+	if (!dev_fmt || sizes->index)
+		return -EINVAL;
+
+	sizes->type = node->desc.frmsizes->type;
+	memcpy(&sizes->stepwise, &node->desc.frmsizes->stepwise,
+	       sizeof(sizes->stepwise));
+
+	return 0;
+}
+
+static int mtk_cam_vidioc_meta_enum_fmt(struct file *file, void *fh,
+					struct v4l2_fmtdesc *f)
+{
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+
+	if (f->index)
+		return -EINVAL;
+
+	strscpy(f->description, node->desc.description,
+		sizeof(node->desc.description));
+	f->pixelformat = node->vdev_fmt.fmt.meta.dataformat;
+	f->flags = 0;
+
+	return 0;
+}
+
+static int mtk_cam_vidioc_g_meta_fmt(struct file *file, void *fh,
+				     struct v4l2_format *f)
+{
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+
+	f->fmt.meta.dataformat = node->vdev_fmt.fmt.meta.dataformat;
+	f->fmt.meta.buffersize = node->vdev_fmt.fmt.meta.buffersize;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_core_ops mtk_cam_subdev_core_ops = {
+	.subscribe_event = mtk_cam_sd_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+	.s_power = mtk_cam_sd_s_power,
+};
+
+static const struct v4l2_subdev_video_ops mtk_cam_subdev_video_ops = {
+	.s_stream =  mtk_cam_sd_s_stream,
+};
+
+static const struct v4l2_subdev_ops mtk_cam_subdev_ops = {
+	.core = &mtk_cam_subdev_core_ops,
+	.video = &mtk_cam_subdev_video_ops,
+};
+
+static const struct media_entity_operations mtk_cam_media_ops = {
+	.link_setup = mtk_cam_media_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct vb2_ops mtk_cam_vb2_ops = {
+	.queue_setup = mtk_cam_vb2_queue_setup,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.buf_init = mtk_cam_vb2_buf_init,
+	.buf_prepare = mtk_cam_vb2_buf_prepare,
+	.start_streaming = mtk_cam_vb2_start_streaming,
+	.stop_streaming = mtk_cam_vb2_stop_streaming,
+	.buf_queue = mtk_cam_vb2_buf_queue,
+	.buf_request_complete = mtk_cam_vb2_buf_request_complete,
+};
+
+static const struct v4l2_file_operations mtk_cam_v4l2_fops = {
+	.unlocked_ioctl = video_ioctl2,
+	.open = mtk_cam_isp_open,
+	.release = mtk_cam_isp_release,
+	.poll = vb2_fop_poll,
+	.mmap = vb2_fop_mmap,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl32 = v4l2_compat_ioctl32,
+#endif
+};
+
+static const struct media_device_ops mtk_cam_media_req_ops = {
+	.link_notify = v4l2_pipeline_link_notify,
+	.req_alloc = mtk_cam_req_alloc,
+	.req_free = mtk_cam_req_free,
+	.req_validate = vb2_request_validate,
+	.req_queue = mtk_cam_req_queue,
+};
+
+static int mtk_cam_media_register(struct device *dev,
+				  struct media_device *media_dev)
+{
+	media_dev->dev = dev;
+	strscpy(media_dev->model, MTK_CAM_DEV_P1_NAME,
+		sizeof(media_dev->model));
+	snprintf(media_dev->bus_info, sizeof(media_dev->bus_info),
+		 "platform:%s", dev_name(dev));
+	media_dev->hw_revision = 0;
+	media_device_init(media_dev);
+	media_dev->ops = &mtk_cam_media_req_ops;
+
+	return media_device_register(media_dev);
+}
+
+static int mtk_cam_video_register_device(struct mtk_cam_dev *cam_dev, u32 i)
+{
+	struct device *dev = cam_dev->dev;
+	struct mtk_cam_video_device *node = &cam_dev->vdev_nodes[i];
+	struct video_device *vdev = &node->vdev;
+	struct vb2_queue *vbq = &node->vbq;
+	u32 output = !cam_dev->vdev_nodes[i].desc.capture;
+	u32 link_flags = cam_dev->vdev_nodes[i].desc.link_flags;
+	int ret;
+
+	cam_dev->subdev_pads[i].flags = output ?
+		MEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;
+
+	/* Initialize media entities */
+	ret = media_entity_pads_init(&vdev->entity, 1, &node->vdev_pad);
+	if (ret) {
+		dev_err(dev, "failed initialize media pad:%d\n", ret);
+		return ret;
+	}
+	node->enabled = false;
+	node->id = i;
+	node->vdev_pad.flags = cam_dev->subdev_pads[i].flags;
+	mtk_cam_dev_load_default_fmt(dev, &node->desc, &node->vdev_fmt);
+
+	/* Initialize vbq */
+	vbq->type = node->vdev_fmt.type;
+	if (vbq->type == V4L2_BUF_TYPE_META_OUTPUT)
+		vbq->io_modes = VB2_MMAP;
+	else
+		vbq->io_modes = VB2_MMAP | VB2_DMABUF;
+
+	if (node->desc.smem_alloc) {
+		vbq->bidirectional = 1;
+		vbq->dev = cam_dev->smem_dev;
+	} else {
+		vbq->dev = dev;
+	}
+
+	if (vbq->type == V4L2_BUF_TYPE_META_CAPTURE)
+		vdev->entity.function =
+			MEDIA_ENT_F_PROC_VIDEO_STATISTICS;
+	vbq->ops = &mtk_cam_vb2_ops;
+	vbq->mem_ops = &vb2_dma_contig_memops;
+	vbq->buf_struct_size = sizeof(struct mtk_cam_dev_buffer);
+	vbq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	vbq->min_buffers_needed = 0;	/* Can streamon w/o buffers */
+	/* Put the process hub sub device in the vb2 private data */
+	vbq->drv_priv = cam_dev;
+	vbq->lock = &node->lock;
+	vbq->requires_requests = node->desc.requires_requests;
+	vbq->supports_requests = node->desc.requires_requests;
+
+	ret = vb2_queue_init(vbq);
+	if (ret) {
+		dev_err(dev, "failed to init. vb2 queue:%d\n", ret);
+		goto fail_vb2_queue;
+	}
+
+	/* Initialize vdev */
+	snprintf(vdev->name, sizeof(vdev->name), "%s %s",
+		 MTK_CAM_DEV_P1_NAME, node->desc.name);
+	/* set cap/type/ioctl_ops of the video device */
+	vdev->device_caps = node->desc.cap | V4L2_CAP_STREAMING;
+	vdev->ioctl_ops = node->desc.ioctl_ops;
+	vdev->fops = &mtk_cam_v4l2_fops;
+	vdev->release = video_device_release_empty;
+	vdev->lock = &node->lock;
+	vdev->v4l2_dev = &cam_dev->v4l2_dev;
+	vdev->queue = &node->vbq;
+	vdev->vfl_dir = output ? VFL_DIR_TX : VFL_DIR_RX;
+	vdev->entity.ops = NULL;
+	/* Enable private control for image video devices */
+	if (node->desc.image) {
+		mtk_cam_ctrl_init(cam_dev, &node->ctrl_handler);
+		vdev->ctrl_handler = &node->ctrl_handler;
+	}
+	video_set_drvdata(vdev, cam_dev);
+	dev_dbg(dev, "register vdev:%d:%s\n", i, vdev->name);
+
+	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+	if (ret) {
+		dev_err(dev, "failed to register vde:%d\n", ret);
+		goto fail_vdev;
+	}
+
+	/* Create link between video node and the subdev pad */
+	if (output) {
+		ret = media_create_pad_link(&vdev->entity, 0,
+					    &cam_dev->subdev.entity,
+					    i, link_flags);
+	} else {
+		ret = media_create_pad_link(&cam_dev->subdev.entity,
+					    i, &vdev->entity, 0,
+					    link_flags);
+	}
+	if (ret)
+		goto fail_link;
+
+	/* Initialize miscellaneous variables */
+	mutex_init(&node->lock);
+	spin_lock_init(&node->slock);
+	INIT_LIST_HEAD(&node->pending_list);
+
+	return 0;
+
+fail_link:
+	video_unregister_device(vdev);
+fail_vdev:
+	vb2_queue_release(vbq);
+fail_vb2_queue:
+	media_entity_cleanup(&vdev->entity);
+
+	return ret;
+}
+
+static int mtk_cam_v4l2_register(struct mtk_cam_dev *cam_dev)
+{
+	struct device *dev = cam_dev->dev;
+	/* Total pad numbers is video devices + one seninf pad */
+	unsigned int num_subdev_pads = MTK_CAM_CIO_PAD_SINK + 1;
+	unsigned int i;
+	int ret;
+
+	ret = mtk_cam_media_register(dev,
+				     &cam_dev->media_dev);
+	if (ret) {
+		dev_err(dev, "failed to register media device:%d\n", ret);
+		return ret;
+	}
+	dev_info(dev, "Register media device: %s, 0x%pK",
+		 MTK_CAM_DEV_P1_NAME, cam_dev->media_dev);
+
+	/* Set up v4l2 device */
+	cam_dev->v4l2_dev.mdev = &cam_dev->media_dev;
+	ret = v4l2_device_register(dev, &cam_dev->v4l2_dev);
+	if (ret) {
+		dev_err(dev, "failed to register V4L2 device:%d\n", ret);
+		goto fail_v4l2_dev;
+	}
+	dev_info(dev, "Register v4l2 device: 0x%pK", cam_dev->v4l2_dev);
+
+	/* Initialize subdev media entity */
+	cam_dev->subdev_pads = devm_kcalloc(dev, num_subdev_pads,
+					    sizeof(*cam_dev->subdev_pads),
+					    GFP_KERNEL);
+	if (!cam_dev->subdev_pads) {
+		ret = -ENOMEM;
+		goto fail_subdev_pads;
+	}
+
+	ret = media_entity_pads_init(&cam_dev->subdev.entity,
+				     num_subdev_pads,
+				     cam_dev->subdev_pads);
+	if (ret) {
+		dev_err(dev, "failed initialize media pads:%d:\n", ret);
+		goto fail_subdev_pads;
+	}
+
+	/* Initialize all pads with MEDIA_PAD_FL_SOURCE */
+	for (i = 0; i < num_subdev_pads; i++)
+		cam_dev->subdev_pads[i].flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Customize the last one pad as CIO sink pad. */
+	cam_dev->subdev_pads[MTK_CAM_CIO_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+
+	/* Initialize subdev */
+	v4l2_subdev_init(&cam_dev->subdev, &mtk_cam_subdev_ops);
+	cam_dev->subdev.entity.function = MEDIA_ENT_F_PROC_VIDEO_STATISTICS;
+	cam_dev->subdev.entity.ops = &mtk_cam_media_ops;
+	cam_dev->subdev.flags = V4L2_SUBDEV_FL_HAS_DEVNODE |
+				V4L2_SUBDEV_FL_HAS_EVENTS;
+	snprintf(cam_dev->subdev.name, sizeof(cam_dev->subdev.name),
+		 "%s", MTK_CAM_DEV_P1_NAME);
+	v4l2_set_subdevdata(&cam_dev->subdev, cam_dev);
+
+	ret = v4l2_device_register_subdev(&cam_dev->v4l2_dev, &cam_dev->subdev);
+	if (ret) {
+		dev_err(dev, "failed initialize subdev:%d\n", ret);
+		goto fail_subdev;
+	}
+	dev_info(dev, "register subdev: %s\n", cam_dev->subdev.name);
+
+	/* Create video nodes and links */
+	for (i = 0; i < MTK_CAM_P1_TOTAL_NODES; i++) {
+		ret = mtk_cam_video_register_device(cam_dev, i);
+		if (ret)
+			goto fail_video_register;
+	}
+
+	vb2_dma_contig_set_max_seg_size(dev, DMA_BIT_MASK(32));
+
+	return 0;
+
+fail_video_register:
+	i--;
+	for (; i >= 0; i--) {
+		video_unregister_device(&cam_dev->vdev_nodes[i].vdev);
+		media_entity_cleanup(&cam_dev->vdev_nodes[i].vdev.entity);
+		mutex_destroy(&cam_dev->vdev_nodes[i].lock);
+	}
+fail_subdev:
+	media_entity_cleanup(&cam_dev->subdev.entity);
+fail_subdev_pads:
+	v4l2_device_unregister(&cam_dev->v4l2_dev);
+fail_v4l2_dev:
+	dev_err(dev, "fail_v4l2_dev mdev: 0x%pK:%d", &cam_dev->media_dev, ret);
+	media_device_unregister(&cam_dev->media_dev);
+	media_device_cleanup(&cam_dev->media_dev);
+
+	return ret;
+}
+
+static int mtk_cam_v4l2_unregister(struct mtk_cam_dev *cam_dev)
+{
+	unsigned int i;
+	struct mtk_cam_video_device *dev;
+
+	for (i = 0; i < MTK_CAM_P1_TOTAL_NODES; i++) {
+		dev = &cam_dev->vdev_nodes[i];
+		video_unregister_device(&dev->vdev);
+		media_entity_cleanup(&dev->vdev.entity);
+		mutex_destroy(&dev->lock);
+		if (dev->desc.image)
+			v4l2_ctrl_handler_free(&dev->ctrl_handler);
+	}
+
+	vb2_dma_contig_clear_max_seg_size(cam_dev->dev);
+
+	v4l2_device_unregister_subdev(&cam_dev->subdev);
+	media_entity_cleanup(&cam_dev->subdev.entity);
+
+	v4l2_device_unregister(&cam_dev->v4l2_dev);
+	media_device_unregister(&cam_dev->media_dev);
+	media_device_cleanup(&cam_dev->media_dev);
+
+	return 0;
+}
+
+static int mtk_cam_dev_complete(struct v4l2_async_notifier *notifier)
+{
+	struct mtk_cam_dev *cam_dev =
+		container_of(notifier, struct mtk_cam_dev, notifier);
+	struct device *dev = cam_dev->dev;
+	int ret;
+
+	ret = media_create_pad_link(&cam_dev->seninf->entity,
+				    MTK_CAM_CIO_PAD_SRC,
+				    &cam_dev->subdev.entity,
+				    MTK_CAM_CIO_PAD_SINK,
+				    0);
+	if (ret) {
+		dev_err(dev, "fail to create pad link %s %s err:%d\n",
+			cam_dev->seninf->entity.name,
+			cam_dev->subdev.entity.name,
+			ret);
+		return ret;
+	}
+
+	dev_info(dev, "Complete the v4l2 registration\n");
+
+	ret = v4l2_device_register_subdev_nodes(&cam_dev->v4l2_dev);
+	if (ret) {
+		dev_err(dev, "failed initialize subdev nodes:%d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int mtk_cam_dev_notifier_bound(struct v4l2_async_notifier *notifier,
+				      struct v4l2_subdev *sd,
+				      struct v4l2_async_subdev *asd)
+{
+	struct mtk_cam_dev *cam_dev =
+		container_of(notifier, struct mtk_cam_dev, notifier);
+
+	cam_dev->seninf = sd;
+	dev_info(cam_dev->dev, "%s is bounded\n", sd->entity.name);
+	return 0;
+}
+
+static void mtk_cam_dev_notifier_unbind(struct v4l2_async_notifier *notifier,
+					struct v4l2_subdev *sd,
+					struct v4l2_async_subdev *asd)
+{
+	struct mtk_cam_dev *cam_dev =
+		container_of(notifier, struct mtk_cam_dev, notifier);
+
+	cam_dev->seninf = NULL;
+	dev_dbg(cam_dev->dev, "%s is unbounded\n", sd->entity.name);
+}
+
+static int mtk_cam_dev_notifier_complete(struct v4l2_async_notifier *notifier)
+{
+	return mtk_cam_dev_complete(notifier);
+}
+
+static const struct v4l2_async_notifier_operations mtk_cam_async_ops = {
+	.bound = mtk_cam_dev_notifier_bound,
+	.unbind = mtk_cam_dev_notifier_unbind,
+	.complete = mtk_cam_dev_notifier_complete,
+};
+
+static int mtk_cam_v4l2_async_register(struct mtk_cam_dev *cam_dev)
+{
+	struct device *dev = cam_dev->dev;
+	int ret;
+
+	v4l2_async_notifier_init(&cam_dev->notifier);
+	ret = v4l2_async_notifier_parse_fwnode_endpoints(dev,
+		&cam_dev->notifier, sizeof(struct v4l2_async_subdev),
+		NULL);
+	if (ret)
+		return ret;
+
+	cam_dev->notifier.ops = &mtk_cam_async_ops;
+	dev_info(dev, "mtk_cam v4l2_async_notifier_register\n");
+	ret = v4l2_async_notifier_register(&cam_dev->v4l2_dev,
+					   &cam_dev->notifier);
+	if (ret) {
+		dev_err(dev, "failed to register async notifier : %d\n", ret);
+		v4l2_async_notifier_cleanup(&cam_dev->notifier);
+	}
+
+	return ret;
+}
+
+static void mtk_cam_v4l2_async_unregister(struct mtk_cam_dev *cam_dev)
+{
+	v4l2_async_notifier_unregister(&cam_dev->notifier);
+	v4l2_async_notifier_cleanup(&cam_dev->notifier);
+}
+
+static const struct v4l2_ioctl_ops mtk_cam_v4l2_vcap_ioctl_ops = {
+	.vidioc_querycap = mtk_cam_vidioc_querycap,
+	.vidioc_enum_framesizes = mtk_cam_vidioc_enum_framesizes,
+	.vidioc_enum_fmt_vid_cap = mtk_cam_vidioc_enum_fmt,
+	.vidioc_g_fmt_vid_cap_mplane = mtk_cam_vidioc_g_fmt,
+	.vidioc_s_fmt_vid_cap_mplane = mtk_cam_vidioc_s_fmt,
+	.vidioc_try_fmt_vid_cap_mplane = mtk_cam_vidioc_try_fmt,
+	.vidioc_enum_input = mtk_cam_vidioc_enum_input,
+	.vidioc_g_input = mtk_cam_vidioc_g_input,
+	.vidioc_s_input = mtk_cam_vidioc_s_input,
+	/* buffer queue management */
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static const struct v4l2_ioctl_ops mtk_cam_v4l2_meta_cap_ioctl_ops = {
+	.vidioc_querycap = mtk_cam_vidioc_querycap,
+	.vidioc_enum_fmt_meta_cap = mtk_cam_vidioc_meta_enum_fmt,
+	.vidioc_g_fmt_meta_cap = mtk_cam_vidioc_g_meta_fmt,
+	.vidioc_s_fmt_meta_cap = mtk_cam_vidioc_g_meta_fmt,
+	.vidioc_try_fmt_meta_cap = mtk_cam_vidioc_g_meta_fmt,
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+};
+
+static const struct v4l2_ioctl_ops mtk_cam_v4l2_meta_out_ioctl_ops = {
+	.vidioc_querycap = mtk_cam_vidioc_querycap,
+	.vidioc_enum_fmt_meta_out = mtk_cam_vidioc_meta_enum_fmt,
+	.vidioc_g_fmt_meta_out = mtk_cam_vidioc_g_meta_fmt,
+	.vidioc_s_fmt_meta_out = mtk_cam_vidioc_g_meta_fmt,
+	.vidioc_try_fmt_meta_out = mtk_cam_vidioc_g_meta_fmt,
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+};
+
+static const struct v4l2_format meta_fmts[] = {
+	{
+		.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_PARAMS,
+			.buffersize = 128 * PAGE_SIZE,
+		},
+	},
+	{
+		.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_3A,
+			.buffersize = 300 * PAGE_SIZE,
+		},
+	},
+	{
+		.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_AF,
+			.buffersize = 160 * PAGE_SIZE,
+		},
+	},
+	{
+		.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_LCS,
+			.buffersize = 72 * PAGE_SIZE,
+		},
+	},
+	{
+		.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_LMV,
+			.buffersize = 256,
+		},
+	},
+};
+
+static const struct v4l2_format stream_out_fmts[] = {
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR8,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR10,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR12,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR14,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG8,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG10,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG12,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG14,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG8,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG10,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG12,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG14,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB8,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB10,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB12,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB14,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.num_planes = 1,
+		},
+	},
+};
+
+static const struct v4l2_format bin_out_fmts[] = {
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR8F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR10F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR12F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR14F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG8F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG10F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG12F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG14F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG8F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG10F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG12F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG14F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB8F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB10F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB12F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.pix_mp = {
+			.width = RRZ_MAX_WIDTH,
+			.height = RRZ_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB14F,
+			.field = V4L2_FIELD_NONE,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.num_planes = 1,
+		},
+	},
+};
+
+static const struct v4l2_frmsizeenum img_frm_size_nums[] = {
+	{
+		.index = 0,
+		.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+		.stepwise = {
+			.max_width = IMG_MAX_WIDTH,
+			.min_width = IMG_MIN_WIDTH,
+			.max_height = IMG_MAX_HEIGHT,
+			.min_height = IMG_MIN_HEIGHT,
+			.step_height = 1,
+			.step_width = 1,
+		},
+	},
+	{
+		.index = 0,
+		.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+		.stepwise = {
+			.max_width = RRZ_MAX_WIDTH,
+			.min_width = RRZ_MIN_WIDTH,
+			.max_height = RRZ_MAX_HEIGHT,
+			.min_height = RRZ_MIN_HEIGHT,
+			.step_height = 1,
+			.step_width = 1,
+		},
+	},
+};
+
+static const struct
+mtk_cam_dev_node_desc output_queues[MTK_CAM_P1_TOTAL_OUTPUT] = {
+	{
+		.id = MTK_CAM_P1_META_IN_0,
+		.name = "meta input",
+		.description = "ISP tuning parameters",
+		.cap = V4L2_CAP_META_OUTPUT,
+		.buf_type = V4L2_BUF_TYPE_META_OUTPUT,
+		.link_flags = 0,
+		.capture = false,
+		.image = false,
+		.smem_alloc = true,
+		.requires_requests = true,
+		.fmts = meta_fmts,
+		.num_fmts = ARRAY_SIZE(meta_fmts),
+		.default_fmt_idx = 0,
+		.max_buf_count = 10,
+		.ioctl_ops = &mtk_cam_v4l2_meta_out_ioctl_ops,
+	},
+};
+
+static const struct
+mtk_cam_dev_node_desc capture_queues[MTK_CAM_P1_TOTAL_CAPTURE] = {
+	{
+		.id = MTK_CAM_P1_MAIN_STREAM_OUT,
+		.name = "main stream",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = 0,
+		.capture = true,
+		.image = true,
+		.smem_alloc = false,
+		.requires_requests = true,
+		.dma_port = R_IMGO,
+		.fmts = stream_out_fmts,
+		.num_fmts = ARRAY_SIZE(stream_out_fmts),
+		.default_fmt_idx = 1,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &img_frm_size_nums[0],
+	},
+	{
+		.id = MTK_CAM_P1_PACKED_BIN_OUT,
+		.name = "packed out",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = 0,
+		.capture = true,
+		.image = true,
+		.smem_alloc = false,
+		.requires_requests = true,
+		.dma_port = R_RRZO,
+		.fmts = bin_out_fmts,
+		.num_fmts = ARRAY_SIZE(bin_out_fmts),
+		.default_fmt_idx = 1,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &img_frm_size_nums[1],
+	},
+	{
+		.id = MTK_CAM_P1_META_OUT_0,
+		.name = "partial meta 0",
+		.description = "AE/AWB histogram",
+		.cap = V4L2_CAP_META_CAPTURE,
+		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
+		.link_flags = 0,
+		.capture = true,
+		.image = false,
+		.smem_alloc = false,
+		.requires_requests = false,
+		.dma_port = R_AAO | R_FLKO | R_PSO,
+		.fmts = meta_fmts,
+		.num_fmts = ARRAY_SIZE(meta_fmts),
+		.default_fmt_idx = 1,
+		.max_buf_count = 5,
+		.ioctl_ops = &mtk_cam_v4l2_meta_cap_ioctl_ops,
+	},
+	{
+		.id = MTK_CAM_P1_META_OUT_1,
+		.name = "partial meta 1",
+		.description = "AF histogram",
+		.cap = V4L2_CAP_META_CAPTURE,
+		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
+		.link_flags = 0,
+		.capture = true,
+		.image = false,
+		.smem_alloc = false,
+		.requires_requests = false,
+		.dma_port = R_AFO,
+		.fmts = meta_fmts,
+		.num_fmts = ARRAY_SIZE(meta_fmts),
+		.default_fmt_idx = 2,
+		.max_buf_count = 5,
+		.ioctl_ops = &mtk_cam_v4l2_meta_cap_ioctl_ops,
+	},
+	{
+		.id = MTK_CAM_P1_META_OUT_2,
+		.name = "partial meta 2",
+		.description = "Local contrast enhanced statistics",
+		.cap = V4L2_CAP_META_CAPTURE,
+		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
+		.link_flags = 0,
+		.capture = true,
+		.image = false,
+		.smem_alloc = false,
+		.requires_requests = true,
+		.dma_port = R_LCSO,
+		.fmts = meta_fmts,
+		.num_fmts = ARRAY_SIZE(meta_fmts),
+		.default_fmt_idx = 3,
+		.max_buf_count = 10,
+		.ioctl_ops = &mtk_cam_v4l2_meta_cap_ioctl_ops,
+	},
+	{
+		.id = MTK_CAM_P1_META_OUT_3,
+		.name = "partial meta 3",
+		.description = "Local motion vector histogram",
+		.cap = V4L2_CAP_META_CAPTURE,
+		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
+		.link_flags = 0,
+		.capture = true,
+		.image = false,
+		.smem_alloc = false,
+		.requires_requests = true,
+		.dma_port = R_LMVO,
+		.fmts = meta_fmts,
+		.num_fmts = ARRAY_SIZE(meta_fmts),
+		.default_fmt_idx = 4,
+		.max_buf_count = 10,
+		.ioctl_ops = &mtk_cam_v4l2_meta_cap_ioctl_ops,
+	},
+};
+
+/* The helper to configure the device context */
+static void mtk_cam_dev_queue_setup(struct mtk_cam_dev *cam_dev)
+{
+	unsigned int i, node_idx;
+
+	node_idx = 0;
+
+	/* Setup the output queue */
+	for (i = 0; i < MTK_CAM_P1_TOTAL_OUTPUT; i++)
+		cam_dev->vdev_nodes[node_idx++].desc = output_queues[i];
+
+	/* Setup the capture queue */
+	for (i = 0; i < MTK_CAM_P1_TOTAL_CAPTURE; i++)
+		cam_dev->vdev_nodes[node_idx++].desc = capture_queues[i];
+}
+
+int mtk_cam_dev_init(struct platform_device *pdev,
+		     struct mtk_cam_dev *cam_dev)
+{
+	int ret;
+
+	cam_dev->dev = &pdev->dev;
+	mtk_cam_dev_queue_setup(cam_dev);
+	/* v4l2 sub-device registration */
+
+	dev_dbg(cam_dev->dev, "name: %s\n", MTK_CAM_DEV_P1_NAME);
+	ret = mtk_cam_v4l2_register(cam_dev);
+	if (ret)
+		return ret;
+
+	ret = mtk_cam_v4l2_async_register(cam_dev);
+	if (ret) {
+		mtk_cam_v4l2_unregister(cam_dev);
+		return ret;
+	}
+
+	spin_lock_init(&cam_dev->req_lock);
+	INIT_LIST_HEAD(&cam_dev->req_list);
+	mutex_init(&cam_dev->lock);
+
+	return 0;
+}
+
+int mtk_cam_dev_release(struct platform_device *pdev,
+			struct mtk_cam_dev *cam_dev)
+{
+	mtk_cam_v4l2_async_unregister(cam_dev);
+	mtk_cam_v4l2_unregister(cam_dev);
+
+	mutex_destroy(&cam_dev->lock);
+
+	return 0;
+}
+
diff --git a/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-v4l2-util.h b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-v4l2-util.h
new file mode 100644
index 000000000000..acb306deafcb
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam-v4l2-util.h
@@ -0,0 +1,175 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_DEV_V4L2_H__
+#define __MTK_CAM_DEV_V4L2_H__
+
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-v4l2.h>
+
+#define MTK_CAM_DEV_P1_NAME			"MTK-ISP-P1-V4L2"
+
+#define MTK_CAM_P1_META_IN_0			0
+#define MTK_CAM_P1_TOTAL_OUTPUT			1
+
+#define MTK_CAM_P1_MAIN_STREAM_OUT		1
+#define MTK_CAM_P1_PACKED_BIN_OUT		2
+#define MTK_CAM_P1_META_OUT_0			3
+#define MTK_CAM_P1_META_OUT_1			4
+#define MTK_CAM_P1_META_OUT_2			5
+#define MTK_CAM_P1_META_OUT_3			6
+#define MTK_CAM_P1_TOTAL_CAPTURE		6
+
+#define MTK_CAM_P1_TOTAL_NODES			7
+
+struct mtk_cam_dev_request {
+	struct media_request	req;
+	struct list_head	list;
+};
+
+struct mtk_cam_dev_buffer {
+	struct vb2_v4l2_buffer	vbb;
+	struct list_head	list;
+	/* Intenal part */
+	dma_addr_t		daddr;
+	dma_addr_t		scp_addr;
+	unsigned int		node_id;
+};
+
+/*
+ * struct mtk_cam_dev_node_desc - node attributes
+ *
+ * @id:		 id of the context queue
+ * @name:	 media entity name
+ * @description: descritpion of node
+ * @cap:	 mapped to V4L2 capabilities
+ * @buf_type:	 mapped to V4L2 buffer type
+ * @dma_port:	 the dma port associated to the buffer
+ * @link_flags:	 default media link flags
+ * @requires_requests: requires the Request API or not
+ * @smem_alloc:	 using the cam_smem_drv as alloc ctx or not
+ * @capture:	 true for capture queue (device to user)
+ *		 false for output queue (from user to device)
+ * @image:	 true for image node, false for meta node
+ * @num_fmts:	 the number of supported formats
+ * @default_fmt_idx: default format of this node
+ * @max_buf_count: maximum V4L2 buffer count
+ * @ioctl_ops:  mapped to v4l2_ioctl_ops
+ * @fmts:	supported format
+ * @frmsizes:	supported frame size number
+ *
+ */
+struct mtk_cam_dev_node_desc {
+	u8 id;
+	char *name;
+	char *description;
+	u32 cap;
+	u32 buf_type;
+	u32 dma_port;
+	u32 link_flags;
+	u8 smem_alloc:1;
+	u8 requires_requests:1;
+	u8 capture:1;
+	u8 image:1;
+	u8 num_fmts;
+	u8 default_fmt_idx;
+	u8 max_buf_count;
+	const struct v4l2_ioctl_ops *ioctl_ops;
+	const struct v4l2_format *fmts;
+	const struct v4l2_frmsizeenum *frmsizes;
+};
+
+/*
+ * struct mtk_cam_video_device - Mediatek video device structure.
+ *
+ * @id:		Id for index of mtk_cam_dev_node_desc:vdev_nodes array
+ * @enabled:	Indicate the device is enabled or not
+ * @vdev_fmt:	The V4L2 format of video device
+ * @vdev_apd:	The media pad graph object of video device
+ * @vbq:	A videobuf queue of video device
+ * @desc:	The node attributes of video device
+ * @ctrl_handler:	The control handler of video device
+ * @pending_list:	List for pending buffers before enqueuing into driver
+ * @lock:	Serializes vb2 queue and video device operations
+ * @slock:	Protect for pending_list
+ *
+ */
+struct mtk_cam_video_device {
+	unsigned int id;
+	unsigned int enabled;
+	struct v4l2_format vdev_fmt;
+	struct mtk_cam_dev_node_desc desc;
+	struct video_device vdev;
+	struct media_pad vdev_pad;
+	struct vb2_queue vbq;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct list_head pending_list;
+	/* Used for vbq & vdev */
+	struct mutex lock;
+	/* protect for pending_list */
+	spinlock_t slock;
+};
+
+/*
+ * struct mtk_cam_dev - Mediatek camera device structure.
+ *
+ * @dev:	Pointer to device
+ * @smem_pdev:	Pointer to shared memory device
+ * @pipeline:	Media pipeline information
+ * @media_dev:	Media device
+ * @subdev:	The V4L2 sub-device
+ * @v4l2_dev:	The V4L2 device driver
+ * @notifier:	The v4l2_device notifier data
+ * @subdev_pads: Pointer to the number of media pads of this sub-device
+ * @ctrl_handler: The control handler
+ * @vdev_nodes: The array list of mtk_cam_video_device nodes
+ * @seninf:	Pointer to the seninf sub-device
+ * @sensor:	Pointer to the active sensor V4L2 sub-device when streaming on
+ * @lock:       The mutex protecting video device open/release operations
+ * @streaming:	Indicate the overall streaming status is on or off
+ * @streamed_node_count: The number of V4L2 video device nodes are streaming on
+ * @req_list:	Lins to keep media requests before streaming on
+ * @req_lock:	Protect the req_list data
+ *
+ * Below is the graph topology for Camera IO connection.
+ * sensor 1 (main) --> sensor IF --> P1 sub-device
+ * sensor 2 (sub)  -->
+ *
+ */
+struct mtk_cam_dev {
+	struct device *dev;
+	struct device *smem_dev;
+	struct media_pipeline pipeline;
+	struct media_device media_dev;
+	struct v4l2_subdev subdev;
+	struct v4l2_device v4l2_dev;
+	struct v4l2_async_notifier notifier;
+	struct media_pad *subdev_pads;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct mtk_cam_video_device vdev_nodes[MTK_CAM_P1_TOTAL_NODES];
+	struct v4l2_subdev *seninf;
+	struct v4l2_subdev *sensor;
+	/* protect video device open/release operations */
+	struct mutex lock;
+	unsigned int streaming:1;
+	atomic_t streamed_node_count;
+	struct list_head req_list;
+	/* protect for req_list */
+	spinlock_t req_lock;
+};
+
+int mtk_cam_dev_init(struct platform_device *pdev,
+		     struct mtk_cam_dev *cam_dev);
+int mtk_cam_dev_release(struct platform_device *pdev,
+			struct mtk_cam_dev *cam_dev);
+#endif /* __MTK_CAM_DEV_V4L2_H__ */
diff --git a/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam.c b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam.c
new file mode 100644
index 000000000000..eae00c7097ac
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam.c
@@ -0,0 +1,1135 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2018 MediaTek Inc.
+
+#include <linux/atomic.h>
+#include <linux/cdev.h>
+#include <linux/compat.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/ktime.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/mtk_scp.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include <linux/sched/clock.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#include <linux/vmalloc.h>
+#include <media/v4l2-event.h>
+
+#include "mtk_cam.h"
+#include "mtk_cam-regs.h"
+#include "mtk_cam-smem.h"
+
+static const struct of_device_id mtk_isp_of_ids[] = {
+	{.compatible = "mediatek,mt8183-camisp",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, mtk_isp_of_ids);
+
+/* List of clocks required by isp cam */
+static const char * const mtk_isp_clks[] = {
+	"camsys_cam_cgpdn", "camsys_camtg_cgpdn"
+};
+
+static void isp_dump_dma_status(struct isp_device *isp_dev)
+{
+	dev_err(isp_dev->dev,
+		"IMGO:0x%x, RRZO:0x%x, AAO=0x%x, AFO=0x%x, LMVO=0x%x\n",
+		readl(isp_dev->regs + REG_IMGO_ERR_STAT),
+		readl(isp_dev->regs + REG_RRZO_ERR_STAT),
+		readl(isp_dev->regs + REG_AAO_ERR_STAT),
+		readl(isp_dev->regs + REG_AFO_ERR_STAT),
+		readl(isp_dev->regs + REG_LMVO_ERR_STAT));
+	dev_err(isp_dev->dev,
+		"LCSO=0x%x, PSO=0x%x, FLKO=0x%x, BPCI:0x%x, LSCI=0x%x\n",
+		readl(isp_dev->regs + REG_LCSO_ERR_STAT),
+		readl(isp_dev->regs + REG_PSO_ERR_STAT),
+		readl(isp_dev->regs + REG_FLKO_ERR_STAT),
+		readl(isp_dev->regs + REG_BPCI_ERR_STAT),
+		readl(isp_dev->regs + REG_LSCI_ERR_STAT));
+}
+
+static void mtk_cam_dev_event_frame_sync(struct mtk_cam_dev *cam_dev,
+					 __u32 frame_seq_no)
+{
+	struct v4l2_event event;
+
+	memset(&event, 0, sizeof(event));
+	event.type = V4L2_EVENT_FRAME_SYNC;
+	event.u.frame_sync.frame_sequence = frame_seq_no;
+	v4l2_event_queue(cam_dev->subdev.devnode, &event);
+}
+
+static void mtk_cam_dev_job_finish(struct mtk_isp_p1_ctx *isp_ctx,
+				   unsigned int request_fd,
+				   unsigned int frame_seq_no,
+				   struct list_head *list_buf,
+				   enum vb2_buffer_state state)
+{
+	struct isp_p1_device *p1_dev = p1_ctx_to_dev(isp_ctx);
+	struct mtk_cam_dev *cam_dev = &p1_dev->cam_dev;
+	struct mtk_cam_dev_buffer *buf, *b0;
+	u64    timestamp;
+
+	if (!cam_dev->streaming)
+		return;
+
+	dev_dbg(&p1_dev->pdev->dev, "%s request fd:%d frame_seq:%d state:%d\n",
+		__func__, request_fd, frame_seq_no, state);
+
+	/*
+	 * Set the buffer's VB2 status so that the user can dequeue
+	 * the buffer.
+	 */
+	timestamp = ktime_get_ns();
+	list_for_each_entry_safe(buf, b0, list_buf, list) {
+		list_del(&buf->list);
+		buf->vbb.vb2_buf.timestamp = timestamp;
+		buf->vbb.sequence = frame_seq_no;
+		if (buf->vbb.vb2_buf.state == VB2_BUF_STATE_ACTIVE)
+			vb2_buffer_done(&buf->vbb.vb2_buf, state);
+	}
+}
+
+static void isp_deque_frame(struct isp_p1_device *p1_dev,
+			    unsigned int node_id, int vb2_index,
+			    int frame_seq_no)
+{
+	struct mtk_cam_dev *cam_dev = &p1_dev->cam_dev;
+	struct device *dev = &p1_dev->pdev->dev;
+	struct mtk_cam_video_device *node = &cam_dev->vdev_nodes[node_id];
+	struct mtk_cam_dev_buffer *b, *b0;
+	struct vb2_buffer *vb;
+
+	if (!cam_dev->vdev_nodes[node_id].enabled || !cam_dev->streaming)
+		return;
+
+	spin_lock(&node->slock);
+	b = list_first_entry(&node->pending_list,
+			     struct mtk_cam_dev_buffer,
+			     list);
+	list_for_each_entry_safe(b, b0, &node->pending_list, list) {
+		vb = &b->vbb.vb2_buf;
+		if (!vb->vb2_queue->uses_requests &&
+		    vb->index == vb2_index &&
+		    vb->state == VB2_BUF_STATE_ACTIVE) {
+			dev_dbg(dev, "%s:%d:%d", __func__, node_id, vb2_index);
+			vb->timestamp = ktime_get_ns();
+			b->vbb.sequence = frame_seq_no;
+			vb2_buffer_done(vb, VB2_BUF_STATE_DONE);
+			list_del(&b->list);
+			break;
+		}
+	}
+	spin_unlock(&node->slock);
+}
+
+static void isp_deque_request_frame(struct isp_p1_device *p1_dev,
+				    int frame_seq_no)
+{
+	struct mtk_isp_p1_ctx *isp_ctx = &p1_dev->isp_ctx;
+	struct device *dev = &p1_dev->pdev->dev;
+	struct mtk_isp_queue_job *framejob, *tmp;
+	struct isp_queue *p1_enqueue_list = &isp_ctx->p1_enqueue_list;
+
+	/* Match dequeue work and enqueue frame */
+	spin_lock(&p1_enqueue_list->lock);
+	list_for_each_entry_safe(framejob, tmp, &p1_enqueue_list->queue,
+				 list_entry) {
+		dev_dbg(dev,
+			"%s frame_seq_no:%d, target frame_seq_no:%d\n",
+			__func__,
+			framejob->frame_seq_no, frame_seq_no);
+		/* Match by the en-queued request number */
+		if (framejob->frame_seq_no == frame_seq_no) {
+			/* Pass to user space */
+			mtk_cam_dev_job_finish(isp_ctx,
+					       framejob->request_fd,
+					       framejob->frame_seq_no,
+					       &framejob->list_buf,
+					       VB2_BUF_STATE_DONE);
+			atomic_dec(&p1_enqueue_list->queue_cnt);
+			dev_dbg(dev,
+				"frame_seq_no:%d is done, queue_cnt:%d\n",
+				framejob->frame_seq_no,
+				atomic_read(&p1_enqueue_list->queue_cnt));
+
+			/* Remove only when frame ready */
+			list_del(&framejob->list_entry);
+			kfree(framejob);
+			break;
+		} else if (framejob->frame_seq_no < frame_seq_no) {
+			/* Pass to user space for frame drop */
+			mtk_cam_dev_job_finish(isp_ctx,
+					       framejob->request_fd,
+					       framejob->frame_seq_no,
+					       &framejob->list_buf,
+					       VB2_BUF_STATE_ERROR);
+			atomic_dec(&p1_enqueue_list->queue_cnt);
+			dev_warn(dev,
+				 "frame_seq_no:%d drop, queue_cnt:%d\n",
+				 framejob->frame_seq_no,
+				 atomic_read(&p1_enqueue_list->queue_cnt));
+
+			/* Remove only drop frame */
+			list_del(&framejob->list_entry);
+			kfree(framejob);
+		} else {
+			break;
+		}
+	}
+	spin_unlock(&p1_enqueue_list->lock);
+}
+
+static int isp_deque_work(void *data)
+{
+	struct isp_p1_device *p1_dev = (struct isp_p1_device *)data;
+	struct mtk_isp_p1_ctx *isp_ctx = &p1_dev->isp_ctx;
+	struct mtk_cam_dev_stat_event_data event_data;
+	atomic_t *irq_data_end = &isp_ctx->irq_data_end;
+	atomic_t *irq_data_start = &isp_ctx->irq_data_start;
+	unsigned long flags;
+	int ret, i;
+
+	while (1) {
+		ret = wait_event_interruptible(isp_ctx->isp_deque_thread.wq,
+					       (atomic_read(irq_data_end) !=
+					       atomic_read(irq_data_start)) ||
+					       kthread_should_stop());
+
+		if (kthread_should_stop())
+			break;
+
+		spin_lock_irqsave(&isp_ctx->irq_dequeue_lock, flags);
+		i = atomic_read(&isp_ctx->irq_data_start);
+		memcpy(&event_data, &isp_ctx->irq_event_datas[i],
+		       sizeof(event_data));
+		atomic_set(&isp_ctx->irq_data_start, ++i & 0x3);
+		spin_unlock_irqrestore(&isp_ctx->irq_dequeue_lock, flags);
+
+		if (event_data.irq_status_mask & HW_PASS1_DON_ST &&
+		    event_data.dma_status_mask & AAO_DONE_ST) {
+			isp_deque_frame(p1_dev,
+					MTK_CAM_P1_META_OUT_0,
+					event_data.meta0_vb2_index,
+					event_data.frame_seq_no);
+		}
+		if (event_data.dma_status_mask & AFO_DONE_ST) {
+			isp_deque_frame(p1_dev,
+					MTK_CAM_P1_META_OUT_1,
+					event_data.meta1_vb2_index,
+					event_data.frame_seq_no);
+		}
+		if (event_data.irq_status_mask & SW_PASS1_DON_ST) {
+			isp_deque_frame(p1_dev,
+					MTK_CAM_P1_META_OUT_0,
+					event_data.meta0_vb2_index,
+					event_data.frame_seq_no);
+			isp_deque_request_frame(p1_dev,
+						event_data.frame_seq_no);
+		}
+	}
+
+	return 0;
+}
+
+static int irq_handle_sof(struct isp_device *isp_dev,
+			  dma_addr_t base_addr,
+			  unsigned int frame_num,
+			  unsigned int meta0_vb2_index,
+			  unsigned int meta1_vb2_index)
+{
+	unsigned int addr_offset;
+	struct isp_p1_device *p1_dev = get_p1_device(isp_dev->dev);
+	int cq_num = atomic_read(&p1_dev->isp_ctx.composed_frame_id);
+
+	isp_dev->sof_count += 1;
+	isp_dev->current_frame = frame_num;
+	isp_dev->meta0_vb2_index = meta0_vb2_index;
+	isp_dev->meta1_vb2_index = meta1_vb2_index;
+
+	if (cq_num <= frame_num) {
+		dev_dbg(isp_dev->dev,
+			"SOF_INT_ST, wait next, cq_num:%d, frame_num:%d",
+			cq_num, frame_num);
+		atomic_set(&p1_dev->isp_ctx.composing_frame, 0);
+		return cq_num;
+	}
+	atomic_set(&p1_dev->isp_ctx.composing_frame, cq_num - frame_num);
+
+	addr_offset = CQ_ADDRESS_OFFSET * (frame_num % CQ_BUFFER_COUNT);
+	writel(base_addr + addr_offset, isp_dev->regs + REG_CQ_THR0_BASEADDR);
+	dev_dbg(isp_dev->dev,
+		"SOF_INT_ST, update next, cq_num:%d, frame_num:%d cq_addr:0x%x",
+		cq_num, frame_num, addr_offset);
+
+	return cq_num;
+}
+
+static void irq_handle_notify_event(struct isp_device *isp_dev,
+				    unsigned int irq_status,
+				    unsigned int dma_status,
+				    bool sof_only)
+{
+	struct isp_p1_device *p1_dev = get_p1_device(isp_dev->dev);
+	struct mtk_isp_p1_ctx *isp_ctx = &p1_dev->isp_ctx;
+	struct device *dev = isp_dev->dev;
+	unsigned long flags;
+	int i;
+
+	if (irq_status & VS_INT_ST) {
+		/* Notify specific HW events to user space */
+		mtk_cam_dev_event_frame_sync(&p1_dev->cam_dev,
+					     isp_dev->current_frame);
+		dev_dbg(dev,
+			"frame sync is sent:%d:%d\n",
+			isp_dev->sof_count,
+			isp_dev->current_frame);
+		if (sof_only)
+			return;
+	}
+
+	/* Notify TX thread to send if TX frame is blocked */
+	if (irq_status & SW_PASS1_DON_ST)
+		wake_up_interruptible(&isp_ctx->composer_tx_thread.wq);
+
+	spin_lock_irqsave(&isp_ctx->irq_dequeue_lock, flags);
+	i = atomic_read(&isp_ctx->irq_data_end);
+	isp_ctx->irq_event_datas[i].frame_seq_no = isp_dev->current_frame;
+	isp_ctx->irq_event_datas[i].meta0_vb2_index = isp_dev->meta0_vb2_index;
+	isp_ctx->irq_event_datas[i].meta1_vb2_index = isp_dev->meta1_vb2_index;
+	isp_ctx->irq_event_datas[i].irq_status_mask =
+		(irq_status & INT_ST_MASK_CAM);
+	isp_ctx->irq_event_datas[i].dma_status_mask =
+		(dma_status & DMA_ST_MASK_CAM);
+	atomic_set(&isp_ctx->irq_data_end, ++i & 0x3);
+	spin_unlock_irqrestore(&isp_ctx->irq_dequeue_lock, flags);
+
+	wake_up_interruptible(&isp_ctx->isp_deque_thread.wq);
+
+	dev_dbg(dev,
+		"%s IRQ:0x%x DMA:0x%x seq:%d idx0:%d idx1:%d\n",
+		__func__,
+		(irq_status & INT_ST_MASK_CAM),
+		(dma_status & DMA_ST_MASK_CAM),
+		isp_dev->current_frame,
+		isp_dev->meta0_vb2_index,
+		isp_dev->meta1_vb2_index);
+}
+
+irqreturn_t isp_irq_cam(int irq, void *data)
+{
+	struct isp_device *isp_dev = (struct isp_device *)data;
+	struct isp_p1_device *p1_dev = get_p1_device(isp_dev->dev);
+	struct mtk_isp_p1_ctx *isp_ctx = &p1_dev->isp_ctx;
+	struct device *dev = isp_dev->dev;
+	unsigned int cam_idx, cq_num, hw_frame_num;
+	unsigned int meta0_vb2_index, meta1_vb2_index;
+	unsigned int irq_status, err_status, dma_status;
+	unsigned int aao_fbc, afo_fbc;
+	unsigned long flags;
+
+	/* Check the streaming is off or not */
+	if (!p1_dev->cam_dev.streaming)
+		return IRQ_HANDLED;
+
+	cam_idx = isp_dev->isp_hw_module - ISP_CAM_A_IDX;
+	cq_num = 0;
+
+	spin_lock_irqsave(&isp_dev->spinlock_irq, flags);
+	irq_status = readl(isp_dev->regs + REG_CTL_RAW_INT_STAT);
+	dma_status = readl(isp_dev->regs + REG_CTL_RAW_INT2_STAT);
+	hw_frame_num = readl(isp_dev->regs + REG_HW_FRAME_NUM);
+	meta0_vb2_index = readl(isp_dev->regs + REG_META0_VB2_INDEX);
+	meta1_vb2_index = readl(isp_dev->regs + REG_META1_VB2_INDEX);
+	aao_fbc = readl(isp_dev->regs + REG_AAO_FBC_STATUS);
+	afo_fbc = readl(isp_dev->regs + REG_AFO_FBC_STATUS);
+	spin_unlock_irqrestore(&isp_dev->spinlock_irq, flags);
+
+	/* Ignore unnecessary IRQ */
+	if (!irq_status && !(dma_status & DMA_ST_MASK_CAM))
+		return IRQ_HANDLED;
+
+	err_status = irq_status & INT_ST_MASK_CAM_ERR;
+
+	/* Sof, done order check */
+	if ((irq_status & SOF_INT_ST) && (irq_status & HW_PASS1_DON_ST)) {
+		dev_dbg(dev, "sof_done block cnt:%d\n", isp_dev->sof_count);
+
+		/* Notify IRQ event and enqueue frame */
+		irq_handle_notify_event(isp_dev, irq_status, dma_status, 0);
+	} else {
+		irq_handle_notify_event(isp_dev, irq_status, dma_status, 1);
+	}
+
+	if (irq_status & SOF_INT_ST)
+		cq_num = irq_handle_sof(isp_dev, isp_ctx->scp_mem_iova,
+					hw_frame_num, meta0_vb2_index,
+					meta1_vb2_index);
+
+	/* Check ISP error status */
+	if (err_status) {
+		dev_err(dev,
+			"raw_int_err:0x%x/0x%x\n",
+			irq_status, err_status);
+		/* Show DMA errors in detail */
+		if (err_status & DMA_ERR_ST)
+			isp_dump_dma_status(isp_dev);
+	}
+
+	if (irq_status & INT_ST_LOG_MASK_CAM)
+		dev_dbg(dev, IRQ_STAT_STR,
+			'A' + cam_idx,
+			isp_dev->sof_count,
+			irq_status,
+			dma_status,
+			hw_frame_num,
+			cq_num,
+			aao_fbc,
+			afo_fbc);
+
+	return IRQ_HANDLED;
+}
+
+static int isp_setup_scp_rproc(struct isp_p1_device *p1_dev)
+{
+	phandle rproc_phandle;
+	struct device *dev = &p1_dev->pdev->dev;
+	int ret;
+
+	p1_dev->scp_pdev = scp_get_pdev(p1_dev->pdev);
+	if (!p1_dev->scp_pdev) {
+		dev_err(dev, "Failed to get scp device\n");
+		return -ENODEV;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "mediatek,scp",
+				   &rproc_phandle);
+	if (ret) {
+		dev_err(dev, "fail to get rproc_phandle:%d\n", ret);
+		return -EINVAL;
+	}
+
+	p1_dev->rproc_handle = rproc_get_by_phandle(rproc_phandle);
+	dev_dbg(dev, "p1 rproc_phandle: 0x%pK\n\n", p1_dev->rproc_handle);
+	if (!p1_dev->rproc_handle) {
+		dev_err(dev, "fail to get rproc_handle\n");
+		return -EINVAL;
+	}
+
+	ret = rproc_boot(p1_dev->rproc_handle);
+	if (ret) {
+		/*
+		 * Return 0 if downloading firmware successfully,
+		 * otherwise it is failed
+		 */
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int isp_init_context(struct isp_p1_device *p1_dev)
+{
+	struct mtk_isp_p1_ctx *isp_ctx = &p1_dev->isp_ctx;
+	struct device *dev = &p1_dev->pdev->dev;
+	unsigned int i;
+
+	dev_dbg(dev, "init irq work thread\n");
+	if (!isp_ctx->isp_deque_thread.thread) {
+		init_waitqueue_head(&isp_ctx->isp_deque_thread.wq);
+		isp_ctx->isp_deque_thread.thread =
+			kthread_run(isp_deque_work, (void *)p1_dev,
+				    "isp_deque_work");
+		if (IS_ERR(isp_ctx->isp_deque_thread.thread)) {
+			dev_err(dev, "unable to alloc kthread\n");
+			isp_ctx->isp_deque_thread.thread = NULL;
+			return -ENOMEM;
+		}
+	}
+	spin_lock_init(&isp_ctx->irq_dequeue_lock);
+	mutex_init(&isp_ctx->lock);
+
+	INIT_LIST_HEAD(&isp_ctx->p1_enqueue_list.queue);
+	atomic_set(&isp_ctx->p1_enqueue_list.queue_cnt, 0);
+
+	for (i = 0; i < ISP_DEV_NODE_NUM; i++)
+		spin_lock_init(&p1_dev->isp_devs[i].spinlock_irq);
+
+	spin_lock_init(&isp_ctx->p1_enqueue_list.lock);
+	spin_lock_init(&isp_ctx->composer_txlist.lock);
+
+	atomic_set(&isp_ctx->irq_data_end, 0);
+	atomic_set(&isp_ctx->irq_data_start, 0);
+
+	return 0;
+}
+
+static int isp_uninit_context(struct device *dev)
+{
+	struct isp_p1_device *p1_dev = get_p1_device(dev);
+	struct mtk_isp_p1_ctx *isp_ctx = &p1_dev->isp_ctx;
+	struct mtk_isp_queue_job *framejob, *tmp_framejob;
+
+	spin_lock_irq(&isp_ctx->p1_enqueue_list.lock);
+	list_for_each_entry_safe(framejob, tmp_framejob,
+				 &isp_ctx->p1_enqueue_list.queue, list_entry) {
+		list_del(&framejob->list_entry);
+		kfree(framejob);
+	}
+	spin_unlock_irq(&isp_ctx->p1_enqueue_list.lock);
+
+	if (isp_ctx->isp_deque_thread.thread) {
+		kthread_stop(isp_ctx->isp_deque_thread.thread);
+		wake_up_interruptible(&isp_ctx->isp_deque_thread.wq);
+		isp_ctx->isp_deque_thread.thread = NULL;
+	}
+
+	mutex_destroy(&isp_ctx->lock);
+
+	return 0;
+}
+
+static unsigned int get_enabled_dma_ports(struct mtk_cam_dev *cam_dev)
+{
+	unsigned int enabled_dma_ports, i;
+
+	/* Get the enabled meta DMA ports */
+	enabled_dma_ports = 0;
+
+	for (i = 0; i < MTK_CAM_P1_TOTAL_NODES; i++)
+		if (cam_dev->vdev_nodes[i].enabled)
+			enabled_dma_ports |=
+				cam_dev->vdev_nodes[i].desc.dma_port;
+
+	dev_dbg(cam_dev->dev, "%s :0x%x", __func__, enabled_dma_ports);
+
+	return enabled_dma_ports;
+}
+
+/* Utility functions */
+static unsigned int get_sensor_pixel_id(unsigned int fmt)
+{
+	switch (fmt) {
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SBGGR14_1X14:
+		return RAW_PXL_ID_B;
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGBRG14_1X14:
+		return RAW_PXL_ID_GB;
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG14_1X14:
+		return RAW_PXL_ID_GR;
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+	case MEDIA_BUS_FMT_SRGGB14_1X14:
+		return RAW_PXL_ID_R;
+	default:
+		return RAW_PXL_ID_B;
+	}
+}
+
+static unsigned int get_sensor_fmt(unsigned int fmt)
+{
+	switch (fmt) {
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+		return IMG_FMT_BAYER8;
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+		return IMG_FMT_BAYER10;
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		return IMG_FMT_BAYER12;
+	case MEDIA_BUS_FMT_SBGGR14_1X14:
+	case MEDIA_BUS_FMT_SGBRG14_1X14:
+	case MEDIA_BUS_FMT_SGRBG14_1X14:
+	case MEDIA_BUS_FMT_SRGGB14_1X14:
+		return IMG_FMT_BAYER14;
+	default:
+		return IMG_FMT_UNKNOWN;
+	}
+}
+
+static unsigned int get_img_fmt(unsigned int fourcc)
+{
+	switch (fourcc) {
+	case V4L2_PIX_FMT_MTISP_SBGGR8:
+	case V4L2_PIX_FMT_MTISP_SGBRG8:
+	case V4L2_PIX_FMT_MTISP_SGRBG8:
+	case V4L2_PIX_FMT_MTISP_SRGGB8:
+		return IMG_FMT_BAYER8;
+	case V4L2_PIX_FMT_MTISP_SBGGR8F:
+	case V4L2_PIX_FMT_MTISP_SGBRG8F:
+	case V4L2_PIX_FMT_MTISP_SGRBG8F:
+	case V4L2_PIX_FMT_MTISP_SRGGB8F:
+		return IMG_FMT_FG_BAYER8;
+	case V4L2_PIX_FMT_MTISP_SBGGR10:
+	case V4L2_PIX_FMT_MTISP_SGBRG10:
+	case V4L2_PIX_FMT_MTISP_SGRBG10:
+	case V4L2_PIX_FMT_MTISP_SRGGB10:
+		return IMG_FMT_BAYER10;
+	case V4L2_PIX_FMT_MTISP_SBGGR10F:
+	case V4L2_PIX_FMT_MTISP_SGBRG10F:
+	case V4L2_PIX_FMT_MTISP_SGRBG10F:
+	case V4L2_PIX_FMT_MTISP_SRGGB10F:
+		return IMG_FMT_FG_BAYER10;
+	case V4L2_PIX_FMT_MTISP_SBGGR12:
+	case V4L2_PIX_FMT_MTISP_SGBRG12:
+	case V4L2_PIX_FMT_MTISP_SGRBG12:
+	case V4L2_PIX_FMT_MTISP_SRGGB12:
+		return IMG_FMT_BAYER12;
+	case V4L2_PIX_FMT_MTISP_SBGGR12F:
+	case V4L2_PIX_FMT_MTISP_SGBRG12F:
+	case V4L2_PIX_FMT_MTISP_SGRBG12F:
+	case V4L2_PIX_FMT_MTISP_SRGGB12F:
+		return IMG_FMT_FG_BAYER12;
+	case V4L2_PIX_FMT_MTISP_SBGGR14:
+	case V4L2_PIX_FMT_MTISP_SGBRG14:
+	case V4L2_PIX_FMT_MTISP_SGRBG14:
+	case V4L2_PIX_FMT_MTISP_SRGGB14:
+		return IMG_FMT_BAYER14;
+	case V4L2_PIX_FMT_MTISP_SBGGR14F:
+	case V4L2_PIX_FMT_MTISP_SGBRG14F:
+	case V4L2_PIX_FMT_MTISP_SGRBG14F:
+	case V4L2_PIX_FMT_MTISP_SRGGB14F:
+		return IMG_FMT_FG_BAYER14;
+	default:
+		return IMG_FMT_UNKNOWN;
+	}
+}
+
+static unsigned int get_pixel_byte(unsigned int fourcc)
+{
+	switch (fourcc) {
+	case V4L2_PIX_FMT_MTISP_SBGGR8:
+	case V4L2_PIX_FMT_MTISP_SGBRG8:
+	case V4L2_PIX_FMT_MTISP_SGRBG8:
+	case V4L2_PIX_FMT_MTISP_SRGGB8:
+	case V4L2_PIX_FMT_MTISP_SBGGR8F:
+	case V4L2_PIX_FMT_MTISP_SGBRG8F:
+	case V4L2_PIX_FMT_MTISP_SGRBG8F:
+	case V4L2_PIX_FMT_MTISP_SRGGB8F:
+		return 8;
+	case V4L2_PIX_FMT_MTISP_SBGGR10:
+	case V4L2_PIX_FMT_MTISP_SGBRG10:
+	case V4L2_PIX_FMT_MTISP_SGRBG10:
+	case V4L2_PIX_FMT_MTISP_SRGGB10:
+	case V4L2_PIX_FMT_MTISP_SBGGR10F:
+	case V4L2_PIX_FMT_MTISP_SGBRG10F:
+	case V4L2_PIX_FMT_MTISP_SGRBG10F:
+	case V4L2_PIX_FMT_MTISP_SRGGB10F:
+		return 10;
+	case V4L2_PIX_FMT_MTISP_SBGGR12:
+	case V4L2_PIX_FMT_MTISP_SGBRG12:
+	case V4L2_PIX_FMT_MTISP_SGRBG12:
+	case V4L2_PIX_FMT_MTISP_SRGGB12:
+	case V4L2_PIX_FMT_MTISP_SBGGR12F:
+	case V4L2_PIX_FMT_MTISP_SGBRG12F:
+	case V4L2_PIX_FMT_MTISP_SGRBG12F:
+	case V4L2_PIX_FMT_MTISP_SRGGB12F:
+		return 12;
+	case V4L2_PIX_FMT_MTISP_SBGGR14:
+	case V4L2_PIX_FMT_MTISP_SGBRG14:
+	case V4L2_PIX_FMT_MTISP_SGRBG14:
+	case V4L2_PIX_FMT_MTISP_SRGGB14:
+	case V4L2_PIX_FMT_MTISP_SBGGR14F:
+	case V4L2_PIX_FMT_MTISP_SGBRG14F:
+	case V4L2_PIX_FMT_MTISP_SGRBG14F:
+	case V4L2_PIX_FMT_MTISP_SRGGB14F:
+		return 14;
+	default:
+		return 10;
+	}
+}
+
+static void config_img_fmt(struct device *dev, struct p1_img_output *out_fmt,
+			   const struct v4l2_format *in_fmt,
+			   const struct v4l2_subdev_format *sd_format)
+{
+	out_fmt->img_fmt = get_img_fmt(in_fmt->fmt.pix_mp.pixelformat);
+	out_fmt->pixel_byte = get_pixel_byte(in_fmt->fmt.pix_mp.pixelformat);
+	out_fmt->size.w = in_fmt->fmt.pix_mp.width;
+	out_fmt->size.h = in_fmt->fmt.pix_mp.height;
+
+	out_fmt->size.stride = in_fmt->fmt.pix_mp.plane_fmt[0].bytesperline;
+	out_fmt->size.xsize = in_fmt->fmt.pix_mp.plane_fmt[0].bytesperline;
+
+	out_fmt->crop.left = 0x0;
+	out_fmt->crop.top = 0x0;
+
+	out_fmt->crop.width = sd_format->format.width;
+	out_fmt->crop.height = sd_format->format.height;
+
+	WARN_ONCE(in_fmt->fmt.pix_mp.width > out_fmt->crop.width ||
+		  in_fmt->fmt.pix_mp.height > out_fmt->crop.height,
+		  "img out:%d:%d in:%d:%d",
+		  in_fmt->fmt.pix_mp.width, in_fmt->fmt.pix_mp.height,
+		  out_fmt->crop.width, out_fmt->crop.height);
+
+	dev_dbg(dev, "pixel_byte:%d img_fmt:0x%x\n",
+		out_fmt->pixel_byte,
+		out_fmt->img_fmt);
+	dev_dbg(dev,
+		"param:size=%0dx%0d, stride:%d, xsize:%d, crop=%0dx%0d\n",
+		out_fmt->size.w, out_fmt->size.h,
+		out_fmt->size.stride, out_fmt->size.xsize,
+		out_fmt->crop.width, out_fmt->crop.height);
+}
+
+/* ISP P1 interface functions */
+int mtk_isp_power_init(struct mtk_cam_dev *cam_dev)
+{
+	struct device *dev = cam_dev->dev;
+	struct isp_p1_device *p1_dev = get_p1_device(dev);
+	struct mtk_isp_p1_ctx *isp_ctx = &p1_dev->isp_ctx;
+	int ret;
+
+	ret = isp_setup_scp_rproc(p1_dev);
+	if (ret)
+		return ret;
+
+	ret = isp_init_context(p1_dev);
+	if (ret)
+		return ret;
+
+	ret = isp_composer_init(dev);
+	if (ret)
+		goto composer_err;
+
+	pm_runtime_get_sync(dev);
+
+	/* ISP HW INIT */
+	isp_ctx->isp_hw_module = ISP_CAM_B_IDX;
+	/* Use pure RAW as default HW path */
+	isp_ctx->isp_raw_path = ISP_PURE_RAW_PATH;
+	atomic_set(&p1_dev->cam_dev.streamed_node_count, 0);
+
+	isp_composer_hw_init(dev);
+	/* Check enabled DMAs which is configured by media setup */
+	isp_composer_meta_config(dev, get_enabled_dma_ports(cam_dev));
+
+	dev_dbg(dev, "%s done\n", __func__);
+
+	return 0;
+
+composer_err:
+	isp_uninit_context(dev);
+
+	return ret;
+}
+
+int mtk_isp_power_release(struct device *dev)
+{
+	isp_composer_hw_deinit(dev);
+	pm_runtime_put_sync(dev);
+	isp_uninit_context(dev);
+
+	dev_dbg(dev, "%s done\n", __func__);
+
+	return 0;
+}
+
+int mtk_isp_config(struct device *dev)
+{
+	struct isp_p1_device *p1_dev = get_p1_device(dev);
+	struct mtk_isp_p1_ctx *isp_ctx = &p1_dev->isp_ctx;
+	struct p1_config_param config_param;
+	struct mtk_cam_dev *cam_dev = &p1_dev->cam_dev;
+	struct v4l2_subdev_format sd_fmt;
+	unsigned int enabled_dma_ports;
+	struct v4l2_format *img_fmt;
+	int ret;
+
+	p1_dev->isp_devs[isp_ctx->isp_hw_module].current_frame = 0;
+	p1_dev->isp_devs[isp_ctx->isp_hw_module].sof_count = 0;
+
+	isp_ctx->frame_seq_no = 1;
+	atomic_set(&isp_ctx->composed_frame_id, 0);
+
+	/* Get the enabled DMA ports */
+	enabled_dma_ports = get_enabled_dma_ports(cam_dev);
+	dev_dbg(dev, "%s enable_dma_ports:0x%x", __func__, enabled_dma_ports);
+
+	/* Sensor config */
+	sd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(cam_dev->sensor, pad, get_fmt, NULL, &sd_fmt);
+
+	if (ret) {
+		dev_dbg(dev, "sensor g_fmt on failed:%d\n", ret);
+		return -EPERM;
+	}
+
+	dev_dbg(dev,
+		"get_fmt ret=%d, w=%d, h=%d, code=0x%x, field=%d, color=%d\n",
+		ret, sd_fmt.format.width, sd_fmt.format.height,
+		sd_fmt.format.code, sd_fmt.format.field,
+		sd_fmt.format.colorspace);
+
+	config_param.cfg_in_param.continuous = 0x1;
+	config_param.cfg_in_param.subsample = 0x0;
+	/* Fix to one pixel mode in default */
+	config_param.cfg_in_param.pixel_mode = 0x1;
+	/* Support normal pattern in default */
+	config_param.cfg_in_param.data_pattern = 0x0;
+
+	config_param.cfg_in_param.crop.left = 0x0;
+	config_param.cfg_in_param.crop.top = 0x0;
+
+	config_param.cfg_in_param.raw_pixel_id =
+		get_sensor_pixel_id(sd_fmt.format.code);
+	config_param.cfg_in_param.img_fmt = get_sensor_fmt(sd_fmt.format.code);
+	config_param.cfg_in_param.crop.width = sd_fmt.format.width;
+	config_param.cfg_in_param.crop.height = sd_fmt.format.height;
+
+	config_param.cfg_main_param.bypass = 1;
+	img_fmt = &cam_dev->vdev_nodes[MTK_CAM_P1_MAIN_STREAM_OUT].vdev_fmt;
+	if ((enabled_dma_ports & R_IMGO) == R_IMGO) {
+		config_param.cfg_main_param.bypass = 0;
+		config_param.cfg_main_param.pure_raw = isp_ctx->isp_raw_path;
+		config_param.cfg_main_param.pure_raw_pack = 1;
+		config_img_fmt(dev, &config_param.cfg_main_param.output,
+			       img_fmt, &sd_fmt);
+	}
+
+	config_param.cfg_resize_param.bypass = 1;
+	img_fmt = &cam_dev->vdev_nodes[MTK_CAM_P1_PACKED_BIN_OUT].vdev_fmt;
+	if ((enabled_dma_ports & R_RRZO) == R_RRZO) {
+		config_param.cfg_resize_param.bypass = 0;
+		config_img_fmt(dev, &config_param.cfg_resize_param.output,
+			       img_fmt, &sd_fmt);
+	}
+
+	/* Configure meta DMAs info. */
+	config_param.cfg_meta_param.enabled_meta_dmas = enabled_dma_ports;
+
+	isp_composer_hw_config(dev, &config_param);
+
+	dev_dbg(dev, "%s done\n", __func__);
+
+	return 0;
+}
+
+void mtk_isp_enqueue(struct device *dev, unsigned int dma_port,
+		     struct mtk_cam_dev_buffer *buffer)
+{
+	struct mtk_isp_scp_p1_cmd frameparams;
+
+	memset(&frameparams, 0, sizeof(frameparams));
+	frameparams.cmd_id = ISP_CMD_ENQUEUE_META;
+	frameparams.meta_frame.enabled_dma = dma_port;
+	frameparams.meta_frame.vb_index = buffer->vbb.vb2_buf.index;
+	frameparams.meta_frame.meta_addr.iova = buffer->daddr;
+	frameparams.meta_frame.meta_addr.scp_addr = buffer->scp_addr;
+
+	isp_composer_enqueue(dev, &frameparams, SCP_ISP_CMD);
+}
+
+void mtk_isp_req_flush_buffers(struct device *dev)
+{
+	struct isp_p1_device *p1_dev = get_p1_device(dev);
+	struct mtk_isp_queue_job *job, *j0;
+	struct mtk_cam_dev_buffer *buf, *b0;
+	struct isp_queue *p1_list = &p1_dev->isp_ctx.p1_enqueue_list;
+
+	if (!atomic_read(&p1_list->queue_cnt))
+		return;
+
+	spin_lock(&p1_list->lock);
+	list_for_each_entry_safe(job, j0, &p1_list->queue, list_entry) {
+		list_for_each_entry_safe(buf, b0, &job->list_buf, list) {
+			list_del(&buf->list);
+			if (buf->vbb.vb2_buf.state == VB2_BUF_STATE_ACTIVE)
+				vb2_buffer_done(&buf->vbb.vb2_buf,
+						VB2_BUF_STATE_ERROR);
+		}
+		list_del(&job->list_entry);
+		atomic_dec(&p1_list->queue_cnt);
+		kfree(job);
+	}
+	spin_unlock(&p1_list->lock);
+}
+
+void mtk_isp_req_enqueue(struct device *dev, struct media_request *req)
+{
+	struct isp_p1_device *p1_dev = get_p1_device(dev);
+	struct mtk_isp_p1_ctx *isp_ctx = &p1_dev->isp_ctx;
+	struct p1_frame_param frameparams;
+	struct mtk_isp_queue_job *framejob;
+	struct media_request_object *obj, *obj_safe;
+	struct vb2_buffer *vb;
+	struct mtk_cam_dev_buffer *buf;
+
+	framejob = kzalloc(sizeof(*framejob), GFP_ATOMIC);
+	memset(framejob, 0, sizeof(*framejob));
+	memset(&frameparams, 0, sizeof(frameparams));
+	INIT_LIST_HEAD(&framejob->list_buf);
+
+	frameparams.frame_seq_no = isp_ctx->frame_seq_no++;
+	frameparams.sof_idx =
+		p1_dev->isp_devs[isp_ctx->isp_hw_module].sof_count;
+	framejob->frame_seq_no = frameparams.frame_seq_no;
+
+	list_for_each_entry_safe(obj, obj_safe, &req->objects, list) {
+		vb = container_of(obj, struct vb2_buffer, req_obj);
+		buf = container_of(vb, struct mtk_cam_dev_buffer, vbb.vb2_buf);
+		framejob->request_fd = buf->vbb.request_fd;
+		frameparams.dma_buffers[buf->node_id].iova = buf->daddr;
+		frameparams.dma_buffers[buf->node_id].scp_addr = buf->scp_addr;
+		list_add_tail(&buf->list, &framejob->list_buf);
+	}
+
+	spin_lock(&isp_ctx->p1_enqueue_list.lock);
+	list_add_tail(&framejob->list_entry, &isp_ctx->p1_enqueue_list.queue);
+	atomic_inc(&isp_ctx->p1_enqueue_list.queue_cnt);
+	spin_unlock(&isp_ctx->p1_enqueue_list.lock);
+
+	isp_composer_enqueue(dev, &frameparams, SCP_ISP_FRAME);
+	dev_dbg(dev, "request fd:%d frame_seq_no:%d is queued cnt:%d\n",
+		framejob->request_fd,
+		frameparams.frame_seq_no,
+		atomic_read(&isp_ctx->p1_enqueue_list.queue_cnt));
+}
+
+static int enable_sys_clock(struct isp_p1_device *p1_dev)
+{
+	struct device *dev = &p1_dev->pdev->dev;
+	int ret;
+
+	dev_info(dev, "- %s\n", __func__);
+
+	ret = clk_bulk_prepare_enable(p1_dev->isp_ctx.num_clks,
+				      p1_dev->isp_ctx.clk_list);
+	if (ret)
+		goto clk_err;
+
+	return 0;
+
+clk_err:
+	dev_err(dev, "cannot pre-en isp_cam clock:%d\n", ret);
+	clk_bulk_disable_unprepare(p1_dev->isp_ctx.num_clks,
+				   p1_dev->isp_ctx.clk_list);
+	return ret;
+}
+
+static void disable_sys_clock(struct isp_p1_device *p1_dev)
+{
+	dev_info(&p1_dev->pdev->dev, "- %s\n", __func__);
+	clk_bulk_disable_unprepare(p1_dev->isp_ctx.num_clks,
+				   p1_dev->isp_ctx.clk_list);
+}
+
+static int mtk_isp_suspend(struct device *dev)
+{
+	struct isp_p1_device *p1_dev = get_p1_device(dev);
+	int module = p1_dev->isp_ctx.isp_hw_module;
+	struct isp_device *isp_dev = &p1_dev->isp_devs[module];
+	unsigned int reg_val;
+
+	dev_dbg(dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	isp_dev = &p1_dev->isp_devs[module];
+	reg_val = readl(isp_dev->regs + REG_TG_VF_CON);
+	if (reg_val & VFDATA_EN_BIT) {
+		dev_dbg(dev, "Cam:%d suspend, disable VF\n", module);
+		/* Disable view finder */
+		writel((reg_val & (~VFDATA_EN_BIT)),
+		       isp_dev->regs + REG_TG_VF_CON);
+		/*
+		 * After VF enable, the TG frame count will be reset to 0;
+		 */
+		reg_val = readl(isp_dev->regs + REG_TG_SEN_MODE);
+		writel((reg_val & (~CMOS_EN_BIT)),
+		       isp_dev->regs +  + REG_TG_SEN_MODE);
+	}
+
+	disable_sys_clock(p1_dev);
+
+	return 0;
+}
+
+static int mtk_isp_resume(struct device *dev)
+{
+	struct isp_p1_device *p1_dev = get_p1_device(dev);
+	int module = p1_dev->isp_ctx.isp_hw_module;
+	struct isp_device *isp_dev = &p1_dev->isp_devs[module];
+	unsigned int reg_val;
+
+	dev_dbg(dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	enable_sys_clock(p1_dev);
+
+	/* V4L2 stream-on phase & restore HW stream-on status */
+	if (p1_dev->cam_dev.streaming) {
+		dev_dbg(dev, "Cam:%d resume,enable VF\n", module);
+		/* Enable CMOS */
+		reg_val = readl(isp_dev->regs + REG_TG_SEN_MODE);
+		writel((reg_val | CMOS_EN_BIT),
+		       isp_dev->regs + REG_TG_SEN_MODE);
+		/* Enable VF */
+		reg_val = readl(isp_dev->regs + REG_TG_VF_CON);
+		writel((reg_val | VFDATA_EN_BIT),
+		       isp_dev->regs + REG_TG_VF_CON);
+	}
+
+	return 0;
+}
+
+static int mtk_isp_probe(struct platform_device *pdev)
+{
+	struct isp_p1_device *p1_dev;
+	struct mtk_isp_p1_ctx *isp_ctx;
+	struct isp_device *isp_dev;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int irq;
+	int ret;
+	unsigned int i;
+
+	p1_dev = devm_kzalloc(dev, sizeof(*p1_dev), GFP_KERNEL);
+	if (!p1_dev)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, p1_dev);
+	isp_ctx = &p1_dev->isp_ctx;
+	p1_dev->pdev = pdev;
+
+	for (i = ISP_CAMSYS_CONFIG_IDX; i < ISP_DEV_NODE_NUM; i++) {
+		isp_dev = &p1_dev->isp_devs[i];
+		isp_dev->isp_hw_module = i;
+		isp_dev->dev = dev;
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		isp_dev->regs = devm_ioremap_resource(dev, res);
+
+		dev_dbg(dev, "cam%u, map_addr=0x%lx\n",
+			i, (unsigned long)isp_dev->regs);
+
+		if (!isp_dev->regs)
+			return PTR_ERR(isp_dev->regs);
+
+		/* Support IRQ from ISP_CAM_A_IDX */
+		if (i >= ISP_CAM_A_IDX) {
+			/* Reg & interrupts index is shifted with 1  */
+			irq = platform_get_irq(pdev, i - 1);
+			if (irq) {
+				ret = devm_request_irq(dev, irq,
+						       isp_irq_cam,
+						       IRQF_SHARED,
+						       dev_driver_string(dev),
+						       (void *)isp_dev);
+				if (ret) {
+					dev_err(dev,
+						"req_irq fail, dev:%s irq=%d\n",
+						dev->of_node->name,
+						irq);
+					return ret;
+				}
+				dev_dbg(dev, "Registered irq=%d, ISR:%s\n",
+					irq, dev_driver_string(dev));
+			}
+		}
+		spin_lock_init(&isp_dev->spinlock_irq);
+	}
+
+	p1_dev->isp_ctx.num_clks = ARRAY_SIZE(mtk_isp_clks);
+	p1_dev->isp_ctx.clk_list =
+		devm_kcalloc(dev,
+			     p1_dev->isp_ctx.num_clks,
+			     sizeof(*p1_dev->isp_ctx.clk_list),
+			     GFP_KERNEL);
+	if (!p1_dev->isp_ctx.clk_list)
+		return -ENOMEM;
+
+	for (i = 0; i < p1_dev->isp_ctx.num_clks; ++i)
+		p1_dev->isp_ctx.clk_list->id = mtk_isp_clks[i];
+
+	ret = devm_clk_bulk_get(dev,
+				p1_dev->isp_ctx.num_clks,
+				p1_dev->isp_ctx.clk_list);
+	if (ret) {
+		dev_err(dev, "cannot get isp cam clock:%d\n", ret);
+		return ret;
+	}
+
+	/* Initialize reserved DMA memory */
+	ret = mtk_cam_reserved_memory_init(p1_dev);
+	if (ret) {
+		dev_err(dev, "failed to configure DMA memory:%d\n", ret);
+		goto err_init;
+	}
+
+	/* Initialize the v4l2 common part */
+	ret = mtk_cam_dev_init(pdev, &p1_dev->cam_dev);
+	if (ret)
+		goto err_init;
+
+	spin_lock_init(&isp_ctx->p1_enqueue_list.lock);
+	pm_runtime_enable(dev);
+
+	return 0;
+
+err_init:
+	if (p1_dev->cam_dev.smem_dev)
+		device_unregister(p1_dev->cam_dev.smem_dev);
+
+	return ret;
+}
+
+static int mtk_isp_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct isp_p1_device *p1_dev = dev_get_drvdata(dev);
+
+	mtk_cam_dev_release(pdev, &p1_dev->cam_dev);
+	pm_runtime_disable(dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops mtk_isp_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mtk_isp_suspend, mtk_isp_resume)
+	SET_RUNTIME_PM_OPS(mtk_isp_suspend, mtk_isp_resume, NULL)
+};
+
+static struct platform_driver mtk_isp_driver = {
+	.probe   = mtk_isp_probe,
+	.remove  = mtk_isp_remove,
+	.driver  = {
+		.name  = "mtk-cam",
+		.of_match_table = of_match_ptr(mtk_isp_of_ids),
+		.pm     = &mtk_isp_pm_ops,
+	}
+};
+
+module_platform_driver(mtk_isp_driver);
+
+MODULE_DESCRIPTION("Camera ISP driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam.h b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam.h
new file mode 100644
index 000000000000..911df96c5638
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/cam/mtk_cam.h
@@ -0,0 +1,242 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ */
+
+#ifndef __CAMERA_ISP_H
+#define __CAMERA_ISP_H
+
+#include <linux/cdev.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/ioctl.h>
+#include <linux/irqreturn.h>
+#include <linux/miscdevice.h>
+#include <linux/pm_qos.h>
+#include <linux/scatterlist.h>
+
+#include "mtk_cam-scp.h"
+#include "mtk_cam-v4l2-util.h"
+
+#define CAM_A_MAX_WIDTH			3328
+#define CAM_A_MAX_HEIGHT		2496
+#define CAM_B_MAX_WIDTH			5376
+#define CAM_B_MAX_HEIGHT		4032
+
+#define CAM_MIN_WIDTH			80
+#define CAM_MIN_HEIGHT			60
+
+#define IMG_MAX_WIDTH			CAM_B_MAX_WIDTH
+#define IMG_MAX_HEIGHT			CAM_B_MAX_HEIGHT
+#define IMG_MIN_WIDTH			CAM_MIN_WIDTH
+#define IMG_MIN_HEIGHT			CAM_MIN_HEIGHT
+
+#define RRZ_MAX_WIDTH			CAM_B_MAX_WIDTH
+#define RRZ_MAX_HEIGHT			CAM_B_MAX_HEIGHT
+#define RRZ_MIN_WIDTH			CAM_MIN_WIDTH
+#define RRZ_MIN_HEIGHT			CAM_MIN_HEIGHT
+
+#define R_IMGO				BIT(0)
+#define R_RRZO				BIT(1)
+#define R_AAO				BIT(3)
+#define R_AFO				BIT(4)
+#define R_LCSO				BIT(5)
+#define R_PDO				BIT(6)
+#define R_LMVO				BIT(7)
+#define R_FLKO				BIT(8)
+#define R_RSSO				BIT(9)
+#define R_PSO				BIT(10)
+
+#define CQ_BUFFER_COUNT			3
+#define IRQ_DATA_BUF_SIZE		4
+#define CQ_ADDRESS_OFFSET		0x640
+
+#define ISP_COMPOSING_MAX_NUM		4
+#define ISP_FRAME_COMPOSING_MAX_NUM	3
+
+#define IRQ_STAT_STR	"cam%c, SOF_%d irq(0x%x), " \
+			"dma(0x%x), frame_num(%d)/cq_num(%d), " \
+			"fbc1(0x%x), fbc2(0x%x)\n"
+
+/*
+ * In order with the sequence of device nodes defined in dtsi rule,
+ * one hardware module should be mapping to one node.
+ */
+enum isp_dev_node_enum {
+	ISP_CAMSYS_CONFIG_IDX = 0,
+	ISP_CAM_UNI_IDX,
+	ISP_CAM_A_IDX,
+	ISP_CAM_B_IDX,
+	ISP_DEV_NODE_NUM
+};
+
+/* Image RAW path for ISP P1 module. */
+enum isp_raw_path_enum {
+	ISP_PROCESS_RAW_PATH = 0,
+	ISP_PURE_RAW_PATH
+};
+
+/* State for struct mtk_isp_p1_ctx: composer_state */
+enum  {
+	SCP_ON = 0,
+	SCP_OFF
+};
+
+enum {
+	IMG_FMT_UNKNOWN		= 0x0000,
+	IMG_FMT_BAYER8		= 0x2200,
+	IMG_FMT_BAYER10,
+	IMG_FMT_BAYER12,
+	IMG_FMT_BAYER14,
+	IMG_FMT_FG_BAYER8,
+	IMG_FMT_FG_BAYER10,
+	IMG_FMT_FG_BAYER12,
+	IMG_FMT_FG_BAYER14,
+};
+
+enum {
+	RAW_PXL_ID_B = 0,
+	RAW_PXL_ID_GB,
+	RAW_PXL_ID_GR,
+	RAW_PXL_ID_R
+};
+
+struct isp_queue {
+	struct list_head queue;
+	atomic_t queue_cnt;
+	spinlock_t lock; /* queue attributes protection */
+};
+
+struct isp_thread {
+	struct task_struct *thread;
+	wait_queue_head_t wq;
+};
+
+struct mtk_isp_queue_work {
+	union {
+		struct mtk_isp_scp_p1_cmd cmd;
+		struct p1_frame_param frameparams;
+	};
+	struct list_head list_entry;
+	enum mtk_isp_scp_type type;
+};
+
+struct mtk_cam_dev_stat_event_data {
+	__u32 frame_seq_no;
+	__u32 meta0_vb2_index;
+	__u32 meta1_vb2_index;
+	__u32 irq_status_mask;
+	__u32 dma_status_mask;
+};
+
+struct mtk_isp_queue_job {
+	struct list_head list_entry;
+	struct list_head list_buf;
+	unsigned int request_fd;
+	unsigned int frame_seq_no;
+};
+
+/*
+ * struct isp_device - the ISP device information
+ *
+ * @dev: Pointer to struct device
+ * @regs: Camera ISP base register address
+ * @spinlock_irq: Used to protect register read/write data
+ * @current_frame: The sequence number of processing frame
+ * @meta0_vb2_index: Meta0 vb2 buffer index, set when SOF
+ * @meta1_vb2_index: Meta1 vb2 buffer index, set when SOF
+ * @sof_count: The accumulated SOF counter
+ * @isp_hw_module: Identity camera A or B
+ *
+ */
+struct isp_device {
+	struct device *dev;
+	void __iomem *regs;
+	spinlock_t spinlock_irq; /* ISP reg setting integrity */
+	unsigned int current_frame;
+	unsigned int meta0_vb2_index;
+	unsigned int meta1_vb2_index;
+	u8 sof_count;
+	u8 isp_hw_module;
+};
+
+/*
+ * struct mtk_isp_p1_ctx - the ISP device information
+ *
+ * @composer_txlist: Queue for SCP TX data including SCP_ISP_CMD & SCP_ISP_FRAME
+ * @composer_tx_thread: TX Thread for SCP data tranmission
+ * @cmd_queued: The number of SCP_ISP_CMD commands will be sent
+ * @ipi_occupied: The total number of SCP TX data has beent sent
+ * @scp_state: The state of SCP control
+ * @composing_frame: The total number of SCP_ISP_FRAME has beent sent
+ * @composed_frame_id: The ack. frame sequence by SCP
+ * @composer_deinit_thread: The de-initialized thread
+ * @p1_enqueue_list: Queue for ISP frame buffers
+ * @isp_deque_thread: Thread for handling ISP frame buffers dequeue
+ * @irq_event_datas: Ring buffer for struct mtk_cam_dev_stat_event_data data
+ * @irq_data_start: Start index of irq_event_datas ring buffer
+ * @irq_data_end: End index of irq_event_datas ring buffer
+ * @irq_dequeue_lock: Lock to protect irq_event_datas ring buffer
+ * @scp_mem_pa: DMA address for SCP device
+ * @scp_mem_iova: DMA address for ISP HW DMA devices
+ * @frame_seq_no: Sequence number for ISP frame buffer
+ * @isp_hw_module: Active camera HW module
+ * @num_clks: The number of driver's clock
+ * @clk_list: The list of clock data
+ * @lock: Lock to protect context operations
+ *
+ */
+struct mtk_isp_p1_ctx {
+	struct isp_queue composer_txlist;
+	struct isp_thread composer_tx_thread;
+	atomic_t cmd_queued;
+	atomic_t ipi_occupied;
+	atomic_t scp_state;
+	atomic_t composing_frame;
+	atomic_t composed_frame_id;
+	struct isp_thread composer_deinit_thread;
+	struct isp_queue p1_enqueue_list;
+	struct isp_thread isp_deque_thread;
+	struct mtk_cam_dev_stat_event_data irq_event_datas[IRQ_DATA_BUF_SIZE];
+	atomic_t irq_data_start;
+	atomic_t irq_data_end;
+	spinlock_t irq_dequeue_lock; /* ISP frame dequeuq protection */
+	dma_addr_t scp_mem_pa;
+	dma_addr_t scp_mem_iova;
+	int frame_seq_no;
+	unsigned int isp_hw_module;
+	unsigned int isp_raw_path;
+	unsigned int num_clks;
+	struct clk_bulk_data *clk_list;
+	struct mutex lock; /* Protect context operations */
+};
+
+struct isp_p1_device {
+	struct platform_device *pdev;
+	struct platform_device *scp_pdev;
+	struct rproc *rproc_handle;
+	struct mtk_isp_p1_ctx isp_ctx;
+	struct mtk_cam_dev cam_dev;
+	struct isp_device isp_devs[ISP_DEV_NODE_NUM];
+};
+
+static inline struct isp_p1_device *
+p1_ctx_to_dev(const struct mtk_isp_p1_ctx *__p1_ctx)
+{
+	return container_of(__p1_ctx, struct isp_p1_device, isp_ctx);
+}
+
+static inline struct isp_p1_device *get_p1_device(struct device *dev)
+{
+	return ((struct isp_p1_device *)dev_get_drvdata(dev));
+}
+
+int mtk_isp_power_init(struct mtk_cam_dev *cam_dev);
+int mtk_isp_power_release(struct device *dev);
+int mtk_isp_config(struct device *dev);
+void mtk_isp_req_enqueue(struct device *dev, struct media_request *req);
+void mtk_isp_enqueue(struct device *dev, unsigned int dma_port,
+		     struct mtk_cam_dev_buffer *buffer);
+void mtk_isp_req_flush_buffers(struct device *dev);
+
+#endif /*__CAMERA_ISP_H*/
diff --git a/drivers/media/platform/mtk-isp/isp_50/dip/Makefile b/drivers/media/platform/mtk-isp/isp_50/dip/Makefile
new file mode 100644
index 000000000000..03137416857b
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/dip/Makefile
@@ -0,0 +1,32 @@
+#
+# Copyright (C) 2018 MediaTek Inc.
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+$(info $(srctree))
+ccflags-y += -I$(srctree)/drivers/media/platform/mtk-mdp3
+
+obj-y += mtk_dip-sys.o
+
+# To provide alloc context managing memory shared
+# between CPU and ISP coprocessor
+mtk_dip_smem-objs := \
+mtk_dip-smem.o
+
+obj-y += mtk_dip_smem.o
+
+# Utilits to provide frame-based streaming model
+# with v4l2 user interfaces
+mtk_dip_util-objs := \
+mtk_dip-dev.o \
+mtk_dip-v4l2.o \
+mtk_dip-ctrl.o \
+
+obj-y += mtk_dip_util.o
diff --git a/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-ctrl.c b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-ctrl.c
new file mode 100644
index 000000000000..3800e6cee4e0
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-ctrl.c
@@ -0,0 +1,122 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/platform_device.h>
+#include "mtk_dip-dev.h"
+
+static void handle_buf_usage_config(struct v4l2_ctrl *ctrl)
+{
+	pr_err("Buffer usage ctrl will be phased out soon\n");
+}
+
+static int handle_buf_rotate_config(struct v4l2_ctrl *ctrl)
+{
+	struct mtk_dip_video_device *node =
+		container_of(ctrl->handler,
+			     struct mtk_dip_video_device, ctrl_handler);
+
+	if (node->desc->id != MTK_DIP_VIDEO_NODE_ID_MDP0_CAPTURE) {
+		pr_debug("[%s] doesn't support rotation\n",
+			 node->desc->name);
+	}
+
+	if (ctrl->val != 0 && ctrl->val != 90 &&
+	    ctrl->val != 180 && ctrl->val != 270) {
+		pr_err("Invalid buffer rotation %d", ctrl->val);
+		return -EINVAL;
+	}
+	node->rotation = ctrl->val;
+	return 0;
+}
+
+static int mtk_dip_video_device_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_PRIVATE_SET_BUFFER_USAGE:
+		handle_buf_usage_config(ctrl);
+		break;
+	case V4L2_CID_ROTATE:
+		ret = handle_buf_rotate_config(ctrl);
+		break;
+	default:
+			break;
+	}
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops mtk_dip_video_device_ctrl_ops = {
+	.s_ctrl = mtk_dip_video_device_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config mtk_dip_buf_usage_config = {
+	.ops	= &mtk_dip_video_device_ctrl_ops,
+	.id	= V4L2_CID_PRIVATE_SET_BUFFER_USAGE,
+	.name	= "MTK ISP SET BUFFER USAGE",
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.min	= MTK_DIP_V4l2_BUF_USAGE_DEFAULT,
+	.max	= MTK_DIP_V4l2_BUF_USAGE_POSTPROC,
+	.step	= 1,
+	.def	= MTK_DIP_V4l2_BUF_USAGE_DEFAULT,
+	.flags	= V4L2_CTRL_FLAG_SLIDER | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	};
+
+int mtk_dip_ctrl_init(struct mtk_dip_pipe *dip_pipe)
+{
+	struct v4l2_ctrl_handler *hdl = &dip_pipe->ctrl_handler;
+	struct mtk_dip_video_device *node;
+	int i;
+	int img_nodes_to_be_init[3] = {
+		MTK_DIP_VIDEO_NODE_ID_RAW_OUT,
+		MTK_DIP_VIDEO_NODE_ID_MDP0_CAPTURE,
+		MTK_DIP_VIDEO_NODE_ID_MDP1_CAPTURE
+	};
+
+	v4l2_ctrl_handler_init(hdl, V4L2_CID_MTK_DIP_MAX);
+
+	pr_debug("%s init ctrl: %p\n", __func__, hdl);
+
+	if (hdl->error) {
+		pr_err("Failed in v4l2_ctrl_handler_init\n");
+		return hdl->error;
+	}
+
+	for (i = 0; i < MTK_DIP_VIDEO_NODE_ID_TOTAL_NUM; i++)
+		v4l2_ctrl_handler_init(&dip_pipe->nodes[i].ctrl_handler,
+				       V4L2_CID_MTK_DIP_MAX);
+
+	for (i = 0; i < ARRAY_SIZE(img_nodes_to_be_init); i++) {
+		node = &dip_pipe->nodes[img_nodes_to_be_init[i]];
+
+		if (v4l2_ctrl_new_custom(&node->ctrl_handler,
+					 &mtk_dip_buf_usage_config,
+					 NULL) == NULL)
+			dev_err(&dip_pipe->dip_dev->pdev->dev,
+				"Node(%s) create buf_usage_config ctrl failed:(%d)",
+				node->desc->name,
+				node->ctrl_handler.error);
+
+		if (v4l2_ctrl_new_std(&dip_pipe->ctrl_handler,
+				      &mtk_dip_video_device_ctrl_ops,
+			V4L2_CID_ROTATE, 0, 270, 90, 0)	== NULL)
+			dev_err(&dip_pipe->dip_dev->pdev->dev,
+				"Node(%s) create rotate ctrl failed:(%d)",
+				node->desc->name, node->ctrl_handler.error);
+	}
+
+return 0;
+}
+EXPORT_SYMBOL_GPL(mtk_dip_ctrl_init);
diff --git a/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-dev.c b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-dev.c
new file mode 100644
index 000000000000..50a789d0b1b2
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-dev.c
@@ -0,0 +1,1475 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-event.h>
+#include "mtk_dip-dev.h"
+#include "mtk_dip-smem.h"
+#include "mtk-mdp3-regs.h"
+#include "mtk-img-ipi.h"
+
+int mtk_dip_pipe_init(struct mtk_dip_pipe *dip_pipe,
+		      struct mtk_dip_dev *dip_dev,
+		      struct mtk_dip_pipe_desc *setting,
+		      struct media_device *media_dev,
+		      struct v4l2_device *v4l2_dev,
+		      struct mtk_dip_smem_dev *smem_alloc_dev)
+{
+	int ret, i;
+
+	dip_pipe->dip_dev = dip_dev;
+	dip_pipe->desc = setting;
+	dip_pipe->smem_alloc_dev = smem_alloc_dev;
+
+	atomic_set(&dip_pipe->pipe_job_sequence, 0);
+	spin_lock_init(&dip_pipe->job_lock);
+	mutex_init(&dip_pipe->lock);
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev, "init pipe(%s,%d)\n",
+		dip_pipe->desc->name,
+		dip_pipe->desc->id);
+
+	dip_pipe->num_nodes = MTK_DIP_VIDEO_NODE_ID_TOTAL_NUM;
+
+	for (i = 0; i < MTK_DIP_VIDEO_NODE_ID_OUT_TOTAL_NUM; i++) {
+		dip_pipe->nodes[i].desc =
+			&dip_pipe->desc->output_queue_descs[i];
+		dip_pipe->nodes[i].immutable = 0;
+		dip_pipe->nodes[i].enabled =
+			dip_pipe->nodes[i].desc->default_enable;
+		dip_pipe->nodes[i].crop.left = 0;
+		dip_pipe->nodes[i].crop.top = 0;
+		dip_pipe->nodes[i].compose.left = 0;
+		dip_pipe->nodes[i].compose.top = 0;
+
+		if (V4L2_TYPE_IS_OUTPUT(dip_pipe->nodes[i].desc->buf_type)) {
+			dip_pipe->nodes[i].crop.width =
+				MTK_DIP_OUTPUT_MAX_WIDTH;
+			dip_pipe->nodes[i].crop.height =
+				MTK_DIP_OUTPUT_MAX_HEIGHT;
+			dip_pipe->nodes[i].compose.width =
+				MTK_DIP_OUTPUT_MAX_WIDTH;
+			dip_pipe->nodes[i].compose.height =
+				MTK_DIP_OUTPUT_MAX_HEIGHT;
+		} else {
+			dip_pipe->nodes[i].crop.width =
+				MTK_DIP_CAPTURE_MAX_WIDTH;
+			dip_pipe->nodes[i].crop.height =
+				MTK_DIP_CAPTURE_MAX_HEIGHT;
+			dip_pipe->nodes[i].compose.width =
+				MTK_DIP_CAPTURE_MAX_WIDTH;
+			dip_pipe->nodes[i].compose.height =
+				MTK_DIP_CAPTURE_MAX_HEIGHT;
+		}
+
+		atomic_set(&dip_pipe->nodes[i].sequence, 0);
+
+		dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+			"%s: init node(%s,%d)\n",
+			dip_pipe->desc->name,
+			dip_pipe->nodes[i].desc->name, i);
+	}
+
+	for (i = MTK_DIP_VIDEO_NODE_ID_OUT_TOTAL_NUM;
+	     i < MTK_DIP_VIDEO_NODE_ID_TOTAL_NUM; i++) {
+		int cap_idx = i - MTK_DIP_VIDEO_NODE_ID_OUT_TOTAL_NUM;
+
+		dip_pipe->nodes[i].desc =
+			&dip_pipe->desc->capture_queue_descs[cap_idx];
+		dip_pipe->nodes[i].immutable = 0;
+		dip_pipe->nodes[i].enabled =
+			dip_pipe->nodes[i].desc->default_enable;
+		atomic_set(&dip_pipe->nodes[i].sequence, 0);
+
+		dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+			"%s: init node(%s,%d)\n",
+			dip_pipe->desc->name,
+			dip_pipe->nodes[i].desc->name, i);
+	}
+
+	if (dip_pipe->desc->master >= 0 &&
+	    dip_pipe->desc->master < MTK_DIP_VIDEO_NODE_ID_TOTAL_NUM) {
+		dip_pipe->nodes[dip_pipe->desc->master].immutable = 1;
+		dip_pipe->nodes[dip_pipe->desc->master].enabled = 1;
+	}
+
+	ret = mtk_dip_ctrl_init(dip_pipe);
+
+	if (ret) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"%s: failed(%d) to initialize ctrls\n",
+			dip_pipe->desc->name, ret);
+		goto failed_ctrl;
+	}
+
+	ret = mtk_dip_pipe_v4l2_register(dip_pipe, media_dev, v4l2_dev);
+
+	if (ret) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"%s: failed(%d) to create V4L2 devices\n",
+			dip_pipe->desc->name, ret);
+		goto failed_pipe;
+	}
+
+	return 0;
+
+failed_ctrl:
+failed_pipe:
+	mutex_destroy(&dip_pipe->lock);
+	return ret;
+}
+
+static int mtk_dip_pipe_next_job_id(struct mtk_dip_pipe *dip_pipe)
+{
+	int global_job_id =
+		atomic_inc_return(&dip_pipe->pipe_job_sequence);
+
+	global_job_id =
+		(global_job_id & 0x0000FFFF) |
+		(dip_pipe->desc->id << 16);
+
+	return global_job_id;
+}
+
+int mtk_dip_pipe_init_job_infos(struct mtk_dip_pipe *dip_pipe)
+{
+	int i;
+
+	spin_lock(&dip_pipe->job_lock);
+
+	dip_pipe->num_pipe_job_infos = ARRAY_SIZE(dip_pipe->pipe_job_infos);
+	INIT_LIST_HEAD(&dip_pipe->pipe_job_running_list);
+	INIT_LIST_HEAD(&dip_pipe->pipe_job_free_list);
+
+	for (i = 0; i < dip_pipe->num_pipe_job_infos; i++) {
+		struct mtk_dip_pipe_job_info *pipe_job_info =
+			&dip_pipe->pipe_job_infos[i];
+		list_add_tail(&pipe_job_info->list,
+			      &dip_pipe->pipe_job_free_list);
+	}
+
+	spin_unlock(&dip_pipe->job_lock);
+
+	return 0;
+}
+
+static int mtk_dip_pipe_process_pipe_job_info(struct mtk_dip_pipe *dip_pipe,
+					      struct mtk_dip_pipe_job_info
+					      *pipe_job_info)
+{
+	spin_lock(&dip_pipe->job_lock);
+
+	list_del(&pipe_job_info->list);
+	list_add_tail(&pipe_job_info->list, &dip_pipe->pipe_job_running_list);
+
+	spin_unlock(&dip_pipe->job_lock);
+	return 0;
+}
+
+struct mtk_dip_pipe_job_info *
+mtk_dip_pipe_get_running_job_info(struct mtk_dip_pipe *dip_pipe,
+				  int pipe_job_id)
+{
+	struct mtk_dip_pipe_job_info *pipe_job_info = NULL;
+
+	spin_lock(&dip_pipe->job_lock);
+
+	list_for_each_entry(pipe_job_info,
+			    &dip_pipe->pipe_job_running_list, list) {
+		if (pipe_job_info->id == pipe_job_id) {
+			spin_unlock(&dip_pipe->job_lock);
+			return pipe_job_info;
+		}
+	}
+
+	spin_unlock(&dip_pipe->job_lock);
+
+	return NULL;
+}
+
+static int
+mtk_dip_pipe_free_job_info(struct mtk_dip_pipe *dip_pipe,
+			   struct mtk_dip_pipe_job_info *pipe_job_info)
+{
+	spin_lock(&dip_pipe->job_lock);
+
+	list_del(&pipe_job_info->list);
+	list_add_tail(&pipe_job_info->list, &dip_pipe->pipe_job_free_list);
+
+	spin_unlock(&dip_pipe->job_lock);
+
+	return 0;
+}
+
+static struct mtk_dip_pipe_job_info *
+mtk_dip_pipe_get_free_job_info(struct mtk_dip_pipe *dip_pipe)
+{
+	struct mtk_dip_pipe_job_info *pipe_job_info = NULL;
+
+	spin_lock(&dip_pipe->job_lock);
+	list_for_each_entry(pipe_job_info,
+			    &dip_pipe->pipe_job_free_list, list) {
+		dev_dbg(&dip_pipe->dip_dev->pdev->dev, "Found free pipe job\n");
+		spin_unlock(&dip_pipe->job_lock);
+		return pipe_job_info;
+	}
+	spin_unlock(&dip_pipe->job_lock);
+
+	dev_err(&dip_pipe->dip_dev->pdev->dev,
+		"%s: can't found free pipe job\n",
+		dip_pipe->desc->name);
+
+	return NULL;
+}
+
+static void
+mtk_dip_pipe_update_job_info(struct mtk_dip_pipe *dip_pipe,
+			     struct mtk_dip_pipe_job_info *pipe_job_info,
+			     struct mtk_dip_video_device *node,
+			     struct mtk_dip_dev_buffer *dev_buf)
+{
+	if (!pipe_job_info || !dev_buf || !node) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"%s: update pipe-job(%p) failed, buf(%p),node(%p)\n",
+			dip_pipe->desc->name,
+			pipe_job_info, dev_buf, node);
+		return;
+	}
+
+	if (pipe_job_info->buf_map[node->desc->id])
+		dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+			"%s:%s: buf overwrite\n",
+			 dip_pipe->desc->name,
+			 node->desc->name);
+
+	if (node->desc->buf_type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		pipe_job_info->num_img_capture_bufs++;
+
+	if (node->desc->buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		pipe_job_info->num_img_output_bufs++;
+
+	if (node->desc->buf_type == V4L2_BUF_TYPE_META_OUTPUT)
+		pipe_job_info->num_meta_output_bufs++;
+
+	if (node->desc->buf_type == V4L2_BUF_TYPE_META_CAPTURE)
+		pipe_job_info->num_meta_capture_bufs++;
+
+	pipe_job_info->buf_map[node->desc->id] = dev_buf;
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s:%s: added buf(%p) to pipe-job(%p)\n",
+		dip_pipe->desc->name, node->desc->name, dev_buf,
+		pipe_job_info);
+}
+
+static void mtk_dip_pipe_debug_job(struct mtk_dip_pipe *dip_pipe,
+				   struct mtk_dip_pipe_job_info *pipe_job_info)
+{
+	int i;
+
+	if (!dip_pipe || !pipe_job_info)
+		return;
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s: pipe-job(%p),id(%d),req(%p)buf nums(%d,%d,%d,%d)\n",
+		dip_pipe->desc->name,
+		pipe_job_info,
+		pipe_job_info->id,
+		pipe_job_info->req,
+		pipe_job_info->num_img_capture_bufs,
+		pipe_job_info->num_img_output_bufs,
+		pipe_job_info->num_meta_capture_bufs,
+		pipe_job_info->num_meta_output_bufs);
+
+	for (i = 0; i < MTK_DIP_VIDEO_NODE_ID_TOTAL_NUM ; i++) {
+		if (pipe_job_info->buf_map[i])
+			dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+				"Node(%s,%d), buf(%p)\n",
+				dip_pipe->nodes[i].desc->name, i,
+				pipe_job_info->buf_map[i]);
+	}
+}
+
+int mtk_dip_pipe_job_finish(struct mtk_dip_pipe *dip_pipe,
+			    unsigned int pipe_job_info_id,
+			    enum vb2_buffer_state vbf_state)
+{
+	int i;
+	struct mtk_dip_pipe_job_info *job_info = NULL;
+	const int pipe_id =
+		mtk_dip_pipe_get_pipe_from_job_id(pipe_job_info_id);
+	u64 timestamp = 0;
+
+	if (!dip_pipe)
+		pr_err("%s: pipe-job id(%d) release failed, dip_pipe is null\n",
+		       __func__, pipe_job_info_id);
+
+	job_info = mtk_dip_pipe_get_running_job_info(dip_pipe,
+						     pipe_job_info_id);
+
+	if (!job_info) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"%s:%s: can't find pipe-job id(%d)\n",
+			__func__, dip_pipe->desc->name, pipe_id);
+		return -EINVAL;
+	}
+
+	timestamp = ktime_get_ns();
+
+	for (i = 0; i < MTK_DIP_VIDEO_NODE_ID_TOTAL_NUM; i++) {
+		struct mtk_dip_dev_buffer *dev_buf = job_info->buf_map[i];
+
+		if (!dev_buf) {
+			continue;
+		} else {
+			dev_buf->vbb.vb2_buf.timestamp = ktime_get_ns();
+			mtk_dip_v4l2_buffer_done(&dev_buf->vbb.vb2_buf,
+						 vbf_state);
+		}
+	}
+
+	mtk_dip_pipe_free_job_info(dip_pipe, job_info);
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s:%s: finish pipe-job, id(%d), vb state(%d)\n",
+		__func__, dip_pipe->desc->name, pipe_id,
+		pipe_job_info_id, vbf_state);
+
+	return 0;
+}
+
+static void mtk_dip_dev_buf_fill_info(struct mtk_dip_pipe *dip_pipe,
+				      struct mtk_dip_dev_buffer *dev_buf)
+{
+	struct vb2_v4l2_buffer *b;
+	struct mtk_dip_video_device *node;
+	struct mtk_dip_video_device_desc *desc;
+
+	b = &dev_buf->vbb;
+	node = mtk_dip_vbq_to_node(b->vb2_buf.vb2_queue);
+	desc = node->desc;
+	dev_buf->fmt = node->vdev_fmt;
+	dev_buf->dev_fmt = node->dev_q.dev_fmt;
+	dev_buf->isp_daddr =
+		vb2_dma_contig_plane_dma_addr(&b->vb2_buf, 0);
+	dev_buf->vaddr = vb2_plane_vaddr(&b->vb2_buf, 0);
+	dev_buf->buffer_usage = desc->dma_port;
+	dev_buf->rotation = node->rotation;
+	dev_buf->crop.c = node->crop;
+	dev_buf->compose = node->compose;
+
+	if (desc->smem_alloc) {
+		dev_buf->scp_daddr =
+			mtk_dip_smem_iova_to_phys
+			(dip_pipe->smem_alloc_dev,
+			 dev_buf->isp_daddr);
+	} else {
+		dev_buf->scp_daddr = 0;
+	}
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s:%s: buf type(%d), idx(%d), mem(%d), isp_daddr(%pad), scp_daddr(%pad)\n",
+		dip_pipe->desc->name,
+		desc->name,
+		b->vb2_buf.type,
+		b->vb2_buf.index,
+		b->vb2_buf.memory,
+		&dev_buf->isp_daddr,
+		&dev_buf->scp_daddr);
+}
+
+int mtk_dip_pipe_queue_buffers(struct media_request *req,
+			       int initial)
+{
+	struct media_request_object *obj;
+	struct mtk_dip_pipe *dip_pipe;
+	struct mtk_dip_pipe_job_info *pipe_job_info = NULL;
+	int ret = 0;
+
+	list_for_each_entry(obj, &req->objects, list) {
+		struct vb2_buffer *vb;
+
+		if (vb2_request_object_is_buffer(obj)) {
+			struct mtk_dip_dev_buffer *buf;
+			struct mtk_dip_dev_buffer *dev_buf;
+			struct mtk_dip_video_device *node;
+
+			vb = container_of(obj, struct vb2_buffer, req_obj);
+			node = mtk_dip_vbq_to_node(vb->vb2_queue);
+			dip_pipe = vb2_get_drv_priv(vb->vb2_queue);
+			dev_buf = mtk_dip_vb2_buf_to_dev_buf(vb);
+			buf = dev_buf;
+
+			if (!pipe_job_info) {
+				pipe_job_info = mtk_dip_pipe_get_free_job_info
+					(dip_pipe);
+
+				if (!pipe_job_info)
+					goto FAILE_JOB_NOT_TRIGGER;
+
+				memset(pipe_job_info->buf_map, 0,
+				       sizeof(pipe_job_info->buf_map));
+				pipe_job_info->num_img_capture_bufs = 0;
+				pipe_job_info->num_img_output_bufs = 0;
+				pipe_job_info->num_meta_capture_bufs = 0;
+				pipe_job_info->num_meta_output_bufs = 0;
+			}
+
+			mtk_dip_dev_buf_fill_info(dip_pipe,
+						  buf);
+
+			mtk_dip_pipe_update_job_info(dip_pipe,
+						     pipe_job_info,
+						     node,
+						     buf);
+		}
+	}
+
+	if (!pipe_job_info)
+		return -EINVAL;
+
+	pipe_job_info->id =
+		mtk_dip_pipe_next_job_id(dip_pipe);
+
+	mtk_dip_pipe_debug_job(dip_pipe, pipe_job_info);
+
+	mutex_lock(&dip_pipe->lock);
+
+	if (!dip_pipe->streaming) {
+		dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+			"%s:%s:  stream is off, no hw enqueue triggered\n",
+			__func__, dip_pipe->desc->name);
+		mutex_unlock(&dip_pipe->lock);
+		return 0;
+	}
+
+	if (mtk_dip_pipe_process_pipe_job_info(dip_pipe, pipe_job_info)) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"%s:%s: can't start to run pipe job id(%d)\n",
+			__func__, dip_pipe->desc->name,
+			pipe_job_info->id);
+		mutex_unlock(&dip_pipe->lock);
+		goto FAILE_JOB_NOT_TRIGGER;
+	}
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s: trigger pipe job, id(%d)\n",
+		dip_pipe->desc->name,
+		dip_pipe->desc->id);
+
+	if (mtk_dip_pipe_job_start(dip_pipe, pipe_job_info)) {
+		mutex_unlock(&dip_pipe->lock);
+		goto FAILE_JOB_NOT_TRIGGER;
+	}
+
+	mutex_unlock(&dip_pipe->lock);
+
+	return 0;
+
+FAILE_JOB_NOT_TRIGGER:
+	if (initial)
+		return ret;
+
+	mtk_dip_pipe_job_finish(dip_pipe, pipe_job_info->id,
+				VB2_BUF_STATE_ERROR);
+
+	return -EINVAL;
+}
+
+int mtk_dip_pipe_release(struct mtk_dip_pipe *dip_pipe)
+{
+	mtk_dip_pipe_v4l2_unregister(dip_pipe);
+	v4l2_ctrl_handler_free(&dip_pipe->ctrl_handler);
+	mutex_destroy(&dip_pipe->lock);
+
+	return 0;
+}
+
+enum {
+	mtk_dip_pixel_mode_default = 0,
+	mtk_dip_pixel_mode_1, /* 1 pixel mode */
+	mtk_dip_pixel_mode_2, /* 2 pixel mode */
+	mtk_dip_pixel_mode_4, /* 4 pixel mode */
+	pixel_mode_num,
+};
+
+static __u32 get_pixel_byte_by_fmt(__u32 pix_fmt)
+{
+	switch (pix_fmt) {
+	case V4L2_PIX_FMT_MTISP_SBGGR10:
+	case V4L2_PIX_FMT_MTISP_SGBRG10:
+	case V4L2_PIX_FMT_MTISP_SGRBG10:
+	case V4L2_PIX_FMT_MTISP_SRGGB10:
+	case V4L2_PIX_FMT_MTISP_SBGGR10F:
+	case V4L2_PIX_FMT_MTISP_SGBRG10F:
+	case V4L2_PIX_FMT_MTISP_SGRBG10F:
+	case V4L2_PIX_FMT_MTISP_SRGGB10F:
+		return 10;
+	default:
+		return 0;
+	}
+}
+
+static __u32
+mtk_dip_pass1_align_main_size(__u32 size, unsigned int pix_mode)
+{
+	switch (pix_mode) {
+	case mtk_dip_pixel_mode_default:
+	case mtk_dip_pixel_mode_4:
+		return ALIGN(size, 8);
+	case mtk_dip_pixel_mode_2:
+		return ALIGN(size, 4);
+	case mtk_dip_pixel_mode_1:
+		return ALIGN(size, 2);
+	default:
+		break;
+	}
+	return 0;
+}
+
+static unsigned int
+mtk_dip_pass1_align_pack_size(__u32 size,
+			      unsigned int pix_mode,
+				     __u32 fmt)
+{
+	switch (pix_mode) {
+	case mtk_dip_pixel_mode_default:
+	case mtk_dip_pixel_mode_4:
+		return ALIGN(size, 16);
+	case mtk_dip_pixel_mode_2:
+		return ALIGN(size, 8);
+	case mtk_dip_pixel_mode_1:
+		if (fmt == V4L2_PIX_FMT_MTISP_SBGGR10F ||
+		    fmt == V4L2_PIX_FMT_MTISP_SGBRG10F ||
+		    fmt == V4L2_PIX_FMT_MTISP_SGRBG10F ||
+		    fmt == V4L2_PIX_FMT_MTISP_SRGGB10F)
+			return ALIGN(size, 4);
+		else
+			return ALIGN(size, 8);
+	default:
+		return ALIGN(size, 16);
+	}
+	return 0;
+}
+
+static __u32
+mtk_dip_pass1_cal_main_stride(__u32 width,
+			      __u32 pix_fmt, __u32 pix_mode)
+{
+	__u32 stride;
+	__u32 pixel_byte = get_pixel_byte_by_fmt(pix_fmt);
+
+	width = ALIGN(width, 4);
+	stride = ALIGN(DIV_ROUND_UP(width * pixel_byte, 8), 2);
+	/* expand stride, instead of shrink width */
+	stride = mtk_dip_pass1_align_main_size(stride,
+					       pix_mode);
+
+	pr_debug("main width:%d, pix_mode:%d, stride:%d\n",
+		 width, pix_mode, stride);
+	return stride;
+}
+
+static __u32
+mtk_dip_pass1_cal_pack_stride(__u32 width,
+			      __u32 pix_fmt, __u32 pix_mode)
+{
+	__u32 stride;
+	__u32 pixel_byte = get_pixel_byte_by_fmt(pix_fmt);
+
+	width = ALIGN(width, 4);
+	stride = DIV_ROUND_UP(width * 3, 2);
+	stride = DIV_ROUND_UP(stride * pixel_byte, 8);
+	/* expand stride, instead of shrink width */
+	stride = mtk_dip_pass1_align_pack_size(stride,
+					       pix_mode,
+						      pix_fmt);
+
+	pr_debug("packed width:%d, pix_mode:%d, stride:%d\n",
+		 width, pix_mode, stride);
+
+	return stride;
+}
+
+static	u32 fmts_pass1_main[] = {
+	V4L2_PIX_FMT_MTISP_SBGGR10,
+	V4L2_PIX_FMT_MTISP_SGBRG10,
+	V4L2_PIX_FMT_MTISP_SGRBG10,
+	V4L2_PIX_FMT_MTISP_SRGGB10,
+};
+
+static u32 fmts_pass1_pack[] = {
+	V4L2_PIX_FMT_MTISP_SBGGR10F,
+	V4L2_PIX_FMT_MTISP_SGBRG10F,
+	V4L2_PIX_FMT_MTISP_SGRBG10F,
+	V4L2_PIX_FMT_MTISP_SRGGB10F,
+};
+
+static int is_stride_need_to_align(u32 format, u32 *need_aligned_fmts,
+				   int length)
+{
+	int i;
+
+	for (i = 0; i < length; i++) {
+		if (format == need_aligned_fmts[i])
+			return true;
+	}
+
+	return false;
+}
+
+static void set_img_fmt(struct v4l2_pix_format_mplane *mfmt_to_fill,
+			struct mtk_dip_dev_format *dev_fmt)
+{
+	int i;
+
+	mfmt_to_fill->pixelformat = dev_fmt->fmt.img.pixelformat;
+	mfmt_to_fill->num_planes = dev_fmt->fmt.img.num_planes;
+	mfmt_to_fill->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	mfmt_to_fill->quantization = V4L2_QUANTIZATION_DEFAULT;
+	mfmt_to_fill->colorspace = dev_fmt->fmt.img.colorspace;
+
+	memset(mfmt_to_fill->reserved, 0, sizeof(mfmt_to_fill->reserved));
+
+	pr_debug("%s: Fmt(%d),w(%d),h(%d),f(%d)\n",
+		 __func__,
+		 mfmt_to_fill->pixelformat,
+		 mfmt_to_fill->width,
+		 mfmt_to_fill->height,
+		 mfmt_to_fill->field);
+
+	for (i = 0 ; i < mfmt_to_fill->num_planes; ++i) {
+		int bpl;
+		int sizeimage;
+
+		if (is_stride_need_to_align(mfmt_to_fill->pixelformat,
+					    fmts_pass1_main,
+					    ARRAY_SIZE(fmts_pass1_main))) {
+			bpl = mtk_dip_pass1_cal_main_stride
+				(mfmt_to_fill->width,
+				 mfmt_to_fill->pixelformat,
+				 mtk_dip_pixel_mode_1);
+			bpl = ALIGN(bpl, 4);
+		} else if (is_stride_need_to_align
+				(mfmt_to_fill->pixelformat, fmts_pass1_pack,
+				 ARRAY_SIZE(fmts_pass1_pack))) {
+			bpl = mtk_dip_pass1_cal_pack_stride
+				(mfmt_to_fill->width,
+				 mfmt_to_fill->pixelformat,
+				 mtk_dip_pixel_mode_1);
+			bpl = ALIGN(bpl, 4);
+
+		} else {
+			bpl = (mfmt_to_fill->width *
+				dev_fmt->fmt.img.row_depth[i]) / 8;
+		}
+
+		sizeimage = (mfmt_to_fill->width * mfmt_to_fill->height *
+			     dev_fmt->fmt.img.depth[i]) / 8;
+		mfmt_to_fill->plane_fmt[i].bytesperline = bpl;
+		mfmt_to_fill->plane_fmt[i].sizeimage = sizeimage;
+
+		memset(mfmt_to_fill->plane_fmt[i].reserved,
+		       0, sizeof(mfmt_to_fill->plane_fmt[i].reserved));
+
+		pr_debug("plane(%d):bpl(%d),sizeimage(%u)\n",
+			 i, bpl,
+			 mfmt_to_fill->plane_fmt[i].sizeimage);
+	}
+}
+
+static void set_meta_fmt(struct v4l2_meta_format *metafmt_to_fill,
+			 struct mtk_dip_dev_format *dev_fmt)
+{
+	metafmt_to_fill->dataformat = dev_fmt->fmt.meta.dataformat;
+
+	if (dev_fmt->fmt.meta.max_buffer_size <= 0) {
+		pr_debug("Invalid meta buf size(%u), use default(%u)\n",
+			 dev_fmt->fmt.meta.max_buffer_size,
+			 MTK_DIP_DEV_META_BUF_DEFAULT_SIZE);
+		metafmt_to_fill->buffersize = MTK_DIP_DEV_META_BUF_DEFAULT_SIZE;
+	} else {
+		pr_debug("Use meta size(%u)\n",
+			 dev_fmt->fmt.meta.max_buffer_size);
+		metafmt_to_fill->buffersize = dev_fmt->fmt.meta.max_buffer_size;
+	}
+}
+
+void mtk_dip_pipe_load_default_fmt(struct mtk_dip_pipe *dip_pipe,
+				   struct mtk_dip_video_device *node,
+				   struct v4l2_format *fmt_to_fill)
+{
+	struct mtk_dip_dev_format *dev_fmt;
+	struct mtk_dip_video_device_desc *desc = node->desc;
+
+	if (desc->num_fmts == 0) {
+		pr_err("%s:%s: desc->num_fmts is 0, no format support list\n",
+		       __func__, desc->name);
+		return;
+	}
+
+	if (desc->default_fmt_idx >= desc->num_fmts) {
+		pr_debug("%s:%s: invalid idx(%d), must < num_fmts(%d)\n",
+			 __func__, desc->name, desc->default_fmt_idx,
+			desc->num_fmts);
+		desc->default_fmt_idx = 0;
+	}
+
+	dev_fmt	= &desc->fmts[desc->default_fmt_idx];
+	fmt_to_fill->type = desc->buf_type;
+	if (mtk_dip_buf_is_meta(desc->buf_type)) {
+		set_meta_fmt(&fmt_to_fill->fmt.meta, dev_fmt);
+	} else {
+		fmt_to_fill->fmt.pix_mp.width = desc->default_width;
+		fmt_to_fill->fmt.pix_mp.height = desc->default_height;
+		fmt_to_fill->fmt.pix_mp.field = V4L2_FIELD_NONE;
+
+		set_img_fmt(&fmt_to_fill->fmt.pix_mp, dev_fmt);
+	}
+}
+
+struct mtk_dip_dev_format *
+mtk_dip_pipe_find_fmt(struct mtk_dip_pipe *dip_pipe,
+		      struct mtk_dip_video_device *node,
+		      u32 format)
+{
+	int i;
+	struct mtk_dip_dev_format *dev_fmt;
+
+	struct mtk_dip_video_device_desc *desc = node->desc;
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev, "fmt to find(%x)\n", format);
+
+	for (i = 0; i < desc->num_fmts; i++) {
+		dev_fmt = &desc->fmts[i];
+		if (!mtk_dip_buf_is_meta(desc->buf_type)) {
+			if (dev_fmt->fmt.img.pixelformat == format)
+				return dev_fmt;
+		} else {
+			if (dev_fmt->fmt.meta.dataformat == format)
+				return dev_fmt;
+		}
+	}
+
+	return NULL;
+}
+
+int mtk_dip_pipe_set_meta_fmt(struct mtk_dip_pipe *dip_pipe,
+			      struct mtk_dip_video_device *node,
+			      struct v4l2_meta_format *user_fmt,
+			      struct v4l2_meta_format *node_fmt)
+{
+	struct mtk_dip_dev_format *dev_fmt;
+
+	if (!user_fmt || !node_fmt)
+		return -EINVAL;
+
+	dev_fmt = mtk_dip_pipe_find_fmt(dip_pipe, node,
+					user_fmt->dataformat);
+
+	if (!dev_fmt)
+		return -EINVAL;
+
+	node->dev_q.dev_fmt = dev_fmt;
+	set_meta_fmt(node_fmt, dev_fmt);
+	*user_fmt = *node_fmt;
+
+	return 0;
+}
+
+int mtk_dip_pipe_set_img_fmt(struct mtk_dip_pipe *dip_pipe,
+			     struct mtk_dip_video_device *node,
+			     struct v4l2_pix_format_mplane *user_fmt,
+			     struct v4l2_pix_format_mplane *dest_fmt)
+{
+	struct mtk_dip_dev_format *dev_fmt;
+
+	if (!user_fmt || !dest_fmt)
+		return -EINVAL;
+
+	dev_fmt = mtk_dip_pipe_find_fmt(dip_pipe, node,
+					user_fmt->pixelformat);
+
+	if (!dev_fmt) {
+		pr_debug("%s:%s:%s: dev_fmt(%d) not found\n",
+			 __func__, dip_pipe->desc->name,
+			 node->desc->name, user_fmt->pixelformat);
+		return -EINVAL;
+	}
+
+	node->dev_q.dev_fmt = dev_fmt;
+	dest_fmt->width = user_fmt->width;
+	dest_fmt->height = user_fmt->height;
+	dest_fmt->field = V4L2_FIELD_NONE;
+
+	set_img_fmt(dest_fmt, dev_fmt);
+
+	return 0;
+}
+
+int mtk_dip_pipe_streamon(struct mtk_dip_pipe *dip_pipe)
+{
+	int ret;
+	struct mtk_dip_dev *dip_dev;
+
+	if (!dip_pipe)
+		return -EINVAL;
+
+	dip_dev = dev_get_drvdata(&dip_pipe->dip_dev->pdev->dev);
+
+	mutex_lock(&dip_pipe->lock);
+
+	ret = mtk_dip_hw_streamon(&dip_dev->dip_hw,
+				  dip_pipe->desc->id);
+
+	if (ret) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"%s:%s:%d: failed to start hw\n",
+			__func__, dip_pipe->desc->name,
+			dip_pipe->desc->id);
+		mutex_unlock(&dip_pipe->lock);
+		return -EBUSY;
+	}
+
+	dip_pipe->streaming = 1;
+	mutex_unlock(&dip_pipe->lock);
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s:%s:%d: start hw\n",
+		__func__, dip_pipe->desc->name,
+		dip_pipe->desc->id);
+
+	return ret;
+}
+
+int mtk_dip_pipe_streamoff(struct mtk_dip_pipe *dip_pipe)
+{
+	int ret;
+	struct mtk_dip_dev *dip_dev;
+
+	if (!dip_pipe)
+		return -EINVAL;
+
+	dip_dev = dev_get_drvdata(&dip_pipe->dip_dev->pdev->dev);
+
+	mutex_lock(&dip_pipe->lock);
+
+	ret = mtk_dip_hw_streamoff(&dip_dev->dip_hw,
+				   dip_pipe->desc->id);
+
+	if (ret) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"%s:%s:%d: failed to stop hw\n",
+			__func__, dip_pipe->desc->name,
+			dip_pipe->desc->id);
+		mutex_unlock(&dip_pipe->lock);
+		return -EBUSY;
+	}
+
+	dip_pipe->streaming = 0;
+	mutex_unlock(&dip_pipe->lock);
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s:%s:%d: stop hw\n",
+		__func__, dip_pipe->desc->name,
+		dip_pipe->desc->id);
+
+	return 0;
+}
+
+static enum mdp_ycbcr_profile
+map_ycbcr_prof_mplane(struct v4l2_pix_format_mplane *pix_mp,
+		      u32 mdp_color)
+{
+	if (MDP_COLOR_IS_RGB(mdp_color))
+		return MDP_YCBCR_PROFILE_FULL_BT601;
+
+	switch (pix_mp->colorspace) {
+	case V4L2_COLORSPACE_JPEG:
+		return MDP_YCBCR_PROFILE_JPEG;
+	case V4L2_COLORSPACE_REC709:
+	case V4L2_COLORSPACE_DCI_P3:
+		if (pix_mp->quantization == V4L2_QUANTIZATION_FULL_RANGE)
+			return MDP_YCBCR_PROFILE_FULL_BT709;
+		return MDP_YCBCR_PROFILE_BT709;
+	case V4L2_COLORSPACE_BT2020:
+		if (pix_mp->quantization == V4L2_QUANTIZATION_FULL_RANGE)
+			return MDP_YCBCR_PROFILE_FULL_BT2020;
+		return MDP_YCBCR_PROFILE_BT2020;
+	}
+	/* V4L2_COLORSPACE_SRGB or else */
+	if (pix_mp->quantization == V4L2_QUANTIZATION_FULL_RANGE)
+		return MDP_YCBCR_PROFILE_FULL_BT601;
+	return MDP_YCBCR_PROFILE_BT601;
+}
+
+/* Stride that is accepted by MDP HW */
+static u32 dip_mdp_fmt_get_stride(const struct mtk_dip_dev_mdp_format *fmt,
+				  u32 bytesperline,
+				  unsigned int plane)
+{
+	enum mdp_color c = fmt->mdp_color;
+	u32 stride;
+
+	stride = (bytesperline * MDP_COLOR_BITS_PER_PIXEL(c))
+		/ fmt->row_depth[0];
+	if (plane == 0)
+		return stride;
+	if (plane < MDP_COLOR_GET_PLANE_COUNT(c)) {
+		if (MDP_COLOR_IS_BLOCK_MODE(c))
+			stride = stride / 2;
+		return stride;
+	}
+	return 0;
+}
+
+/* Stride that is accepted by MDP HW of format with contiguous planes */
+static u32
+dip_mdp_fmt_get_stride_contig(const struct mtk_dip_dev_mdp_format *fmt,
+			      u32 pix_stride,
+			      unsigned int plane)
+{
+	enum mdp_color c = fmt->mdp_color;
+	u32 stride = pix_stride;
+
+	if (plane == 0)
+		return stride;
+	if (plane < MDP_COLOR_GET_PLANE_COUNT(c)) {
+		stride = stride >> MDP_COLOR_GET_H_SUBSAMPLE(c);
+		if (MDP_COLOR_IS_UV_COPLANE(c) && !MDP_COLOR_IS_BLOCK_MODE(c))
+			stride = stride * 2;
+		return stride;
+	}
+	return 0;
+}
+
+/* Plane size that is accepted by MDP HW */
+static u32
+dip_mdp_fmt_get_plane_size(const struct mtk_dip_dev_mdp_format *fmt,
+			   u32 stride, u32 height,
+			   unsigned int plane)
+{
+	enum mdp_color c = fmt->mdp_color;
+	u32 bytesperline;
+
+	bytesperline = (stride * fmt->row_depth[0])
+		/ MDP_COLOR_BITS_PER_PIXEL(c);
+	if (plane == 0)
+		return bytesperline * height;
+	if (plane < MDP_COLOR_GET_PLANE_COUNT(c)) {
+		height = height >> MDP_COLOR_GET_V_SUBSAMPLE(c);
+		if (MDP_COLOR_IS_BLOCK_MODE(c))
+			bytesperline = bytesperline * 2;
+		return bytesperline * height;
+	}
+	return 0;
+}
+
+static int is_contig_mp_buffer(struct mtk_dip_dev_buffer *dev_buf)
+{
+	if (MDP_COLOR_GET_PLANE_COUNT(dev_buf->dev_fmt->fmt.img.mdp_color)
+	    == 1)
+		return 0;
+	else
+		return 1;
+}
+
+static int fill_ipi_img_param_mp(struct mtk_dip_pipe *dip_pipe,
+				 struct img_image_buffer *b,
+				 struct mtk_dip_dev_buffer *dev_buf,
+				 char *buf_name)
+{
+	struct v4l2_pix_format_mplane *pix_mp;
+	struct mtk_dip_dev_mdp_format *mdp_fmt;
+	unsigned int i;
+	unsigned int total_plane_size = 0;
+
+	if (!dev_buf || !dev_buf->dev_fmt) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"%s: %s's dev format not set\n",
+			__func__, buf_name);
+		return -EINVAL;
+	}
+
+	pix_mp = &dev_buf->fmt.fmt.pix_mp;
+	mdp_fmt = &dev_buf->dev_fmt->fmt.img;
+
+	b->format.colorformat = dev_buf->dev_fmt->fmt.img.mdp_color;
+	b->format.width = dev_buf->fmt.fmt.pix_mp.width;
+	b->format.height = dev_buf->fmt.fmt.pix_mp.height;
+	b->format.ycbcr_prof =
+		map_ycbcr_prof_mplane(pix_mp,
+				      dev_buf->dev_fmt->fmt.img.mdp_color);
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s: buf(%s), IPI: w(%d),h(%d),c(0x%x)\n",
+		dip_pipe->desc->name,
+		buf_name,
+		b->format.width,
+		b->format.height,
+		b->format.colorformat);
+
+	for (i = 0; i < pix_mp->num_planes; ++i) {
+		u32 stride =
+			dip_mdp_fmt_get_stride
+			(mdp_fmt, pix_mp->plane_fmt[i].bytesperline, i);
+
+		b->format.plane_fmt[i].stride = stride;
+		b->format.plane_fmt[i].size =
+			dip_mdp_fmt_get_plane_size(mdp_fmt,
+						   stride,
+						   pix_mp->height, i);
+		b->iova[i] = dev_buf->isp_daddr;
+		dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+			"Contiguous-mp-buf:plane(%i),stride(%d),size(%d),iova(%llx)",
+			i,
+			b->format.plane_fmt[i].stride,
+			b->format.plane_fmt[i].size,
+			b->iova[i]);
+		total_plane_size = b->format.plane_fmt[i].size;
+	}
+
+	for (; i < MDP_COLOR_GET_PLANE_COUNT(b->format.colorformat); ++i) {
+		u32 stride =
+			dip_mdp_fmt_get_stride_contig
+			(mdp_fmt, b->format.plane_fmt[0].stride, i);
+
+		b->format.plane_fmt[i].stride = stride;
+		b->format.plane_fmt[i].size =
+			dip_mdp_fmt_get_plane_size(mdp_fmt, stride,
+						   pix_mp->height, i);
+		b->iova[i] = b->iova[i - 1] + b->format.plane_fmt[i - 1].size;
+		dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+			"Contiguous-mp-buf:plane(%i),stride(%d),size(%d),iova(%llx)",
+			i,
+			b->format.plane_fmt[i].stride,
+			b->format.plane_fmt[i].size,
+			b->iova[i]);
+		total_plane_size += b->format.plane_fmt[i].size;
+	}
+
+	b->usage = dev_buf->buffer_usage;
+	if (b->usage == 0xf) {
+		dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+			"Invalid usage as 0xf for buf(%s)\n", buf_name);
+		b->usage = 0;
+	}
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"Contiguous-mp-buf(%s),v4l2-sizeimage(%d),total-plane-size(%d)\n",
+		buf_name,
+		pix_mp->plane_fmt[0].sizeimage,
+		total_plane_size);
+
+	return 0;
+}
+
+static int fill_ipi_img_param(struct mtk_dip_pipe *dip_pipe,
+			      struct img_image_buffer *img,
+			      struct mtk_dip_dev_buffer *dev_buf,
+			      char *buf_name)
+{
+	int bpl;
+
+	img->format.width = dev_buf->fmt.fmt.pix_mp.width;
+	img->format.height = dev_buf->fmt.fmt.pix_mp.height;
+
+	if (dev_buf && dev_buf->dev_fmt) {
+		img->format.colorformat =
+			dev_buf->dev_fmt->fmt.img.mdp_color;
+	} else {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"%s: %s's dev format not set\n",
+			__func__, buf_name);
+		return -EINVAL;
+	}
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s: buf(%s) IPI: w(%d),h(%d),c(0x%x)\n",
+		dip_pipe->desc->name,
+		buf_name,
+		img->format.width,
+		img->format.height,
+		img->format.colorformat);
+
+	img->format.plane_fmt[0].size =
+			dev_buf->fmt.fmt.pix_mp.plane_fmt[0].sizeimage;
+
+	if (is_stride_need_to_align(dev_buf->fmt.fmt.pix_mp.pixelformat,
+				    fmts_pass1_main,
+				    ARRAY_SIZE(fmts_pass1_main))) {
+		bpl = mtk_dip_pass1_cal_main_stride
+			(img->format.width,
+			 dev_buf->fmt.fmt.pix_mp.pixelformat,
+			 mtk_dip_pixel_mode_1);
+		bpl = ALIGN(bpl, 4);
+	} else if (is_stride_need_to_align(dev_buf->fmt.fmt.pix_mp.pixelformat,
+					   fmts_pass1_pack,
+					   ARRAY_SIZE(fmts_pass1_pack))) {
+		bpl = mtk_dip_pass1_cal_pack_stride
+			(img->format.width,
+			 dev_buf->fmt.fmt.pix_mp.pixelformat,
+			 mtk_dip_pixel_mode_1);
+		bpl = ALIGN(bpl, 4);
+	} else {
+		bpl = dev_buf->fmt.fmt.pix_mp.plane_fmt[0].bytesperline;
+	}
+
+	img->format.plane_fmt[0].stride = bpl;
+	img->iova[0] = dev_buf->isp_daddr;
+	img->usage = dev_buf->buffer_usage;
+	if (img->usage == 0xf) {
+		dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+			"Invalid usage as 0xf for img(%s)\n", buf_name);
+		img->usage = 0;
+	}
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"size(%d), stride(%d),ycbcr(%d),iova(%p),u(%d)\n",
+		img->format.plane_fmt[0].size,
+		img->format.plane_fmt[0].stride,
+		img->format.ycbcr_prof,
+		img->iova[0],
+		img->usage);
+
+	return 0;
+}
+
+static int fill_input_ipi_param(struct mtk_dip_pipe *dip_pipe,
+				struct img_input *iin,
+				struct mtk_dip_dev_buffer *dev_buf,
+				char *buf_name)
+{
+	struct img_image_buffer *img = &iin->buffer;
+
+	/* Will map the vale with V4L2 color space in the future */
+	img->format.ycbcr_prof = 1;
+	if (is_contig_mp_buffer(dev_buf))
+		return fill_ipi_img_param_mp(dip_pipe, img, dev_buf,
+					     buf_name);
+	else
+		return fill_ipi_img_param(dip_pipe, img, dev_buf,
+					  buf_name);
+}
+
+static int fill_output_ipi_param(struct mtk_dip_pipe *dip_pipe,
+				 struct img_output *iout,
+				 struct mtk_dip_dev_buffer *dev_buf_out,
+				 struct mtk_dip_dev_buffer *dev_buf_in,
+				 char *buf_name)
+{
+	int ret;
+	struct img_image_buffer *img = &iout->buffer;
+
+	img->format.ycbcr_prof = 0;
+
+	if (is_contig_mp_buffer(dev_buf_out))
+		ret = fill_ipi_img_param_mp(dip_pipe, img, dev_buf_out,
+					    buf_name);
+	else
+		ret = fill_ipi_img_param(dip_pipe, img, dev_buf_out,
+					 buf_name);
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s: buf(%s):img_output(%p),dev_buf_out(%p),dev_buf_in(%p)\n",
+		dip_pipe->desc->name,
+		buf_name, iout, dev_buf_out, dev_buf_in);
+
+	iout->crop.left = 0;
+	iout->crop.top = 0;
+	iout->crop.width = dev_buf_in->fmt.fmt.pix_mp.width;
+	iout->crop.height = dev_buf_in->fmt.fmt.pix_mp.height;
+	iout->crop.left_subpix = 0;
+	iout->crop.top_subpix = 0;
+	iout->crop.width_subpix = 0;
+	iout->crop.height_subpix = 0;
+	iout->rotation = 0;
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s: buf(%s) IPI-ext:c_l(%d),c_t(%d),c_w(%d),c_h(%d)\n",
+		dip_pipe->desc->name,
+		buf_name,
+		iout->crop.left,
+		iout->crop.top,
+		iout->crop.width,
+		iout->crop.height);
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"c_ls(%d),c_ts(%d),c_ws(%d),c_hs(%d),rot(%d)\n",
+		iout->crop.left_subpix,
+		iout->crop.top_subpix,
+		iout->crop.width_subpix,
+		iout->crop.height_subpix,
+		iout->rotation);
+
+	return ret;
+}
+
+static u32 dip_to_fixed(u32 *r, struct v4l2_fract *f)
+{
+	u32 q;
+
+	if (f->denominator == 0) {
+		*r = 0;
+		return 0;
+	}
+
+	q = f->numerator / f->denominator;
+	*r = (((u64)f->numerator - q * f->denominator) << IMG_SUBPIXEL_SHIFT)
+		/ f->denominator;
+	return q;
+}
+
+static void dip_set_src_crop(struct img_crop *c, struct mtk_dip_crop *crop)
+{
+	c->left = crop->c.left
+		+ dip_to_fixed(&c->left_subpix, &crop->left_subpix);
+	c->top = crop->c.top
+		+ dip_to_fixed(&c->top_subpix, &crop->top_subpix);
+	c->width = crop->c.width
+		+ dip_to_fixed(&c->width_subpix, &crop->width_subpix);
+	c->height = crop->c.height
+		+ dip_to_fixed(&c->height_subpix, &crop->height_subpix);
+}
+
+static void dip_set_orientation(struct img_output *out,
+				s32 rotation, bool hflip, bool vflip)
+{
+	u8 flip = 0;
+
+	if (hflip)
+		flip ^= 1;
+	if (vflip) {
+		/*
+		 * A vertical flip is equivalent to
+		 * a 180-degree rotation with a horizontal flip
+		 */
+		rotation += 180;
+		flip ^= 1;
+	}
+
+	out->rotation = rotation % 360;
+	if (flip != 0)
+		out->flags |= IMG_CTRL_FLAG_HFLIP;
+	else
+		out->flags &= ~IMG_CTRL_FLAG_HFLIP;
+}
+
+static void dip_set_crop_config(struct mtk_dip_dev *dip_dev,
+				struct mtk_dip_dev_buffer *dev_buf_out,
+				struct img_output *iout, char *buf_name)
+{
+	iout->buffer.format.width = dev_buf_out->compose.width;
+	iout->buffer.format.height = dev_buf_out->compose.height;
+
+	dip_set_src_crop(&iout->crop, &dev_buf_out->crop);
+
+	dev_dbg(&dip_dev->pdev->dev,
+		"IPI-ext(%s):c_l(%d),c_t(%d),c_w(%d),c_h(%d)\n",
+		buf_name, iout->crop.left, iout->crop.top,
+		iout->crop.width,
+		iout->crop.height);
+
+	dev_dbg(&dip_dev->pdev->dev,
+		"c_ls(%d),c_ts(%d),c_ws(%d),c_hs(%d)\n",
+		iout->crop.left_subpix,
+		iout->crop.top_subpix,
+		iout->crop.width_subpix, iout->crop.height_subpix);
+}
+
+static void dip_set_rotate_config(struct mtk_dip_dev *dev_ctx,
+				  struct mtk_dip_dev_buffer *dev_buf_in,
+				  struct mtk_dip_dev_buffer *dev_buf_out,
+				  struct img_output *iout, char *buf_name)
+{
+	dip_set_orientation(iout, dev_buf_out->rotation,
+			    dev_buf_out->hflip, dev_buf_out->vflip);
+
+	dev_dbg(&dev_ctx->pdev->dev,
+		"IPI-ext(%s)r(%d)\n", buf_name, iout->rotation);
+}
+
+int mtk_dip_pipe_job_start(struct mtk_dip_pipe *dip_pipe,
+			   struct mtk_dip_pipe_job_info *pipe_job_info)
+{
+	struct platform_device *pdev = dip_pipe->dip_dev->pdev;
+	int ret;
+	int out_img_buf_idx;
+	int in_img_buf_idx;
+	struct img_ipi_frameparam dip_param;
+	struct mtk_dip_dev_buffer *dev_buf_in;
+	struct mtk_dip_dev_buffer *dev_buf_out;
+	struct mtk_dip_dev_buffer *dev_buf_tuning;
+
+	if (!pipe_job_info) {
+		dev_err(&pdev->dev,
+			"pipe_job_info(%p) in start can't be NULL\n",
+			pipe_job_info);
+		return -EINVAL;
+	}
+
+	/* We need RAW and at least MDP0 or MDP 1 buffer */
+	if (!pipe_job_info->buf_map[MTK_DIP_VIDEO_NODE_ID_RAW_OUT] ||
+	    (!pipe_job_info->buf_map[MTK_DIP_VIDEO_NODE_ID_MDP0_CAPTURE] &&
+		 !pipe_job_info->buf_map[MTK_DIP_VIDEO_NODE_ID_MDP1_CAPTURE] &&
+		 !pipe_job_info->buf_map[MTK_DIP_VIDEO_NODE_ID_IMG3_CAPTURE])){
+		struct mtk_dip_dev_buffer **map = pipe_job_info->buf_map;
+
+		dev_dbg(&pdev->dev,
+			"can't trigger job: raw(%p), mdp0(%p), mdp1(%p)\n",
+			map[MTK_DIP_VIDEO_NODE_ID_RAW_OUT],
+			map[MTK_DIP_VIDEO_NODE_ID_MDP0_CAPTURE],
+			map[MTK_DIP_VIDEO_NODE_ID_MDP1_CAPTURE]);
+		return -EINVAL;
+	}
+
+	dev_dbg(&pdev->dev,
+		"%s:%s: pipe-job id(%d)\n",
+		__func__, dip_pipe->desc->name,
+		pipe_job_info->id);
+
+	/* Fill ipi params for DIP driver */
+	memset(&dip_param, 0, sizeof(struct img_ipi_frameparam));
+
+	dip_param.index = pipe_job_info->id;
+	dip_param.type = STREAM_ISP_IC;
+
+	/* Tuning buffer */
+	dev_buf_tuning =
+		pipe_job_info->buf_map[MTK_DIP_VIDEO_NODE_ID_TUNING_OUT];
+	if (dev_buf_tuning) {
+		dev_dbg(&pdev->dev,
+			"Tuning buf queued: scp_daddr(%pad),va(%p),isp_daddr(%pad)\n",
+			&dev_buf_tuning->scp_daddr,
+			dev_buf_tuning->vaddr,
+			&dev_buf_tuning->isp_daddr);
+		dip_param.tuning_data.pa = (uint32_t)dev_buf_tuning->scp_daddr;
+		dip_param.tuning_data.va = (uint64_t)dev_buf_tuning->vaddr;
+		dip_param.tuning_data.iova =
+			(uint32_t)dev_buf_tuning->isp_daddr;
+	} else {
+		dev_dbg(&pdev->dev,
+			"Doesn't enqueued tuning buffer, by-pass\n");
+	dip_param.tuning_data.pa = 0;
+	dip_param.tuning_data.va = 0;
+	dip_param.tuning_data.iova = 0;
+	}
+
+	/* Raw-in buffer */
+	in_img_buf_idx = 0;
+	dev_buf_in =
+		pipe_job_info->buf_map[MTK_DIP_VIDEO_NODE_ID_RAW_OUT];
+	if (dev_buf_in) {
+		struct img_input *iin = &dip_param.inputs[in_img_buf_idx];
+
+		fill_input_ipi_param(dip_pipe, iin, dev_buf_in, "RAW");
+		in_img_buf_idx++;
+	}
+
+	out_img_buf_idx = 0;
+
+	/* MDP 0 buffer */
+	dev_buf_out =
+		pipe_job_info->buf_map[MTK_DIP_VIDEO_NODE_ID_MDP0_CAPTURE];
+	if (dev_buf_out) {
+		struct img_output *iout = &dip_param.outputs[out_img_buf_idx];
+
+		fill_output_ipi_param(dip_pipe, iout, dev_buf_out,
+				      dev_buf_in, "MDP0");
+		dip_set_crop_config(dip_pipe->dip_dev, dev_buf_out, iout,
+				    "MPD0");
+		dip_set_rotate_config(dip_pipe->dip_dev, dev_buf_in,
+				      dev_buf_out, iout, "MPD0");
+		out_img_buf_idx++;
+	}
+
+	/* MDP 1 buffer */
+	dev_buf_out =
+		pipe_job_info->buf_map[MTK_DIP_VIDEO_NODE_ID_MDP1_CAPTURE];
+	if (dev_buf_out) {
+		struct img_output *iout = &dip_param.outputs[out_img_buf_idx];
+
+		fill_output_ipi_param(dip_pipe, iout, dev_buf_out,
+				      dev_buf_in, "MDP1");
+		dip_set_crop_config(dip_pipe->dip_dev, dev_buf_out, iout,
+				    "MPD1");
+		out_img_buf_idx++;
+	}
+
+	/* IMG2O buffer */
+	dev_buf_out =
+		pipe_job_info->buf_map[MTK_DIP_VIDEO_NODE_ID_IMG2_CAPTURE];
+	if (dev_buf_out) {
+		struct img_output *iout = &dip_param.outputs[out_img_buf_idx];
+
+		fill_output_ipi_param(dip_pipe, iout, dev_buf_out,
+				      dev_buf_in,  "IMG2O");
+		out_img_buf_idx++;
+	}
+
+	/* IMG3O buffer */
+	dev_buf_out =
+		pipe_job_info->buf_map[MTK_DIP_VIDEO_NODE_ID_IMG3_CAPTURE];
+	if (dev_buf_out) {
+		struct img_output *iout = &dip_param.outputs[out_img_buf_idx];
+
+		fill_output_ipi_param(dip_pipe, iout, dev_buf_out,
+				      dev_buf_in,  "IMG3O");
+		out_img_buf_idx++;
+	}
+
+	/* VIPI buffer */
+	dev_buf_in =
+		pipe_job_info->buf_map[MTK_DIP_VIDEO_NODE_ID_VIPI_OUT];
+	if (dev_buf_in) {
+		struct img_input *iin = &dip_param.inputs[in_img_buf_idx];
+
+		fill_input_ipi_param(dip_pipe, iin, dev_buf_in, "VIPI");
+		in_img_buf_idx++;
+	}
+
+	/* LCEI buffer */
+	dev_buf_in =
+		pipe_job_info->buf_map[MTK_DIP_VIDEO_NODE_ID_LCEI_OUT];
+	if (dev_buf_in) {
+		struct img_input *iin = &dip_param.inputs[in_img_buf_idx];
+
+		fill_input_ipi_param(dip_pipe, iin, dev_buf_in, "LCEI");
+		in_img_buf_idx++;
+	}
+
+	dip_param.num_outputs = out_img_buf_idx;
+	dip_param.num_inputs = in_img_buf_idx;
+
+	dev_dbg(&pdev->dev, "%s:%s: dip frame buf(frame=%d), img-in(%d), img-out(%d):\n",
+		__func__,
+		dip_pipe->desc->name,
+		pipe_job_info->id,
+		dip_param.num_inputs,
+		dip_param.num_outputs);
+
+	ret = mtk_dip_hw_enqueue(&dip_pipe->dip_dev->dip_hw, &dip_param);
+
+	if (ret) {
+		dev_dbg(&pdev->dev,
+			"%s:%s: enqueue to HW failed(%d)\n",
+			 __func__, dip_pipe->desc->name, ret);
+		return -EBUSY;
+	}
+
+	return ret;
+}
diff --git a/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-dev.h b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-dev.h
new file mode 100644
index 000000000000..c55e13d8e5c2
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-dev.h
@@ -0,0 +1,338 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _MTK_DIP_DEV_H_
+#define _MTK_DIP_DEV_H_
+
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <linux/videodev2.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-v4l2.h>
+
+#include "mtk_dip-hw.h"
+#include "mtk_dip-smem.h"
+
+#define MTK_DIP_PIPE_ID_PREVIEW				0
+#define MTK_DIP_PIPE_ID_CAPTURE				1
+#define MTK_DIP_PIPE_ID_REPROCESS			2
+#define MTK_DIP_PIPE_ID_TOTAL_NUM			3
+
+#define MTK_DIP_VIDEO_NODE_ID_RAW_OUT			0
+#define MTK_DIP_VIDEO_NODE_ID_TUNING_OUT		1
+#define MTK_DIP_VIDEO_NODE_ID_VIPI_OUT			2
+#define MTK_DIP_VIDEO_NODE_ID_LCEI_OUT			3
+#define MTK_DIP_VIDEO_NODE_ID_OUT_TOTAL_NUM		4
+
+#define MTK_DIP_VIDEO_NODE_ID_MDP0_CAPTURE		4
+#define MTK_DIP_VIDEO_NODE_ID_MDP1_CAPTURE		5
+#define MTK_DIP_VIDEO_NODE_ID_IMG2_CAPTURE		6
+#define MTK_DIP_VIDEO_NODE_ID_IMG3_CAPTURE		7
+#define MTK_DIP_VIDEO_NODE_ID_CAPTURE_TOTAL_NUM		4
+#define MTK_DIP_VIDEO_NODE_ID_TOTAL_NUM \
+	(MTK_DIP_VIDEO_NODE_ID_OUT_TOTAL_NUM + \
+	MTK_DIP_VIDEO_NODE_ID_CAPTURE_TOTAL_NUM)
+
+#define MTK_DIP_VIDEO_NODE_ID_NO_MASTER			-1
+
+#define MTK_DIP_OUTPUT_MIN_WIDTH		2U
+#define MTK_DIP_OUTPUT_MIN_HEIGHT		2U
+#define MTK_DIP_OUTPUT_MAX_WIDTH		5376U
+#define MTK_DIP_OUTPUT_MAX_HEIGHT		4032U
+#define MTK_DIP_CAPTURE_MIN_WIDTH		2U
+#define MTK_DIP_CAPTURE_MIN_HEIGHT		2U
+#define MTK_DIP_CAPTURE_MAX_WIDTH		5376U
+#define MTK_DIP_CAPTURE_MAX_HEIGHT		4032U
+
+#define MTK_DIP_DEV_DIP_MEDIA_MODEL_NAME	"MTK-ISP-DIP-V4L2"
+#define MTK_DIP_DEV_DIP_PREVIEW_NAME \
+	MTK_DIP_DEV_DIP_MEDIA_MODEL_NAME
+#define MTK_DIP_DEV_DIP_CAPTURE_NAME		"MTK-ISP-DIP-CAP-V4L2"
+#define MTK_DIP_DEV_DIP_REPROCESS_NAME		"MTK-ISP-DIP-REP-V4L2"
+
+#define MTK_DIP_DEV_META_BUF_DEFAULT_SIZE (1110 * 1024)
+
+#define V4L2_CID_PRIVATE_UT_NUM			(V4L2_CID_USER_BASE | 0x1001)
+#define V4L2_CID_PRIVATE_SET_BUFFER_USAGE	(V4L2_CID_PRIVATE_UT_NUM + 2)
+#define V4L2_CID_MTK_DIP_MAX			100
+
+enum mtk_dip_v4l2_buffer_usage {
+	MTK_DIP_V4l2_BUF_USAGE_DEFAULT = 0,
+	MTK_DIP_V4l2_BUF_USAGE_FD,
+	MTK_DIP_V4l2_BUF_USAGE_POSTPROC,
+	MTK_DIP_V4l2_BUF_USAGE_NONE,
+};
+
+/*
+ * Supported format and the information used for
+ * size calculation
+ */
+struct mtk_dip_dev_meta_format {
+	u32 dataformat;
+	u32 max_buffer_size;
+	u8 flags;
+};
+
+/* MDP part private format definitation */
+struct mtk_dip_dev_mdp_format {
+	u32 pixelformat;
+	u32 mdp_color;
+	u32 colorspace;
+	u8 depth[VIDEO_MAX_PLANES];
+	u8 row_depth[VIDEO_MAX_PLANES];
+	u8 num_planes;
+	u8 walign;
+	u8 halign;
+	u8 salign;
+	u32 flags;
+};
+
+struct mtk_dip_dev_format {
+	union {
+		struct mtk_dip_dev_meta_format meta;
+		struct mtk_dip_dev_mdp_format img;
+	} fmt;
+};
+
+struct mtk_dip_pipe_job_info {
+	struct media_request *req;
+	int id;
+	struct mtk_dip_dev_buffer*
+		buf_map[MTK_DIP_VIDEO_NODE_ID_TOTAL_NUM];
+	int num_img_capture_bufs;
+	int num_img_output_bufs;
+	int num_meta_capture_bufs;
+	int num_meta_output_bufs;
+	struct list_head list;
+};
+
+struct mtk_dip_crop {
+	struct v4l2_rect	c;
+	struct v4l2_fract	left_subpix;
+	struct v4l2_fract	top_subpix;
+	struct v4l2_fract	width_subpix;
+	struct v4l2_fract	height_subpix;
+};
+
+struct mtk_dip_dev_buffer {
+	struct vb2_v4l2_buffer vbb;
+	struct v4l2_format fmt;
+	struct mtk_dip_dev_format *dev_fmt;
+	int pipe_job_id;
+	void *vaddr;
+	dma_addr_t isp_daddr;
+	dma_addr_t scp_daddr;
+	unsigned int buffer_usage;
+	struct mtk_dip_crop crop;
+	struct v4l2_rect compose;
+	int rotation;
+	bool hflip;
+	bool vflip;
+	struct list_head list;
+};
+
+struct mtk_dip_pipe_desc {
+	char *name;
+	int master;
+	int id;
+	struct mtk_dip_video_device_desc *output_queue_descs;
+	int total_output_queues;
+	struct mtk_dip_video_device_desc *capture_queue_descs;
+	int total_capture_queues;
+};
+
+struct mtk_dip_video_device_desc {
+	int id;
+	char *name;
+	u32 buf_type;
+	u32 cap;
+	int smem_alloc;
+	int dynamic;
+	int default_enable;
+	struct mtk_dip_dev_format *fmts;
+	int num_fmts;
+	char *description;
+	int default_width;
+	int default_height;
+	const struct v4l2_ioctl_ops *ops;
+	int default_fmt_idx;
+	int dma_port;
+};
+
+struct mtk_dip_dev_queue {
+	struct vb2_queue vbq;
+	/* Serializes vb2 queue and video device operations */
+	struct mutex lock;
+	struct mtk_dip_dev_format *dev_fmt;
+};
+
+struct mtk_dip_video_device {
+	struct video_device vdev;
+	struct mtk_dip_dev_queue dev_q;
+	struct v4l2_format vdev_fmt;
+	struct media_pad vdev_pad;
+	struct v4l2_mbus_framefmt pad_fmt;
+	struct v4l2_ctrl_handler ctrl_handler;
+	int immutable;
+	int enabled;
+	struct mtk_dip_video_device_desc *desc;
+	atomic_t sequence;
+	struct v4l2_rect crop;
+	struct v4l2_rect compose;
+	int rotation;
+};
+
+struct mtk_dip_pipe {
+	struct mtk_dip_dev *dip_dev;
+	struct mtk_dip_video_device nodes[MTK_DIP_VIDEO_NODE_ID_TOTAL_NUM];
+	int num_nodes;
+	int streaming;
+	struct media_pad *subdev_pads;
+	struct media_pipeline pipeline;
+	struct v4l2_subdev subdev;
+	struct v4l2_subdev_fh *fh;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct mtk_dip_smem_dev *smem_alloc_dev;
+	atomic_t pipe_job_sequence;
+	struct mtk_dip_pipe_job_info pipe_job_infos[VB2_MAX_FRAME];
+	int num_pipe_job_infos;
+	struct list_head pipe_job_running_list;
+	struct list_head pipe_job_free_list;
+	/* Serializes pipe's stream on/off and buffers enqueue operations */
+	struct mutex lock;
+	spinlock_t job_lock; /* protect the pipe job list */
+	struct mtk_dip_pipe_desc *desc;
+};
+
+struct mtk_dip_dev {
+	struct platform_device *pdev;
+	struct media_device mdev;
+	struct v4l2_device v4l2_dev;
+	struct mtk_dip_pipe dip_pipe[MTK_DIP_PIPE_ID_TOTAL_NUM];
+	struct mtk_dip_smem_dev smem_alloc_dev;
+	struct mtk_dip_hw dip_hw;
+};
+
+int mtk_dip_dev_media_register(struct device *dev,
+			       struct media_device *media_dev,
+			       const char *model);
+
+int mtk_dip_dev_v4l2_init(struct mtk_dip_dev *dip_dev);
+
+void mtk_dip_dev_v4l2_release(struct mtk_dip_dev *dip_dev);
+
+int mtk_dip_dev_v4l2_register(struct device *dev,
+			      struct media_device *media_dev,
+			      struct v4l2_device *v4l2_dev);
+
+int mtk_dip_pipe_v4l2_register(struct mtk_dip_pipe *dip_pipe,
+			       struct media_device *media_dev,
+			       struct v4l2_device *v4l2_dev);
+
+int mtk_dip_pipe_v4l2_unregister(struct mtk_dip_pipe *dip_pipe);
+
+void mtk_dip_v4l2_buffer_done(struct vb2_buffer *vb,
+			      enum vb2_buffer_state state);
+
+int mtk_dip_pipe_queue_buffers(struct media_request *req, int initial);
+
+int mtk_dip_pipe_init(struct mtk_dip_pipe *dip_pipe,
+		      struct mtk_dip_dev *dip_dev,
+		      struct mtk_dip_pipe_desc *setting,
+		      struct media_device *media_dev,
+		      struct v4l2_device *v4l2_dev,
+		      struct mtk_dip_smem_dev *smem_alloc_dev);
+
+int mtk_dip_pipe_release(struct mtk_dip_pipe *dip_pipe);
+
+int mtk_dip_pipe_job_finish(struct mtk_dip_pipe *dip_pipe,
+			    unsigned int pipe_job_info_id,
+			    enum vb2_buffer_state state);
+
+int mtk_dip_pipe_job_start(struct mtk_dip_pipe *dip_pipe,
+			   struct mtk_dip_pipe_job_info *pipe_job_info);
+
+int mtk_dip_pipe_init_job_infos(struct mtk_dip_pipe *dip_pipe);
+
+struct mtk_dip_dev_format *
+mtk_dip_pipe_find_fmt(struct mtk_dip_pipe *dip_pipe,
+		      struct mtk_dip_video_device *node,
+		      u32 format);
+
+int mtk_dip_pipe_set_img_fmt(struct mtk_dip_pipe *dip_pipe,
+			     struct mtk_dip_video_device *node,
+			     struct v4l2_pix_format_mplane *user_fmt,
+			     struct v4l2_pix_format_mplane *node_fmt);
+
+int mtk_dip_pipe_set_meta_fmt(struct mtk_dip_pipe *dip_pipe,
+			      struct mtk_dip_video_device *node,
+			      struct v4l2_meta_format *user_fmt,
+			      struct v4l2_meta_format *node_fmt);
+
+void mtk_dip_pipe_load_default_fmt(struct mtk_dip_pipe *dip_pipe,
+				   struct mtk_dip_video_device *node,
+				   struct v4l2_format *fmt_to_fill);
+
+int mtk_dip_pipe_streamon(struct mtk_dip_pipe *dip_pipe);
+
+int mtk_dip_pipe_streamoff(struct mtk_dip_pipe *dip_pipe);
+
+int mtk_dip_ctrl_init(struct mtk_dip_pipe *dip_pipe);
+
+static inline struct mtk_dip_video_device *
+mtk_dip_file_to_node(struct file *file)
+{
+	return container_of(video_devdata(file),
+			    struct mtk_dip_video_device, vdev);
+}
+
+static inline struct mtk_dip_pipe *
+mtk_dip_subdev_to_pipe(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct mtk_dip_pipe, subdev);
+}
+
+static inline struct mtk_dip_video_device *
+mtk_dip_vbq_to_node(struct vb2_queue *vq)
+{
+	return container_of(vq, struct mtk_dip_video_device, dev_q.vbq);
+}
+
+static inline struct mtk_dip_dev_buffer *
+mtk_dip_vb2_buf_to_dev_buf(struct vb2_buffer *vb)
+{
+	return container_of(vb, struct mtk_dip_dev_buffer, vbb.vb2_buf);
+}
+
+static inline struct mtk_dip_dev *mtk_dip_hw_to_dev(struct mtk_dip_hw *dip_hw)
+{
+	return container_of(dip_hw, struct mtk_dip_dev, dip_hw);
+}
+
+static inline int mtk_dip_buf_is_meta(u32 type)
+{
+	return type == V4L2_BUF_TYPE_META_CAPTURE ||
+		type == V4L2_BUF_TYPE_META_OUTPUT;
+}
+
+static inline int mtk_dip_pipe_get_pipe_from_job_id(int pipe_job_id)
+{
+	return (pipe_job_id >> 16) & 0x0000FFFF;
+}
+
+#endif /* _MTK_DIP_DEV_H_ */
diff --git a/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-hw.h b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-hw.h
new file mode 100644
index 000000000000..4651ebc16e8d
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-hw.h
@@ -0,0 +1,173 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 MediaTek Inc.
+ * Author: Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _MTK_DIP_HW_H_
+#define _MTK_DIP_HW_H_
+
+#include <linux/clk.h>
+#include "mtk-img-ipi.h"
+
+#define MTK_DIP_CLK_NUM 2
+
+enum STREAM_TYPE_ENUM {
+	STREAM_UNKNOWN,
+	STREAM_BITBLT,
+	STREAM_GPU_BITBLT,
+	STREAM_DUAL_BITBLT,
+	STREAM_2ND_BITBLT,
+	STREAM_ISP_IC,
+	STREAM_ISP_VR,
+	STREAM_ISP_ZSD,
+	STREAM_ISP_IP,
+	STREAM_ISP_VSS,
+	STREAM_ISP_ZSD_SLOW,
+	STREAM_WPE,
+	STREAM_WPE2,
+};
+
+enum mtk_dip_hw_user_state {
+	DIP_STATE_INIT	= 0,
+	DIP_STATE_OPENED,
+	DIP_STATE_STREAMON,
+	DIP_STATE_STREAMOFF
+};
+
+struct mtk_dip_hw_frame_job {
+	struct img_frameparam fparam;
+	int sequence;
+};
+
+struct mtk_dip_hw_user_id {
+	struct list_head list_entry;
+	u16 id;
+	u32 num;
+	u16 state;
+};
+
+struct mtk_dip_hw_subframe {
+	struct img_addr buffer;
+	struct sg_table table;
+	struct img_sw_addr config_data;
+	struct img_addr tuning_buf;
+	struct img_sw_addr frameparam;
+	struct list_head list_entry;
+};
+
+struct mtk_dip_hw_queue {
+	struct list_head queue;
+	struct mutex queuelock; /* protect queue and queue_cnt */
+	u32 queue_cnt;
+};
+
+struct mtk_dip_hw_joblist {
+	struct list_head queue;
+	spinlock_t queuelock; /* protect job list */
+	u32 queue_cnt;
+};
+
+struct mtk_dip_hw_thread {
+	struct task_struct *thread;
+	wait_queue_head_t wq;
+};
+
+struct mtk_dip_hw_work {
+	struct list_head list_entry;
+	struct img_ipi_frameparam frameparams;
+	struct mtk_dip_hw_user_id *user_id;
+};
+
+struct mtk_dip_hw_submit_work {
+	struct work_struct frame_work;
+	struct mtk_dip_hw *dip_hw;
+};
+
+struct mtk_dip_hw_mdpcb_work {
+	struct work_struct frame_work;
+	struct img_ipi_frameparam *frameparams;
+};
+
+struct mtk_dip_hw_clk {
+	struct clk *img_larb5;
+	struct clk *img_dip;
+};
+
+enum frame_state {
+	FRAME_STATE_INIT = 0,
+	FRAME_STATE_COMPOSING,
+	FRAME_STATE_RUNNING,
+	FRAME_STATE_DONE,
+	FRAME_STATE_STREAMOFF,
+	FRAME_STATE_ERROR,
+	FRAME_STATE_HW_TIMEOUT
+};
+
+struct mtk_dip_hw {
+	struct clk_bulk_data clks[MTK_DIP_CLK_NUM];
+	struct device *larb_dev;
+	struct mtk_dip_hw_joblist dip_gcejoblist;
+	struct mtk_dip_hw_queue dip_freebufferlist;
+	struct mtk_dip_hw_queue dip_usedbufferlist;
+	struct mtk_dip_hw_thread dip_runner_thread;
+	struct mtk_dip_hw_queue dip_useridlist;
+	struct mtk_dip_hw_queue dip_worklist;
+	struct workqueue_struct *composer_wq;
+	wait_queue_head_t composing_wq;
+	wait_queue_head_t flushing_wq;
+	atomic_t num_composing;	/* increase after ipi */
+	/* increase after calling MDP driver */
+	atomic_t num_running;
+	/*MDP/GCE callback workqueue */
+	struct workqueue_struct *mdpcb_workqueue;
+	/* for MDP driver  */
+	struct platform_device *mdp_pdev;
+	/* for SCP driver  */
+	struct platform_device *scp_pdev;
+	struct rproc *rproc_handle;
+	dma_addr_t scp_workingbuf_addr;
+	/* increase after enqueue */
+	atomic_t dip_enque_cnt;
+	/* increase after stream on, decrease when stream off */
+	atomic_t dip_stream_cnt;
+	/* increase after open, decrease when close */
+	atomic_t dip_user_cnt;
+	/* driver internal state */
+	atomic_t dip_state;
+	/* To serialize request opertion to DIP co-procrosser and hadrware */
+	struct mutex hw_op_lock;
+};
+
+int mtk_dip_hw_enqueue(struct mtk_dip_hw *dip_hw,
+		       struct img_ipi_frameparam *frameparams);
+int mtk_dip_hw_connect(struct mtk_dip_hw *dip_hw);
+int mtk_dip_hw_disconnect(struct mtk_dip_hw *dip_hw);
+int mtk_dip_hw_streamon(struct mtk_dip_hw *dip_hw, u16 id);
+int mtk_dip_hw_streamoff(struct mtk_dip_hw *dip_hw, u16 id);
+
+static inline struct mtk_dip_hw_frame_job
+*mtk_dip_fparam_to_job(struct img_frameparam *fparam)
+{
+	return container_of(fparam, struct mtk_dip_hw_frame_job, fparam);
+}
+
+static inline struct mtk_dip_hw_frame_job *
+mtk_dip_ipi_fparam_to_job(struct img_ipi_frameparam *ipi_fparam)
+{
+	return container_of(ipi_fparam,
+			    struct mtk_dip_hw_frame_job,
+			    fparam.frameparam);
+}
+
+#endif /* _MTK_DIP_HW_H_ */
+
diff --git a/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-smem.c b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-smem.c
new file mode 100644
index 000000000000..2e3a1c8af793
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-smem.c
@@ -0,0 +1,334 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/cacheflush.h>
+#include <linux/iommu.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_fdt.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <media/videobuf2-dma-contig.h>
+#include "mtk_dip-smem.h"
+
+#define MTK_DIP_SMEM_DEV_NAME "MTK-DIP-SMEM"
+
+struct dma_coherent_mem {
+	void		*virt_base;
+	dma_addr_t	device_base;
+	unsigned long	pfn_base;
+	int		size;
+	int		flags;
+	unsigned long	*bitmap;
+	spinlock_t	spinlock; /* protect dma_coherent_mem member */
+	bool		use_dev_dma_pfn_offset;
+};
+
+static struct dma_coherent_mem *dev_get_coherent_memory(struct device *dev)
+{
+	if (dev && dev->dma_mem)
+		return dev->dma_mem;
+	return NULL;
+}
+
+phys_addr_t mtk_dip_smem_iova_to_phys(struct mtk_dip_smem_dev *smem_dev,
+				      dma_addr_t iova)
+{
+		struct iommu_domain *smem_dom;
+		phys_addr_t addr;
+		phys_addr_t limit;
+
+		if (!smem_dev)
+			return 0;
+
+		smem_dom = iommu_get_domain_for_dev(&smem_dev->dev);
+
+		if (!smem_dom)
+			return 0;
+
+		addr = iommu_iova_to_phys(smem_dom, iova);
+
+		limit = smem_dev->smem_base + smem_dev->smem_size;
+
+		if (addr < smem_dev->smem_base || addr >= limit) {
+			dev_err(&smem_dev->dev,
+				"Unexpected scp_daddr %pa (must >= %pa and <%pa)\n",
+				&addr, &smem_dev->smem_base, &limit);
+			return 0;
+		}
+		dev_dbg(&smem_dev->dev, "Pa verifcation pass: %pa(>=%pa, <%pa)\n",
+			&addr, &smem_dev->smem_base, &limit);
+		return addr;
+}
+
+/********************************************
+ * MTK DIP SMEM DMA ops *
+ ********************************************/
+static int mtk_dip_smem_get_sgtable(struct device *dev,
+				    struct sg_table *sgt,
+				    void *cpu_addr,
+				    dma_addr_t dma_addr,
+				    size_t size, unsigned long attrs)
+{
+	struct mtk_dip_smem_dev *smem_dev = dev_get_drvdata(dev);
+	int n_pages_align;
+	int size_align;
+	int page_start;
+	unsigned long long offset_p;
+
+	phys_addr_t paddr = mtk_dip_smem_iova_to_phys(smem_dev, dma_addr);
+
+	offset_p = (unsigned long long)paddr -
+		(unsigned long long)smem_dev->smem_base;
+
+	dev_dbg(dev, "%s: dma_addr(%pad), cpu_addr(%p), pa(%pa), size(%d)\n",
+		__func__, &dma_addr, cpu_addr, &paddr, size);
+
+	size_align = round_up(size, PAGE_SIZE);
+	n_pages_align = size_align >> PAGE_SHIFT;
+	page_start = offset_p >> PAGE_SHIFT;
+
+	dev_dbg(dev, "%s: page_start(%d), page pa(%llx), pa(%pa), aligned size(%d)\n",
+		__func__,
+		page_start,
+		page_to_phys(*(smem_dev->smem_pages + page_start)),
+		&paddr,
+		size_align
+		);
+
+	if (!smem_dev) {
+		dev_err(dev, "can't get sgtable from smem_dev\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "%s: get sgt of the smem: %d pages\n", __func__,
+		n_pages_align);
+
+	return sg_alloc_table_from_pages(sgt,
+					 smem_dev->smem_pages + page_start,
+					 n_pages_align,
+					 0, size_align, GFP_KERNEL);
+}
+
+static void *mtk_dip_smem_get_cpu_addr(struct mtk_dip_smem_dev *smem_dev,
+				       struct scatterlist *sg)
+{
+	struct device *dev = &smem_dev->dev;
+	struct dma_coherent_mem *dma_mem =
+		dev_get_coherent_memory(dev);
+
+	phys_addr_t addr = (phys_addr_t)sg_phys(sg);
+
+	if (addr < smem_dev->smem_base ||
+	    addr > smem_dev->smem_base + smem_dev->smem_size) {
+		dev_err(dev, "%s: Invalid paddr %pa from sg\n",
+			__func__, &addr);
+		return NULL;
+	}
+
+	return dma_mem->virt_base + (addr - smem_dev->smem_base);
+}
+
+static void mtk_dip_smem_sync_sg_for_cpu(struct device *dev,
+					 struct scatterlist *sgl,
+					 int nelems,
+					 enum dma_data_direction dir)
+{
+	struct mtk_dip_smem_dev *smem_dev =
+		dev_get_drvdata(dev);
+	void *cpu_addr;
+
+	cpu_addr = mtk_dip_smem_get_cpu_addr(smem_dev, sgl);
+
+	dev_dbg(dev, "%s: paddr(%p),vaddr(%p),size(%d)\n",
+		__func__, sg_phys(sgl), cpu_addr, sgl->length);
+
+	if (cpu_addr)
+		__dma_unmap_area(cpu_addr, sgl->length, dir);
+}
+
+static void mtk_dip_smem_sync_sg_for_device(struct device *dev,
+					    struct scatterlist *sgl,
+					    int nelems,
+					    enum dma_data_direction dir)
+{
+	struct mtk_dip_smem_dev *smem_dev =
+			dev_get_drvdata(dev);
+	void *cpu_addr;
+
+	cpu_addr = mtk_dip_smem_get_cpu_addr(smem_dev, sgl);
+
+	dev_dbg(dev, "%s: pa(%p),va(%p),size(%d),dir(%d)\n",
+		__func__, sg_phys(sgl), cpu_addr, sgl->length, dir);
+
+	if (cpu_addr)
+		__dma_map_area(cpu_addr, sgl->length, dir);
+}
+
+static int mtk_dip_smem_setup_dma_ops(struct mtk_dip_smem_dev *smem_dev)
+{
+	memcpy((void *)&smem_dev->smem_dma_ops, smem_dev->dev.parent->dma_ops,
+	       sizeof(smem_dev->smem_dma_ops));
+
+	smem_dev->smem_dma_ops.get_sgtable =
+		mtk_dip_smem_get_sgtable;
+	smem_dev->smem_dma_ops.sync_sg_for_device =
+		mtk_dip_smem_sync_sg_for_device;
+	smem_dev->smem_dma_ops.sync_sg_for_cpu =
+		mtk_dip_smem_sync_sg_for_cpu;
+	smem_dev->dev.dma_ops = &smem_dev->smem_dma_ops;
+
+	dev_dbg(&smem_dev->dev, "setup smem_dma_ops: %p\n",
+		smem_dev->dev.dma_ops);
+
+	return 0;
+}
+
+void mtk_dip_smem_alloc_dev_release(struct mtk_dip_smem_dev *smem_dev)
+{
+	device_unregister(&smem_dev->dev);
+}
+
+int mtk_dip_smem_alloc_dev_init(struct mtk_dip_smem_dev *smem_dev,
+				struct device *parent)
+{
+	int i;
+	int ret;
+	struct device *dev;
+	struct device_node *node;
+	struct iommu_domain *smem_dom;
+	struct reserved_mem *r_mem;
+	phys_addr_t reserved_mem_base;
+	phys_addr_t addr;
+	int reserved_mem_size;
+	dma_addr_t dma_addr;
+	int size_align;
+	struct page **pages;
+	int n_pages;
+	struct sg_table *sgt;
+
+	dev = &smem_dev->dev;
+	dev->parent = parent;
+	dev->iommu_group = parent->iommu_group;
+	dev_set_name(&smem_dev->dev, "dip-smem");
+	set_dma_ops(dev, get_dma_ops(parent));
+
+	ret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
+	if (ret)
+		dev_warn(dev, "No suitable DMA available\n");
+
+	vb2_dma_contig_set_max_seg_size(dev, DMA_BIT_MASK(32));
+
+	ret = device_register(dev);
+	if (ret)
+		dev_err(parent, "Failed to register smem device\n");
+
+	dev_dbg(dev, "init alloc dev(%p), parent(%p)\n", dev, dev->parent);
+
+	dev_set_drvdata(dev, smem_dev);
+	node = of_parse_phandle(parent->of_node, "memory-region", 0);
+	if (!node) {
+		dev_err(parent, "no memory-region specified\n");
+		return -EINVAL;
+	}
+
+	r_mem = of_reserved_mem_lookup(node);
+	if (!r_mem) {
+		dev_err(parent, "of_reserved_mem_lookup failed\n");
+		return ret;
+	}
+
+	reserved_mem_base = r_mem->base;
+	reserved_mem_size = r_mem->size;
+	sgt = &smem_dev->sgt;
+	size_align = round_down(reserved_mem_size, PAGE_SIZE);
+	n_pages = size_align >> PAGE_SHIFT;
+	pages = kmalloc_array(n_pages, sizeof(struct page *),
+			      GFP_KERNEL);
+	if (!pages)
+		return -ENOMEM;
+
+	for (i = 0; i < n_pages; i++)
+		pages[i] = phys_to_page(reserved_mem_base
+					+ i * PAGE_SIZE);
+
+	ret = sg_alloc_table_from_pages(sgt, pages, n_pages, 0,
+					size_align, GFP_KERNEL);
+
+	if (ret) {
+		dev_err(dev, "failed to get alloc sg table\n");
+		return -ENOMEM;
+	}
+
+	dma_map_sg_attrs(dev, sgt->sgl, sgt->nents,
+			 DMA_BIDIRECTIONAL,
+			 DMA_ATTR_SKIP_CPU_SYNC);
+	dma_addr = sg_dma_address(sgt->sgl);
+	smem_dom = iommu_get_domain_for_dev(dev);
+	addr = iommu_iova_to_phys(smem_dom, dma_addr);
+	if (addr != reserved_mem_base)
+		dev_warn(dev,
+			 "incorrect pa(%pa) of smem_dma_base, should be %pa\n",
+			 &addr, &reserved_mem_base);
+
+	ret = dma_declare_coherent_memory(dev,
+					  reserved_mem_base,
+					  dma_addr, size_align,
+					  DMA_MEMORY_EXCLUSIVE);
+
+	dev_dbg(dev, "Coherent mem base(%pa,%pad),size(%ld),ret(%d)\n",
+		&reserved_mem_base, &dma_addr, size_align, ret);
+
+	smem_dev->smem_base = reserved_mem_base;
+	smem_dev->smem_size = size_align;
+	smem_dev->smem_pages = pages;
+	smem_dev->num_smem_pages = n_pages;
+	smem_dev->smem_dma_base = dma_addr;
+
+	dev_dbg(dev, "smem_dev setting (%pa,%d,%p,%d)\n",
+		&smem_dev->smem_base, smem_dev->smem_size,
+		smem_dev->smem_pages, smem_dev->num_smem_pages);
+
+	ret = mtk_dip_smem_setup_dma_ops(smem_dev);
+
+	return ret;
+}
+
+static int __init mtk_dip_smem_dma_setup(struct reserved_mem *rmem)
+{
+	unsigned long node = rmem->fdt_node;
+
+	if (of_get_flat_dt_prop(node, "reusable", NULL))
+		return -EINVAL;
+
+	if (!of_get_flat_dt_prop(node, "no-map", NULL)) {
+		pr_err("Reserved memory: regions without no-map are not yet supported\n");
+		return -EINVAL;
+	}
+
+	pr_debug("Reserved memory: created DMA memory pool at %pa, size %ld MiB\n",
+		 &rmem->base, (unsigned long)rmem->size / SZ_1M);
+	return 0;
+}
+
+RESERVEDMEM_OF_DECLARE(mtk_dip_smem,
+		       "mediatek,reserve-memory-dip-smem",
+		       mtk_dip_smem_dma_setup);
+
+MODULE_AUTHOR("Frederic Chen <frederic.chen@mediatek.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Mediatek Camera DIP shared memory alloc device");
+
diff --git a/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-smem.h b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-smem.h
new file mode 100644
index 000000000000..4d236cad6529
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-smem.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _MTK_DIP_SMEM_H_
+#define _MTK_DIP_SMEM_H_
+
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+
+struct mtk_dip_smem_dev {
+	struct device dev;
+	struct sg_table sgt;
+	struct page **smem_pages;
+	int num_smem_pages;
+	phys_addr_t smem_base;
+	dma_addr_t smem_dma_base;
+	int smem_size;
+	struct dma_map_ops smem_dma_ops;
+};
+
+phys_addr_t mtk_dip_smem_iova_to_phys(struct mtk_dip_smem_dev *smem_dev,
+				      dma_addr_t iova);
+int mtk_dip_smem_alloc_dev_init(struct mtk_dip_smem_dev *smem_dev,
+				struct device *default_alloc_dev);
+void mtk_dip_smem_alloc_dev_release(struct mtk_dip_smem_dev *smem_dev);
+
+#endif /*_MTK_DIP_SMEM_H_*/
+
diff --git a/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-sys.c b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-sys.c
new file mode 100644
index 000000000000..38bef0f8d279
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-sys.c
@@ -0,0 +1,1422 @@
+// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/device.h>
+#include <linux/dma-iommu.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_data/mtk_scp.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include "mtk-mdp3-cmdq.h"
+#include "mtk_dip-dev.h"
+#include "mtk_dip-hw.h"
+
+#define DIP_DEV_NAME			"camera-dip"
+
+#define DIP_COMPOSER_THREAD_TIMEOUT	16U
+#define DIP_COMPOSING_WQ_TIMEOUT	16U
+#define DIP_COMPOSING_MAX_NUM		3
+#define DIP_FLUSHING_WQ_TIMEOUT		16U
+#define DIP_MAX_ERR_COUNT		188U
+
+#define DIP_FRM_SZ			(84 * 1024)
+#define DIP_SUB_FRM_SZ			(20 * 1024)
+#define DIP_TUNING_SZ			(32 * 1024)
+#define DIP_COMP_SZ			(28 * 1024)
+#define DIP_FRAMEPARAM_SZ		(4 * 1024)
+
+#define DIP_TUNING_OFFSET		DIP_SUB_FRM_SZ
+#define DIP_COMP_OFFSET			(DIP_TUNING_OFFSET + DIP_TUNING_SZ)
+#define DIP_FRAMEPARAM_OFFSET		(DIP_COMP_OFFSET + DIP_COMP_SZ)
+#define DIP_SUB_FRM_DATA_NUM		32
+#define DIP_SCP_WORKINGBUF_OFFSET	(5 * 1024 * 1024)
+
+static inline struct mtk_dip_hw *get_dip_device(struct device *dev)
+{
+	struct mtk_dip_dev *dip_dev = dev_get_drvdata(dev);
+
+	if (dip_dev)
+		return &dip_dev->dip_hw;
+	else
+		return NULL;
+}
+
+static struct img_frameparam *dip_create_framejob(int sequence)
+{
+	struct mtk_dip_hw_frame_job *fjob;
+
+	fjob = kzalloc(sizeof(*fjob), GFP_ATOMIC);
+
+	if (!fjob)
+		return NULL;
+
+	fjob->sequence = sequence;
+
+	return &fjob->fparam;
+}
+
+static void dip_free_framejob(struct img_frameparam *fparam)
+{
+	struct mtk_dip_hw_frame_job *fjob;
+
+	fjob = mtk_dip_fparam_to_job(fparam);
+	fjob->sequence = -1;
+
+	kfree(fjob);
+}
+
+static int dip_send(struct platform_device *pdev, enum scp_ipi_id id,
+		    void *buf, unsigned int  len, unsigned int wait)
+{
+	return scp_ipi_send(pdev, id, buf, len, wait);
+}
+
+static struct mtk_dip_pipe *get_mtk_dip_pipe(struct mtk_dip_dev *dip_dev,
+					     unsigned int pipe_id)
+{
+	if (pipe_id < 0 && pipe_id >= MTK_DIP_PIPE_ID_TOTAL_NUM)
+		return NULL;
+	return &dip_dev->dip_pipe[pipe_id];
+}
+
+static void call_mtk_dip_pipe_finish(struct mtk_dip_hw *dip_hw,
+				     struct img_ipi_frameparam *iparam)
+{
+	struct mtk_dip_dev *dip_dev;
+	struct mtk_dip_pipe *dip_pipe;
+	enum vb2_buffer_state vbf_state;
+	int pipe_id;
+	int ret;
+
+	if (!dip_hw) {
+		pr_err("%s: can't update buffer status, dip_hw is NULL\n",
+		       __func__);
+		return;
+	}
+
+	dip_dev = mtk_dip_hw_to_dev(dip_hw);
+
+	if (!iparam) {
+		dev_dbg(&dip_dev->pdev->dev, "%s: iparam can't be NULL\n",
+			__func__);
+		return;
+	}
+
+	pipe_id = mtk_dip_pipe_get_pipe_from_job_id(iparam->index);
+	dip_pipe = get_mtk_dip_pipe(dip_dev, pipe_id);
+	if (!dip_pipe) {
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s: unknown pipe id(%d)\n", __func__, pipe_id);
+		return;
+	}
+
+	if (iparam->state == FRAME_STATE_ERROR)
+		vbf_state = VB2_BUF_STATE_ERROR;
+	else
+		vbf_state = VB2_BUF_STATE_DONE;
+
+	dev_dbg(&dip_dev->pdev->dev,
+		"%s: ready to return buffers,pipe(%d),pipe_job_id(%d)\n",
+		__func__, pipe_id, iparam->index);
+
+	ret = mtk_dip_pipe_job_finish(dip_pipe, iparam->index, vbf_state);
+	if (ret)
+		dev_dbg(&dip_dev->pdev->dev, "%s: finish CB failed(%d)\n",
+			__func__, ret);
+}
+
+static void mtk_dip_notify(void *data)
+{
+	struct mtk_dip_hw *dip_hw;
+	struct mtk_dip_dev *dip_dev;
+	struct img_frameparam *framejob;
+	struct mtk_dip_hw_user_id *user_id;
+	struct mtk_dip_hw_subframe *buf, *tmpbuf;
+	struct img_ipi_frameparam *frameparam;
+	struct img_ipi_param ipi_param;
+	u32 num;
+	bool found = false;
+
+	frameparam = (struct img_ipi_frameparam *)data;
+	dip_hw = (struct mtk_dip_hw *)frameparam->drv_data;
+	dip_dev = mtk_dip_hw_to_dev(dip_hw);
+	framejob = container_of(frameparam,
+				struct img_frameparam,
+				frameparam);
+	if (frameparam->state == FRAME_STATE_HW_TIMEOUT) {
+		ipi_param.usage = IMG_IPI_DEBUG;
+		dip_send(dip_hw->scp_pdev, SCP_IPI_DIP,
+			 (void *)&ipi_param, sizeof(ipi_param), 0);
+		dev_err(&dip_dev->pdev->dev, "%s: frame no(%d) HW timeout\n",
+			__func__, frameparam->frame_no);
+	}
+
+	mutex_lock(&dip_hw->dip_usedbufferlist.queuelock);
+	list_for_each_entry_safe(buf, tmpbuf,
+				 &dip_hw->dip_usedbufferlist.queue,
+				 list_entry) {
+		if (buf->buffer.pa == frameparam->subfrm_data.pa) {
+			list_del(&buf->list_entry);
+			dip_hw->dip_usedbufferlist.queue_cnt--;
+			found = true;
+			dev_dbg(&dip_dev->pdev->dev,
+				"%s: Found used buffer(%x)\n",
+				__func__, buf->buffer.pa);
+			break;
+		}
+	}
+	mutex_unlock(&dip_hw->dip_usedbufferlist.queuelock);
+
+	if (!found) {
+		dev_err(&dip_dev->pdev->dev,
+			"%s: frame_no(%d), buf(%x), used buf cnt(%d)\n",
+			__func__, frameparam->frame_no,
+			frameparam->subfrm_data.pa,
+			dip_hw->dip_usedbufferlist.queue_cnt);
+
+		frameparam->state = FRAME_STATE_ERROR;
+
+	} else {
+		mutex_lock(&dip_hw->dip_freebufferlist.queuelock);
+		list_add_tail(&buf->list_entry,
+			      &dip_hw->dip_freebufferlist.queue);
+		dip_hw->dip_freebufferlist.queue_cnt++;
+		mutex_unlock(&dip_hw->dip_freebufferlist.queuelock);
+
+		frameparam->state = FRAME_STATE_DONE;
+	}
+
+	call_mtk_dip_pipe_finish(dip_hw, frameparam);
+
+	found = false;
+	mutex_lock(&dip_hw->dip_useridlist.queuelock);
+	list_for_each_entry(user_id,
+			    &dip_hw->dip_useridlist.queue,
+			    list_entry) {
+		if (mtk_dip_pipe_get_pipe_from_job_id(frameparam->index)
+			== user_id->id) {
+			user_id->num--;
+			dev_dbg(&dip_dev->pdev->dev,
+				"%s: user_id(%x) found, cnt(%d)\n",
+				__func__, user_id->id, user_id->num);
+			found = true;
+			break;
+		}
+	}
+	mutex_unlock(&dip_hw->dip_useridlist.queuelock);
+	wake_up(&dip_hw->flushing_wq);
+	dev_dbg(&dip_dev->pdev->dev,
+		"%s: frame_no(%d) is finished\n",
+		__func__, framejob->frameparam.frame_no);
+	dip_free_framejob(framejob);
+
+	num = atomic_dec_return(&dip_hw->num_running);
+	dev_dbg(&dip_dev->pdev->dev, "%s: running cnt(%d)\n", __func__, num);
+}
+
+static void mdp_cb_worker(struct work_struct *work)
+{
+	struct mtk_dip_hw_mdpcb_work *mdpcb_work;
+
+	mdpcb_work = container_of(work, struct mtk_dip_hw_mdpcb_work,
+				  frame_work);
+	mtk_dip_notify(mdpcb_work->frameparams);
+	kfree(mdpcb_work);
+}
+
+static struct img_ipi_frameparam *convert_to_fparam(struct cmdq_cb_data *data)
+{
+	struct mtk_dip_hw *dip_hw;
+	struct mtk_dip_dev *dip_dev;
+	struct mtk_dip_hw_frame_job *fjob;
+	struct img_ipi_frameparam *ipi_fparam;
+
+	if (!data) {
+		pr_err("%s: cmdq_cb_data can't be NULL\n",
+		       __func__);
+		return NULL;
+	}
+
+	if (data->sta != CMDQ_CB_NORMAL)
+		pr_debug("%s: got CMDQ CB(%d) without CMDQ_CB_NORMAL\n",
+			 __func__, data->sta);
+
+	if (!data->data) {
+		pr_err("%s: got NULL in cmdq_cb_data\n",
+		       __func__);
+		return NULL;
+	}
+
+	fjob = mtk_dip_ipi_fparam_to_job(data->data);
+	if (fjob->sequence == -1) {
+		pr_err("%s: Invalid cmdq_cb_data(%p)\n",
+		       __func__, data);
+		ipi_fparam = NULL;
+	} else {
+		ipi_fparam = &fjob->fparam.frameparam;
+		dip_hw = (struct mtk_dip_hw *)ipi_fparam->drv_data;
+		dip_dev = mtk_dip_hw_to_dev(dip_hw);
+	}
+
+	dev_dbg(&dip_dev->pdev->dev, "%s: framejob(%p), seq(%d)\n",
+		__func__, fjob, fjob->sequence);
+	dev_dbg(&dip_dev->pdev->dev, "%s: idx(%d), no(%d), s(%d), n_in(%d), n_out(%d), drv(%p)\n",
+		__func__,
+		fjob->fparam.frameparam.index,
+		fjob->fparam.frameparam.frame_no,
+		fjob->fparam.frameparam.state,
+		fjob->fparam.frameparam.num_inputs,
+		fjob->fparam.frameparam.num_outputs,
+		fjob->fparam.frameparam.drv_data
+	);
+
+	return ipi_fparam;
+}
+
+/* Maybe in IRQ context of cmdq */
+static void dip_mdp_cb_func(struct cmdq_cb_data data)
+{
+	struct img_ipi_frameparam *frameparam;
+	struct mtk_dip_hw *dip_hw;
+	struct mtk_dip_dev *dip_dev;
+	struct mtk_dip_hw_mdpcb_work *mdpcb_work;
+
+	frameparam = convert_to_fparam(&data);
+	if (!frameparam) {
+		pr_err("%s: return due to NULL cmdq_cb_data)",
+		       __func__, &data);
+		return;
+	}
+
+	dip_hw = (struct mtk_dip_hw *)frameparam->drv_data;
+	dip_dev = mtk_dip_hw_to_dev(dip_hw);
+
+	mdpcb_work = kzalloc(sizeof(*mdpcb_work), GFP_ATOMIC);
+
+	if (WARN_ONCE(!mdpcb_work, "%s: frame_no(%d) is lost",
+		      __func__, frameparam->frame_no))
+		return;
+
+	INIT_WORK(&mdpcb_work->frame_work, mdp_cb_worker);
+	mdpcb_work->frameparams = frameparam;
+	if (data.sta != CMDQ_CB_NORMAL)
+		mdpcb_work->frameparams->state = FRAME_STATE_HW_TIMEOUT;
+
+	queue_work(dip_hw->mdpcb_workqueue, &mdpcb_work->frame_work);
+}
+
+static void dip_scp_handler(void *data, unsigned int len, void *priv)
+{
+	struct img_frameparam *framejob;
+	struct img_ipi_frameparam *frameparam;
+	struct mtk_dip_hw *dip_hw;
+	struct mtk_dip_dev *dip_dev;
+	struct img_ipi_param *ipi_param;
+	unsigned long flags;
+	u32 num;
+
+	if (WARN_ONCE(!data, "%s: failed due to NULL data\n", __func__))
+		return;
+
+	ipi_param = (struct img_ipi_param *)data;
+	frameparam = (struct img_ipi_frameparam *)ipi_param->frm_param.va;
+	framejob = dip_create_framejob(frameparam->index);
+
+	if (WARN_ONCE(!framejob, "%s: frame_no(%d) is lost\n",
+		      __func__, frameparam->frame_no))
+		return;
+
+	dip_hw = (struct mtk_dip_hw *)frameparam->drv_data;
+	dip_dev = mtk_dip_hw_to_dev(dip_hw);
+
+	wake_up(&dip_hw->composing_wq);
+	memcpy(&framejob->frameparam, frameparam, sizeof(framejob->frameparam));
+	num = atomic_dec_return(&dip_hw->num_composing);
+
+	spin_lock_irqsave(&dip_hw->dip_gcejoblist.queuelock, flags);
+	list_add_tail(&framejob->list_entry, &dip_hw->dip_gcejoblist.queue);
+	dip_hw->dip_gcejoblist.queue_cnt++;
+	spin_unlock_irqrestore(&dip_hw->dip_gcejoblist.queuelock, flags);
+
+	dev_dbg(&dip_dev->pdev->dev,
+		"%s: frame_no(%d) is back, composing num(%d)\n",
+		__func__, frameparam->frame_no, num);
+
+	wake_up(&dip_hw->dip_runner_thread.wq);
+}
+
+static int dip_runner_func(void *data)
+{
+	struct img_frameparam *framejob;
+	struct mtk_dip_hw *dip_hw;
+	struct mtk_dip_dev *dip_dev;
+	struct mtk_dip_hw_user_id *user_id;
+	unsigned long flags;
+	bool found;
+	u32 queuecnt, num;
+	int ret;
+
+	dip_hw = (struct mtk_dip_hw *)data;
+	dip_dev = mtk_dip_hw_to_dev(dip_hw);
+
+	while (1) {
+		spin_lock_irqsave(&dip_hw->dip_gcejoblist.queuelock, flags);
+		queuecnt = dip_hw->dip_gcejoblist.queue_cnt;
+		spin_unlock_irqrestore(&dip_hw->dip_gcejoblist.queuelock,
+				       flags);
+
+		ret = wait_event_interruptible_timeout
+			(dip_hw->dip_runner_thread.wq,
+			 queuecnt || kthread_should_stop(),
+			 msecs_to_jiffies(DIP_COMPOSER_THREAD_TIMEOUT));
+
+		if (kthread_should_stop())
+			break;
+
+		if (!ret) {
+			/* Timeout */
+			ret = -ETIME;
+		} else if (ret == -ERESTARTSYS) {
+			dev_err(&dip_dev->pdev->dev,
+				"%s: interrupted by a signal\n", __func__);
+		}
+
+		if (queuecnt > 0) {
+			spin_lock_irqsave(&dip_hw->dip_gcejoblist.queuelock,
+					  flags);
+			framejob = list_first_entry
+				(&dip_hw->dip_gcejoblist.queue,
+				 struct img_frameparam, list_entry);
+
+			dip_hw->dip_gcejoblist.queue_cnt--;
+			list_del(&framejob->list_entry);
+			spin_unlock_irqrestore
+				(&dip_hw->dip_gcejoblist.queuelock, flags);
+
+			found = false;
+			mutex_lock(&dip_hw->dip_useridlist.queuelock);
+			list_for_each_entry(user_id,
+					    &dip_hw->dip_useridlist.queue,
+					    list_entry) {
+				int id = framejob->frameparam.index;
+
+				if (mtk_dip_pipe_get_pipe_from_job_id(id) ==
+					user_id->id) {
+					found = true;
+					break;
+				}
+			}
+			mutex_unlock(&dip_hw->dip_useridlist.queuelock);
+
+			if (!found) {
+				dev_err(&dip_dev->pdev->dev,
+					"%s: frame_no(%d), idx(0x%x) is abnormal\n",
+					__func__,
+					framejob->frameparam.frame_no,
+					framejob->frameparam.index);
+				/*
+				 * Due to error index, DIP driver could NOT
+				 * notify the V4L2 common driver to
+				 * return buffer
+				 */
+				dip_free_framejob(framejob);
+				continue;
+			}
+
+			mutex_lock(&dip_hw->dip_useridlist.queuelock);
+			if (user_id->state == DIP_STATE_STREAMOFF) {
+				user_id->num--;
+				mutex_unlock
+					(&dip_hw->dip_useridlist.queuelock);
+				framejob->frameparam.state =
+					FRAME_STATE_STREAMOFF;
+				call_mtk_dip_pipe_finish(dip_hw,
+							 &framejob->frameparam);
+
+				dev_dbg(&dip_dev->pdev->dev,
+					"%s: user_id(%x) streamoff, current num(%d); frame_no(%d) flushed\n",
+					__func__, user_id->id, user_id->num,
+					framejob->frameparam.frame_no);
+
+				dip_free_framejob(framejob);
+				continue;
+			}
+			mutex_unlock(&dip_hw->dip_useridlist.queuelock);
+
+			dev_dbg(&dip_dev->pdev->dev,
+				"%s: MDP run frame_no(%d) and the rest joblist cnt(%d)\n",
+				__func__, framejob->frameparam.frame_no,
+				dip_hw->dip_gcejoblist.queue_cnt);
+
+			/*
+			 * Call MDP/GCE API to do HW excecution
+			 * Pass the framejob to MDP driver
+			 */
+			framejob->frameparam.state = FRAME_STATE_COMPOSING;
+
+			mdp_cmdq_sendtask
+				(dip_hw->mdp_pdev,
+				 (struct img_config *)
+					framejob->frameparam.config_data.va,
+				 &framejob->frameparam, NULL, false,
+				 dip_mdp_cb_func,
+				 (void *)&framejob->frameparam);
+
+			num = atomic_inc_return(&dip_hw->num_running);
+			dev_dbg(&dip_dev->pdev->dev,
+				"%s,MDP running num(%d)\n", __func__, num);
+		}
+
+	};
+	dev_dbg(&dip_dev->pdev->dev,
+		"%s: runner thread terminated\n", __func__);
+
+	return 0;
+}
+
+static void dip_submit_worker(struct work_struct *work)
+{
+	struct mtk_dip_hw_submit_work *dip_submit_work =
+		container_of(work, struct mtk_dip_hw_submit_work, frame_work);
+	struct mtk_dip_hw  *dip_hw = dip_submit_work->dip_hw;
+	struct mtk_dip_dev *dip_dev = mtk_dip_hw_to_dev(dip_hw);
+	struct mtk_dip_hw_work *dip_work;
+	struct mtk_dip_hw_subframe *buf;
+	struct img_ipi_param ipi_param;
+	u32 len, num;
+	int ret;
+
+	num  = atomic_read(&dip_hw->num_composing);
+
+	mutex_lock(&dip_hw->dip_worklist.queuelock);
+	dip_work = list_first_entry(&dip_hw->dip_worklist.queue,
+				    struct mtk_dip_hw_work, list_entry);
+	list_del(&dip_work->list_entry);
+	dip_hw->dip_worklist.queue_cnt--;
+	len = dip_hw->dip_worklist.queue_cnt;
+	mutex_unlock(&dip_hw->dip_worklist.queuelock);
+
+	mutex_lock(&dip_hw->dip_useridlist.queuelock);
+	if (dip_work->user_id->state == DIP_STATE_STREAMOFF) {
+		dip_work->user_id->num--;
+		mutex_unlock(&dip_hw->dip_useridlist.queuelock);
+
+		dip_work->frameparams.state = FRAME_STATE_STREAMOFF;
+		call_mtk_dip_pipe_finish(dip_hw, &dip_work->frameparams);
+
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s: user_id(%x) is streamoff,num(%d),frame_no(%d),idx:0x%x\n",
+			 __func__, dip_work->user_id->id,
+			 dip_work->user_id->num,
+			dip_work->frameparams.frame_no,
+			dip_work->frameparams.index);
+
+		goto free_work_list;
+	}
+	mutex_unlock(&dip_hw->dip_useridlist.queuelock);
+
+	while (num >= DIP_COMPOSING_MAX_NUM) {
+		ret = wait_event_interruptible_timeout
+			(dip_hw->composing_wq,
+			 (num < DIP_COMPOSING_MAX_NUM),
+			 msecs_to_jiffies(DIP_COMPOSING_WQ_TIMEOUT));
+		if (ret == -ERESTARTSYS)
+			dev_err(&dip_dev->pdev->dev,
+				"%s: interrupted by a signal\n", __func__);
+		else if (ret == 0)
+			dev_dbg(&dip_dev->pdev->dev,
+				"%s: timeout frame_no(%d),num(%d)\n",
+				__func__, dip_work->frameparams.frame_no,
+				num);
+		else
+			dev_dbg(&dip_dev->pdev->dev,
+				"%s: wakeup frame_no(%d),num(%d)\n",
+				__func__, dip_work->frameparams.frame_no, num);
+
+		num = atomic_read(&dip_hw->num_composing);
+	};
+
+	mutex_lock(&dip_hw->dip_freebufferlist.queuelock);
+	if (list_empty(&dip_hw->dip_freebufferlist.queue)) {
+		mutex_unlock(&dip_hw->dip_freebufferlist.queuelock);
+
+		dev_err(&dip_dev->pdev->dev,
+			"%s: frame_no(%d), idx(0x%x), no free buffer(%d)\n",
+			__func__, dip_work->frameparams.frame_no,
+			dip_work->frameparams.index,
+			dip_hw->dip_freebufferlist.queue_cnt);
+
+		/*
+		 * Call callback to notify V4L2 common framework
+		 * for failure of enqueue
+		 */
+		dip_work->frameparams.state = FRAME_STATE_ERROR;
+		call_mtk_dip_pipe_finish(dip_hw, &dip_work->frameparams);
+
+		mutex_lock(&dip_hw->dip_useridlist.queuelock);
+		dip_work->user_id->num--;
+		mutex_unlock(&dip_hw->dip_useridlist.queuelock);
+
+		goto free_work_list;
+	}
+
+	buf = list_first_entry(&dip_hw->dip_freebufferlist.queue,
+			       struct mtk_dip_hw_subframe,
+			       list_entry);
+	list_del(&buf->list_entry);
+	dip_hw->dip_freebufferlist.queue_cnt--;
+	mutex_unlock(&dip_hw->dip_freebufferlist.queuelock);
+
+	mutex_lock(&dip_hw->dip_usedbufferlist.queuelock);
+	list_add_tail(&buf->list_entry, &dip_hw->dip_usedbufferlist.queue);
+	dip_hw->dip_usedbufferlist.queue_cnt++;
+	mutex_unlock(&dip_hw->dip_usedbufferlist.queuelock);
+
+	memcpy(&dip_work->frameparams.subfrm_data,
+	       &buf->buffer, sizeof(buf->buffer));
+	memset((char *)buf->buffer.va, 0, DIP_SUB_FRM_SZ);
+	memcpy(&dip_work->frameparams.config_data,
+	       &buf->config_data, sizeof(buf->config_data));
+	memset((char *)buf->config_data.va, 0, DIP_COMP_SZ);
+
+	if (dip_work->frameparams.tuning_data.pa == 0) {
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s: frame_no(%d) has no tuning_data\n",
+			__func__, dip_work->frameparams.frame_no);
+
+		memcpy(&dip_work->frameparams.tuning_data,
+		       &buf->tuning_buf, sizeof(buf->tuning_buf));
+		memset((char *)buf->tuning_buf.va, 0, DIP_TUNING_SZ);
+		/*
+		 * When user enqueued without tuning buffer,
+		 * it would use driver internal buffer.
+		 * So, tuning_data.va should be 0
+		 */
+		dip_work->frameparams.tuning_data.va = 0;
+	}
+
+	dip_work->frameparams.drv_data = (u64)dip_hw;
+	dip_work->frameparams.state = FRAME_STATE_COMPOSING;
+
+	dip_work->frameparams.self_data.va = buf->frameparam.va;
+	dip_work->frameparams.self_data.pa = buf->frameparam.pa;
+
+	memcpy((void *)buf->frameparam.va, &dip_work->frameparams,
+	       sizeof(dip_work->frameparams));
+
+	ipi_param.usage = IMG_IPI_FRAME;
+	ipi_param.frm_param.va = buf->frameparam.va;
+	ipi_param.frm_param.pa = buf->frameparam.pa;
+	ret = dip_send(dip_hw->scp_pdev, SCP_IPI_DIP,
+		       (void *)&ipi_param, sizeof(ipi_param), 0);
+	if (ret)
+		dev_dbg(&dip_dev->pdev->dev, "%s: send SCP_IPI_DIP_FRAME failed %d\n",
+			__func__, ret);
+
+	num = atomic_inc_return(&dip_hw->num_composing);
+
+free_work_list:
+
+	dev_dbg(&dip_dev->pdev->dev,
+		"%s, free: frame_no(%d),idx(0x%x),worklist cnt(%d),composing num(%d)\n",
+		__func__, dip_work->frameparams.frame_no,
+		dip_work->frameparams.index, len, num);
+
+	kfree(dip_work);
+	kfree(work);
+}
+
+static int mtk_dip_hw_res_init(struct mtk_dip_hw *dip_hw)
+{
+	struct mtk_dip_dev *dip_dev = mtk_dip_hw_to_dev(dip_hw);
+	u32 i;
+	dma_addr_t scp_daddr;
+	u64 scp_mem_va;
+	int ret;
+
+	dip_hw->mdp_pdev = mdp_get_plat_device(dip_dev->pdev);
+	if (!dip_hw->mdp_pdev) {
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s: failed to get MDP device\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	init_waitqueue_head(&dip_hw->dip_runner_thread.wq);
+
+	/*  All lists in DIP initialization */
+	INIT_LIST_HEAD(&dip_hw->dip_gcejoblist.queue);
+	spin_lock_init(&dip_hw->dip_gcejoblist.queuelock);
+	dip_hw->dip_gcejoblist.queue_cnt = 0;
+
+	INIT_LIST_HEAD(&dip_hw->dip_freebufferlist.queue);
+	mutex_init(&dip_hw->dip_freebufferlist.queuelock);
+	dip_hw->dip_freebufferlist.queue_cnt = 0;
+
+	INIT_LIST_HEAD(&dip_hw->dip_usedbufferlist.queue);
+	mutex_init(&dip_hw->dip_usedbufferlist.queuelock);
+	dip_hw->dip_usedbufferlist.queue_cnt = 0;
+
+	dip_hw->mdpcb_workqueue =
+		create_singlethread_workqueue("mdp_callback");
+	if (!dip_hw->mdpcb_workqueue) {
+		dev_err(&dip_dev->pdev->dev,
+			"%s: unable to alloc mdpcb workqueue\n", __func__);
+		ret = -ENOMEM;
+		goto err_alloc_mdpcb_wq;
+	}
+
+	dip_hw->composer_wq =
+		create_singlethread_workqueue("dip_composer");
+	if (!dip_hw->composer_wq) {
+		dev_err(&dip_dev->pdev->dev,
+			"%s: unable to alloc composer workqueue\n", __func__);
+		ret = -ENOMEM;
+		goto err_alloc_composer_wq;
+	}
+	init_waitqueue_head(&dip_hw->composing_wq);
+	init_waitqueue_head(&dip_hw->flushing_wq);
+
+	INIT_LIST_HEAD(&dip_hw->dip_worklist.queue);
+	mutex_init(&dip_hw->dip_worklist.queuelock);
+	dip_hw->dip_worklist.queue_cnt = 0;
+
+	INIT_LIST_HEAD(&dip_hw->dip_useridlist.queue);
+	mutex_init(&dip_hw->dip_useridlist.queuelock);
+	dip_hw->dip_useridlist.queue_cnt = 0;
+
+	dip_hw->dip_runner_thread.thread =
+		kthread_run(dip_runner_func, (void *)dip_hw, "dip_runner");
+	if (IS_ERR(dip_hw->dip_runner_thread.thread)) {
+		dev_err(&dip_dev->pdev->dev, "%s: unable to alloc workqueue\n",
+			__func__);
+		ret = PTR_ERR(dip_hw->dip_runner_thread.thread);
+		dip_hw->dip_runner_thread.thread = NULL;
+		goto err_create_thread;
+	}
+
+	scp_mem_va = scp_get_reserve_mem_virt(SCP_DIP_MEM_ID);
+	scp_daddr = scp_get_reserve_mem_phys(SCP_DIP_MEM_ID);
+	dip_hw->scp_workingbuf_addr = scp_daddr + DIP_SCP_WORKINGBUF_OFFSET;
+	dev_dbg(&dip_dev->pdev->dev,
+		"%s: scp_mem_va(%llx) ,pa(%pad)\n", __func__, scp_mem_va,
+		&scp_daddr);
+
+	scp_ipi_register(dip_hw->scp_pdev, SCP_IPI_DIP, dip_scp_handler, NULL);
+
+	for (i = 0; i < DIP_SUB_FRM_DATA_NUM; i++) {
+		u32 size_align;
+		struct mtk_dip_hw_subframe *buf;
+		struct sg_table *sgt;
+		struct page **pages;
+		u32 npages, j;
+
+		buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+		if (!buf) {
+			ret = -ENOMEM;
+			goto err_create_thread;
+		}
+
+		/*
+		 * Total: 0 ~ 72 KB
+		 * SubFrame: 0 ~ 16 KB
+		 */
+		buf->buffer.pa = scp_daddr + i * DIP_FRM_SZ;
+		buf->buffer.va = scp_mem_va + i * DIP_FRM_SZ;
+
+		/* Tuning: 16 ~ 48 KB */
+		buf->tuning_buf.pa = buf->buffer.pa + DIP_TUNING_OFFSET;
+		buf->tuning_buf.va = buf->buffer.va + DIP_TUNING_OFFSET;
+
+		/* Config_data: 48 ~ 72 KB */
+		buf->config_data.pa = buf->buffer.pa + DIP_COMP_OFFSET;
+		buf->config_data.va = buf->buffer.va + DIP_COMP_OFFSET;
+
+		/* Frame parameters: 72 ~ 76 KB */
+		buf->frameparam.pa = buf->buffer.pa + DIP_FRAMEPARAM_OFFSET;
+		buf->frameparam.va = buf->buffer.va + DIP_FRAMEPARAM_OFFSET;
+
+		/* get iova */
+		npages = (DIP_SUB_FRM_SZ + DIP_TUNING_SZ) >> PAGE_SHIFT;
+		pages = kmalloc_array(npages,
+				      sizeof(struct page *),
+				      GFP_KERNEL);
+		if (!pages) {
+			kfree(buf);
+			ret = -ENOMEM;
+			goto err_create_thread;
+		}
+
+		sgt = &buf->table;
+		for (j = 0; j < npages; j++)
+			pages[j] =
+				phys_to_page(buf->buffer.pa + j * PAGE_SIZE);
+
+		size_align = round_up(DIP_SUB_FRM_SZ + DIP_TUNING_SZ,
+				      PAGE_SIZE);
+		ret = sg_alloc_table_from_pages(sgt, pages, npages,
+						0, size_align, GFP_KERNEL);
+		if (ret < 0) {
+			dev_err(&dip_dev->pdev->dev,
+				"%s: failed to get sgt from pages\n", __func__);
+			ret = -ENOMEM;
+			kfree(pages);
+			kfree(buf);
+			goto err_create_thread;
+		}
+
+		dma_map_sg_attrs(&dip_dev->pdev->dev, sgt->sgl, sgt->nents,
+				 DMA_BIDIRECTIONAL, DMA_ATTR_SKIP_CPU_SYNC);
+		buf->buffer.iova = sg_dma_address(buf->table.sgl);
+		buf->tuning_buf.iova = buf->buffer.iova +
+			DIP_TUNING_OFFSET;
+
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s: buf(%d), pa(%x), iova(%llx)\n",
+			__func__, i, buf->buffer.pa, buf->buffer.iova);
+
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s: config_data(%d), pa(%x), va(%llx)\n",
+			__func__, i, buf->config_data.pa, buf->config_data.va);
+
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s: tuning_buf(%d), pa(%x), iova(%llx)\n",
+			__func__, i, buf->tuning_buf.pa, buf->tuning_buf.iova);
+
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s: frameparam(%d), pa(%x), va(%llx)\n",
+			__func__, i, buf->frameparam.pa, buf->frameparam.va);
+
+		list_add_tail(&buf->list_entry,
+			      &dip_hw->dip_freebufferlist.queue);
+		dip_hw->dip_freebufferlist.queue_cnt++;
+		kfree(pages);
+	}
+
+	atomic_set(&dip_hw->dip_state, DIP_STATE_OPENED);
+	return 0;
+
+err_create_thread:
+	mutex_destroy(&dip_hw->dip_useridlist.queuelock);
+	mutex_destroy(&dip_hw->dip_worklist.queuelock);
+	mutex_destroy(&dip_hw->dip_usedbufferlist.queuelock);
+	mutex_destroy(&dip_hw->dip_freebufferlist.queuelock);
+
+err_alloc_composer_wq:
+	destroy_workqueue(dip_hw->composer_wq);
+
+err_alloc_mdpcb_wq:
+	destroy_workqueue(dip_hw->mdpcb_workqueue);
+
+	return ret;
+}
+
+static int mtk_dip_hw_res_release(struct mtk_dip_hw *dip_hw)
+{
+	u32 i;
+	struct mtk_dip_dev *dip_dev = mtk_dip_hw_to_dev(dip_hw);
+	struct mtk_dip_hw_subframe *buf, *tmpbuf;
+	struct mtk_dip_hw_work *dip_work, *tmp_work;
+	struct mtk_dip_hw_user_id  *dip_userid, *tmp_id;
+
+	dev_dbg(&dip_dev->pdev->dev, "%s: composer work queue(%d)\n",
+		__func__, dip_hw->dip_worklist.queue_cnt);
+
+	mutex_lock(&dip_hw->dip_worklist.queuelock);
+	list_for_each_entry_safe(dip_work, tmp_work,
+				 &dip_hw->dip_worklist.queue,
+				 list_entry) {
+		list_del(&dip_work->list_entry);
+		dev_dbg(&dip_dev->pdev->dev, "%s: dip work frame no(%d)\n",
+			__func__, dip_work->frameparams.frame_no);
+		kfree(dip_work);
+		dip_hw->dip_worklist.queue_cnt--;
+	}
+	mutex_unlock(&dip_hw->dip_worklist.queuelock);
+
+	if (dip_hw->dip_worklist.queue_cnt != 0)
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s: dip_worklist is not empty(%d)\n",
+			__func__, dip_hw->dip_worklist.queue_cnt);
+
+	mutex_lock(&dip_hw->dip_useridlist.queuelock);
+	list_for_each_entry_safe(dip_userid, tmp_id,
+				 &dip_hw->dip_useridlist.queue,
+				 list_entry) {
+		list_del(&dip_userid->list_entry);
+		dev_dbg(&dip_dev->pdev->dev, "%s: dip user id(0x%x)\n",
+			__func__, dip_userid->id);
+		kfree(dip_userid);
+		dip_hw->dip_useridlist.queue_cnt--;
+	}
+	mutex_unlock(&dip_hw->dip_useridlist.queuelock);
+
+	if (dip_hw->dip_useridlist.queue_cnt != 0)
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s: dip_useridlist is not empty(%d)\n",
+			__func__, dip_hw->dip_useridlist.queue_cnt);
+
+	flush_workqueue(dip_hw->mdpcb_workqueue);
+	destroy_workqueue(dip_hw->mdpcb_workqueue);
+	dip_hw->mdpcb_workqueue = NULL;
+
+	flush_workqueue(dip_hw->composer_wq);
+	destroy_workqueue(dip_hw->composer_wq);
+	dip_hw->composer_wq = NULL;
+
+	atomic_set(&dip_hw->num_composing, 0);
+	atomic_set(&dip_hw->num_running, 0);
+
+	kthread_stop(dip_hw->dip_runner_thread.thread);
+	dip_hw->dip_runner_thread.thread = NULL;
+
+	atomic_set(&dip_hw->dip_user_cnt, 0);
+	atomic_set(&dip_hw->dip_stream_cnt, 0);
+	atomic_set(&dip_hw->dip_enque_cnt, 0);
+	atomic_set(&dip_hw->dip_state, 0);
+
+	/* All the buffer should be in the freebufferlist when release */
+	i = 0;
+	list_for_each_entry_safe(buf, tmpbuf,
+				 &dip_hw->dip_freebufferlist.queue,
+				 list_entry) {
+		struct sg_table *sgt = &buf->table;
+
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s: buf(%d) pa(%llx)\n", __func__, i,
+			buf->buffer.pa);
+		dip_hw->dip_freebufferlist.queue_cnt--;
+		dma_unmap_sg_attrs(&dip_dev->pdev->dev, sgt->sgl,
+				   sgt->orig_nents,
+				   DMA_BIDIRECTIONAL, DMA_ATTR_SKIP_CPU_SYNC);
+		sg_free_table(sgt);
+		list_del(&buf->list_entry);
+		kfree(buf);
+		buf = NULL;
+		i++;
+	}
+
+	if (dip_hw->dip_freebufferlist.queue_cnt != 0 &&
+	    i != DIP_SUB_FRM_DATA_NUM)
+		dev_err(&dip_dev->pdev->dev,
+			"%s: dip_freebufferlist is not empty (%d/%d)\n",
+			__func__, dip_hw->dip_freebufferlist.queue_cnt, i);
+
+	mutex_destroy(&dip_hw->dip_useridlist.queuelock);
+	mutex_destroy(&dip_hw->dip_worklist.queuelock);
+	mutex_destroy(&dip_hw->dip_usedbufferlist.queuelock);
+	mutex_destroy(&dip_hw->dip_freebufferlist.queuelock);
+
+	return 0;
+}
+
+static int mtk_dip_hw_flush_by_id(struct mtk_dip_hw *dip_hw,
+				  u16 id,
+			       struct mtk_dip_hw_user_id *user_id)
+{
+	struct mtk_dip_dev *dip_dev;
+	u32 num, err_cnt;
+	int ret;
+
+	dip_dev = mtk_dip_hw_to_dev(dip_hw);
+	err_cnt = 0;
+	do {
+		mutex_lock(&dip_hw->dip_useridlist.queuelock);
+		num = user_id->num;
+		mutex_unlock(&dip_hw->dip_useridlist.queuelock);
+
+		ret = wait_event_interruptible_timeout
+			(dip_hw->flushing_wq,
+			 (num == 0),
+			 msecs_to_jiffies(DIP_FLUSHING_WQ_TIMEOUT));
+		if (ret == -ERESTARTSYS)
+			dev_err(&dip_dev->pdev->dev,
+				"%s: interrupted by a signal, num(%d)\n",
+				__func__, num);
+		else if (ret == 0)
+			dev_dbg(&dip_dev->pdev->dev,
+				"%s: timeout num(%d)\n", __func__, num);
+		else
+			dev_dbg(&dip_dev->pdev->dev,
+				"%s: wakeup  num(%d)\n", __func__, num);
+
+		err_cnt++;
+		if (num > 0 && err_cnt >= DIP_MAX_ERR_COUNT) {
+			dev_err(&dip_dev->pdev->dev,
+				"%s: flushing is aborted, num(%d), err_cnt(%d)\n",
+				__func__, num, err_cnt);
+			return -EINVAL;
+		}
+
+	} while (num > 0);
+
+	dev_dbg(&dip_dev->pdev->dev, "Flushing is done num: %d\n", num);
+	return 0;
+}
+
+int mtk_dip_hw_connect(struct mtk_dip_hw *dip_hw)
+{
+	int ret;
+	s32 usercount;
+	struct mtk_dip_dev *dip_dev = mtk_dip_hw_to_dev(dip_hw);
+	struct img_ipi_param ipi_param;
+	phandle rproc_phandle;
+
+	mutex_lock(&dip_hw->hw_op_lock);
+	usercount = atomic_read(&dip_hw->dip_user_cnt);
+	if (!usercount) {
+		struct img_ipi_frameparam frameparam;
+
+		dip_hw->scp_pdev = scp_get_pdev(dip_dev->pdev);
+		if (!dip_hw->scp_pdev) {
+			dev_err(&dip_dev->pdev->dev,
+				"%s: failed to get scp device\n",
+				__func__);
+
+			goto failed_hw_connect;
+		}
+
+		if (of_property_read_u32(dip_dev->pdev->dev.of_node,
+					 "mediatek,scp",
+					 &rproc_phandle)) {
+			dev_err(&dip_dev->pdev->dev,
+				"%s: could not get scp device\n",
+				__func__);
+			goto failed_hw_connect;
+		}
+
+		dip_hw->rproc_handle = rproc_get_by_phandle(rproc_phandle);
+		if (!dip_hw->rproc_handle) {
+			dev_err(&dip_dev->pdev->dev,
+				"%s: could not get DIP's rproc_handle\n",
+				__func__);
+			goto failed_hw_connect;
+		}
+
+		ret = rproc_boot(dip_hw->rproc_handle);
+		if (ret) {
+			dev_err(&dip_dev->pdev->dev,
+				"%s: FW load failed(rproc:%p):%d\n",
+				__func__, dip_hw->rproc_handle,	ret);
+			goto failed_hw_connect;
+		}
+
+		dev_dbg(&dip_dev->pdev->dev, "%s: FW loaded(rproc:%p)\n",
+			__func__, dip_hw->rproc_handle);
+
+		ret = pm_runtime_get_sync(dip_hw->larb_dev);
+		if (ret < 0)
+			dev_warn(&dip_dev->pdev->dev,
+				 "Failed to increment the device's usage counter (%d)\n",
+				 ret);
+
+		ret = clk_bulk_prepare_enable(MTK_DIP_CLK_NUM, dip_hw->clks);
+		if (ret) {
+			dev_err(&dip_dev->pdev->dev, "failed to enable Larb5 and clks\n");
+			goto failed_hw_connect;
+		}
+
+		memset(&frameparam, 0, sizeof(frameparam));
+		/* SCP only support 32bits address */
+		frameparam.drv_data = (u64)dip_hw;
+		frameparam.state = FRAME_STATE_INIT;
+		ipi_param.usage = IMG_IPI_INIT;
+		dip_send(dip_hw->scp_pdev, SCP_IPI_DIP,
+			 (void *)&ipi_param, sizeof(ipi_param), 0);
+		ret = mtk_dip_hw_res_init(dip_hw);
+		if (ret)
+			goto failed_hw_connect;
+
+	} else {
+		ret = 0;
+	}
+	usercount = atomic_inc_return(&dip_hw->dip_user_cnt);
+	mutex_unlock(&dip_hw->hw_op_lock);
+
+	dev_dbg(&dip_dev->pdev->dev, "%s: dip_hw connected, usercount(%d)\n",
+		__func__, usercount);
+
+	return ret;
+failed_hw_connect:
+	dev_dbg(&dip_dev->pdev->dev, "%s: dip_hw connect failed, usercount(%d)\n",
+		__func__, usercount);
+	mutex_unlock(&dip_hw->hw_op_lock);
+
+	return  -EINVAL;
+}
+
+int mtk_dip_hw_disconnect(struct mtk_dip_hw *dip_hw)
+{
+	struct mtk_dip_dev *dip_dev = mtk_dip_hw_to_dev(dip_hw);
+	s32 usercount;
+	int ret;
+
+	mutex_lock(&dip_hw->hw_op_lock);
+	usercount = atomic_read(&dip_hw->dip_user_cnt);
+	if (usercount > 0 && atomic_dec_and_test(&dip_hw->dip_user_cnt)) {
+		ret = mtk_dip_hw_res_release(dip_hw);
+		if (ret)
+			dev_err(&dip_dev->pdev->dev,
+				"%s: Got some error(%d) when releasing hw resource\n",
+				__func__, ret);
+
+		clk_bulk_disable_unprepare(MTK_DIP_CLK_NUM, dip_hw->clks);
+
+		ret = pm_runtime_put_sync(dip_hw->larb_dev);
+		if (ret < 0) {
+			dev_warn(&dip_dev->pdev->dev,
+				 "Failed to decrement the device's usage counter (%d)\n",
+				 ret);
+			goto failed_hw_disconnect;
+		}
+	}
+
+	mutex_unlock(&dip_hw->hw_op_lock);
+
+	dev_dbg(&dip_dev->pdev->dev,
+		"%s: dip_hw disconnected, usercount(%d)\n",
+		__func__, atomic_read(&dip_hw->dip_user_cnt));
+
+	return 0;
+
+failed_hw_disconnect:
+	mutex_unlock(&dip_hw->hw_op_lock);
+	return  -EINVAL;
+}
+
+int mtk_dip_hw_streamon(struct mtk_dip_hw  *dip_hw, u16 id)
+{
+	struct mtk_dip_dev *dip_dev = mtk_dip_hw_to_dev(dip_hw);
+	struct mtk_dip_hw_user_id *user_id;
+	s32 count, len;
+
+	if (atomic_read(&dip_hw->dip_state) == DIP_STATE_INIT) {
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s id: %x failed due to incomplete open\n",
+			__func__, id);
+		return -EBUSY;
+	}
+
+	count = atomic_inc_return(&dip_hw->dip_stream_cnt);
+
+	dev_dbg(&dip_dev->pdev->dev, "%s: id(0x%x)\n", __func__, id);
+
+	user_id = kzalloc(sizeof(*user_id), GFP_KERNEL);
+	if (!user_id)
+		return -ENOMEM;
+
+	user_id->id = id;
+	user_id->state = DIP_STATE_STREAMON;
+
+	mutex_lock(&dip_hw->dip_useridlist.queuelock);
+	list_add_tail(&user_id->list_entry, &dip_hw->dip_useridlist.queue);
+	dip_hw->dip_useridlist.queue_cnt++;
+	len = dip_hw->dip_useridlist.queue_cnt;
+	mutex_unlock(&dip_hw->dip_useridlist.queuelock);
+
+	dev_dbg(&dip_dev->pdev->dev,
+		"%s: stream count(%d),id(0x%x),len(%d)\n", __func__,
+		count, id, len);
+
+	return 0;
+}
+
+int mtk_dip_hw_streamoff(struct mtk_dip_hw  *dip_hw, u16 id)
+{
+	struct mtk_dip_hw_user_id *user_id;
+	struct mtk_dip_dev *dip_dev = mtk_dip_hw_to_dev(dip_hw);
+	s32 count = -1;
+	bool found = false;
+	int ret;
+
+	dev_dbg(&dip_dev->pdev->dev, "%s: streamoff id(0x%x)\n",
+		__func__, id);
+
+	mutex_lock(&dip_hw->dip_useridlist.queuelock);
+	list_for_each_entry(user_id,
+			    &dip_hw->dip_useridlist.queue, list_entry) {
+		if (user_id->id == id) {
+			user_id->state = DIP_STATE_STREAMOFF;
+			found = true;
+			break;
+		}
+	}
+	mutex_unlock(&dip_hw->dip_useridlist.queuelock);
+
+	if (found) {
+		ret = mtk_dip_hw_flush_by_id(dip_hw, id, user_id);
+		if (ret != 0) {
+			dev_err(&dip_dev->pdev->dev,
+				"%s: stream id(0x%x), streamoff err(%d)\n",
+				__func__, id, ret);
+			WARN_ON(1);
+		}
+
+		mutex_lock(&dip_hw->dip_useridlist.queuelock);
+		list_del(&user_id->list_entry);
+		dip_hw->dip_useridlist.queue_cnt--;
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s: stream id(%x), user_id cnt(%d)\n",
+			__func__, id, dip_hw->dip_useridlist.queue_cnt);
+		mutex_unlock(&dip_hw->dip_useridlist.queuelock);
+
+		kfree(user_id);
+		user_id = NULL;
+		count = atomic_dec_return(&dip_hw->dip_stream_cnt);
+
+		dev_dbg(&dip_dev->pdev->dev, "%s: stream id(%d),cnt(%d)\n",
+			__func__, id, count);
+	} else {
+		dev_dbg(&dip_dev->pdev->dev,
+			"%s: stream id(%x) not found\n",
+			__func__, id);
+	}
+
+	if (count < 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+int mtk_dip_hw_enqueue(struct mtk_dip_hw *dip_hw,
+		       struct img_ipi_frameparam *frameparams)
+{
+	struct mtk_dip_hw_work *framework = NULL;
+	struct mtk_dip_hw_user_id *user_id = NULL;
+	struct mtk_dip_dev *dip_dev = mtk_dip_hw_to_dev(dip_hw);
+	struct mtk_dip_hw_submit_work *submit_work;
+	bool found = false;
+	u32 tmpcount;
+	int ret;
+
+	dev_dbg(&dip_dev->pdev->dev, "%s: frame idx(0x%x)",
+		__func__, frameparams->index);
+
+	mutex_lock(&dip_hw->dip_useridlist.queuelock);
+	list_for_each_entry(user_id, &dip_hw->dip_useridlist.queue,
+			    list_entry) {
+		if (mtk_dip_pipe_get_pipe_from_job_id(frameparams->index) ==
+			user_id->id) {
+			user_id->num++;
+			dev_dbg(&dip_dev->pdev->dev,
+				"%s: user_id(%x) found, current num(%d)\n",
+				__func__, user_id->id, user_id->num);
+			found = true;
+			break;
+		}
+	}
+	mutex_unlock(&dip_hw->dip_useridlist.queuelock);
+
+	if (!found) {
+		dev_err(&dip_dev->pdev->dev,
+			"%s: user_id(0x%x) not found, idx(0x%x)\n",
+			__func__,
+			mtk_dip_pipe_get_pipe_from_job_id(frameparams->index),
+			frameparams->index);
+		return -EINVAL;
+	}
+
+	framework = kzalloc(sizeof(*framework), GFP_KERNEL);
+	if (!framework)
+		return -ENOMEM;
+
+	memcpy(&framework->frameparams, frameparams, sizeof(*frameparams));
+	framework->frameparams.state = FRAME_STATE_INIT;
+	framework->frameparams.frame_no =
+		atomic_inc_return(&dip_hw->dip_enque_cnt);
+	framework->user_id = user_id;
+
+	mutex_lock(&dip_hw->dip_worklist.queuelock);
+	list_add_tail(&framework->list_entry, &dip_hw->dip_worklist.queue);
+	dip_hw->dip_worklist.queue_cnt++;
+	tmpcount = dip_hw->dip_worklist.queue_cnt;
+	mutex_unlock(&dip_hw->dip_worklist.queuelock);
+	dev_dbg(&dip_dev->pdev->dev,
+		"%s: frame_no(%d) into worklist, cnt(%d)\n",
+		__func__, framework->frameparams.frame_no, tmpcount);
+
+	submit_work = kzalloc(sizeof(*submit_work), GFP_KERNEL);
+	INIT_WORK(&submit_work->frame_work, dip_submit_worker);
+	submit_work->dip_hw = dip_hw;
+	ret = queue_work(dip_hw->composer_wq, &submit_work->frame_work);
+	if (!ret) {
+		dev_dbg(&dip_dev->pdev->dev,
+			"frame_no(%d) queue_work failed, already on a queue\n",
+			framework->frameparams.frame_no, ret);
+
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mtk_dip_probe(struct platform_device *pdev)
+{
+	struct mtk_dip_dev *dip_dev;
+	struct mtk_dip_hw *dip_hw;
+	struct device_node *node;
+	struct platform_device *larb_pdev;
+	int ret = 0;
+
+	dip_dev = devm_kzalloc(&pdev->dev, sizeof(*dip_dev), GFP_KERNEL);
+	if (!dip_dev)
+		return -ENOMEM;
+
+	dip_dev->pdev = pdev;
+	dev_set_drvdata(&pdev->dev, dip_dev);
+	dip_hw = &dip_dev->dip_hw;
+
+	node = of_parse_phandle(pdev->dev.of_node, "mediatek,larb", 0);
+	if (!node) {
+		dev_err(&pdev->dev, "No mediatek,larb found");
+		return -EINVAL;
+	}
+
+	larb_pdev = of_find_device_by_node(node);
+	if (!larb_pdev) {
+		dev_err(&pdev->dev, "No mediatek,larb device found");
+		return -EINVAL;
+	}
+
+	dip_hw->larb_dev = &larb_pdev->dev;
+	dip_hw->clks[0].id = "DIP_CG_IMG_LARB5";
+	dip_hw->clks[1].id = "DIP_CG_IMG_DIP";
+
+	ret = devm_clk_bulk_get(&pdev->dev, MTK_DIP_CLK_NUM,
+				dip_hw->clks);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to get LARB5 and DIP clks:%d\n",
+			ret);
+		return ret;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	atomic_set(&dip_hw->dip_user_cnt, 0);
+	atomic_set(&dip_hw->dip_stream_cnt, 0);
+	atomic_set(&dip_hw->dip_enque_cnt, 0);
+	atomic_set(&dip_hw->dip_state, 0);
+	atomic_set(&dip_hw->num_composing, 0);
+	atomic_set(&dip_hw->num_running, 0);
+	dip_hw->dip_worklist.queue_cnt = 0;
+	mutex_init(&dip_hw->hw_op_lock);
+
+	ret = mtk_dip_dev_v4l2_init(dip_dev);
+	if (ret)
+		dev_err(&pdev->dev, "v4l2 init failed(%d)\n", ret);
+
+	dev_info(&pdev->dev, "DIP driver probe\n");
+
+	return ret;
+}
+
+static int mtk_dip_remove(struct platform_device *pdev)
+{
+	struct mtk_dip_dev *dip_dev = dev_get_drvdata(&pdev->dev);
+
+	mtk_dip_dev_v4l2_release(dip_dev);
+	pm_runtime_disable(&pdev->dev);
+	mutex_destroy(&dip_dev->dip_hw.hw_op_lock);
+
+	return 0;
+}
+
+static int __maybe_unused mtk_dip_pm_suspend(struct device *dev)
+{
+	struct mtk_dip_dev *dip_dev = dev_get_drvdata(dev);
+	int ret;
+
+	if (atomic_read(&dip_dev->dip_hw.dip_user_cnt) > 0) {
+		clk_bulk_disable_unprepare(MTK_DIP_CLK_NUM,
+					   dip_dev->dip_hw.clks);
+
+		ret = pm_runtime_put_sync(dip_dev->dip_hw.larb_dev);
+		if (ret < 0)
+			dev_warn(&dip_dev->pdev->dev,
+				 "Failed to decrement the device's usage counter (%d)\n",
+				 ret);
+	}
+
+	return 0;
+}
+
+static int __maybe_unused mtk_dip_pm_resume(struct device *dev)
+{
+	struct mtk_dip_dev *dip_dev = dev_get_drvdata(dev);
+	int ret;
+
+	if (atomic_read(&dip_dev->dip_hw.dip_user_cnt) > 0) {
+		ret = pm_runtime_get_sync(dip_dev->dip_hw.larb_dev);
+		if (ret < 0)
+			dev_warn(&dip_dev->pdev->dev,
+				 "Failed to increment the device's usage counter (%d)\n",
+				 ret);
+
+		ret = clk_bulk_prepare_enable(MTK_DIP_CLK_NUM,
+					      dip_dev->dip_hw.clks);
+		if (ret) {
+			dev_err(&dip_dev->pdev->dev, "failed to enable Larb5 and clks\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int __maybe_unused mtk_dip_suspend(struct device *dev)
+{
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	return mtk_dip_pm_suspend(dev);
+}
+
+static int __maybe_unused mtk_dip_resume(struct device *dev)
+{
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	return mtk_dip_pm_resume(dev);
+}
+
+static const struct dev_pm_ops mtk_dip_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mtk_dip_suspend, mtk_dip_resume)
+	SET_RUNTIME_PM_OPS(mtk_dip_suspend, mtk_dip_resume, NULL)
+};
+
+static const struct of_device_id mtk_dip_of_match[] = {
+	{ .compatible = "mediatek,mt8183-dip", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, mtk_dip_of_match);
+
+static struct platform_driver mtk_dip_driver = {
+	.probe   = mtk_dip_probe,
+	.remove  = mtk_dip_remove,
+	.driver  = {
+		.name  = DIP_DEV_NAME,
+		.pm     = &mtk_dip_pm_ops,
+		.of_match_table = mtk_dip_of_match,
+	}
+};
+
+module_platform_driver(mtk_dip_driver);
+
+MODULE_DESCRIPTION("Mediatek Camera DIP V4L2 driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-v4l2.c b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-v4l2.c
new file mode 100644
index 000000000000..29fc629493e1
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-v4l2.c
@@ -0,0 +1,1713 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/platform_device.h>
+#include <linux/videodev2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-event.h>
+#include "mtk_dip-dev.h"
+#include "mtk_dip-hw.h"
+#include "mtk-mdp3-regs.h"
+
+static int mtk_dip_subdev_open(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_fh *fh)
+{
+	struct mtk_dip_pipe *dip_pipe = mtk_dip_subdev_to_pipe(sd);
+	struct mtk_dip_dev *dip_dev =
+		dev_get_drvdata(&dip_pipe->dip_dev->pdev->dev);
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s:%s: pipe(%d) connects to dip_hw\n",
+		__func__, dip_pipe->desc->name,
+		dip_pipe->desc->id);
+
+	dip_pipe->fh = fh;
+
+	mtk_dip_pipe_init_job_infos(dip_pipe);
+
+	return mtk_dip_hw_connect(&dip_dev->dip_hw);
+}
+
+static int mtk_dip_subdev_close(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh)
+{
+	struct mtk_dip_pipe *dip_pipe = mtk_dip_subdev_to_pipe(sd);
+	struct mtk_dip_dev *dip_dev =
+		dev_get_drvdata(&dip_pipe->dip_dev->pdev->dev);
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s:%s: pipe(%d) disconnect to dip_hw\n",
+		__func__, dip_pipe->desc->name,
+		dip_pipe->desc->id);
+
+	return mtk_dip_hw_disconnect(&dip_dev->dip_hw);
+}
+
+static int mtk_dip_subdev_s_stream(struct v4l2_subdev *sd,
+				   int enable)
+{
+	struct mtk_dip_pipe *dip_pipe = mtk_dip_subdev_to_pipe(sd);
+	int ret;
+
+	if (enable)
+		ret = mtk_dip_pipe_streamon(dip_pipe);
+	else
+		ret = mtk_dip_pipe_streamoff(dip_pipe);
+
+	return ret;
+}
+
+static int mtk_dip_subdev_subscribe_event(struct v4l2_subdev *subdev,
+					  struct v4l2_fh *fh,
+					  struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_CTRL:
+		return v4l2_ctrl_subscribe_event(fh, sub);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int mtk_dip_subdev_get_fmt(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct mtk_dip_pipe *dip_pipe = mtk_dip_subdev_to_pipe(sd);
+	struct v4l2_mbus_framefmt *mf;
+
+	u32 pad = fmt->pad;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		fmt->format = dip_pipe->nodes[pad].pad_fmt;
+	} else {
+		mf = v4l2_subdev_get_try_format(sd, cfg, pad);
+		fmt->format = *mf;
+	}
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"get(try:%d) node:%s(pad:%d)fmt: %dx%d",
+		fmt->which, dip_pipe->nodes[pad].desc->name, pad,
+		fmt->format.width, fmt->format.height);
+
+	return 0;
+}
+
+static int mtk_dip_subdev_set_fmt(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct mtk_dip_pipe *dip_pipe = mtk_dip_subdev_to_pipe(sd);
+	struct v4l2_mbus_framefmt *mf;
+	u32 pad = fmt->pad;
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev, "set(try:%d) node:%s(pad:%d)fmt: %dx%d",
+		fmt->which, dip_pipe->nodes[pad].desc->name, pad,
+		fmt->format.width, fmt->format.height);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		mf = v4l2_subdev_get_try_format(sd, cfg, pad);
+	else
+		mf = &dip_pipe->nodes[pad].pad_fmt;
+
+	fmt->format.code = mf->code;
+
+	/* Clamp the w and h based on the hardware capabilities */
+	if (dip_pipe->subdev_pads[pad].flags & MEDIA_PAD_FL_SOURCE) {
+		fmt->format.width = clamp(fmt->format.width,
+					  MTK_DIP_CAPTURE_MIN_WIDTH,
+					  MTK_DIP_CAPTURE_MAX_WIDTH);
+		fmt->format.height = clamp(fmt->format.height,
+					   MTK_DIP_CAPTURE_MIN_HEIGHT,
+					   MTK_DIP_CAPTURE_MAX_HEIGHT);
+	} else {
+		fmt->format.width = clamp(fmt->format.width,
+					  MTK_DIP_OUTPUT_MIN_WIDTH,
+					  MTK_DIP_OUTPUT_MAX_WIDTH);
+		fmt->format.height = clamp(fmt->format.height,
+					   MTK_DIP_OUTPUT_MIN_WIDTH,
+					   MTK_DIP_OUTPUT_MAX_WIDTH);
+	}
+
+	*mf = fmt->format;
+
+	return 0;
+}
+
+static int mtk_dip_subdev_get_selection(struct v4l2_subdev *sd,
+					struct v4l2_subdev_pad_config *cfg,
+					struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *try_sel, *r;
+	struct mtk_dip_pipe *dip_pipe = mtk_dip_subdev_to_pipe(sd);
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"get subdev %s sel which %d target 0x%4x rect [%dx%d]",
+		dip_pipe->desc->name, sel->which, sel->target,
+		sel->r.width, sel->r.height);
+
+	if (sel->pad != MTK_DIP_VIDEO_NODE_ID_MDP0_CAPTURE &&
+	    sel->pad != MTK_DIP_VIDEO_NODE_ID_MDP1_CAPTURE) {
+		dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+			"g_select failed(%s:%d):not support\n",
+			dip_pipe->nodes[sel->pad].desc->name, sel->pad);
+		return -EINVAL;
+	}
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP:
+		try_sel = v4l2_subdev_get_try_crop(sd, cfg, sel->pad);
+		r = &dip_pipe->nodes[sel->pad].crop;  /* effective resolution */
+		break;
+	default:
+		dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+			"s_select failed(%s:%d):target(%d) not support\n",
+			dip_pipe->nodes[sel->pad].desc->name, sel->pad,
+			sel->target);
+		return -EINVAL;
+	}
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY)
+		sel->r = *try_sel;
+	else
+		sel->r = *r;
+
+	return 0;
+}
+
+static int mtk_dip_subdev_set_selection(struct v4l2_subdev *sd,
+					struct v4l2_subdev_pad_config *cfg,
+					struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect, *try_sel;
+	struct mtk_dip_pipe *dip_pipe = mtk_dip_subdev_to_pipe(sd);
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"set subdev %s sel which %d target 0x%4x rect [%dx%d]",
+		dip_pipe->desc->name, sel->which, sel->target,
+		sel->r.width, sel->r.height);
+
+	if (sel->pad != MTK_DIP_VIDEO_NODE_ID_MDP0_CAPTURE &&
+	    sel->pad != MTK_DIP_VIDEO_NODE_ID_MDP1_CAPTURE) {
+		dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+			"g_select failed(%s:%d):not support\n",
+			dip_pipe->nodes[sel->pad].desc->name, sel->pad);
+		return -EINVAL;
+	}
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP:
+		try_sel = v4l2_subdev_get_try_crop(sd, cfg, sel->pad);
+		rect = &dip_pipe->nodes[sel->pad].crop;
+		break;
+	default:
+		dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+			"s_select failed(%s:%d):target(%d) not support\n",
+			dip_pipe->nodes[sel->pad].desc->name, sel->pad,
+			sel->target);
+		return -EINVAL;
+	}
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY)
+		*try_sel = sel->r;
+	else
+		*rect = sel->r;
+
+	return 0;
+}
+
+static int mtk_dip_link_setup(struct media_entity *entity,
+			      const struct media_pad *local,
+			      const struct media_pad *remote, u32 flags)
+{
+	struct mtk_dip_pipe *dip_pipe =
+		container_of(entity, struct mtk_dip_pipe, subdev.entity);
+	u32 pad = local->index;
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s: link setup, flags(0x%x), (%s)%d -->(%s)%d\n",
+		dip_pipe->desc->name,
+		flags,
+		local->entity->name,
+		local->index,
+		remote->entity->name,
+		remote->index);
+
+	WARN_ON(entity->obj_type != MEDIA_ENTITY_TYPE_V4L2_SUBDEV);
+
+	WARN_ON(pad >= dip_pipe->num_nodes);
+
+	dip_pipe->nodes[pad].enabled = !!(flags & MEDIA_LNK_FL_ENABLED);
+
+	return 0;
+}
+
+static int mtk_dip_vb2_buf_prepare(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+
+	v4l2_buf->field = V4L2_FIELD_NONE;
+	return 0;
+}
+
+static int mtk_dip_vb2_buf_out_validate(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+
+	v4l2_buf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static void mtk_dip_vb2_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+
+	v4l2_buf->field = V4L2_FIELD_NONE;
+}
+
+static int mtk_dip_vb2_queue_setup(struct vb2_queue *vq,
+				   unsigned int *num_buffers,
+				   unsigned int *num_planes,
+				   unsigned int sizes[],
+				   struct device *alloc_devs[])
+{
+	struct mtk_dip_pipe *dip_pipe = vb2_get_drv_priv(vq);
+	struct mtk_dip_video_device *node =
+		mtk_dip_vbq_to_node(vq);
+	struct device *dev = &dip_pipe->dip_dev->pdev->dev;
+	struct device *buf_alloc_ctx;
+
+	/* Get V4L2 format with the following method */
+	const struct v4l2_format *fmt = &node->vdev_fmt;
+	unsigned int size;
+
+	*num_buffers = clamp_val(*num_buffers, 1, VB2_MAX_FRAME);
+
+	if (node->desc->smem_alloc) {
+		buf_alloc_ctx = &dip_pipe->smem_alloc_dev->dev;
+		dev_dbg(dev, "%s:%s: select smem_vb2_alloc_ctx(%p)\n",
+			dip_pipe->desc->name,
+			node->desc->name,
+			buf_alloc_ctx);
+	} else {
+		buf_alloc_ctx = &dip_pipe->dip_dev->pdev->dev;
+		dev_dbg(dev, "%s:%s: select default_vb2_alloc_ctx(%p)\n",
+			dip_pipe->desc->name,
+			node->desc->name,
+			buf_alloc_ctx);
+	}
+
+	alloc_devs[0] = buf_alloc_ctx;
+	vq->dma_attrs |= DMA_ATTR_NON_CONSISTENT;
+
+	if (vq->type == V4L2_BUF_TYPE_META_CAPTURE ||
+	    vq->type == V4L2_BUF_TYPE_META_OUTPUT)
+		size = fmt->fmt.meta.buffersize;
+	else
+		size = fmt->fmt.pix_mp.plane_fmt[0].sizeimage;
+
+	if (*num_planes) {
+		if (sizes[0] < size) {
+			dev_dbg(dev, "%s:%s:%s: size error(user:%d, max:%d)\n",
+				__func__, dip_pipe->desc->name,
+				node->desc->name, sizes[0], size);
+			return -EINVAL;
+		}
+	} else {
+		*num_planes = 1;
+		sizes[0] = size;
+	}
+
+	dev_dbg(dev, "%s:%s:%s: n_planes(%d), n_bufs(%d), size(%d)\n",
+		__func__, dip_pipe->desc->name,
+		node->desc->name, *num_planes, *num_buffers, sizes[0]);
+
+	return 0;
+}
+
+static int
+	mtk_dip_all_nodes_streaming(struct mtk_dip_pipe *dip_pipe,
+				    struct mtk_dip_video_device *except)
+{
+	int i;
+
+	for (i = 0; i < dip_pipe->num_nodes; i++) {
+		struct mtk_dip_video_device *node = &dip_pipe->nodes[i];
+
+		if (node == except)
+			continue;
+		if (node->enabled &&
+		    !vb2_start_streaming_called(&node->dev_q.vbq))
+			return 0;
+	}
+
+	return 1;
+}
+
+static void mtk_dip_return_all_buffers(struct mtk_dip_pipe *dip_pipe,
+				       struct mtk_dip_video_device *node,
+				       enum vb2_buffer_state state)
+{
+	int i;
+
+	for (i = 0; i < node->dev_q.vbq.num_buffers; i++) {
+		if (node->dev_q.vbq.bufs[i]->state ==
+			VB2_BUF_STATE_ACTIVE)
+			vb2_buffer_done(node->dev_q.vbq.bufs[i],
+					state);
+	}
+}
+
+static int mtk_dip_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	struct mtk_dip_pipe *dip_pipe = vb2_get_drv_priv(vq);
+	struct mtk_dip_video_device *node =
+		mtk_dip_vbq_to_node(vq);
+	int ret;
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s:%s:%s\n",
+		dip_pipe->desc->name, node->desc->name,
+		__func__);
+
+	if (!node->enabled) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"%s:%s: stream on failed, node is not enabled\n",
+			dip_pipe->desc->name, node->desc->name);
+		ret = -EINVAL;
+		goto fail_return_bufs;
+	}
+
+	ret = media_pipeline_start(&node->vdev.entity, &dip_pipe->pipeline);
+
+	if (ret < 0) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"%s:%s: media_pipeline_start failed(%d)\n",
+			dip_pipe->desc->name, node->desc->name,
+			ret);
+		goto fail_return_bufs;
+	}
+
+	if (!mtk_dip_all_nodes_streaming(dip_pipe, node))
+		return 0;
+
+	/* Start streaming of the whole pipeline */
+	ret = v4l2_subdev_call(&dip_pipe->subdev, video, s_stream, 1);
+	if (ret < 0) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"%s:%s: sub dev s_stream(1) failed(%d)\n",
+			dip_pipe->desc->name, node->desc->name,
+			ret);
+		goto fail_stop_pipeline;
+	}
+	return 0;
+
+fail_stop_pipeline:
+	media_pipeline_stop(&node->vdev.entity);
+fail_return_bufs:
+	mtk_dip_return_all_buffers(dip_pipe, node, VB2_BUF_STATE_QUEUED);
+
+	return ret;
+}
+
+static void mtk_dip_vb2_stop_streaming(struct vb2_queue *vq)
+{
+	struct mtk_dip_pipe *dip_pipe = vb2_get_drv_priv(vq);
+	struct mtk_dip_video_device *node =
+		mtk_dip_vbq_to_node(vq);
+	int ret;
+
+	WARN_ON(!node->enabled);
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s:%s:%s\n",
+		dip_pipe->desc->name, node->desc->name,
+		__func__);
+
+	if (mtk_dip_all_nodes_streaming(dip_pipe, node)) {
+		ret = v4l2_subdev_call(&dip_pipe->subdev, video, s_stream, 0);
+
+	if (ret)
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"%s:%s: sub dev s_stream(0) failed(%d)\n",
+			dip_pipe->desc->name, node->desc->name,
+			ret);
+	}
+
+	mtk_dip_return_all_buffers(dip_pipe, node, VB2_BUF_STATE_ERROR);
+	media_pipeline_stop(&node->vdev.entity);
+}
+
+static void mtk_dip_vb2_request_complete(struct vb2_buffer *vb)
+{
+	struct mtk_dip_video_device *node =
+		mtk_dip_vbq_to_node(vb->vb2_queue);
+
+	v4l2_ctrl_request_complete(vb->req_obj.req,
+				   &node->ctrl_handler);
+}
+
+static u32 mtk_dip_node_get_v4l2_cap(struct mtk_dip_pipe *dip_pipe,
+				     struct mtk_dip_video_device *node)
+{
+	return node->desc->cap;
+}
+
+static int mtk_dip_videoc_querycap(struct file *file, void *fh,
+				   struct v4l2_capability *cap)
+{
+	struct mtk_dip_pipe *dip_pipe = video_drvdata(file);
+
+	strlcpy(cap->driver, dip_pipe->desc->name,
+		sizeof(cap->driver));
+	strlcpy(cap->card, dip_pipe->desc->name,
+		sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info),
+		 "platform:%s", dev_name(dip_pipe->dip_dev->mdev.dev));
+
+	return 0;
+}
+
+static int mtk_dip_videoc_try_fmt(struct file *file,
+				  void *fh,
+	 struct v4l2_format *f)
+{
+	struct mtk_dip_pipe *dip_pipe = video_drvdata(file);
+	struct mtk_dip_video_device *node = mtk_dip_file_to_node(file);
+	struct v4l2_format try_fmt;
+	int ret;
+
+	memset(&try_fmt, 0, sizeof(try_fmt));
+
+	try_fmt.type = node->dev_q.vbq.type;
+
+	ret = mtk_dip_pipe_set_img_fmt(dip_pipe, node, &f->fmt.pix_mp,
+				       &try_fmt.fmt.pix_mp);
+
+	if (ret)
+		mtk_dip_pipe_load_default_fmt(dip_pipe, node, &try_fmt);
+
+	*f = try_fmt;
+
+	return 0;
+}
+
+static int mtk_dip_videoc_g_fmt(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct mtk_dip_video_device *node = mtk_dip_file_to_node(file);
+
+	*f = node->vdev_fmt;
+
+	return 0;
+}
+
+static int mtk_dip_videoc_s_fmt(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct mtk_dip_video_device *node = mtk_dip_file_to_node(file);
+	struct mtk_dip_pipe *dip_pipe = video_drvdata(file);
+
+	int ret;
+
+	if (dip_pipe->streaming)
+		return -EBUSY;
+
+	ret = mtk_dip_videoc_try_fmt(file, fh, f);
+
+	if (!ret) {
+		node->vdev_fmt = *f;
+		/* reset crop setting of nodes */
+		node->crop.left = 0;
+		node->crop.top = 0;
+		node->crop.width = f->fmt.pix_mp.width;
+		node->crop.height = f->fmt.pix_mp.height;
+		node->compose.left = 0;
+		node->compose.top = 0;
+		node->compose.width = f->fmt.pix_mp.width;
+		node->compose.height = f->fmt.pix_mp.height;
+	}
+
+	return 0;
+}
+
+static int mtk_dip_videoc_enum_framesizes(struct file *file,
+					  void *priv,
+					  struct v4l2_frmsizeenum *sizes)
+{
+	struct mtk_dip_pipe *dip_pipe = video_drvdata(file);
+	struct mtk_dip_video_device *node = mtk_dip_file_to_node(file);
+	struct mtk_dip_dev_format *dev_fmt;
+
+	dev_fmt = mtk_dip_pipe_find_fmt(dip_pipe, node, sizes->pixel_format);
+
+	if (!dev_fmt || sizes->index)
+		return -EINVAL;
+
+	sizes->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
+
+	if (V4L2_TYPE_IS_OUTPUT(node->desc->buf_type)) {
+		sizes->stepwise.max_width = MTK_DIP_OUTPUT_MAX_WIDTH;
+		sizes->stepwise.min_width = MTK_DIP_OUTPUT_MIN_WIDTH;
+		sizes->stepwise.max_height = MTK_DIP_OUTPUT_MAX_HEIGHT;
+		sizes->stepwise.min_height = MTK_DIP_OUTPUT_MIN_HEIGHT;
+		sizes->stepwise.step_height = 1;
+		sizes->stepwise.step_width = 1;
+	} else {
+		sizes->stepwise.max_width = MTK_DIP_CAPTURE_MAX_WIDTH;
+		sizes->stepwise.min_width = MTK_DIP_CAPTURE_MIN_WIDTH;
+		sizes->stepwise.max_height = MTK_DIP_CAPTURE_MAX_HEIGHT;
+		sizes->stepwise.min_height = MTK_DIP_CAPTURE_MIN_HEIGHT;
+		sizes->stepwise.step_height = 1;
+		sizes->stepwise.step_width = 1;
+	}
+
+	return 0;
+}
+
+static int mtk_dip_videoc_enum_fmt(struct file *file, void *fh,
+				   struct v4l2_fmtdesc *f)
+{
+	struct mtk_dip_video_device *node = mtk_dip_file_to_node(file);
+
+	if (f->index > node->desc->num_fmts ||
+	    f->type != node->dev_q.vbq.type)
+		return -EINVAL;
+
+	strscpy(f->description, node->desc->description,
+		sizeof(f->description));
+
+	f->pixelformat = node->desc->fmts[f->index].fmt.img.pixelformat;
+	f->flags = 0;
+
+	return 0;
+}
+
+static int mtk_dip_meta_enum_format(struct file *file,
+				    void *fh, struct v4l2_fmtdesc *f)
+{
+	struct mtk_dip_video_device *node = mtk_dip_file_to_node(file);
+
+	if (f->index > 0 || f->type != node->dev_q.vbq.type)
+		return -EINVAL;
+
+	strscpy(f->description, node->desc->description,
+		sizeof(f->description));
+
+	f->pixelformat = node->vdev_fmt.fmt.meta.dataformat;
+
+	return 0;
+}
+
+static int mtk_dip_videoc_g_meta_fmt(struct file *file,
+				     void *fh, struct v4l2_format *f)
+{
+	struct mtk_dip_video_device *node = mtk_dip_file_to_node(file);
+	*f = node->vdev_fmt;
+
+	return 0;
+}
+
+static int
+mtk_dip_vidioc_subscribe_event(struct v4l2_fh *fh,
+			       const struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_CTRL:
+		return v4l2_ctrl_subscribe_event(fh, sub);
+	default:
+		return -EINVAL;
+	}
+}
+
+/******************** function pointers ********************/
+
+/* subdev internal operations */
+static const struct v4l2_subdev_internal_ops mtk_dip_subdev_internal_ops = {
+	.open = mtk_dip_subdev_open,
+	.close = mtk_dip_subdev_close,
+};
+
+static const struct v4l2_subdev_core_ops mtk_dip_subdev_core_ops = {
+	.subscribe_event = mtk_dip_subdev_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops mtk_dip_subdev_video_ops = {
+	.s_stream = mtk_dip_subdev_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops mtk_dip_subdev_pad_ops = {
+	.link_validate = v4l2_subdev_link_validate_default,
+	.get_fmt = mtk_dip_subdev_get_fmt,
+	.set_fmt = mtk_dip_subdev_set_fmt,
+	.get_selection = mtk_dip_subdev_get_selection,
+	.set_selection = mtk_dip_subdev_set_selection,
+};
+
+static const struct v4l2_subdev_ops mtk_dip_subdev_ops = {
+	.core = &mtk_dip_subdev_core_ops,
+	.video = &mtk_dip_subdev_video_ops,
+	.pad = &mtk_dip_subdev_pad_ops,
+};
+
+static const struct media_entity_operations mtk_dip_media_ops = {
+	.link_setup = mtk_dip_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int mtk_dip_request_buf_validate(struct media_request *req,
+					int all_enable_node_need_buf)
+{
+	struct media_request_object *obj;
+	struct mtk_dip_pipe *dip_pipe;
+	struct mtk_dip_pipe *dip_dev_first;
+	struct vb2_buffer *vbs[MTK_DIP_VIDEO_NODE_ID_TOTAL_NUM] = {};
+	int count = 0;
+
+	if (!all_enable_node_need_buf)
+		return	vb2_request_validate(req);
+
+	list_for_each_entry(obj, &req->objects, list) {
+		struct vb2_buffer *vb;
+
+		if (vb2_request_object_is_buffer(obj)) {
+			struct mtk_dip_video_device *node;
+
+			vb = container_of(obj, struct vb2_buffer, req_obj);
+			node = mtk_dip_vbq_to_node(vb->vb2_queue);
+			dip_pipe = vb2_get_drv_priv(vb->vb2_queue);
+			vbs[node->desc->id] = vb;
+
+			if (count == 0)
+				dip_dev_first = dip_pipe;
+
+			if (dip_dev_first != dip_pipe) {
+				pr_err("Req(%p):found buf of different pipes(%p,%p)",
+				       req, dip_dev_first, dip_pipe);
+				return -EINVAL;
+			}
+		}
+	}
+
+	if (!dip_pipe) {
+		pr_debug("No dip dev found for the request\n");
+		return -EINVAL;
+	}
+
+	for (count = 0; count < MTK_DIP_VIDEO_NODE_ID_TOTAL_NUM; count++) {
+		if (dip_pipe->nodes[count].enabled) {
+			pr_debug("Node(%d:%s): vb(0x%x)\n",
+				 count, dip_pipe->nodes[count].desc->name,
+				 vbs[count]);
+
+			if (!vbs[count]) {
+				pr_debug("Node(%s) enable and no buf enqueue\n",
+					 dip_pipe->nodes[count].desc->name);
+				return -EINVAL;
+			}
+		}
+	}
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s:%s: all bufs found, ready for req(%p) enqueue\n",
+		__func__, dip_pipe->desc->name, req);
+
+	return vb2_request_validate(req);
+}
+
+static int mtk_dip_vb2_request_validate(struct media_request *req)
+{
+	return mtk_dip_request_buf_validate(req, 0);
+}
+
+static void mtk_dip_vb2_request_queue(struct media_request *req)
+{
+	vb2_request_queue(req);
+	mtk_dip_pipe_queue_buffers(req, 0);
+}
+
+static const struct media_device_ops mtk_dip_media_req_ops = {
+	.req_validate = mtk_dip_vb2_request_validate,
+	.req_queue = mtk_dip_vb2_request_queue,
+};
+
+static const struct vb2_ops mtk_dip_vb2_ops = {
+	.buf_queue = mtk_dip_vb2_buf_queue,
+	.queue_setup = mtk_dip_vb2_queue_setup,
+	.buf_prepare  = mtk_dip_vb2_buf_prepare,
+	.buf_out_validate = mtk_dip_vb2_buf_out_validate,
+	.start_streaming = mtk_dip_vb2_start_streaming,
+	.stop_streaming = mtk_dip_vb2_stop_streaming,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.buf_request_complete = mtk_dip_vb2_request_complete,
+};
+
+static const struct v4l2_file_operations mtk_dip_v4l2_fops = {
+	.unlocked_ioctl = video_ioctl2,
+	.open = v4l2_fh_open,
+	.release = vb2_fop_release,
+	.poll = vb2_fop_poll,
+	.mmap = vb2_fop_mmap,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl32 = v4l2_compat_ioctl32,
+#endif
+};
+
+static void mtk_dip_node_to_v4l2(struct mtk_dip_pipe *dip_pipe,
+				 u32 idx,
+				 struct video_device *vdev,
+				 struct v4l2_format *f)
+{
+	u32 cap;
+	struct mtk_dip_video_device *node = &dip_pipe->nodes[idx];
+
+	cap = mtk_dip_node_get_v4l2_cap(dip_pipe, node);
+	vdev->ioctl_ops = node->desc->ops;
+	vdev->device_caps = V4L2_CAP_STREAMING | cap;
+	f->type = node->desc->buf_type;
+	mtk_dip_pipe_load_default_fmt(dip_pipe, node, f);
+}
+
+int mtk_dip_dev_media_register(struct device *dev,
+			       struct media_device *media_dev,
+			       const char *model)
+{
+	int ret = 0;
+
+	media_dev->dev = dev;
+	dev_dbg(dev, "setup media_dev.dev: %p\n",
+		media_dev->dev);
+
+	strlcpy(media_dev->model, model,
+		sizeof(media_dev->model));
+	dev_dbg(dev, "setup media_dev.model: %s\n",
+		media_dev->model);
+
+	snprintf(media_dev->bus_info, sizeof(media_dev->bus_info),
+		 "platform:%s", dev_name(dev));
+	dev_dbg(dev, "setup media_dev.bus_info: %s\n",
+		media_dev->bus_info);
+
+	media_dev->hw_revision = 0;
+	dev_dbg(dev, "setup media_dev.hw_revision: %d\n",
+		media_dev->hw_revision);
+
+	media_dev->ops = &mtk_dip_media_req_ops;
+
+	dev_dbg(dev, "media_device_init: media_dev:%p\n",
+		media_dev);
+	media_device_init(media_dev);
+
+	pr_debug("Register media device: %s, %p",
+		 media_dev->model,
+		media_dev);
+
+	ret = media_device_register(media_dev);
+
+	if (ret) {
+		dev_err(dev, "failed to register media device (%d)\n", ret);
+		goto fail_media_dev;
+	}
+	return 0;
+
+fail_media_dev:
+	media_device_unregister(media_dev);
+	media_device_cleanup(media_dev);
+
+	return ret;
+}
+
+int mtk_dip_dev_v4l2_register(struct device *dev,
+			      struct media_device *media_dev,
+			      struct v4l2_device *v4l2_dev)
+{
+	int ret = 0;
+	/* Set up v4l2 device */
+	v4l2_dev->mdev = media_dev;
+	dev_dbg(dev, "setup v4l2_dev->mdev: %p",
+		v4l2_dev->mdev);
+	v4l2_dev->ctrl_handler = NULL;
+	dev_dbg(dev, "setup v4l2_dev->ctrl_handler: %p",
+		v4l2_dev->ctrl_handler);
+
+	pr_debug("Register v4l2 device: %p",
+		 v4l2_dev);
+
+	ret = v4l2_device_register(dev, v4l2_dev);
+
+	if (ret) {
+		dev_err(dev, "failed to register V4L2 device (%d)\n", ret);
+		goto fail_v4l2_dev;
+	}
+
+	return 0;
+
+fail_v4l2_dev:
+	media_device_unregister(media_dev);
+	media_device_cleanup(media_dev);
+
+	return ret;
+}
+
+int mtk_dip_pipe_v4l2_register(struct mtk_dip_pipe *dip_pipe,
+			       struct media_device *media_dev,
+			       struct v4l2_device *v4l2_dev)
+{
+	int i, ret;
+
+	/* Initialize miscellaneous variables */
+	dip_pipe->streaming = 0;
+
+	/* Initialize subdev media entity */
+	dip_pipe->subdev_pads = kcalloc(dip_pipe->num_nodes,
+					sizeof(*dip_pipe->subdev_pads),
+					GFP_KERNEL);
+	if (!dip_pipe->subdev_pads) {
+		ret = -ENOMEM;
+		goto fail_subdev_pads;
+	}
+
+	ret = media_entity_pads_init(&dip_pipe->subdev.entity,
+				     dip_pipe->num_nodes,
+				     dip_pipe->subdev_pads);
+	if (ret) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"failed initialize subdev media entity (%d)\n", ret);
+		goto fail_media_entity;
+	}
+
+	/* Initialize subdev */
+	v4l2_subdev_init(&dip_pipe->subdev, &mtk_dip_subdev_ops);
+
+	dip_pipe->subdev.entity.function =
+		MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;
+
+	dip_pipe->subdev.entity.ops = &mtk_dip_media_ops;
+
+	for (i = 0; i < dip_pipe->num_nodes; i++) {
+		struct mtk_dip_video_device_desc *desc =
+			dip_pipe->nodes[i].desc;
+
+		dip_pipe->subdev_pads[i].flags =
+			V4L2_TYPE_IS_OUTPUT(desc->buf_type) ?
+			MEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;
+	}
+
+	dip_pipe->subdev.flags =
+		V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+	snprintf(dip_pipe->subdev.name, sizeof(dip_pipe->subdev.name),
+		 "%s", dip_pipe->desc->name);
+	v4l2_set_subdevdata(&dip_pipe->subdev, dip_pipe);
+	dip_pipe->subdev.ctrl_handler = &dip_pipe->ctrl_handler;
+	dip_pipe->subdev.internal_ops = &mtk_dip_subdev_internal_ops;
+
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"register subdev: %s, ctrl_handler %p\n",
+		 dip_pipe->subdev.name, dip_pipe->subdev.ctrl_handler);
+	ret = v4l2_device_register_subdev(&dip_pipe->dip_dev->v4l2_dev,
+					  &dip_pipe->subdev);
+	if (ret) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"failed initialize subdev (%d)\n", ret);
+		goto fail_subdev;
+	}
+
+	ret = v4l2_device_register_subdev_nodes(&dip_pipe->dip_dev->v4l2_dev);
+	if (ret) {
+		dev_err(&dip_pipe->dip_dev->pdev->dev,
+			"failed to register subdevs (%d)\n", ret);
+		goto fail_subdevs;
+	}
+
+	/* Create video nodes and links */
+	for (i = 0; i < dip_pipe->num_nodes; i++) {
+		struct mtk_dip_video_device *node = &dip_pipe->nodes[i];
+		struct video_device *vdev = &node->vdev;
+		struct vb2_queue *vbq = &node->dev_q.vbq;
+		struct mtk_dip_video_device_desc *desc = node->desc;
+		u32 flags;
+
+		/* Initialize miscellaneous variables */
+		mutex_init(&node->dev_q.lock);
+
+		/* Initialize formats to default values */
+		mtk_dip_node_to_v4l2(dip_pipe, i, vdev, &node->vdev_fmt);
+
+		/* Initialize media entities */
+		ret = media_entity_pads_init(&vdev->entity, 1, &node->vdev_pad);
+		if (ret) {
+			dev_err(&dip_pipe->dip_dev->pdev->dev,
+				"failed initialize media entity (%d)\n", ret);
+			goto fail_vdev_media_entity;
+		}
+
+		node->vdev_pad.flags = V4L2_TYPE_IS_OUTPUT(desc->buf_type) ?
+			MEDIA_PAD_FL_SOURCE : MEDIA_PAD_FL_SINK;
+		vdev->entity.ops = NULL;
+
+		/* Initialize vbq */
+		vbq->type = node->vdev_fmt.type;
+		vbq->io_modes = VB2_MMAP | VB2_DMABUF;
+		vbq->ops = &mtk_dip_vb2_ops;
+		vbq->mem_ops = &vb2_dma_contig_memops;
+		vbq->supports_requests = true;
+		vbq->buf_struct_size = sizeof(struct mtk_dip_dev_buffer);
+		vbq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+		vbq->min_buffers_needed = 0;
+		/* Put the process hub sub device in the vb2 private data*/
+		vbq->drv_priv = dip_pipe;
+		vbq->lock = &node->dev_q.lock;
+		ret = vb2_queue_init(vbq);
+		if (ret) {
+			dev_err(&dip_pipe->dip_dev->pdev->dev,
+				"failed to initialize video queue (%d)\n", ret);
+			goto fail_vdev;
+		}
+
+		/* Initialize vdev */
+		snprintf(vdev->name, sizeof(vdev->name), "%s %s",
+			 dip_pipe->desc->name,
+			 node->desc->name);
+		vdev->release = video_device_release_empty;
+		vdev->fops = &mtk_dip_v4l2_fops;
+		vdev->lock = &node->dev_q.lock;
+		vdev->ctrl_handler = &dip_pipe->nodes[i].ctrl_handler;
+		vdev->v4l2_dev = &dip_pipe->dip_dev->v4l2_dev;
+		vdev->queue = &node->dev_q.vbq;
+		vdev->vfl_dir = V4L2_TYPE_IS_OUTPUT(desc->buf_type) ?
+			VFL_DIR_TX : VFL_DIR_RX;
+		video_set_drvdata(vdev, dip_pipe);
+		pr_debug("register vdev: %s\n", vdev->name);
+		ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+		if (ret) {
+			dev_err(&dip_pipe->dip_dev->pdev->dev,
+				"failed to register video device (%d)\n", ret);
+			goto fail_vdev;
+		}
+
+		/* Create link between video node and the subdev pad */
+		flags = 0;
+		if (desc->dynamic)
+			flags |= MEDIA_LNK_FL_DYNAMIC;
+		if (node->enabled)
+			flags |= MEDIA_LNK_FL_ENABLED;
+		if (node->immutable)
+			flags |= MEDIA_LNK_FL_IMMUTABLE;
+
+		if (V4L2_TYPE_IS_OUTPUT(desc->buf_type))
+			ret = media_create_pad_link(&vdev->entity, 0,
+						    &dip_pipe->subdev.entity,
+						    i, flags);
+		else
+			ret = media_create_pad_link(&dip_pipe->subdev.entity,
+						    i, &vdev->entity, 0,
+						    flags);
+
+		if (ret)
+			goto fail_link;
+	}
+
+	return 0;
+
+	for (; i >= 0; i--) {
+fail_link:
+		video_unregister_device(&dip_pipe->nodes[i].vdev);
+fail_vdev:
+		vb2_queue_release(&dip_pipe->nodes[i].dev_q.vbq);
+		media_entity_cleanup(&dip_pipe->nodes[i].vdev.entity);
+fail_vdev_media_entity:
+		mutex_destroy(&dip_pipe->nodes[i].dev_q.lock);
+	}
+fail_subdevs:
+	v4l2_device_unregister_subdev(&dip_pipe->subdev);
+fail_subdev:
+	media_entity_cleanup(&dip_pipe->subdev.entity);
+fail_media_entity:
+	kfree(dip_pipe->subdev_pads);
+fail_subdev_pads:
+	v4l2_device_unregister(&dip_pipe->dip_dev->v4l2_dev);
+	pr_err("fail_v4l2_dev: media_device_unregister and clenaup:%p",
+	       &dip_pipe->dip_dev->mdev);
+	media_device_unregister(&dip_pipe->dip_dev->mdev);
+	media_device_cleanup(&dip_pipe->dip_dev->mdev);
+
+	return ret;
+}
+
+int mtk_dip_pipe_v4l2_unregister(struct mtk_dip_pipe *dip_pipe)
+{
+	unsigned int i;
+
+	for (i = 0; i < dip_pipe->num_nodes; i++) {
+		video_unregister_device(&dip_pipe->nodes[i].vdev);
+		vb2_queue_release(&dip_pipe->nodes[i].dev_q.vbq);
+		media_entity_cleanup(&dip_pipe->nodes[i].vdev.entity);
+		mutex_destroy(&dip_pipe->nodes[i].dev_q.lock);
+	}
+
+	v4l2_device_unregister_subdev(&dip_pipe->subdev);
+	media_entity_cleanup(&dip_pipe->subdev.entity);
+	kfree(dip_pipe->subdev_pads);
+	v4l2_device_unregister(&dip_pipe->dip_dev->v4l2_dev);
+	media_device_unregister(&dip_pipe->dip_dev->mdev);
+	media_device_cleanup(&dip_pipe->dip_dev->mdev);
+
+	return 0;
+}
+
+void mtk_dip_v4l2_buffer_done(struct vb2_buffer *vb,
+			      enum vb2_buffer_state state)
+{
+	struct mtk_dip_pipe *dip_pipe;
+	struct mtk_dip_video_device *node;
+
+	dip_pipe = vb2_get_drv_priv(vb->vb2_queue);
+	node = mtk_dip_vbq_to_node(vb->vb2_queue);
+	dev_dbg(&dip_pipe->dip_dev->pdev->dev,
+		"%s:%s: return buf, idx(%d), state(%d)\n",
+		dip_pipe->desc->name, node->desc->name,
+		vb->index, state);
+	vb2_buffer_done(vb, state);
+}
+
+/********************************************
+ * MTK DIP V4L2 Settings *
+ ********************************************/
+
+static const struct v4l2_ioctl_ops mtk_dip_v4l2_video_out_ioctl_ops = {
+	.vidioc_querycap = mtk_dip_videoc_querycap,
+	.vidioc_enum_framesizes = mtk_dip_videoc_enum_framesizes,
+	.vidioc_enum_fmt_vid_cap = mtk_dip_videoc_enum_fmt,
+	.vidioc_g_fmt_vid_cap_mplane = mtk_dip_videoc_g_fmt,
+	.vidioc_s_fmt_vid_cap_mplane = mtk_dip_videoc_s_fmt,
+	.vidioc_try_fmt_vid_cap_mplane = mtk_dip_videoc_try_fmt,
+	.vidioc_enum_fmt_vid_out = mtk_dip_videoc_enum_fmt,
+	.vidioc_g_fmt_vid_out_mplane = mtk_dip_videoc_g_fmt,
+	.vidioc_s_fmt_vid_out_mplane = mtk_dip_videoc_s_fmt,
+	.vidioc_try_fmt_vid_out_mplane = mtk_dip_videoc_try_fmt,
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_subscribe_event = mtk_dip_vidioc_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+
+};
+
+static const struct v4l2_ioctl_ops mtk_dip_v4l2_video_cap_ioctl_ops = {
+	.vidioc_querycap = mtk_dip_videoc_querycap,
+	.vidioc_enum_framesizes = mtk_dip_videoc_enum_framesizes,
+	.vidioc_enum_fmt_vid_cap = mtk_dip_videoc_enum_fmt,
+	.vidioc_g_fmt_vid_cap_mplane = mtk_dip_videoc_g_fmt,
+	.vidioc_s_fmt_vid_cap_mplane = mtk_dip_videoc_s_fmt,
+	.vidioc_try_fmt_vid_cap_mplane = mtk_dip_videoc_try_fmt,
+	.vidioc_enum_fmt_vid_out = mtk_dip_videoc_enum_fmt,
+	.vidioc_g_fmt_vid_out_mplane = mtk_dip_videoc_g_fmt,
+	.vidioc_s_fmt_vid_out_mplane = mtk_dip_videoc_s_fmt,
+	.vidioc_try_fmt_vid_out_mplane = mtk_dip_videoc_try_fmt,
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_subscribe_event = mtk_dip_vidioc_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+
+};
+
+static const struct v4l2_ioctl_ops mtk_dip_v4l2_meta_out_ioctl_ops = {
+	.vidioc_querycap = mtk_dip_videoc_querycap,
+
+	.vidioc_enum_fmt_meta_cap = mtk_dip_meta_enum_format,
+	.vidioc_g_fmt_meta_cap = mtk_dip_videoc_g_meta_fmt,
+	.vidioc_s_fmt_meta_cap = mtk_dip_videoc_g_meta_fmt,
+	.vidioc_try_fmt_meta_cap = mtk_dip_videoc_g_meta_fmt,
+
+	.vidioc_enum_fmt_meta_out = mtk_dip_meta_enum_format,
+	.vidioc_g_fmt_meta_out = mtk_dip_videoc_g_meta_fmt,
+	.vidioc_s_fmt_meta_out = mtk_dip_videoc_g_meta_fmt,
+	.vidioc_try_fmt_meta_out = mtk_dip_videoc_g_meta_fmt,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+};
+
+static struct mtk_dip_dev_format fw_param_fmts[] = {
+	{
+		.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_PARAMS,
+			.max_buffer_size = 1024 * (128 + 288),
+		},
+	},
+};
+
+static struct mtk_dip_dev_format lcei_fmts[] = {
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR8,
+			.mdp_color = MDP_COLOR_BAYER8,
+			.depth = { 8 },
+			.row_depth = { 8 },
+			.num_planes = 1,
+		},
+	},
+};
+
+static struct mtk_dip_dev_format in_fmts[] = {
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_VYUY,
+			.mdp_color = MDP_COLOR_VYUY,
+			.colorspace = V4L2_COLORSPACE_BT2020,
+			.depth	 = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_YUYV,
+			.mdp_color = MDP_COLOR_YUYV,
+			.colorspace = V4L2_COLORSPACE_BT2020,
+			.depth	 = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_YVYU,
+			.mdp_color = MDP_COLOR_YVYU,
+			.colorspace = V4L2_COLORSPACE_BT2020,
+			.depth	 = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_NV12,
+			.mdp_color = MDP_COLOR_NV12,
+			.colorspace = V4L2_COLORSPACE_BT2020,
+			.depth = { 12 },
+			.row_depth = { 8 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR10,
+			.mdp_color = MDP_COLOR_BAYER10_BGGR,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.depth = { 10 },
+			.row_depth = { 10 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG10,
+			.mdp_color = MDP_COLOR_BAYER10_GBRG,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.depth = { 10 },
+			.row_depth = { 10 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG10,
+			.mdp_color = MDP_COLOR_BAYER10_GRBG,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.depth = { 10 },
+			.row_depth = { 10 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB10,
+			.mdp_color = MDP_COLOR_BAYER10_RGGB,
+			.colorspace = V4L2_COLORSPACE_SRGB,
+			.depth = { 10 },
+			.row_depth = { 10 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR10F,
+			.mdp_color = MDP_COLOR_FULLG10_BGGR,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.depth = { 15 },
+			.row_depth = { 15 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG10F,
+			.mdp_color = MDP_COLOR_FULLG10_GBRG,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.depth = { 15 },
+			.row_depth = { 15 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG10F,
+			.mdp_color = MDP_COLOR_FULLG10_GRBG,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.depth = { 15 },
+			.row_depth = { 15 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB10F,
+			.mdp_color = MDP_COLOR_FULLG10_RGGB,
+			.colorspace = V4L2_COLORSPACE_RAW,
+			.depth = { 15 },
+			.row_depth = { 15 },
+			.num_planes = 1,
+		},
+	},
+};
+
+static struct mtk_dip_dev_format mdp_fmts[] = {
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_VYUY,
+			.mdp_color = MDP_COLOR_VYUY,
+			.depth = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_YUYV,
+			.mdp_color = MDP_COLOR_YUYV,
+			.depth = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_YVYU,
+			.mdp_color = MDP_COLOR_YVYU,
+			.depth = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_YVU420,
+			.mdp_color = MDP_COLOR_YV12,
+			.depth = { 12 },
+			.row_depth = { 8 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_NV12,
+			.mdp_color = MDP_COLOR_NV12,
+			.depth = { 12 },
+			.row_depth = { 8 },
+			.num_planes = 1,
+		},
+	}
+};
+
+static struct mtk_dip_dev_format img2_fmts[] = {
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_YUYV,
+			.mdp_color = MDP_COLOR_YUYV,
+			.depth = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+};
+
+static struct mtk_dip_dev_format img3_fmts[] = {
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_VYUY,
+			.mdp_color = MDP_COLOR_VYUY,
+			.colorspace = MDP_YCBCR_PROFILE_BT601,
+			.depth = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_YUYV,
+			.mdp_color = MDP_COLOR_YUYV,
+			.colorspace = MDP_YCBCR_PROFILE_BT601,
+			.depth = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_YVYU,
+			.mdp_color = MDP_COLOR_YVYU,
+			.colorspace = MDP_YCBCR_PROFILE_BT601,
+			.depth = { 16 },
+			.row_depth = { 16 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_YVU420,
+			.mdp_color = MDP_COLOR_YV12,
+			.colorspace = MDP_YCBCR_PROFILE_BT601,
+			.depth = { 12 },
+			.row_depth = { 8 },
+			.num_planes = 1,
+		},
+	},
+	{
+		.fmt.img = {
+			.pixelformat = V4L2_PIX_FMT_NV12,
+			.mdp_color = MDP_COLOR_NV12,
+			.colorspace = MDP_YCBCR_PROFILE_BT601,
+			.depth = { 12 },
+			.row_depth = { 8 },
+			.num_planes = 1,
+		},
+	}
+};
+
+static struct mtk_dip_video_device_desc
+	output_queues_setting[MTK_DIP_VIDEO_NODE_ID_OUT_TOTAL_NUM] = {
+	{
+		.id = MTK_DIP_VIDEO_NODE_ID_RAW_OUT,
+		.name = "Raw Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.dynamic = 0,
+		.smem_alloc = 0,
+		.default_enable = 1,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.ops = &mtk_dip_v4l2_video_out_ioctl_ops,
+		.dma_port = 0,
+		.description = "Main image source",
+	},
+	{
+		.id = MTK_DIP_VIDEO_NODE_ID_TUNING_OUT,
+		.name = "Tuning",
+		.cap = V4L2_CAP_META_OUTPUT,
+		.buf_type = V4L2_BUF_TYPE_META_OUTPUT,
+		.dynamic = 0,
+		.smem_alloc = 1,
+		.default_enable = 0,
+		.fmts = fw_param_fmts,
+		.num_fmts = 1,
+		.default_fmt_idx = 0,
+		.ops = &mtk_dip_v4l2_meta_out_ioctl_ops,
+		.dma_port = 0xf,
+		.description = "Tuning data",
+	},
+	{
+		.id = MTK_DIP_VIDEO_NODE_ID_VIPI_OUT,
+		.name = "Vipi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.dynamic = 1,
+		.smem_alloc = 0,
+		.default_enable = 0,
+		.fmts = img3_fmts,
+		.num_fmts = ARRAY_SIZE(img3_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.ops = &mtk_dip_v4l2_video_out_ioctl_ops,
+		.dma_port = 1,
+		.description = "Vipi image source",
+	},
+	{
+		.id = MTK_DIP_VIDEO_NODE_ID_LCEI_OUT,
+		.name = "LCEI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.dynamic = 1,
+		.smem_alloc = 0,
+		.default_enable = 0,
+		.fmts = lcei_fmts,
+		.num_fmts = ARRAY_SIZE(lcei_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.ops = &mtk_dip_v4l2_video_out_ioctl_ops,
+		.dma_port = 2,
+		.description = "Vipi image source",
+	},
+
+};
+
+static struct mtk_dip_video_device_desc
+	reprocess_output_queues_setting[MTK_DIP_VIDEO_NODE_ID_OUT_TOTAL_NUM] = {
+	{
+		.id = MTK_DIP_VIDEO_NODE_ID_RAW_OUT,
+		.name = "Raw Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.dynamic = 0,
+		.smem_alloc = 0,
+		.default_enable = 1,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 3,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.ops = &mtk_dip_v4l2_video_out_ioctl_ops,
+		.dma_port = 0,
+		.description = "Source image to be process",
+
+	},
+	{
+		.id = MTK_DIP_VIDEO_NODE_ID_TUNING_OUT,
+		.name = "Tuning",
+		.cap = V4L2_CAP_META_OUTPUT,
+		.buf_type = V4L2_BUF_TYPE_META_OUTPUT,
+		.dynamic = 0,
+		.smem_alloc = 1,
+		.default_enable = 0,
+		.fmts = fw_param_fmts,
+		.num_fmts = 1,
+		.default_fmt_idx = 0,
+		.ops = &mtk_dip_v4l2_meta_out_ioctl_ops,
+		.dma_port = 0xf,
+		.description = "Tuning data for image enhancement",
+	},
+	{
+		.id = MTK_DIP_VIDEO_NODE_ID_VIPI_OUT,
+		.name = "Vipi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.dynamic = 1,
+		.smem_alloc = 0,
+		.default_enable = 0,
+		.fmts = img3_fmts,
+		.num_fmts = ARRAY_SIZE(img3_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.ops = &mtk_dip_v4l2_video_out_ioctl_ops,
+		.dma_port = 1,
+		.description = "Vipi image source",
+	},
+	{
+		.id = MTK_DIP_VIDEO_NODE_ID_LCEI_OUT,
+		.name = "LCEI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.dynamic = 1,
+		.smem_alloc = 0,
+		.default_enable = 0,
+		.fmts = lcei_fmts,
+		.num_fmts = ARRAY_SIZE(lcei_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.ops = &mtk_dip_v4l2_video_out_ioctl_ops,
+		.dma_port = 2,
+		.description = "Vipi image source",
+	},
+};
+
+static struct mtk_dip_video_device_desc
+	capture_queues_setting[MTK_DIP_VIDEO_NODE_ID_CAPTURE_TOTAL_NUM] = {
+	{
+		.id = MTK_DIP_VIDEO_NODE_ID_MDP0_CAPTURE,
+		.name = "MDP0",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.dynamic = 1,
+		.smem_alloc = 0,
+		.fmts = mdp_fmts,
+		.num_fmts = ARRAY_SIZE(mdp_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.ops = &mtk_dip_v4l2_video_cap_ioctl_ops,
+		.dma_port = 0,
+		.description = "Output quality enhanced image",
+	},
+	{
+		.id = MTK_DIP_VIDEO_NODE_ID_MDP1_CAPTURE,
+		.name = "MDP1",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.dynamic = 1,
+		.smem_alloc = 0,
+		.fmts = mdp_fmts,
+		.num_fmts = ARRAY_SIZE(mdp_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.ops = &mtk_dip_v4l2_video_cap_ioctl_ops,
+		.dma_port = 0,
+		.description = "Output quality enhanced image",
+	},
+	{
+		.id = MTK_DIP_VIDEO_NODE_ID_IMG2_CAPTURE,
+		.name = "IMG2",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.dynamic = 1,
+		.smem_alloc = 0,
+		.fmts = img2_fmts,
+		.num_fmts = ARRAY_SIZE(img2_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.ops = &mtk_dip_v4l2_video_cap_ioctl_ops,
+		.dma_port = 1,
+		.description = "Output quality enhanced image",
+	},
+	{
+		.id = MTK_DIP_VIDEO_NODE_ID_IMG3_CAPTURE,
+		.name = "IMG3",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.dynamic = 1,
+		.smem_alloc = 0,
+		.fmts = img3_fmts,
+		.num_fmts = ARRAY_SIZE(img3_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.ops = &mtk_dip_v4l2_video_cap_ioctl_ops,
+		.dma_port = 2,
+		.description = "Output quality enhanced image",
+
+	},
+};
+
+static struct mtk_dip_pipe_desc
+	pipe_settings[MTK_DIP_PIPE_ID_TOTAL_NUM] = {
+	{
+		.name = MTK_DIP_DEV_DIP_PREVIEW_NAME,
+		.id = MTK_DIP_PIPE_ID_PREVIEW,
+		.master = MTK_DIP_VIDEO_NODE_ID_NO_MASTER,
+		.output_queue_descs = output_queues_setting,
+		.total_output_queues = MTK_DIP_VIDEO_NODE_ID_OUT_TOTAL_NUM,
+		.capture_queue_descs = capture_queues_setting,
+		.total_capture_queues = MTK_DIP_VIDEO_NODE_ID_CAPTURE_TOTAL_NUM,
+	},
+	{
+		.name = MTK_DIP_DEV_DIP_CAPTURE_NAME,
+		.id = MTK_DIP_PIPE_ID_CAPTURE,
+		.master = MTK_DIP_VIDEO_NODE_ID_NO_MASTER,
+		.output_queue_descs = output_queues_setting,
+		.total_output_queues = MTK_DIP_VIDEO_NODE_ID_OUT_TOTAL_NUM,
+		.capture_queue_descs = capture_queues_setting,
+		.total_capture_queues = MTK_DIP_VIDEO_NODE_ID_CAPTURE_TOTAL_NUM,
+	},
+	{
+		.name = MTK_DIP_DEV_DIP_REPROCESS_NAME,
+		.id = MTK_DIP_PIPE_ID_REPROCESS,
+		.master = MTK_DIP_VIDEO_NODE_ID_NO_MASTER,
+		.output_queue_descs = reprocess_output_queues_setting,
+		.total_output_queues = MTK_DIP_VIDEO_NODE_ID_OUT_TOTAL_NUM,
+		.capture_queue_descs = capture_queues_setting,
+		.total_capture_queues = MTK_DIP_VIDEO_NODE_ID_CAPTURE_TOTAL_NUM,
+	},
+};
+
+int mtk_dip_dev_v4l2_init(struct mtk_dip_dev *dip_dev)
+{
+	struct media_device *media_dev;
+	struct v4l2_device *v4l2_dev;
+	struct mtk_dip_smem_dev *smem_alloc_dev = &dip_dev->smem_alloc_dev;
+	int i;
+	int ret = 0;
+
+	media_dev = &dip_dev->mdev;
+	v4l2_dev = &dip_dev->v4l2_dev;
+
+	ret = mtk_dip_dev_media_register(&dip_dev->pdev->dev,
+					 media_dev,
+					 MTK_DIP_DEV_DIP_MEDIA_MODEL_NAME);
+
+	ret = mtk_dip_dev_v4l2_register(&dip_dev->pdev->dev,
+					media_dev,
+					v4l2_dev);
+
+	ret = mtk_dip_smem_alloc_dev_init(smem_alloc_dev, &dip_dev->pdev->dev);
+
+	for (i = 0; i < MTK_DIP_PIPE_ID_TOTAL_NUM; i++) {
+		ret = mtk_dip_pipe_init(&dip_dev->dip_pipe[i], dip_dev,
+					&pipe_settings[i],
+					media_dev, v4l2_dev, smem_alloc_dev);
+		if (ret) {
+			dev_err(&dip_dev->pdev->dev,
+				"%s: Pipe id(%d) init failed(%d)\n",
+				dip_dev->dip_pipe[i].desc->name,
+				i, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+void mtk_dip_dev_v4l2_release(struct mtk_dip_dev *dip_dev)
+{
+	int i = 0;
+
+	if (dip_dev)
+		for (i = 0; i < MTK_DIP_PIPE_ID_TOTAL_NUM; i++)
+			mtk_dip_pipe_release(&dip_dev->dip_pipe[i]);
+
+	mtk_dip_smem_alloc_dev_release(&dip_dev->smem_alloc_dev);
+}
+
diff --git a/drivers/media/platform/mtk-isp/isp_50/seninf/Makefile b/drivers/media/platform/mtk-isp/isp_50/seninf/Makefile
new file mode 100644
index 000000000000..bf193feb0ce9
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/seninf/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+
+MODULE		= mtk_seninf
+LIB_FILES	= mtk_seninf
+
+obj-$(CONFIG_MTK_SENINF) += mtk_seninf.o
diff --git a/drivers/media/platform/mtk-isp/isp_50/seninf/mtk_seninf.c b/drivers/media/platform/mtk-isp/isp_50/seninf/mtk_seninf.c
new file mode 100644
index 000000000000..87ffb21ee8ed
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/seninf/mtk_seninf.c
@@ -0,0 +1,1326 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/of_graph.h>
+#include <linux/of_irq.h>
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+#include <linux/videodev2.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-async.h>
+#include "mtk_seninf_reg.h"
+#include "mtk_seninf_def.h"
+
+#define SUBDEV_SENSOR_MAIN_NAME		"sensor_main"
+#define SUBDEV_SENSOR_SUB_NAME		"sensor_sub"
+#define MTK_CAM_SENINF_PAD_MAIN_SINK		0
+#define MTK_CAM_SENINF_PAD_SUB_SINK		1
+#define MIPI_SENSOR_TYPE MIPI_OPHY_NCSI2
+
+static inline void mt_reg_sync_writel(unsigned int v, void *a)
+{
+	__raw_writel((v), (void __force __iomem *)((a)));
+}
+
+static inline unsigned int seninf_read_reg
+	(void *reg_base, unsigned int reg_name)
+{
+	return (unsigned int)ioread32(reg_base + reg_name);
+}
+
+static inline void seninf_write_reg
+	(void *reg_base, unsigned int reg_name,
+	unsigned int value)
+{
+	mt_reg_sync_writel(value, reg_base + reg_name);
+}
+
+static inline void write_master
+	(void *reg_base, unsigned int reg_name,
+	unsigned int value, unsigned int mask)
+{
+	mt_reg_sync_writel((ioread32(reg_base + reg_name) & ~(mask)) |
+		value, reg_base + reg_name);
+}
+
+static inline int is_4d1c(unsigned int port)
+{
+	return (port < CFG_CSI_PORT_0A);
+}
+
+static inline int is_cdphy_combo(unsigned int port)
+{
+	return (port == CFG_CSI_PORT_0A ||
+		port == CFG_CSI_PORT_0B ||
+		port == CFG_CSI_PORT_0);
+}
+
+static struct seninf_csi_info SENINF_CSI_INFO[CFG_CSI_PORT_MAX_NUM] = {
+	{CFG_CSI_PORT_0,  SENINF_1},
+	{CFG_CSI_PORT_1,  SENINF_3},
+	{CFG_CSI_PORT_2,  SENINF_5},
+	{CFG_CSI_PORT_0A, SENINF_1},
+	{CFG_CSI_PORT_0B, SENINF_2},
+};
+
+struct _seninf {
+	struct v4l2_subdev subdev;
+	struct v4l2_async_notifier notifier;
+	struct device *dev;
+	struct v4l2_fwnode_endpoint ep[NUM_PORTS];
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct media_pad pads[NUM_PADS];
+	struct clk *cam_clk, *top_mux_clk;
+	unsigned int port;
+	struct v4l2_subdev_format fmt;
+	unsigned int mux_select;
+	void __iomem *base_reg;
+	void __iomem *rx_reg;
+	unsigned char *csi2_rx[CFG_CSI_PORT_MAX_NUM];
+};
+
+static int set_top_mux_ctrl(struct _seninf *priv,
+			    unsigned int mux_idx,
+			    unsigned int seninf_src)
+{
+	void *pseninf = priv->base_reg;
+
+	seninf_write_reg(pseninf, SENINF_TOP_MUX_CTRL,
+			 ((seninf_read_reg(pseninf, SENINF_TOP_MUX_CTRL) &
+			 (~(0xF << (mux_idx * 4)))) | ((seninf_src & 0xF)
+			 << (mux_idx * 4))));
+
+	return 0;
+}
+
+static void set_mux_ctrl
+	(struct _seninf *priv, unsigned int mux,
+	unsigned int input_data_type)
+{
+	void *pseninf = priv->base_reg + 0x1000 * mux;
+	unsigned int temp;
+	unsigned int pix_sel_ext;
+	unsigned int pix_sel;
+	unsigned int hs_pol = 0;
+	unsigned int vs_pol = 0;
+	unsigned int pixel_mode = ONE_PIXEL_MODE;
+	unsigned int src_type_sel = MIPI_SENSOR;
+
+	write_master(pseninf, SENINF1_MUX_CTRL,
+		     (src_type_sel << 12), 0x0000F000);
+	temp = (src_type_sel == TEST_MODEL) ? 0 : 1;
+	write_master(pseninf, SENINF1_MUX_CTRL_EXT,
+		     (temp << 0), 0x00000003);
+
+	switch (pixel_mode) {
+	case 1: /* 2 Pixel */
+		pix_sel_ext = 0;
+		pix_sel = 1 << 8;
+		break;
+	case 2: /* 4 Pixel */
+		pix_sel_ext = 1 << 4;
+		pix_sel = 0;
+		break;
+	default: /* 1 Pixel */
+		pix_sel_ext = 0;
+		pix_sel = 0;
+		break;
+	}
+
+	write_master(pseninf, SENINF1_MUX_CTRL_EXT, pix_sel_ext, 0x00000010);
+	write_master(pseninf, SENINF1_MUX_CTRL, pix_sel, 0x00000100);
+
+	if (input_data_type != JPEG_FMT)
+		write_master(pseninf, SENINF1_MUX_CTRL,
+			     (2 << 28), 0x30000000);
+	else
+		write_master(pseninf, SENINF1_MUX_CTRL, 0, 0x30000000);
+
+	if (src_type_sel == CSI2 || src_type_sel >= MIPI_SENSOR) {
+		/* Need to use Default for New design */
+		if (input_data_type != JPEG_FMT)
+			write_master(pseninf, SENINF1_MUX_CTRL,
+				     ((0x1B << 22) | (0x1F << 16)),
+				     0x0FFF0000);
+		else
+			write_master(pseninf, SENINF1_MUX_CTRL,
+				     ((0x18 << 22) | (0x1E << 16)),
+				     0x0FFF0000);
+	}
+
+	write_master(pseninf, SENINF1_MUX_CTRL,
+		     ((hs_pol << 10) | (vs_pol << 9)), 0x00000600);
+
+	temp = seninf_read_reg(pseninf, SENINF1_MUX_CTRL);
+	seninf_write_reg(pseninf, SENINF1_MUX_CTRL, temp | 0x3);
+	seninf_write_reg(pseninf, SENINF1_MUX_CTRL, temp & 0xFFFFFFFC);
+}
+
+static void enable_mux(struct _seninf *priv, unsigned int mux)
+{
+	void *pseninf = priv->base_reg + 0x1000 * mux;
+
+	write_master(pseninf, SENINF1_MUX_CTRL, (1 << 31), 0x80000000);
+}
+
+static struct seninf_csi_info *get_csi_info(struct _seninf *priv,
+					    unsigned int mipi_port)
+{
+	int i;
+
+	for (i = 0; i < CFG_CSI_PORT_MAX_NUM; i++) {
+		if (SENINF_CSI_INFO[i].port == mipi_port)
+			return &SENINF_CSI_INFO[i];
+	}
+
+	return NULL;
+}
+
+static void set_dphy
+	(struct _seninf *priv,
+	struct seninf_csi_mipi *pcsi_mipi)
+{
+	struct seninf_csi_info *csi_info = pcsi_mipi->csi_info;
+	void *pmipi_rx_base = priv->csi2_rx[CFG_CSI_PORT_0];
+	void *pmipi_rx = priv->csi2_rx[csi_info->port];
+	void *pmipi_rx_conf = priv->base_reg + 0x1000 * csi_info->seninf;
+
+	/* Set analog phy mode to DPHY */
+	if (is_cdphy_combo(csi_info->port))
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0A, 0, 0x00000001);
+	/* 4D1C: MIPIRX_ANALOG_A_BASE = 0x00001A42 */
+	if (is_4d1c(csi_info->port))
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0A,
+			     (1 << 6) | (1 << 9) | (1 << 11) | (1 << 12),
+			     0x00001B60);
+	else /* MIPIRX_ANALOG_BASE = 0x102 */
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0A,
+			     (1 << 8), 0x00001B60);
+
+	if (is_cdphy_combo(csi_info->port))
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0B, 0, 0x00000001);
+
+	/* Only 4d1c need set CSIB: MIPIRX_ANALOG_B_BASE = 0x00001242 */
+	if (is_4d1c(csi_info->port))
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0B,
+			     (1 << 6) | (1 << 9) | (1 << 12), 0x00001B60);
+	else /* MIPIRX_ANALOG_BASE = 0x102 */
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0B,
+			     (1 << 8) | (1 << 9), 0x00001B40);
+
+	/* Byte clock invert */
+	write_master(pmipi_rx, MIPI_RX_ANAA8_CSI0A,
+		     (1 << 0) | (1 << 1) | (1 << 2), 0x00000007);
+	if (is_4d1c(csi_info->port))
+		write_master(pmipi_rx, MIPI_RX_ANAA8_CSI0B,
+			     (1 << 0) | (1 << 1) | (1 << 2),
+			     0x00000007);
+
+	/* Start ANA EQ tuning */
+	if (is_cdphy_combo(csi_info->port)) {
+		write_master(pmipi_rx, MIPI_RX_ANA18_CSI0A,
+			     (1 << 4) | (1 << 6), 0x000000F0);
+		write_master(pmipi_rx, MIPI_RX_ANA1C_CSI0A,
+			     (1 << 20) | (1 << 22), 0x00F00000);
+		write_master(pmipi_rx, MIPI_RX_ANA20_CSI0A,
+			     (1 << 20) | (1 << 22), 0x00F00000);
+
+		if (is_4d1c(csi_info->port)) { /* 4d1c */
+			write_master(pmipi_rx, MIPI_RX_ANA18_CSI0B,
+				     (1 << 4) | (1 << 6), 0x000000F0);
+			write_master(pmipi_rx, MIPI_RX_ANA1C_CSI0B,
+				     (1 << 20) | (1 << 22),
+				     0x00F00000);
+			write_master(pmipi_rx, MIPI_RX_ANA20_CSI0B,
+				     (1 << 20) | (1 << 22),
+				     0x00F00000);
+		}
+	} else {
+		write_master(pmipi_rx, MIPI_RX_ANA18_CSI1A,
+			     (1 << 4) | (1 << 6) | (1 << 20) |
+			     (1 << 22), 0x00F000F0);
+		write_master(pmipi_rx, MIPI_RX_ANA1C_CSI1A,
+			     (1 << 4) | (1 << 6), 0x000000F0);
+
+		if (is_4d1c(csi_info->port)) { /* 4d1c */
+			write_master(pmipi_rx,
+				     MIPI_RX_ANA18_CSI1B, (1 << 4) |
+				     (1 << 6) | (1 << 20) |
+				     (1 << 22), 0x00F000F0);
+			write_master(pmipi_rx,
+				     MIPI_RX_ANA1C_CSI1B, (1 << 4) |
+				     (1 << 6), 0x000000F0);
+		}
+	}
+
+	/* End ANA EQ tuning */
+	seninf_write_reg(pmipi_rx_base, MIPI_RX_ANA40_CSI0A, 0x90);
+	write_master(pmipi_rx, MIPI_RX_ANA24_CSI0A,
+		     (0x40 << 24), 0xFF000000);
+	if (is_4d1c(csi_info->port))
+		write_master(pmipi_rx, MIPI_RX_ANA24_CSI0B,
+			     (0x40 << 24), 0xFF000000);
+	write_master(pmipi_rx, MIPI_RX_WRAPPER80_CSI0A, 0, 0x00030000);
+	if (is_4d1c(csi_info->port))
+		write_master(pmipi_rx, MIPI_RX_WRAPPER80_CSI0B, 0, 0x00030000);
+	/* ANA power on */
+	write_master(pmipi_rx, MIPI_RX_ANA00_CSI0A,
+		     (1 << 3), 0x00000008);
+	if (is_4d1c(csi_info->port))
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0B,
+			     (1 << 3), 0x00000008);
+	usleep_range(20, 40);
+	write_master(pmipi_rx, MIPI_RX_ANA00_CSI0A,
+		     (1 << 3), 0x00000008);
+	if (is_4d1c(csi_info->port))
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0B,
+			     (1 << 2), 0x00000004);
+	udelay(1);
+	/* 4d1c: MIPIRX_CONFIG_CSI_BASE = 0xC9000000; */
+	if (is_4d1c(csi_info->port)) {
+		write_master(pmipi_rx_conf, MIPI_RX_CON24_CSI0,
+			     (1 << 24) | (2 << 26) | (3 << 30), 0xFF000000);
+	} else { /* 2d1c: MIPIRX_CONFIG_CSI_BASE = 0xE4000000; */
+		write_master(pmipi_rx_conf, MIPI_RX_CON24_CSI0,
+			     (1 << 26) | (2 << 28) | (3 << 30), 0xFF000000);
+	}
+	pr_debug("pcsi_mipi->CSI2_IP %d, MIPI_RX_CON24_CSI0 0x%x\n",
+		 csi_info->port,
+		 seninf_read_reg(pmipi_rx_conf, MIPI_RX_CON24_CSI0));
+	usleep_range(20, 40);
+	/* D-PHY SW Delay Line calibration */
+}
+
+static void set_cphy
+	(struct _seninf *priv,
+	struct seninf_csi_mipi *pcsi_mipi)
+{ /* Cphy setting for CSI0 */
+	struct seninf_csi_info *csi_info = pcsi_mipi->csi_info;
+	void *pmipi_rx = priv->csi2_rx[csi_info->port];
+	int status;
+	int i;
+
+	/* Byte clock invert */
+	write_master(pmipi_rx, MIPI_RX_ANAA8_CSI0A,
+		     (1 << 0) | (1 << 2), 0x00000005);
+	write_master(pmipi_rx, MIPI_RX_ANAA8_CSI0B,
+		     (1 << 0) | (1 << 2), 0x00000005);
+	/* EQ Power to Enhance Speed */
+	write_master(pmipi_rx, MIPI_RX_ANA18_CSI0A,
+		     (1 << 6) | (1 << 22), 0x00C000C0);
+	write_master(pmipi_rx, MIPI_RX_ANA1C_CSI0A,
+		     (1 << 6) | (1 << 22), 0x00C000C0);
+	write_master(pmipi_rx, MIPI_RX_ANA20_CSI0A,
+		     (1 << 6) | (1 << 22), 0x00C000C0);
+	write_master(pmipi_rx, MIPI_RX_ANA18_CSI0B,
+		     (1 << 6) | (1 << 22), 0x00C000C0);
+	write_master(pmipi_rx, MIPI_RX_ANA1C_CSI0B,
+		     (1 << 6) | (1 << 22), 0x00C000C0);
+	write_master(pmipi_rx, MIPI_RX_ANA20_CSI0B,
+		     (1 << 6) | (1 << 22), 0x00C000C0);
+
+	/* CDR register setting */
+
+	*((int *)(priv->csi2_rx[csi_info->port] + 0x30)) = 0x06040404;
+	*((int *)(priv->csi2_rx[csi_info->port] + 0x3c)) = 0x06040404;
+	*((int *)(priv->csi2_rx[csi_info->port] + 0x34)) = 0x1;
+	*((int *)(priv->csi2_rx[csi_info->port] + 0x28)) = 0x1;
+
+	*((int *)(priv->csi2_rx[csi_info->port] + 0x1030)) =
+		0x06040404;
+	*((int *)(priv->csi2_rx[csi_info->port] + 0x103c)) =
+		0x06040404;
+	*((int *)(priv->csi2_rx[csi_info->port] + 0x1034)) = 0x1;
+	*((int *)(priv->csi2_rx[csi_info->port] + 0x1028)) = 0x1;
+
+	write_master(pmipi_rx, MIPI_RX_ANA00_CSI0A,
+		     (1 << 0), 0x00001B61);
+	write_master(pmipi_rx, MIPI_RX_ANA00_CSI0B,
+		     (1 << 0), 0x00001B61);
+	/* Power on DPHY */
+	write_master(pmipi_rx, MIPI_RX_ANA00_CSI0A,
+		     (1 << 3), 0x00000008);
+	write_master(pmipi_rx, MIPI_RX_ANA00_CSI0B,
+		     (1 << 3), 0x00000008);
+	usleep_range(20, 40);
+	/* Enable LPF */
+	write_master(pmipi_rx, MIPI_RX_ANA00_CSI0A,
+		     (1 << 2), 0x00000004);
+	write_master(pmipi_rx, MIPI_RX_ANA00_CSI0B,
+		     (1 << 2), 0x00000004);
+	udelay(1);
+	/* Offset calibration */
+	write_master(pmipi_rx, MIPI_RX_ANA18_CSI0A,
+		     (1 << 0) | (1 << 16), 0x00010001);
+	write_master(pmipi_rx, MIPI_RX_ANA1C_CSI0A,
+		     (1 << 0) | (1 << 16), 0x00010001);
+	write_master(pmipi_rx, MIPI_RX_ANA20_CSI0A,
+		     (1 << 0) | (1 << 16), 0x00010001);
+	write_master(pmipi_rx, MIPI_RX_ANA18_CSI0B,
+		     (1 << 0) | (1 << 16), 0x00010001);
+	write_master(pmipi_rx, MIPI_RX_ANA1C_CSI0B,
+		     (1 << 0) | (1 << 16), 0x00010001);
+	write_master(pmipi_rx, MIPI_RX_ANA20_CSI0B,
+		     (1 << 0) | (1 << 16), 0x00010001);
+	udelay(1);
+
+	i = 0;
+	while (1) {
+		status = seninf_read_reg(pmipi_rx,
+					 MIPI_RX_ANA48_CSI0A);
+		if ((status & 0x3f) == 0x3f)
+			break;
+		i++;
+		if (i > 100) {
+			pr_debug("CSIA offset calibration timeout\n");
+			break;
+		}
+		usleep_range(20, 40);
+	}
+
+	i = 0;
+	while (1) {
+		status = seninf_read_reg(pmipi_rx,
+					 MIPI_RX_ANA48_CSI0B);
+		if ((status & 0x3f) == 0x3f)
+			break;
+		i++;
+		if (i > 100) {
+			pr_debug("CSIB offset calibration timeout\n");
+			break;
+		}
+		usleep_range(20, 40);
+	}
+}
+
+static void set_csi_mipi
+	(struct _seninf *priv,
+	struct seninf_csi_mipi *pcsi_mipi)
+{
+	struct seninf_csi_info *csi_info = pcsi_mipi->csi_info;
+	void *seninf_base = priv->base_reg;
+	void *pseninf = priv->base_reg + 0x1000 * csi_info->seninf;
+	void *pmipi_rx = priv->csi2_rx[csi_info->port];
+	unsigned int cal_sel;
+	unsigned int mipi_enable = 1;
+	unsigned int data_header_order = 1;
+	unsigned int pad_sel = PAD_10BIT;
+	unsigned int csi_type = (MIPI_SENSOR_TYPE == MIPI_CPHY)
+		? CSI2_2_5G_CPHY : CSI2_2_5G;
+
+	pr_debug("IS_4D1C %d csi_type %d port %d\n",
+		 is_4d1c(csi_info->port), csi_type, csi_info->port);
+
+	switch (csi_info->port) {
+	case CFG_CSI_PORT_1:
+		cal_sel = 1;
+		write_master(seninf_base, SENINF_TOP_PHY_SENINF_CTL_CSI1,
+			     ((2 << 8) | (mipi_enable << 31)), 0x80000701);
+		break;
+	case CFG_CSI_PORT_2:
+		cal_sel = 2;
+		write_master(seninf_base, SENINF_TOP_PHY_SENINF_CTL_CSI2,
+			     ((2 << 8) | (mipi_enable << 31)), 0x80000701);
+		break;
+	case CFG_CSI_PORT_0:
+		cal_sel = 0;
+		write_master(seninf_base, SENINF_TOP_PHY_SENINF_CTL_CSI0,
+			     ((2 << 8) |
+			     (mipi_enable << 31)), 0x80000701);
+		break;
+	case CFG_CSI_PORT_0A:
+	case CFG_CSI_PORT_0B:
+		cal_sel = 0;
+		write_master(seninf_base, SENINF_TOP_PHY_SENINF_CTL_CSI0,
+			     ((1 << 8) | (1 << 12) |
+			     (mipi_enable << 31)), 0x80003701);
+		break;
+	default:
+		pr_err("unsupported CSI configuration\n");
+		cal_sel = 0;
+		write_master(seninf_base, SENINF_TOP_PHY_SENINF_CTL_CSI0,
+			     ((2 << 8) |
+			     (mipi_enable << 31)), 0x80000701);
+		break;
+	}
+
+	/* First Enable Sensor interface and select pad (0x1a04_0200) */
+	write_master(pseninf, SENINF1_CTRL,
+		     mipi_enable << 0, 0x00000001);
+	write_master(pseninf, SENINF1_CTRL,
+		     pad_sel << 28, 0x70000000);
+
+	if (csi_type == CSI2_1_5G || csi_type == CSI2_2_5G) {
+		write_master(pseninf, SENINF1_CTRL, 0, 0x0000F000);
+		write_master(pseninf, SENINF1_CTRL_EXT,
+			     (mipi_enable << 6), 0x00000060);
+	}
+	if (!mipi_enable) {
+		seninf_write_reg(pseninf, SENINF1_CSI2_CTL,
+				 seninf_read_reg(pseninf, SENINF1_CSI2_CTL) &
+				 0xFFFFFFE0);
+		/* Disable mipi BG */
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0A, 0, 0x0000000C);
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0B, 0, 0x0000000C);
+		return;
+	}
+
+	if (csi_type != CSI2_2_5G_CPHY)
+		set_dphy(priv, pcsi_mipi);
+	else
+		set_cphy(priv, pcsi_mipi);
+
+	/* DPCM Enable */
+	seninf_write_reg(pseninf, SENINF1_CSI2_DPCM,
+			 1 << ((pcsi_mipi->dpcm == 0x2a)
+			 ? 15 : ((pcsi_mipi->dpcm & 0xF) + 7)));
+
+	pr_debug("CSI2-%d cnt:%d LaneNum:%d CSI2_EN:%d HeadOrder:%d dpcm:%d\n",
+		 cal_sel, SENINF_SETTLE_DELAY,
+		 (int)(pcsi_mipi->data_lane_num + 1), (int)mipi_enable,
+		 (int)data_header_order, (int)pcsi_mipi->dpcm);
+
+	/* Settle delay */
+	write_master(pseninf, SENINF1_CSI2_LNRD_TIMING,
+		     (SENINF_SETTLE_DELAY << 8), 0x0000FF00);
+	/* CSI2 control */
+	if (csi_type != CSI2_2_5G_CPHY) { /* DPhy */
+		seninf_write_reg(pseninf, SENINF1_CSI2_CTL,
+				 (seninf_read_reg(pseninf, SENINF1_CSI2_CTL) |
+				 (data_header_order << 16) |
+				 (mipi_enable << 4) |
+				 (((1 << (pcsi_mipi->data_lane_num + 1)) - 1)
+				 )));
+		write_master(pseninf, SENINF1_CSI2_RESYNC_MERGE_CTL,
+			     (3 << 0), 0x00000C07);
+		write_master(pseninf, SENINF1_CSI2_MODE, 0, 0x000007FF);
+		write_master(pseninf, SENINF1_CSI2_DPHY_SYNC,
+			     (0xff00 << 0) | (0x001d << 16), 0xFFFFFFFF);
+		seninf_write_reg(pseninf, SENINF1_CSI2_SPARE0,
+				 seninf_read_reg(pseninf, SENINF1_CSI2_SPARE0)
+				 & 0xFFFFFFFE);
+	} else {
+		/* CPhy */
+		unsigned int temp;
+
+		write_master(pseninf, SENINF1_CSI2_LNRD_TIMING, 0, 0x000000FF);
+		seninf_write_reg(pseninf, SENINF1_CSI2_CTL,
+				 (seninf_read_reg(pseninf, SENINF1_CSI2_CTL) |
+				 data_header_order << 16));
+		temp = (pcsi_mipi->data_lane_num == SENSOR_MIPI_1_LANE) ? 1 :
+			(pcsi_mipi->data_lane_num == SENSOR_MIPI_2_LANE) ? 2 :
+			(pcsi_mipi->data_lane_num == SENSOR_MIPI_3_LANE) ?
+			4 : 5;
+		write_master(pseninf, SENINF1_CSI2_MODE,
+			     (temp << 8), 0x00000700);
+		temp = pcsi_mipi->data_lane_num >= SENSOR_MIPI_1_LANE;
+		write_master(pseninf, SENINF1_CSI2_CTRL_TRIO_CON,
+			     (temp << 0), 0x00000001);
+		temp = pcsi_mipi->data_lane_num >= SENSOR_MIPI_2_LANE;
+		write_master(pseninf, SENINF1_CSI2_CTRL_TRIO_CON,
+			     (temp << 2), 0x00000004);
+		temp = pcsi_mipi->data_lane_num >= SENSOR_MIPI_3_LANE;
+		write_master(pseninf, SENINF1_CSI2_CTRL_TRIO_CON,
+			     (temp << 4), 0x00000010);
+		temp = pcsi_mipi->data_lane_num >= SENSOR_MIPI_4_LANE;
+		write_master(pseninf, SENINF1_CSI2_CTRL_TRIO_CON,
+			     (temp << 6), 0x00000040);
+		write_master(pseninf, SENINF1_CSI2_MODE,
+			     (0x2 << 0), 0x000000FF);
+		write_master(pseninf, SENINF1_CSI2_RESYNC_MERGE_CTL,
+			     (3 << 0) | (1 << 11), 0x00000C07);
+		write_master(pseninf, SENINF1_SYNC_RESYNC_CTL,
+			     (1 << 0), 0x00000007);
+		write_master(pseninf, SENINF1_POST_DETECT_CTL,
+			     (1 << 1), 0x00000002);
+
+		seninf_write_reg(pseninf, SENINF1_CSI2_SPARE0,
+				 seninf_read_reg(pseninf, SENINF1_CSI2_SPARE0)
+				 | 0x1);
+	}
+
+	write_master(pseninf, SENINF1_CSI2_CTL, (1 << 25), 0x0A000080);
+	write_master(pseninf, SENINF1_CSI2_HS_TRAIL,
+		     (SENINF_HS_TRAIL_PARAMETER << 0), 0x000000FF);
+
+	/* Set debug port to output packet number */
+	seninf_write_reg(pseninf, SENINF1_CSI2_DGB_SEL, 0x8000001A);
+	/* Enable CSI2 IRQ mask */
+	/* Turn on all interrupt */
+	seninf_write_reg(pseninf, SENINF1_CSI2_INT_EN, 0xFFFFFFFF);
+	/* Write clear CSI2 IRQ */
+	seninf_write_reg(pseninf, SENINF1_CSI2_INT_STATUS, 0xFFFFFFFF);
+	/* Enable CSI2 Extend IRQ mask */
+	/* Turn on all interrupt */
+	seninf_write_reg(pseninf, SENINF1_CSI2_INT_EN_EXT, 0x0000001f);
+
+	write_master(pseninf, SENINF1_CTRL, (1 << 7), 0x00000080);
+	udelay(1);
+	write_master(pseninf, SENINF1_CTRL, 0, 0x00000080);
+}
+
+static void power_off(struct _seninf *priv, void *pcsi)
+{
+	struct seninf_csi_mipi *pcsi_mipi = (struct seninf_csi_mipi *)pcsi;
+	struct seninf_csi_info *csi_info = pcsi_mipi->csi_info;
+	void *pmipi_rx = priv->csi2_rx[csi_info->port];
+	void *pseninf = priv->base_reg + 0x1000 * csi_info->seninf;
+
+	/* Disable CSI2(2.5G) first */
+	seninf_write_reg(pseninf, SENINF1_CSI2_CTL,
+			 seninf_read_reg(pseninf, SENINF1_CSI2_CTL)
+			 & 0xFFFFFFE0);
+	/* Disable mipi BG */
+	switch (csi_info->port) {
+	case CFG_CSI_PORT_0A:
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0A,
+			     0, 0x0000000C);
+		break;
+	case CFG_CSI_PORT_0B:
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0B,
+			     0, 0x0000000C);
+		break;
+	default:
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0A,
+			     0, 0x0000000C);
+		write_master(pmipi_rx, MIPI_RX_ANA00_CSI0B,
+			     0, 0x0000000C);
+		break;
+	}
+}
+
+static int seninf_subscribe_event(struct v4l2_subdev *sd,
+				  struct v4l2_fh *fh,
+				  struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_CTRL:
+		return v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int map_fmt
+	(struct _seninf *priv,
+	struct seninf_csi_mipi *pcsi_mipi)
+{
+	int fmtidx;
+
+	switch (priv->fmt.format.code) {
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+		fmtidx = 0;
+		pcsi_mipi->dpcm = 0;
+		break;
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+		fmtidx = 1;
+		pcsi_mipi->dpcm = 0;
+		break;
+	case MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:
+		fmtidx = 0;
+		/* dpcm mode 0x2a, */
+		pcsi_mipi->dpcm = 0x2a;
+		break;
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		fmtidx = 2;
+		pcsi_mipi->dpcm = 0;
+		break;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_VYUY8_1X16:
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_YVYU8_1X16:
+		fmtidx = 3;
+		pcsi_mipi->dpcm = 0;
+		break;
+	case MEDIA_BUS_FMT_JPEG_1X8:
+	case MEDIA_BUS_FMT_S5C_UYVY_JPEG_1X8:
+		fmtidx = 7;
+		pcsi_mipi->dpcm = 0;
+		break;
+	default:
+		fmtidx = 0;
+		pcsi_mipi->dpcm = 0;
+		WARN(1, "CSI2: pixel format %08x unsupported!\n",
+		     priv->fmt.format.code);
+		break;
+	}
+	return fmtidx;
+}
+
+static void init_fmt(struct _seninf *priv)
+{
+	priv->fmt.format.code = MEDIA_BUS_FMT_SBGGR10_1X10;
+	priv->fmt.format.width = DEFAULT_WIDTH;
+	priv->fmt.format.height = DEFAULT_HEIGHT;
+	priv->fmt.format.field = V4L2_FIELD_NONE;
+	priv->fmt.format.colorspace = V4L2_COLORSPACE_SRGB;
+	priv->fmt.format.xfer_func = V4L2_XFER_FUNC_DEFAULT;
+	priv->fmt.format.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	priv->fmt.format.quantization = V4L2_QUANTIZATION_DEFAULT;
+}
+
+static const struct v4l2_mbus_framefmt fmt_default = {
+	.code = MEDIA_BUS_FMT_SBGGR10_1X10,
+	.width = DEFAULT_WIDTH,
+	.height = DEFAULT_HEIGHT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_SRGB,
+	.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+	.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+	.quantization = V4L2_QUANTIZATION_DEFAULT,
+};
+
+static int seninf_init_cfg
+				(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg)
+{
+	struct v4l2_mbus_framefmt *mf;
+	unsigned int i;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		mf = v4l2_subdev_get_try_format(sd, cfg, i);
+		*mf = fmt_default;
+	}
+
+	return 0;
+}
+
+static int seninf_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct _seninf *priv = container_of(sd, struct _seninf, subdev);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, cfg, fmt->pad) = fmt->format;
+	} else {
+		priv->fmt.format.code = fmt->format.code;
+		priv->fmt.format.width = fmt->format.width;
+		priv->fmt.format.height = fmt->format.height;
+	}
+
+	pr_debug("set format 0x%x\n", priv->fmt.format.code);
+
+	return 0;
+}
+
+static int seninf_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct _seninf *priv = container_of(sd, struct _seninf, subdev);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		fmt->format = *v4l2_subdev_get_try_format(sd, cfg, fmt->pad);
+	} else {
+		fmt->format.code = priv->fmt.format.code;
+		fmt->format.width = priv->fmt.format.width;
+		fmt->format.height = priv->fmt.format.height;
+		fmt->format.field = priv->fmt.format.field;
+		fmt->format.colorspace = priv->fmt.format.colorspace;
+		fmt->format.xfer_func = priv->fmt.format.xfer_func;
+		fmt->format.ycbcr_enc = priv->fmt.format.ycbcr_enc;
+		fmt->format.quantization = priv->fmt.format.quantization;
+	}
+	pr_debug("get format 0x%x\n", priv->fmt.format.code);
+	return 0;
+}
+
+static int seninf_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct _seninf *priv = container_of(sd, struct _seninf, subdev);
+	struct seninf_csi_mipi csi_mipi;
+	struct seninf_csi_info *csi_info;
+	unsigned int mux_select;
+	unsigned int input_data_type;
+	unsigned int port;
+	unsigned int seninf_src;
+	unsigned char sensor_mipi_lane_num =
+		priv->ep[priv->port].bus.mipi_csi2.num_data_lanes;
+	void *pseninf = priv->base_reg;
+
+	mux_select = priv->mux_select;
+	port = priv->port;
+	csi_info = get_csi_info(priv, port);
+	seninf_src = csi_info->seninf;
+
+	pr_debug("seninf csi_info->seninf(%d) port(%d)\n",
+		 csi_info->seninf, csi_info->port);
+
+	/* Configure Mipi */
+	csi_mipi.data_lane_num = sensor_mipi_lane_num - 1;
+	csi_mipi.csi_info = csi_info;
+	input_data_type = (unsigned int)map_fmt(priv, &csi_mipi);
+
+	if (on) {
+		/* Configure timestamp */
+		write_master(pseninf, SENINF1_CTRL, (1 << 0), 0x00000001);
+		write_master(pseninf, SENINF1_CTRL_EXT, (1 << 6), 0x00000040);
+		seninf_write_reg(pseninf, SENINF_TG1_TM_STP,
+				 SENINF_TIMESTAMP_STEP);
+
+		set_csi_mipi(priv, &csi_mipi);
+
+		enable_mux(priv, mux_select);
+		set_mux_ctrl(priv, mux_select, input_data_type);
+
+		set_top_mux_ctrl(priv, mux_select, seninf_src);
+		seninf_write_reg(pseninf, SENINF_TOP_CAM_MUX_CTRL, 0x0);
+	} else {
+		power_off(priv, &csi_mipi);
+	}
+
+	return 0;
+};
+
+static const struct v4l2_subdev_pad_ops seninf_subdev_pad_ops = {
+	.init_cfg = seninf_init_cfg,
+	.set_fmt = seninf_set_fmt,
+	.get_fmt = seninf_get_fmt,
+};
+
+static const struct v4l2_subdev_video_ops seninf_subdev_video_ops = {
+	.s_stream = seninf_s_stream,
+};
+
+static struct v4l2_subdev_core_ops seninf_subdev_core_ops = {
+	.subscribe_event	= seninf_subscribe_event,
+	.unsubscribe_event	= v4l2_event_subdev_unsubscribe,
+};
+
+static struct v4l2_subdev_ops seninf_subdev_ops = {
+	.core	= &seninf_subdev_core_ops,
+	.video	= &seninf_subdev_video_ops,
+	.pad	= &seninf_subdev_pad_ops,
+};
+
+static int seninf_link_setup(struct media_entity *entity,
+			     const struct media_pad *local,
+			     const struct media_pad *remote, u32 flags)
+{
+	struct v4l2_subdev *sd;
+	struct _seninf *priv;
+
+	sd = media_entity_to_v4l2_subdev(entity);
+	priv = v4l2_get_subdevdata(sd);
+	pr_debug("mtk_seninf: remote %d-%d, local %d-%d\n",
+		 remote->entity->graph_obj.id, remote->index,
+		 local->entity->graph_obj.id, local->index);
+	pr_debug("local->flags %d flags %d\n", local->flags, flags);
+
+	if ((local->flags & MEDIA_PAD_FL_SOURCE) &&
+	    (flags & MEDIA_LNK_FL_ENABLED)) {
+		pr_info("set cam mux %d\n", local->index);
+/* Select cam mux, cam mux from pads 4~11,  pads 0~3 are used for sensor */
+		priv->mux_select = local->index - 4;
+	}
+
+	if ((local->flags & MEDIA_PAD_FL_SINK) &&
+	    (flags & MEDIA_LNK_FL_ENABLED)) {
+		pr_info("set port\n", local->index);
+		/* Select port */
+		priv->port = local->index;
+		if (priv->port > NUM_PORTS) {
+			pr_err("port index is over number of ports\n");
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
+static const struct media_entity_operations seninf_media_ops = {
+	.link_setup = seninf_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int mtk_seninf_notifier_bound(struct v4l2_async_notifier *notifier,
+				     struct v4l2_subdev *sd,
+				     struct v4l2_async_subdev *asd)
+{
+	struct _seninf *priv = container_of(notifier, struct _seninf, notifier);
+	struct device_node *node;
+	unsigned int pad, ret;
+	unsigned int is_sensor;
+	struct device_node *endpoint;
+
+	node = to_of_node(sd->fwnode);
+	dev_info(priv->dev, "%s bounded\n", sd->entity.name);
+
+	is_sensor = 0;
+	if (!strcmp(node->name, SUBDEV_SENSOR_MAIN_NAME)) {
+		pad = MTK_CAM_SENINF_PAD_MAIN_SINK;
+		is_sensor = 1;
+	}
+
+	if (!strcmp(node->name, SUBDEV_SENSOR_SUB_NAME)) {
+		pad = MTK_CAM_SENINF_PAD_SUB_SINK;
+		is_sensor = 1;
+	}
+
+	if (is_sensor == 1) {
+		for_each_endpoint_of_node(node, endpoint) {
+			ret = v4l2_fwnode_endpoint_parse
+				(of_fwnode_handle(endpoint),
+				&priv->ep[pad]);
+			of_node_put(endpoint);
+			dev_info(priv->dev, "ep %d, bus.mipi_csi2.num_data_lanes %d\n",
+				 pad,
+				 priv->ep[pad].bus.mipi_csi2.num_data_lanes);
+		}
+
+		ret = media_create_pad_link(&sd->entity, 0,
+					    &priv->subdev.entity, pad, 0);
+		dev_info
+			(priv->dev, "%s bounded with pad:%d\n",
+			sd->entity.name, pad);
+		if (ret) {
+			dev_err(priv->dev,
+				"failed to create link for %s\n",
+				sd->entity.name);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void mtk_seninf_notifier_unbind(struct v4l2_async_notifier *notifier,
+				       struct v4l2_subdev *sd,
+				       struct v4l2_async_subdev *asd)
+{
+	struct _seninf *priv = container_of(notifier, struct _seninf, notifier);
+
+	dev_info(priv->dev, "%s is unbounded\n", sd->entity.name);
+}
+
+static const struct v4l2_async_notifier_operations mtk_seninf_async_ops = {
+	.bound = mtk_seninf_notifier_bound,
+	.unbind = mtk_seninf_notifier_unbind,
+};
+
+static int mtk_seninf_fwnode_parse(struct device *dev,
+				   struct v4l2_fwnode_endpoint *vep,
+				   struct v4l2_async_subdev *asd)
+{
+	return 0;
+}
+
+static int seninf_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct _seninf *priv = container_of(sd, struct _seninf, subdev);
+	int ret;
+
+	ret = pm_runtime_get_sync(priv->dev);
+	if (ret < 0) {
+		dev_err(priv->dev, "Failed to pm_runtime_get_sync: %d\n", ret);
+		return ret;
+	}
+
+	clk_prepare_enable(priv->cam_clk);
+	clk_prepare_enable(priv->top_mux_clk);
+
+	return ret;
+}
+
+static int seninf_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct _seninf *priv = container_of(sd, struct _seninf, subdev);
+
+	clk_disable_unprepare(priv->top_mux_clk);
+	clk_disable_unprepare(priv->cam_clk);
+	pm_runtime_put(priv->dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API
+static const struct v4l2_subdev_internal_ops seninf_internal_ops = {
+	.open = seninf_open,
+	.close = seninf_close,
+};
+#endif
+
+static irqreturn_t seninf_irq(int irq, void *device_id)
+{
+	return IRQ_HANDLED;
+}
+
+static int seninf_enable_test_pattern(struct _seninf *priv, u32 pattern)
+{
+	void *pseninf = priv->base_reg;
+
+	switch (pattern) {
+	case TEST_DISABLED:
+		break;
+	case TEST_GEN_PATTERN:
+		seninf_write_reg(pseninf, SENINF_TOP_CTRL, 0x00000C00);
+		seninf_write_reg(pseninf, SENINF1_CTRL, 0x00001001);
+		seninf_write_reg(pseninf, SENINF1_MUX_CTRL, 0x96DF1080);
+	    seninf_write_reg(pseninf, SENINF1_MUX_INTEN, 0x8000007F);
+		seninf_write_reg(pseninf, SENINF1_MUX_SPARE, 0x00000000);
+		seninf_write_reg(pseninf, SENINF1_MUX_CTRL_EXT, 0x000E2000);
+		seninf_write_reg(pseninf, SENINF1_MUX_CTRL_EXT, 0x00000000);
+		seninf_write_reg(pseninf, SENINF_TG1_TM_CTL, 0x000404C1);
+		seninf_write_reg
+			(pseninf, SENINF_TG1_TM_SIZE,
+			(priv->fmt.format.height + 0x100) << 16
+			| priv->fmt.format.width + 0x100);
+		seninf_write_reg(pseninf, SENINF_TG1_TM_CLK, 0x00000000);
+		seninf_write_reg(pseninf, SENINF_TG1_TM_STP, 0x1);
+		seninf_write_reg
+			(pseninf, SENINF1_CTRL_EXT, seninf_read_reg(pseninf,
+			SENINF1_CTRL_EXT) | 0x02);/* TESTMDL EN*/
+		break;
+	case TEST_DUMP_DEBUG_INFO:
+		/* Sensor Interface Control */
+		pr_info("SENINF_CSI2_CTL SENINF1:0x%x, 2:0x%x, 3:0x%x, 5:0x%x\n",
+			seninf_read_reg(pseninf, SENINF1_CSI2_CTL),
+			seninf_read_reg(pseninf, SENINF2_CSI2_CTL),
+			seninf_read_reg(pseninf, SENINF3_CSI2_CTL),
+			seninf_read_reg(pseninf, SENINF5_CSI2_CTL));
+		/* Read width/height */
+		/* Read interrupt status */
+		pr_info("SENINF1_IRQ:0x%x, 2:0x%x, 3:0x%x, 5:0x%x\n",
+			seninf_read_reg(pseninf, SENINF1_CSI2_INT_STATUS),
+			seninf_read_reg(pseninf, SENINF2_CSI2_INT_STATUS),
+			seninf_read_reg(pseninf, SENINF3_CSI2_INT_STATUS),
+			seninf_read_reg(pseninf, SENINF5_CSI2_INT_STATUS));
+		/* Mux1 */
+		pr_info("SENINF1_MUX_CTRL:0x%x, INTSTA:0x%x, DEBUG_2(0x%x)\n",
+			seninf_read_reg(pseninf, SENINF1_MUX_CTRL),
+			seninf_read_reg(pseninf, SENINF1_MUX_INTSTA),
+			seninf_read_reg(pseninf, SENINF1_MUX_DEBUG_2));
+		if (seninf_read_reg(pseninf, SENINF1_MUX_INTSTA) & 0x1) {
+			seninf_write_reg(pseninf, SENINF1_MUX_INTSTA,
+					 0xffffffff);
+			udelay(SENINF_DRV_DEBUG_DELAY);
+			pr_info("overrun CTRL:%x INTSTA:%x DEBUG_2:%x\n",
+				seninf_read_reg(pseninf, SENINF1_MUX_CTRL),
+				seninf_read_reg(pseninf, SENINF1_MUX_INTSTA),
+				seninf_read_reg(pseninf, SENINF1_MUX_DEBUG_2));
+		}
+		break;
+	default:
+		dev_warn(priv->dev, "%s Unhandled testcase:%d\n",
+			 __func__, pattern);
+		break;
+	}
+
+	return 0;
+}
+
+static int seninf_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct _seninf *priv = container_of(ctrl->handler,
+					     struct _seninf, ctrl_handler);
+	int ret;
+
+	switch (ctrl->id) {
+	case V4L2_CID_TEST_PATTERN:
+		ret = seninf_enable_test_pattern(priv, ctrl->val);
+		break;
+	default:
+		ret = 0;
+		dev_warn(priv->dev, "%s Unhandled id:0x%x, val:0x%x\n",
+			 __func__, ctrl->id, ctrl->val);
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops seninf_ctrl_ops = {
+	.s_ctrl = seninf_set_ctrl,
+};
+
+static const char * const seninf_test_pattern_menu[] = {
+	"Disabled",
+	"generate_test_pattern",
+	"dump_debug_info",
+};
+
+static int seninf_initialize_controls(struct _seninf *priv)
+{
+	struct v4l2_ctrl_handler *handler;
+	struct v4l2_ctrl *test_pattern;
+	int ret;
+
+	handler = &priv->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(handler, 2);
+	if (ret)
+		return ret;
+	test_pattern =
+	v4l2_ctrl_new_std_menu_items(handler, &seninf_ctrl_ops,
+				     V4L2_CID_TEST_PATTERN,
+				     ARRAY_SIZE(seninf_test_pattern_menu) - 1,
+				     0, 0, seninf_test_pattern_menu);
+
+	if (handler->error) {
+		ret = handler->error;
+		dev_err(priv->dev,
+			"Failed to init controls(%d)\n", ret);
+		goto err_free_handler;
+	}
+
+	priv->subdev.ctrl_handler = handler;
+	return 0;
+
+err_free_handler:
+	v4l2_ctrl_handler_free(handler);
+
+	return ret;
+}
+
+static int seninf_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct _seninf *priv;
+	struct v4l2_subdev *sd;
+	struct device *dev = &pdev->dev;
+	struct media_pad *pads;
+	unsigned int irq_info[3];
+	unsigned int irq;
+	int i;
+	int ret;
+
+	dev_dbg(dev, "seninf probe +\n");
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct _seninf), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	memset(priv, 0, sizeof(struct _seninf));
+	priv->dev = &pdev->dev;
+	sd = &priv->subdev;
+	pads = priv->pads;
+	/* Get IRQ ID and request IRQ */
+	irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+
+	if (!irq) {
+		pr_debug("No IRQ found!!\n");
+		return 0;
+	}
+	/* Get IRQ Flag from device node */
+	if (of_property_read_u32_array(pdev->dev.of_node,
+				       "interrupts", irq_info,
+				       ARRAY_SIZE(irq_info))) {
+		dev_err(dev, "get irq flags from DTS fail!!\n");
+		return -ENODEV;
+	}
+	ret = request_irq(irq, seninf_irq,
+			  irq_info[2], "SENINF", NULL);
+	if (ret) {
+		dev_err(dev, "request_irq fail\n");
+		return ret;
+	}
+	pr_debug("Seninf devnode:%s, irq=%d\n",
+		 pdev->dev.of_node->name, irq);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "base_reg");
+	priv->base_reg = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->base_reg))
+		return PTR_ERR(priv->base_reg);
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "rx_reg");
+	priv->rx_reg = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->rx_reg))
+		return PTR_ERR(priv->rx_reg);
+
+	priv->csi2_rx[CFG_CSI_PORT_0]  = priv->rx_reg;
+	priv->csi2_rx[CFG_CSI_PORT_0A] = priv->rx_reg;
+	priv->csi2_rx[CFG_CSI_PORT_0B] = priv->rx_reg + 0x1000;
+	priv->csi2_rx[CFG_CSI_PORT_1]  = priv->rx_reg + 0x2000;
+	priv->csi2_rx[CFG_CSI_PORT_2]  = priv->rx_reg + 0x4000;
+
+	priv->cam_clk = devm_clk_get(dev, "CLK_CAM_SENINF");
+	if (IS_ERR(priv->cam_clk)) {
+		dev_err(dev, "Failed to get cam_clk\n");
+		return -EINVAL;
+	}
+
+	priv->top_mux_clk = devm_clk_get(dev, "CLK_TOP_MUX_SENINF");
+	if (IS_ERR(priv->top_mux_clk)) {
+		dev_err(dev, "Failed to get top_mux_clk\n");
+		return -EINVAL;
+	}
+
+	v4l2_subdev_init(sd, &seninf_subdev_ops);
+
+	init_fmt(priv);
+	ret = seninf_initialize_controls(priv);
+	if (ret) {
+		dev_err(dev, "Failed to initialize controls\n");
+		return ret;
+	}
+#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API
+	sd->internal_ops = &seninf_internal_ops;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS;
+#endif
+	priv->subdev.dev = &pdev->dev;
+	snprintf(sd->name, V4L2_SUBDEV_NAME_SIZE, "%s.mipi-csi",
+		 dev_name(&pdev->dev));
+	v4l2_set_subdevdata(sd, priv);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	sd->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+	sd->entity.ops = &seninf_media_ops;
+	for (i = 0; i < 4; i++)
+		pads[i].flags = MEDIA_PAD_FL_SINK;
+	for (i = 4; i < NUM_PADS; i++)
+		pads[i].flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&sd->entity, NUM_PADS, pads);
+	if (ret < 0)
+		goto err_free_handler;
+#endif
+	v4l2_async_notifier_init(&priv->notifier);
+	ret = v4l2_async_notifier_parse_fwnode_endpoints
+		(dev, &priv->notifier, sizeof(struct v4l2_async_subdev),
+		 mtk_seninf_fwnode_parse);
+	if (ret < 0)
+		goto err_clean_entity;
+
+	priv->subdev.subdev_notifier = &priv->notifier;
+	priv->notifier.ops = &mtk_seninf_async_ops;
+	ret = v4l2_async_subdev_notifier_register(sd, &priv->notifier);
+	if (ret < 0) {
+		dev_err(dev, "v4l2 async notifier register failed\n");
+		goto err_clean_notififer;
+	}
+
+	ret = v4l2_async_register_subdev(sd);
+	if (ret < 0) {
+		dev_err(dev, "v4l2 async register subdev failed\n");
+		goto err_clean_notififer;
+	}
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+	dev_info(dev, "seninf probe -\n");
+	return 0;
+
+err_clean_notififer:
+	v4l2_async_notifier_cleanup(&priv->notifier);
+err_clean_entity:
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&sd->entity);
+#endif
+err_free_handler:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+
+	return ret;
+}
+
+static int seninf_pm_suspend(struct device *dev)
+{
+	pr_debug("seninf_runtime_suspend\n");
+
+	return 0;
+}
+
+static int seninf_pm_resume(struct device *dev)
+{
+	pr_debug("seninf_runtime_resume\n");
+
+	return 0;
+}
+
+static const struct dev_pm_ops runtime_pm_ops = {
+	SET_RUNTIME_PM_OPS(seninf_pm_suspend,
+			   seninf_pm_resume,
+			   NULL)
+};
+
+static int seninf_remove(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev = platform_get_drvdata(pdev);
+	struct _seninf *priv = container_of(subdev, struct _seninf, subdev);
+	struct v4l2_subdev *sd = &priv->subdev;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&sd->entity);
+#endif
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	v4l2_async_unregister_subdev(&priv->subdev);
+	pm_runtime_disable(priv->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id mtk_seninf_of_match[] = {
+	{.compatible = "mediatek,mt8183-seninf"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, mtk_seninf_of_match);
+#endif
+
+static int seninf_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	return 0;
+}
+
+static int seninf_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver seninf_pdrv = {
+	.probe	= seninf_probe,
+	.remove	= seninf_remove,
+	.suspend = seninf_suspend,
+	.resume = seninf_resume,
+	.driver	= {
+		.name	= "seninf",
+		.owner  = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = mtk_seninf_of_match,
+#endif
+		.pm  = &runtime_pm_ops,
+	},
+};
+
+static int __init mtk_seninf_init(void)
+{
+	int ret;
+
+	pr_debug("seninf Init\n");
+	ret = platform_driver_register(&seninf_pdrv);
+	if (ret) {
+		pr_err("Failed to register platform driver\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit mtk_seninf_exit(void)
+{
+	pr_debug("seninf Exit\n");
+	platform_driver_unregister(&seninf_pdrv);
+}
+
+late_initcall(mtk_seninf_init);
+module_exit(mtk_seninf_exit);
+
+MODULE_DESCRIPTION("MTK seninf driver");
+MODULE_AUTHOR("Louis Kuo <louis.kuo@mediatek.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("MTK:mtk_seninf");
diff --git a/drivers/media/platform/mtk-isp/isp_50/seninf/mtk_seninf_def.h b/drivers/media/platform/mtk-isp/isp_50/seninf/mtk_seninf_def.h
new file mode 100644
index 000000000000..8d00b889cd9c
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/seninf/mtk_seninf_def.h
@@ -0,0 +1,155 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __SENINF_DRV_DEF_H__
+#define __SENINF_DRV_DEF_H__
+
+#if defined(SENINF_CLK_208M)
+#define SENINF_TIMESTAMP_STEP		0x67
+#define SENINF_SETTLE_DELAY		0x15
+#define SENINF_HS_TRAIL_PARAMETER	0x8
+#elif defined(SENINF_CLK_312M)
+#define SENINF_TIMESTAMP_STEP		0x9b
+#define SENINF_SETTLE_DELAY		0x20
+#define SENINF_HS_TRAIL_PARAMETER	0xa
+#else
+#define SENINF_TIMESTAMP_STEP		0x67
+#define SENINF_SETTLE_DELAY		0x15
+#define SENINF_HS_TRAIL_PARAMETER	0x8
+#endif
+
+#define SENINF_DRV_DEBUG_DELAY		1000
+
+#define SENSOR_CLOCK_POLARITY_HIGH	0
+#define SENSOR_CLOCK_POLARITY_LOW	1
+#define NUM_PADS			12
+#define NUM_PORTS			2
+#define DEFAULT_WIDTH			1600
+#define DEFAULT_HEIGHT			1200
+
+enum {
+	MIPI_OPHY_NCSI2 = 0,
+	MIPI_OPHY_CSI2  = 1,
+	MIPI_CPHY       = 2,
+};
+
+enum {
+	TEST_DISABLED = 0X0,
+	TEST_GEN_PATTERN,
+	TEST_DUMP_DEBUG_INFO,
+};
+
+enum {
+	CFG_CSI_PORT_0 = 0x0,	/* 4D1C */
+	CFG_CSI_PORT_1,		/* 4D1C */
+	CFG_CSI_PORT_2,		/* 4D1C */
+	CFG_CSI_PORT_0A,	/* 2D1C */
+	CFG_CSI_PORT_0B,	/* 2D1C */
+	CFG_CSI_PORT_MAX_NUM,
+	CFG_CSI_PORT_NONE	/*for non-MIPI sensor */
+};
+
+enum {
+	ONE_PIXEL_MODE  = 0x0,
+	TWO_PIXEL_MODE  = 0x1,
+	FOUR_PIXEL_MODE = 0x2,
+};
+
+#define SENINF_CAM_MUX_MIN      SENINF_MUX1
+#define SENINF_CAM_MUX_MAX      SENINF_MUX3
+#define SENINF_CAMSV_MUX_MIN    SENINF_MUX3
+#define SENINF_CAMSV_MUX_MAX    SENINF_MUX_NUM
+
+#define SENINF_PIXEL_MODE_CAM   TWO_PIXEL_MODE
+#define SENINF_PIXEL_MODE_CAMSV FOUR_PIXEL_MODE
+
+#define SENINF_TIMESTAMP_CLK    1000
+
+enum {
+	SENSOR_MIPI_1_LANE = 0,
+	SENSOR_MIPI_2_LANE,
+	SENSOR_MIPI_3_LANE,
+	SENSOR_MIPI_4_LANE
+};
+
+enum {
+	SENINF_MUX1 = 0x0,
+	SENINF_MUX2 = 0x1,
+	SENINF_MUX3 = 0x2,
+	SENINF_MUX4 = 0x3,
+	SENINF_MUX5 = 0x4,
+	SENINF_MUX6 = 0x5,
+	SENINF_MUX_NUM,
+	SENINF_MUX_ERROR = -1,
+};
+
+enum {
+	SENINF_1 = 0x0,
+	SENINF_2 = 0x1,
+	SENINF_3 = 0x2,
+	SENINF_4 = 0x3,
+	SENINF_5 = 0x4,
+	SENINF_NUM,
+};
+
+enum {
+	PAD_10BIT       = 0x0,
+	PAD_8BIT_7_0    = 0x3,
+	PAD_8BIT_9_2    = 0x4,
+};
+
+enum { /* 0:CSI2(2.5G), 3: parallel, 8:NCSI2(1.5G) */
+	CSI2            = 0x0, /* 2.5G support */
+	TEST_MODEL      = 0x1,
+	CCIR656         = 0x2,
+	PARALLEL_SENSOR = 0x3,
+	SERIAL_SENSOR   = 0x4,
+	HD_TV           = 0x5,
+	EXT_CSI2_OUT1   = 0x6,
+	EXT_CSI2_OUT2   = 0x7,
+	MIPI_SENSOR     = 0x8,/* 1.5G support */
+	VIRTUAL_CHANNEL_1  = 0x9,
+	VIRTUAL_CHANNEL_2  = 0xA,
+	VIRTUAL_CHANNEL_3  = 0xB,
+	VIRTUAL_CHANNEL_4  = 0xC,
+	VIRTUAL_CHANNEL_5  = 0xD,
+	VIRTUAL_CHANNEL_6  = 0xE,
+};
+
+enum { /* 0:CSI2(2.5G), 1:NCSI2(1.5G) */
+	CSI2_1_5G           = 0x0, /* 1.5G support */
+	CSI2_2_5G           = 0x1, /* 2.5G support*/
+	CSI2_2_5G_CPHY      = 0x2, /* 2.5G support*/
+};
+
+enum {
+	RAW_8BIT_FMT        = 0x0,
+	RAW_10BIT_FMT       = 0x1,
+	RAW_12BIT_FMT       = 0x2,
+	YUV422_FMT          = 0x3,
+	RAW_14BIT_FMT       = 0x4,
+	RGB565_MIPI_FMT     = 0x5,
+	RGB888_MIPI_FMT     = 0x6,
+	JPEG_FMT            = 0x7
+};
+
+enum {
+	CMD_SENINF_GET_SENINF_ADDR,
+	CMD_SENINF_DEBUG_TASK,
+	CMD_SENINF_DEBUG_TASK_CAMSV,
+	CMD_SENINF_DEBUG_PIXEL_METER,
+	CMD_SENINF_MAX
+};
+
+/* MIPI sensor pad usage */
+struct seninf_csi_info {
+	unsigned int port;
+	unsigned int         seninf;
+};
+
+struct seninf_csi_mipi {
+	struct seninf_csi_info  *csi_info;
+	unsigned int     data_lane_num;
+	unsigned int     dpcm;
+};
+
+#endif /*__SENINF_DRV_DEF_H__ */
diff --git a/drivers/media/platform/mtk-isp/isp_50/seninf/mtk_seninf_reg.h b/drivers/media/platform/mtk-isp/isp_50/seninf/mtk_seninf_reg.h
new file mode 100644
index 000000000000..349dc9c4e795
--- /dev/null
+++ b/drivers/media/platform/mtk-isp/isp_50/seninf/mtk_seninf_reg.h
@@ -0,0 +1,965 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef _SENINF_REG_H_
+#define _SENINF_REG_H_
+
+/* 0x11C80000..0x11C850AC */
+#define MIPI_RX_ANA00_CSI0A           0x0000
+#define MIPI_RX_ANA04_CSI0A           0x0004
+#define MIPI_RX_ANA08_CSI0A           0x0008
+#define MIPI_RX_ANA0C_CSI0A           0x000C
+#define MIPI_RX_ANA10_CSI0A           0x0010
+#define MIPI_RX_ANA14_CSI0A           0x0014
+#define MIPI_RX_ANA18_CSI0A           0x0018
+#define MIPI_RX_ANA1C_CSI0A           0x001C
+#define MIPI_RX_ANA20_CSI0A           0x0020
+#define MIPI_RX_ANA24_CSI0A           0x0024
+#define MIPI_RX_ANA28_CSI0A           0x0028
+#define MIPI_RX_ANA2C_CSI0A           0x002C
+#define rsv_0030                      0x0030
+#define MIPI_RX_ANA34_CSI0A           0x0034
+#define MIPI_RX_ANA38_CSI0A           0x0038
+#define rsv_003C                      0x003C
+#define MIPI_RX_ANA40_CSI0A           0x0040
+#define rsv_0044                      0x0044
+#define MIPI_RX_ANA48_CSI0A           0x0048
+#define rsv_004C_13                   0x004C
+#define MIPI_RX_WRAPPER80_CSI0A       0x0080
+#define MIPI_RX_WRAPPER84_CSI0A       0x0084
+#define MIPI_RX_WRAPPER88_CSI0A       0x0088
+#define MIPI_RX_WRAPPER8C_CSI0A       0x008C
+#define MIPI_RX_WRAPPER90_CSI0A       0x0090
+#define MIPI_RX_WRAPPER94_CSI0A       0x0094
+#define MIPI_RX_WRAPPER98_CSI0A       0x0098
+#define MIPI_RX_WRAPPER9C_CSI0A       0x009C
+#define rsv_00A0                      0x00A0
+#define MIPI_RX_ANAA4_CSI0A           0x00A4
+#define MIPI_RX_ANAA8_CSI0A           0x00A8
+#define rsv_00AC_981                  0x00AC
+#define MIPI_RX_ANA00_CSI0B           0x1000
+#define MIPI_RX_ANA04_CSI0B           0x1004
+#define MIPI_RX_ANA08_CSI0B           0x1008
+#define MIPI_RX_ANA0C_CSI0B           0x100C
+#define MIPI_RX_ANA10_CSI0B           0x1010
+#define MIPI_RX_ANA14_CSI0B           0x1014
+#define MIPI_RX_ANA18_CSI0B           0x1018
+#define MIPI_RX_ANA1C_CSI0B           0x101C
+#define MIPI_RX_ANA20_CSI0B           0x1020
+#define MIPI_RX_ANA24_CSI0B           0x1024
+#define MIPI_RX_ANA28_CSI0B           0x1028
+#define MIPI_RX_ANA2C_CSI0B           0x102C
+#define rsv_1030                      0x1030
+#define MIPI_RX_ANA34_CSI0B           0x1034
+#define MIPI_RX_ANA38_CSI0B           0x1038
+#define rsv_103C_3                    0x103C
+#define MIPI_RX_ANA48_CSI0B           0x1048
+#define rsv_104C_13                   0x104C
+#define MIPI_RX_WRAPPER80_CSI0B       0x1080
+#define MIPI_RX_WRAPPER84_CSI0B       0x1084
+#define MIPI_RX_WRAPPER88_CSI0B       0x1088
+#define MIPI_RX_WRAPPER8C_CSI0B       0x108C
+#define MIPI_RX_WRAPPER90_CSI0B       0x1090
+#define MIPI_RX_WRAPPER94_CSI0B       0x1094
+#define MIPI_RX_WRAPPER98_CSI0B       0x1098
+#define MIPI_RX_WRAPPER9C_CSI0B       0x109C
+#define rsv_10A0                      0x10A0
+#define MIPI_RX_ANAA4_CSI0B           0x10A4
+#define MIPI_RX_ANAA8_CSI0B           0x10A8
+#define rsv_10AC_981                  0x10AC
+#define MIPI_RX_ANA00_CSI1A           0x2000
+#define MIPI_RX_ANA04_CSI1A           0x2004
+#define MIPI_RX_ANA08_CSI1A           0x2008
+#define MIPI_RX_ANA0C_CSI1A           0x200C
+#define MIPI_RX_ANA10_CSI1A           0x2010
+#define rsv_2014                      0x2014
+#define MIPI_RX_ANA18_CSI1A           0x2018
+#define MIPI_RX_ANA1C_CSI1A           0x201C
+#define rsv_2020                      0x2020
+#define MIPI_RX_ANA24_CSI1A           0x2024
+#define rsv_2028_8                    0x2028
+#define MIPI_RX_ANA48_CSI1A           0x2048
+#define rsv_204C_13                   0x204C
+#define MIPI_RX_WRAPPER80_CSI1A       0x2080
+#define MIPI_RX_WRAPPER84_CSI1A       0x2084
+#define MIPI_RX_WRAPPER88_CSI1A       0x2088
+#define MIPI_RX_WRAPPER8C_CSI1A       0x208C
+#define MIPI_RX_WRAPPER90_CSI1A       0x2090
+#define MIPI_RX_WRAPPER94_CSI1A       0x2094
+#define MIPI_RX_WRAPPER98_CSI1A       0x2098
+#define MIPI_RX_WRAPPER9C_CSI1A       0x209C
+#define rsv_20A0                      0x20A0
+#define MIPI_RX_ANAA4_CSI1A           0x20A4
+#define MIPI_RX_ANAA8_CSI1A           0x20A8
+#define rsv_20AC_981                  0x20AC
+#define MIPI_RX_ANA00_CSI1B           0x3000
+#define MIPI_RX_ANA04_CSI1B           0x3004
+#define MIPI_RX_ANA08_CSI1B           0x3008
+#define MIPI_RX_ANA0C_CSI1B           0x300C
+#define MIPI_RX_ANA10_CSI1B           0x3010
+#define rsv_3014                      0x3014
+#define MIPI_RX_ANA18_CSI1B           0x3018
+#define MIPI_RX_ANA1C_CSI1B           0x301C
+#define rsv_3020                      0x3020
+#define MIPI_RX_ANA24_CSI1B           0x3024
+#define rsv_3028_8                    0x3028
+#define MIPI_RX_ANA48_CSI1B           0x3048
+#define rsv_304C_13                   0x304C
+#define MIPI_RX_WRAPPER80_CSI1B       0x3080
+#define MIPI_RX_WRAPPER84_CSI1B       0x3084
+#define MIPI_RX_WRAPPER88_CSI1B       0x3088
+#define MIPI_RX_WRAPPER8C_CSI1B       0x308C
+#define MIPI_RX_WRAPPER90_CSI1B       0x3090
+#define MIPI_RX_WRAPPER94_CSI1B       0x3094
+#define MIPI_RX_WRAPPER98_CSI1B       0x3098
+#define MIPI_RX_WRAPPER9C_CSI1B       0x309C
+#define rsv_30A0                      0x30A0
+#define MIPI_RX_ANAA4_CSI1B           0x30A4
+#define MIPI_RX_ANAA8_CSI1B           0x30A8
+#define rsv_30AC_981                  0x30AC
+#define MIPI_RX_ANA00_CSI2A           0x4000
+#define MIPI_RX_ANA04_CSI2A           0x4004
+#define MIPI_RX_ANA08_CSI2A           0x4008
+#define MIPI_RX_ANA0C_CSI2A           0x400C
+#define MIPI_RX_ANA10_CSI2A           0x4010
+#define rsv_4014                      0x4014
+#define MIPI_RX_ANA18_CSI2A           0x4018
+#define MIPI_RX_ANA1C_CSI2A           0x401C
+#define rsv_4020                      0x4020
+#define MIPI_RX_ANA24_CSI2A           0x4024
+#define rsv_4028_8                    0x4028
+#define MIPI_RX_ANA48_CSI2A           0x4048
+#define rsv_404C_13                   0x404C
+#define MIPI_RX_WRAPPER80_CSI2A       0x4080
+#define MIPI_RX_WRAPPER84_CSI2A       0x4084
+#define MIPI_RX_WRAPPER88_CSI2A       0x4088
+#define MIPI_RX_WRAPPER8C_CSI2A       0x408C
+#define MIPI_RX_WRAPPER90_CSI2A       0x4090
+#define MIPI_RX_WRAPPER94_CSI2A       0x4094
+#define MIPI_RX_WRAPPER98_CSI2A       0x4098
+#define MIPI_RX_WRAPPER9C_CSI2A       0x409C
+#define rsv_40A0                      0x40A0
+#define MIPI_RX_ANAA4_CSI2A           0x40A4
+#define MIPI_RX_ANAA8_CSI2A           0x40A8
+#define rsv_40AC_981                  0x40AC
+#define MIPI_RX_ANA00_CSI2B           0x5000
+#define MIPI_RX_ANA04_CSI2B           0x5004
+#define MIPI_RX_ANA08_CSI2B           0x5008
+#define MIPI_RX_ANA0C_CSI2B           0x500C
+#define MIPI_RX_ANA10_CSI2B           0x5010
+#define rsv_5014                      0x5014
+#define MIPI_RX_ANA18_CSI2B           0x5018
+#define MIPI_RX_ANA1C_CSI2B           0x501C
+#define rsv_5020                      0x5020
+#define MIPI_RX_ANA24_CSI2B           0x5024
+#define rsv_5028_8                    0x5028
+#define MIPI_RX_ANA48_CSI2B           0x5048
+#define rsv_504C_13                   0x504C
+#define MIPI_RX_WRAPPER80_CSI2B       0x5080
+#define MIPI_RX_WRAPPER84_CSI2B       0x5084
+#define MIPI_RX_WRAPPER88_CSI2B       0x5088
+#define MIPI_RX_WRAPPER8C_CSI2B       0x508C
+#define MIPI_RX_WRAPPER90_CSI2B       0x5090
+#define MIPI_RX_WRAPPER94_CSI2B       0x5094
+#define MIPI_RX_WRAPPER98_CSI2B       0x5098
+#define MIPI_RX_WRAPPER9C_CSI2B       0x509C
+#define rsv_50A0                      0x50A0
+#define MIPI_RX_ANAA4_CSI2B           0x50A4
+#define MIPI_RX_ANAA8_CSI2B           0x50A8
+#define rsv_50AC_20                   0x50AC
+
+/* 0x1A040000..0x1A047D40 */
+#define SENINF_TOP_CTRL                        0x0000
+#define SENINF_TOP_CMODEL_PAR                  0x0004
+#define SENINF_TOP_MUX_CTRL                    0x0008
+#define rsv_000C                               0x000C
+#define SENINF_TOP_CAM_MUX_CTRL                0x0010
+#define SENINF_TOP_N3D_A_CTL                   0x0014
+#define SENINF_TOP_N3D_B_CTL                   0x0018
+#define SENINF_TOP_PHY_SENINF_CTL_CSI0         0x001C
+#define SENINF_TOP_PHY_SENINF_CTL_CSI1         0x0020
+#define SENINF_TOP_PHY_SENINF_CTL_CSI2         0x0024
+#define rsv_0028_54                            0x0028
+#define SENINF_N3D_A_CTL                       0x0100
+#define SENINF_N3D_A_POS                       0x0104
+#define SENINF_N3D_A_TRIG                      0x0108
+#define SENINF_N3D_A_INT                       0x010C
+#define SENINF_N3D_A_CNT0                      0x0110
+#define SENINF_N3D_A_CNT1                      0x0114
+#define SENINF_N3D_A_DBG                       0x0118
+#define SENINF_N3D_A_DIFF_THR                  0x011C
+#define SENINF_N3D_A_DIFF_CNT                  0x0120
+#define SENINF_N3D_A_DBG_1                     0x0124
+#define SENINF_N3D_A_VALID_TG_CNT              0x0128
+#define SENINF_N3D_A_SYNC_A_PERIOD             0x012C
+#define SENINF_N3D_A_SYNC_B_PERIOD             0x0130
+#define SENINF_N3D_A_SYNC_A_PULSE_LEN          0x0134
+#define SENINF_N3D_A_SYNC_B_PULSE_LEN          0x0138
+#define SENINF_N3D_A_SUB_CNT                   0x013C
+#define SENINF_N3D_A_VSYNC_CNT                 0x0140
+#define rsv_0144_47                            0x0144
+#define SENINF1_CTRL                           0x0200
+#define SENINF1_CTRL_EXT                       0x0204
+#define SENINF1_ASYNC_CTRL                     0x0208
+#define rsv_020C_253                           0x020C
+#define SENINF_TG1_PH_CNT                      0x0600
+#define SENINF_TG1_SEN_CK                      0x0604
+#define SENINF_TG1_TM_CTL                      0x0608
+#define SENINF_TG1_TM_SIZE                     0x060C
+#define SENINF_TG1_TM_CLK                      0x0610
+#define SENINF_TG1_TM_STP                      0x0614
+#define rsv_0618_131                           0x0618
+#define MIPI_RX_CON24_CSI0                     0x0824
+#define MIPI_RX_CON28_CSI0                     0x0828
+#define rsv_082C_2                             0x082C
+#define MIPI_RX_CON34_CSI0                     0x0834
+#define MIPI_RX_CON38_CSI0                     0x0838
+#define MIPI_RX_CON3C_CSI0                     0x083C
+#define rsv_0840_15                            0x0840
+#define MIPI_RX_CON7C_CSI0                     0x087C
+#define MIPI_RX_CON80_CSI0                     0x0880
+#define MIPI_RX_CON84_CSI0                     0x0884
+#define MIPI_RX_CON88_CSI0                     0x0888
+#define MIPI_RX_CON8C_CSI0                     0x088C
+#define MIPI_RX_CON90_CSI0                     0x0890
+#define MIPI_RX_CON94_CSI0                     0x0894
+#define MIPI_RX_CON98_CSI0                     0x0898
+#define rsv_089C                               0x089C
+#define MIPI_RX_CONA0_CSI0                     0x08A0
+#define rsv_08A4_3                             0x08A4
+#define MIPI_RX_CONB0_CSI0                     0x08B0
+#define MIPI_RX_CONB4_CSI0                     0x08B4
+#define MIPI_RX_CONB8_CSI0                     0x08B8
+#define MIPI_RX_CONBC_CSI0                     0x08BC
+#define MIPI_RX_CONC0_CSI0                     0x08C0
+#define MIPI_RX_CONC4_CSI0                     0x08C4
+#define MIPI_RX_CONC8_CSI0                     0x08C8
+#define MIPI_RX_CONCC_CSI0                     0x08CC
+#define MIPI_RX_COND0_CSI0                     0x08D0
+#define rsv_08D4_75                            0x08D4
+#define SENINF1_CSI2_CTL                       0x0A00
+#define SENINF1_CSI2_LNRC_TIMING               0x0A04
+#define SENINF1_CSI2_LNRD_TIMING               0x0A08
+#define SENINF1_CSI2_DPCM                      0x0A0C
+#define SENINF1_CSI2_INT_EN                    0x0A10
+#define SENINF1_CSI2_INT_STATUS                0x0A14
+#define SENINF1_CSI2_DGB_SEL                   0x0A18
+#define SENINF1_CSI2_DBG_PORT                  0x0A1C
+#define SENINF1_CSI2_SPARE0                    0x0A20
+#define SENINF1_CSI2_SPARE1                    0x0A24
+#define SENINF1_CSI2_LNRC_FSM                  0x0A28
+#define SENINF1_CSI2_LNRD_FSM                  0x0A2C
+#define SENINF1_CSI2_FRAME_LINE_NUM            0x0A30
+#define SENINF1_CSI2_GENERIC_SHORT             0x0A34
+#define SENINF1_CSI2_HSRX_DBG                  0x0A38
+#define SENINF1_CSI2_DI                        0x0A3C
+#define SENINF1_CSI2_HS_TRAIL                  0x0A40
+#define SENINF1_CSI2_DI_CTRL                   0x0A44
+#define rsv_0A48                               0x0A48
+#define SENINF1_CSI2_DETECT_CON1               0x0A4C
+#define SENINF1_CSI2_DETECT_CON2               0x0A50
+#define SENINF1_CSI2_DETECT_CON3               0x0A54
+#define SENINF1_CSI2_RLR0_CON0                 0x0A58
+#define SENINF1_CSI2_RLR1_CON0                 0x0A5C
+#define SENINF1_CSI2_RLR2_CON0                 0x0A60
+#define SENINF1_CSI2_RLR_CON0                  0x0A64
+#define SENINF1_CSI2_MUX_CON                   0x0A68
+#define SENINF1_CSI2_DETECT_DBG0               0x0A6C
+#define SENINF1_CSI2_DETECT_DBG1               0x0A70
+#define SENINF1_CSI2_RESYNC_MERGE_CTL          0x0A74
+#define SENINF1_CSI2_CTRL_TRIO_MUX             0x0A78
+#define SENINF1_CSI2_CTRL_TRIO_CON             0x0A7C
+#define SENINF1_FIX_ADDR_CPHY0_DBG             0x0A80
+#define SENINF1_FIX_ADDR_CPHY1_DBG             0x0A84
+#define SENINF1_FIX_ADDR_CPHY2_DBG             0x0A88
+#define SENINF1_FIX_ADDR_DBG                   0x0A8C
+#define SENINF1_WIRE_STATE_DECODE_CPHY0_DBG0   0x0A90
+#define SENINF1_WIRE_STATE_DECODE_CPHY0_DBG1   0x0A94
+#define SENINF1_WIRE_STATE_DECODE_CPHY1_DBG0   0x0A98
+#define SENINF1_WIRE_STATE_DECODE_CPHY1_DBG1   0x0A9C
+#define SENINF1_WIRE_STATE_DECODE_CPHY2_DBG0   0x0AA0
+#define SENINF1_WIRE_STATE_DECODE_CPHY2_DBG1   0x0AA4
+#define SENINF1_SYNC_RESYNC_CTL                0x0AA8
+#define SENINF1_POST_DETECT_CTL                0x0AAC
+#define SENINF1_WIRE_STATE_DECODE_CONFIG       0x0AB0
+#define SENINF1_CSI2_CPHY_LNRD_FSM             0x0AB4
+#define SENINF1_FIX_ADDR_CPHY0_DBG0            0x0AB8
+#define SENINF1_FIX_ADDR_CPHY0_DBG1            0x0ABC
+#define SENINF1_FIX_ADDR_CPHY0_DBG2            0x0AC0
+#define SENINF1_FIX_ADDR_CPHY1_DBG0            0x0AC4
+#define SENINF1_FIX_ADDR_CPHY1_DBG1            0x0AC8
+#define SENINF1_FIX_ADDR_CPHY1_DBG2            0x0ACC
+#define SENINF1_FIX_ADDR_CPHY2_DBG0            0x0AD0
+#define SENINF1_FIX_ADDR_CPHY2_DBG1            0x0AD4
+#define SENINF1_FIX_ADDR_CPHY2_DBG2            0x0AD8
+#define SENINF1_FIX_ADDR_DBG0                  0x0ADC
+#define SENINF1_FIX_ADDR_DBG1                  0x0AE0
+#define SENINF1_FIX_ADDR_DBG2                  0x0AE4
+#define SENINF1_CSI2_MODE                      0x0AE8
+#define rsv_0AEC                               0x0AEC
+#define SENINF1_CSI2_DI_EXT                    0x0AF0
+#define SENINF1_CSI2_DI_CTRL_EXT               0x0AF4
+#define SENINF1_CSI2_CPHY_LOOPBACK             0x0AF8
+#define rsv_0AFC                               0x0AFC
+#define SENINF1_CSI2_PROGSEQ_0                 0x0B00
+#define SENINF1_CSI2_PROGSEQ_1                 0x0B04
+#define rsv_0B08_2                             0x0B08
+#define SENINF1_CSI2_INT_EN_EXT                0x0B10
+#define SENINF1_CSI2_INT_STATUS_EXT            0x0B14
+#define SENINF1_CSI2_CPHY_FIX_POINT_RST        0x0B18
+#define SENINF1_CSI2_RLR3_CON0                 0x0B1C
+#define SENINF1_CSI2_DPHY_SYNC                 0x0B20
+#define SENINF1_CSI2_DESKEW_SYNC               0x0B24
+#define SENINF1_CSI2_DETECT_DBG2               0x0B28
+#define rsv_0B2C                               0x0B2C
+#define SENINF1_FIX_ADDR_CPHY3_DBG0            0x0B30
+#define SENINF1_FIX_ADDR_CPHY3_DBG1            0x0B34
+#define SENINF1_FIX_ADDR_CPHY3_DBG2            0x0B38
+#define SENINF1_CSI2_DI_EXT_2                  0x0B3C
+#define SENINF1_CSI2_DI_CTRL_EXT_2             0x0B40
+#define SENINF1_WIRE_STATE_DECODE_CPHY3_DBG0   0x0B44
+#define SENINF1_WIRE_STATE_DECODE_CPHY3_DBG1   0x0B48
+#define rsv_0B4C_109                           0x0B4C
+#define SENINF1_MUX_CTRL                       0x0D00
+#define SENINF1_MUX_INTEN                      0x0D04
+#define SENINF1_MUX_INTSTA                     0x0D08
+#define SENINF1_MUX_SIZE                       0x0D0C
+#define SENINF1_MUX_DEBUG_1                    0x0D10
+#define SENINF1_MUX_DEBUG_2                    0x0D14
+#define SENINF1_MUX_DEBUG_3                    0x0D18
+#define SENINF1_MUX_DEBUG_4                    0x0D1C
+#define SENINF1_MUX_DEBUG_5                    0x0D20
+#define SENINF1_MUX_DEBUG_6                    0x0D24
+#define SENINF1_MUX_DEBUG_7                    0x0D28
+#define SENINF1_MUX_SPARE                      0x0D2C
+#define SENINF1_MUX_DATA                       0x0D30
+#define SENINF1_MUX_DATA_CNT                   0x0D34
+#define SENINF1_MUX_CROP                       0x0D38
+#define SENINF1_MUX_CTRL_EXT                   0x0D3C
+#define rsv_0D40_240                           0x0D40
+#define SENINF_N3D_B_CTL                       0x1100
+#define SENINF_N3D_B_POS                       0x1104
+#define SENINF_N3D_B_TRIG                      0x1108
+#define SENINF_N3D_B_INT                       0x110C
+#define SENINF_N3D_B_CNT0                      0x1110
+#define SENINF_N3D_B_CNT1                      0x1114
+#define SENINF_N3D_B_DBG                       0x1118
+#define SENINF_N3D_B_DIFF_THR                  0x111C
+#define SENINF_N3D_B_DIFF_CNT                  0x1120
+#define SENINF_N3D_B_DBG_1                     0x1124
+#define SENINF_N3D_B_VALID_TG_CNT              0x1128
+#define SENINF_N3D_B_SYNC_A_PERIOD             0x112C
+#define SENINF_N3D_B_SYNC_B_PERIOD             0x1130
+#define SENINF_N3D_B_SYNC_A_PULSE_LEN          0x1134
+#define SENINF_N3D_B_SYNC_B_PULSE_LEN          0x1138
+#define SENINF_N3D_B_SUB_CNT                   0x113C
+#define SENINF_N3D_B_VSYNC_CNT                 0x1140
+#define rsv_1144_47                            0x1144
+#define SENINF2_CTRL                           0x1200
+#define SENINF2_CTRL_EXT                       0x1204
+#define SENINF2_ASYNC_CTRL                     0x1208
+#define rsv_120C_253                           0x120C
+#define SENINF_TG2_PH_CNT                      0x1600
+#define SENINF_TG2_SEN_CK                      0x1604
+#define SENINF_TG2_TM_CTL                      0x1608
+#define SENINF_TG2_TM_SIZE                     0x160C
+#define SENINF_TG2_TM_CLK                      0x1610
+#define SENINF_TG2_TM_STP                      0x1614
+#define rsv_1618_131                           0x1618
+#define MIPI_RX_CON24_CSI1                     0x1824
+#define MIPI_RX_CON28_CSI1                     0x1828
+#define rsv_182C_2                             0x182C
+#define MIPI_RX_CON34_CSI1                     0x1834
+#define MIPI_RX_CON38_CSI1                     0x1838
+#define MIPI_RX_CON3C_CSI1                     0x183C
+#define rsv_1840_15                            0x1840
+#define MIPI_RX_CON7C_CSI1                     0x187C
+#define MIPI_RX_CON80_CSI1                     0x1880
+#define MIPI_RX_CON84_CSI1                     0x1884
+#define MIPI_RX_CON88_CSI1                     0x1888
+#define MIPI_RX_CON8C_CSI1                     0x188C
+#define MIPI_RX_CON90_CSI1                     0x1890
+#define MIPI_RX_CON94_CSI1                     0x1894
+#define MIPI_RX_CON98_CSI1                     0x1898
+#define rsv_189C                               0x189C
+#define MIPI_RX_CONA0_CSI1                     0x18A0
+#define rsv_18A4_3                             0x18A4
+#define MIPI_RX_CONB0_CSI1                     0x18B0
+#define MIPI_RX_CONB4_CSI1                     0x18B4
+#define MIPI_RX_CONB8_CSI1                     0x18B8
+#define MIPI_RX_CONBC_CSI1                     0x18BC
+#define MIPI_RX_CONC0_CSI1                     0x18C0
+#define MIPI_RX_CONC4_CSI1                     0x18C4
+#define MIPI_RX_CONC8_CSI1                     0x18C8
+#define MIPI_RX_CONCC_CSI1                     0x18CC
+#define MIPI_RX_COND0_CSI1                     0x18D0
+#define rsv_18D4_75                            0x18D4
+#define SENINF2_CSI2_CTL                       0x1A00
+#define SENINF2_CSI2_LNRC_TIMING               0x1A04
+#define SENINF2_CSI2_LNRD_TIMING               0x1A08
+#define SENINF2_CSI2_DPCM                      0x1A0C
+#define SENINF2_CSI2_INT_EN                    0x1A10
+#define SENINF2_CSI2_INT_STATUS                0x1A14
+#define SENINF2_CSI2_DGB_SEL                   0x1A18
+#define SENINF2_CSI2_DBG_PORT                  0x1A1C
+#define SENINF2_CSI2_SPARE0                    0x1A20
+#define SENINF2_CSI2_SPARE1                    0x1A24
+#define SENINF2_CSI2_LNRC_FSM                  0x1A28
+#define SENINF2_CSI2_LNRD_FSM                  0x1A2C
+#define SENINF2_CSI2_FRAME_LINE_NUM            0x1A30
+#define SENINF2_CSI2_GENERIC_SHORT             0x1A34
+#define SENINF2_CSI2_HSRX_DBG                  0x1A38
+#define SENINF2_CSI2_DI                        0x1A3C
+#define SENINF2_CSI2_HS_TRAIL                  0x1A40
+#define SENINF2_CSI2_DI_CTRL                   0x1A44
+#define rsv_1A48                               0x1A48
+#define SENINF2_CSI2_DETECT_CON1               0x1A4C
+#define SENINF2_CSI2_DETECT_CON2               0x1A50
+#define SENINF2_CSI2_DETECT_CON3               0x1A54
+#define SENINF2_CSI2_RLR0_CON0                 0x1A58
+#define SENINF2_CSI2_RLR1_CON0                 0x1A5C
+#define SENINF2_CSI2_RLR2_CON0                 0x1A60
+#define SENINF2_CSI2_RLR_CON0                  0x1A64
+#define SENINF2_CSI2_MUX_CON                   0x1A68
+#define SENINF2_CSI2_DETECT_DBG0               0x1A6C
+#define SENINF2_CSI2_DETECT_DBG1               0x1A70
+#define SENINF2_CSI2_RESYNC_MERGE_CTL          0x1A74
+#define SENINF2_CSI2_CTRL_TRIO_MUX             0x1A78
+#define SENINF2_CSI2_CTRL_TRIO_CON             0x1A7C
+#define SENINF2_FIX_ADDR_CPHY0_DBG             0x1A80
+#define SENINF2_FIX_ADDR_CPHY1_DBG             0x1A84
+#define SENINF2_FIX_ADDR_CPHY2_DBG             0x1A88
+#define SENINF2_FIX_ADDR_DBG                   0x1A8C
+#define SENINF2_WIRE_STATE_DECODE_CPHY0_DBG0   0x1A90
+#define SENINF2_WIRE_STATE_DECODE_CPHY0_DBG1   0x1A94
+#define SENINF2_WIRE_STATE_DECODE_CPHY1_DBG0   0x1A98
+#define SENINF2_WIRE_STATE_DECODE_CPHY1_DBG1   0x1A9C
+#define SENINF2_WIRE_STATE_DECODE_CPHY2_DBG0   0x1AA0
+#define SENINF2_WIRE_STATE_DECODE_CPHY2_DBG1   0x1AA4
+#define SENINF2_SYNC_RESYNC_CTL                0x1AA8
+#define SENINF2_POST_DETECT_CTL                0x1AAC
+#define SENINF2_WIRE_STATE_DECODE_CONFIG       0x1AB0
+#define SENINF2_CSI2_CPHY_LNRD_FSM             0x1AB4
+#define SENINF2_FIX_ADDR_CPHY0_DBG0            0x1AB8
+#define SENINF2_FIX_ADDR_CPHY0_DBG1            0x1ABC
+#define SENINF2_FIX_ADDR_CPHY0_DBG2            0x1AC0
+#define SENINF2_FIX_ADDR_CPHY1_DBG0            0x1AC4
+#define SENINF2_FIX_ADDR_CPHY1_DBG1            0x1AC8
+#define SENINF2_FIX_ADDR_CPHY1_DBG2            0x1ACC
+#define SENINF2_FIX_ADDR_CPHY2_DBG0            0x1AD0
+#define SENINF2_FIX_ADDR_CPHY2_DBG1            0x1AD4
+#define SENINF2_FIX_ADDR_CPHY2_DBG2            0x1AD8
+#define SENINF2_FIX_ADDR_DBG0                  0x1ADC
+#define SENINF2_FIX_ADDR_DBG1                  0x1AE0
+#define SENINF2_FIX_ADDR_DBG2                  0x1AE4
+#define SENINF2_CSI2_MODE                      0x1AE8
+#define rsv_1AEC                               0x1AEC
+#define SENINF2_CSI2_DI_EXT                    0x1AF0
+#define SENINF2_CSI2_DI_CTRL_EXT               0x1AF4
+#define SENINF2_CSI2_CPHY_LOOPBACK             0x1AF8
+#define rsv_1AFC                               0x1AFC
+#define SENINF2_CSI2_PROGSEQ_0                 0x1B00
+#define SENINF2_CSI2_PROGSEQ_1                 0x1B04
+#define rsv_1B08_2                             0x1B08
+#define SENINF2_CSI2_INT_EN_EXT                0x1B10
+#define SENINF2_CSI2_INT_STATUS_EXT            0x1B14
+#define SENINF2_CSI2_CPHY_FIX_POINT_RST        0x1B18
+#define SENINF2_CSI2_RLR3_CON0                 0x1B1C
+#define SENINF2_CSI2_DPHY_SYNC                 0x1B20
+#define SENINF2_CSI2_DESKEW_SYNC               0x1B24
+#define SENINF2_CSI2_DETECT_DBG2               0x1B28
+#define rsv_1B2C                               0x1B2C
+#define SENINF2_FIX_ADDR_CPHY3_DBG0            0x1B30
+#define SENINF2_FIX_ADDR_CPHY3_DBG1            0x1B34
+#define SENINF2_FIX_ADDR_CPHY3_DBG2            0x1B38
+#define SENINF2_CSI2_DI_EXT_2                  0x1B3C
+#define SENINF2_CSI2_DI_CTRL_EXT_2             0x1B40
+#define SENINF2_WIRE_STATE_DECODE_CPHY3_DBG0   0x1B44
+#define SENINF2_WIRE_STATE_DECODE_CPHY3_DBG1   0x1B48
+#define rsv_1B4C_109                           0x1B4C
+#define SENINF2_MUX_CTRL                       0x1D00
+#define SENINF2_MUX_INTEN                      0x1D04
+#define SENINF2_MUX_INTSTA                     0x1D08
+#define SENINF2_MUX_SIZE                       0x1D0C
+#define SENINF2_MUX_DEBUG_1                    0x1D10
+#define SENINF2_MUX_DEBUG_2                    0x1D14
+#define SENINF2_MUX_DEBUG_3                    0x1D18
+#define SENINF2_MUX_DEBUG_4                    0x1D1C
+#define SENINF2_MUX_DEBUG_5                    0x1D20
+#define SENINF2_MUX_DEBUG_6                    0x1D24
+#define SENINF2_MUX_DEBUG_7                    0x1D28
+#define SENINF2_MUX_SPARE                      0x1D2C
+#define SENINF2_MUX_DATA                       0x1D30
+#define SENINF2_MUX_DATA_CNT                   0x1D34
+#define SENINF2_MUX_CROP                       0x1D38
+#define SENINF2_MUX_CTRL_EXT                   0x1D3C
+#define rsv_1D40_304                           0x1D40
+#define SENINF3_CTRL                           0x2200
+#define SENINF3_CTRL_EXT                       0x2204
+#define SENINF3_ASYNC_CTRL                     0x2208
+#define rsv_220C_253                           0x220C
+#define SENINF_TG3_PH_CNT                      0x2600
+#define SENINF_TG3_SEN_CK                      0x2604
+#define SENINF_TG3_TM_CTL                      0x2608
+#define SENINF_TG3_TM_SIZE                     0x260C
+#define SENINF_TG3_TM_CLK                      0x2610
+#define SENINF_TG3_TM_STP                      0x2614
+#define rsv_2618_131                           0x2618
+#define MIPI_RX_CON24_CSI2                     0x2824
+#define MIPI_RX_CON28_CSI2                     0x2828
+#define rsv_282C_2                             0x282C
+#define MIPI_RX_CON34_CSI2                     0x2834
+#define MIPI_RX_CON38_CSI2                     0x2838
+#define MIPI_RX_CON3C_CSI2                     0x283C
+#define rsv_2840_15                            0x2840
+#define MIPI_RX_CON7C_CSI2                     0x287C
+#define MIPI_RX_CON80_CSI2                     0x2880
+#define MIPI_RX_CON84_CSI2                     0x2884
+#define MIPI_RX_CON88_CSI2                     0x2888
+#define MIPI_RX_CON8C_CSI2                     0x288C
+#define MIPI_RX_CON90_CSI2                     0x2890
+#define MIPI_RX_CON94_CSI2                     0x2894
+#define MIPI_RX_CON98_CSI2                     0x2898
+#define rsv_289C                               0x289C
+#define MIPI_RX_CONA0_CSI2                     0x28A0
+#define rsv_28A4_3                             0x28A4
+#define MIPI_RX_CONB0_CSI2                     0x28B0
+#define MIPI_RX_CONB4_CSI2                     0x28B4
+#define MIPI_RX_CONB8_CSI2                     0x28B8
+#define MIPI_RX_CONBC_CSI2                     0x28BC
+#define MIPI_RX_CONC0_CSI2                     0x28C0
+#define MIPI_RX_CONC4_CSI2                     0x28C4
+#define MIPI_RX_CONC8_CSI2                     0x28C8
+#define MIPI_RX_CONCC_CSI2                     0x28CC
+#define MIPI_RX_COND0_CSI2                     0x28D0
+#define rsv_28D4_75                            0x28D4
+#define SENINF3_CSI2_CTL                       0x2A00
+#define SENINF3_CSI2_LNRC_TIMING               0x2A04
+#define SENINF3_CSI2_LNRD_TIMING               0x2A08
+#define SENINF3_CSI2_DPCM                      0x2A0C
+#define SENINF3_CSI2_INT_EN                    0x2A10
+#define SENINF3_CSI2_INT_STATUS                0x2A14
+#define SENINF3_CSI2_DGB_SEL                   0x2A18
+#define SENINF3_CSI2_DBG_PORT                  0x2A1C
+#define SENINF3_CSI2_SPARE0                    0x2A20
+#define SENINF3_CSI2_SPARE1                    0x2A24
+#define SENINF3_CSI2_LNRC_FSM                  0x2A28
+#define SENINF3_CSI2_LNRD_FSM                  0x2A2C
+#define SENINF3_CSI2_FRAME_LINE_NUM            0x2A30
+#define SENINF3_CSI2_GENERIC_SHORT             0x2A34
+#define SENINF3_CSI2_HSRX_DBG                  0x2A38
+#define SENINF3_CSI2_DI                        0x2A3C
+#define SENINF3_CSI2_HS_TRAIL                  0x2A40
+#define SENINF3_CSI2_DI_CTRL                   0x2A44
+#define rsv_2A48                               0x2A48
+#define SENINF3_CSI2_DETECT_CON1               0x2A4C
+#define SENINF3_CSI2_DETECT_CON2               0x2A50
+#define SENINF3_CSI2_DETECT_CON3               0x2A54
+#define SENINF3_CSI2_RLR0_CON0                 0x2A58
+#define SENINF3_CSI2_RLR1_CON0                 0x2A5C
+#define SENINF3_CSI2_RLR2_CON0                 0x2A60
+#define SENINF3_CSI2_RLR_CON0                  0x2A64
+#define SENINF3_CSI2_MUX_CON                   0x2A68
+#define SENINF3_CSI2_DETECT_DBG0               0x2A6C
+#define SENINF3_CSI2_DETECT_DBG1               0x2A70
+#define SENINF3_CSI2_RESYNC_MERGE_CTL          0x2A74
+#define SENINF3_CSI2_CTRL_TRIO_MUX             0x2A78
+#define SENINF3_CSI2_CTRL_TRIO_CON             0x2A7C
+#define SENINF3_FIX_ADDR_CPHY0_DBG             0x2A80
+#define SENINF3_FIX_ADDR_CPHY1_DBG             0x2A84
+#define SENINF3_FIX_ADDR_CPHY2_DBG             0x2A88
+#define SENINF3_FIX_ADDR_DBG                   0x2A8C
+#define SENINF3_WIRE_STATE_DECODE_CPHY0_DBG0   0x2A90
+#define SENINF3_WIRE_STATE_DECODE_CPHY0_DBG1   0x2A94
+#define SENINF3_WIRE_STATE_DECODE_CPHY1_DBG0   0x2A98
+#define SENINF3_WIRE_STATE_DECODE_CPHY1_DBG1   0x2A9C
+#define SENINF3_WIRE_STATE_DECODE_CPHY2_DBG0   0x2AA0
+#define SENINF3_WIRE_STATE_DECODE_CPHY2_DBG1   0x2AA4
+#define SENINF3_SYNC_RESYNC_CTL                0x2AA8
+#define SENINF3_POST_DETECT_CTL                0x2AAC
+#define SENINF3_WIRE_STATE_DECODE_CONFIG       0x2AB0
+#define SENINF3_CSI2_CPHY_LNRD_FSM             0x2AB4
+#define SENINF3_FIX_ADDR_CPHY0_DBG0            0x2AB8
+#define SENINF3_FIX_ADDR_CPHY0_DBG1            0x2ABC
+#define SENINF3_FIX_ADDR_CPHY0_DBG2            0x2AC0
+#define SENINF3_FIX_ADDR_CPHY1_DBG0            0x2AC4
+#define SENINF3_FIX_ADDR_CPHY1_DBG1            0x2AC8
+#define SENINF3_FIX_ADDR_CPHY1_DBG2            0x2ACC
+#define SENINF3_FIX_ADDR_CPHY2_DBG0            0x2AD0
+#define SENINF3_FIX_ADDR_CPHY2_DBG1            0x2AD4
+#define SENINF3_FIX_ADDR_CPHY2_DBG2            0x2AD8
+#define SENINF3_FIX_ADDR_DBG0                  0x2ADC
+#define SENINF3_FIX_ADDR_DBG1                  0x2AE0
+#define SENINF3_FIX_ADDR_DBG2                  0x2AE4
+#define SENINF3_CSI2_MODE                      0x2AE8
+#define rsv_2AEC                               0x2AEC
+#define SENINF3_CSI2_DI_EXT                    0x2AF0
+#define SENINF3_CSI2_DI_CTRL_EXT               0x2AF4
+#define SENINF3_CSI2_CPHY_LOOPBACK             0x2AF8
+#define rsv_2AFC                               0x2AFC
+#define SENINF3_CSI2_PROGSEQ_0                 0x2B00
+#define SENINF3_CSI2_PROGSEQ_1                 0x2B04
+#define rsv_2B08_2                             0x2B08
+#define SENINF3_CSI2_INT_EN_EXT                0x2B10
+#define SENINF3_CSI2_INT_STATUS_EXT            0x2B14
+#define SENINF3_CSI2_CPHY_FIX_POINT_RST        0x2B18
+#define SENINF3_CSI2_RLR3_CON0                 0x2B1C
+#define SENINF3_CSI2_DPHY_SYNC                 0x2B20
+#define SENINF3_CSI2_DESKEW_SYNC               0x2B24
+#define SENINF3_CSI2_DETECT_DBG2               0x2B28
+#define rsv_2B2C                               0x2B2C
+#define SENINF3_FIX_ADDR_CPHY3_DBG0            0x2B30
+#define SENINF3_FIX_ADDR_CPHY3_DBG1            0x2B34
+#define SENINF3_FIX_ADDR_CPHY3_DBG2            0x2B38
+#define SENINF3_CSI2_DI_EXT_2                  0x2B3C
+#define SENINF3_CSI2_DI_CTRL_EXT_2             0x2B40
+#define SENINF3_WIRE_STATE_DECODE_CPHY3_DBG0   0x2B44
+#define SENINF3_WIRE_STATE_DECODE_CPHY3_DBG1   0x2B48
+#define rsv_2B4C_109                           0x2B4C
+#define SENINF3_MUX_CTRL                       0x2D00
+#define SENINF3_MUX_INTEN                      0x2D04
+#define SENINF3_MUX_INTSTA                     0x2D08
+#define SENINF3_MUX_SIZE                       0x2D0C
+#define SENINF3_MUX_DEBUG_1                    0x2D10
+#define SENINF3_MUX_DEBUG_2                    0x2D14
+#define SENINF3_MUX_DEBUG_3                    0x2D18
+#define SENINF3_MUX_DEBUG_4                    0x2D1C
+#define SENINF3_MUX_DEBUG_5                    0x2D20
+#define SENINF3_MUX_DEBUG_6                    0x2D24
+#define SENINF3_MUX_DEBUG_7                    0x2D28
+#define SENINF3_MUX_SPARE                      0x2D2C
+#define SENINF3_MUX_DATA                       0x2D30
+#define SENINF3_MUX_DATA_CNT                   0x2D34
+#define SENINF3_MUX_CROP                       0x2D38
+#define SENINF3_MUX_CTRL_EXT                   0x2D3C
+#define rsv_2D40_304                           0x2D40
+#define SENINF4_CTRL                           0x3200
+#define SENINF4_CTRL_EXT                       0x3204
+#define SENINF4_ASYNC_CTRL                     0x3208
+#define rsv_320C_253                           0x320C
+#define SENINF_TG4_PH_CNT                      0x3600
+#define SENINF_TG4_SEN_CK                      0x3604
+#define SENINF_TG4_TM_CTL                      0x3608
+#define SENINF_TG4_TM_SIZE                     0x360C
+#define SENINF_TG4_TM_CLK                      0x3610
+#define SENINF_TG4_TM_STP                      0x3614
+#define rsv_3618_131                           0x3618
+#define MIPI_RX_CON24_CSI3                     0x3824
+#define MIPI_RX_CON28_CSI3                     0x3828
+#define rsv_382C_2                             0x382C
+#define MIPI_RX_CON34_CSI3                     0x3834
+#define MIPI_RX_CON38_CSI3                     0x3838
+#define MIPI_RX_CON3C_CSI3                     0x383C
+#define rsv_3840_15                            0x3840
+#define MIPI_RX_CON7C_CSI3                     0x387C
+#define MIPI_RX_CON80_CSI3                     0x3880
+#define MIPI_RX_CON84_CSI3                     0x3884
+#define MIPI_RX_CON88_CSI3                     0x3888
+#define MIPI_RX_CON8C_CSI3                     0x388C
+#define MIPI_RX_CON90_CSI3                     0x3890
+#define MIPI_RX_CON94_CSI3                     0x3894
+#define MIPI_RX_CON98_CSI3                     0x3898
+#define rsv_389C                               0x389C
+#define MIPI_RX_CONA0_CSI3                     0x38A0
+#define rsv_38A4_3                             0x38A4
+#define MIPI_RX_CONB0_CSI3                     0x38B0
+#define MIPI_RX_CONB4_CSI3                     0x38B4
+#define MIPI_RX_CONB8_CSI3                     0x38B8
+#define MIPI_RX_CONBC_CSI3                     0x38BC
+#define MIPI_RX_CONC0_CSI3                     0x38C0
+#define MIPI_RX_CONC4_CSI3                     0x38C4
+#define MIPI_RX_CONC8_CSI3                     0x38C8
+#define MIPI_RX_CONCC_CSI3                     0x38CC
+#define MIPI_RX_COND0_CSI3                     0x38D0
+#define rsv_38D4_75                            0x38D4
+#define SENINF4_CSI2_CTL                       0x3A00
+#define SENINF4_CSI2_LNRC_TIMING               0x3A04
+#define SENINF4_CSI2_LNRD_TIMING               0x3A08
+#define SENINF4_CSI2_DPCM                      0x3A0C
+#define SENINF4_CSI2_INT_EN                    0x3A10
+#define SENINF4_CSI2_INT_STATUS                0x3A14
+#define SENINF4_CSI2_DGB_SEL                   0x3A18
+#define SENINF4_CSI2_DBG_PORT                  0x3A1C
+#define SENINF4_CSI2_SPARE0                    0x3A20
+#define SENINF4_CSI2_SPARE1                    0x3A24
+#define SENINF4_CSI2_LNRC_FSM                  0x3A28
+#define SENINF4_CSI2_LNRD_FSM                  0x3A2C
+#define SENINF4_CSI2_FRAME_LINE_NUM            0x3A30
+#define SENINF4_CSI2_GENERIC_SHORT             0x3A34
+#define SENINF4_CSI2_HSRX_DBG                  0x3A38
+#define SENINF4_CSI2_DI                        0x3A3C
+#define SENINF4_CSI2_HS_TRAIL                  0x3A40
+#define SENINF4_CSI2_DI_CTRL                   0x3A44
+#define rsv_3A48                               0x3A48
+#define SENINF4_CSI2_DETECT_CON1               0x3A4C
+#define SENINF4_CSI2_DETECT_CON2               0x3A50
+#define SENINF4_CSI2_DETECT_CON3               0x3A54
+#define SENINF4_CSI2_RLR0_CON0                 0x3A58
+#define SENINF4_CSI2_RLR1_CON0                 0x3A5C
+#define SENINF4_CSI2_RLR2_CON0                 0x3A60
+#define SENINF4_CSI2_RLR_CON0                  0x3A64
+#define SENINF4_CSI2_MUX_CON                   0x3A68
+#define SENINF4_CSI2_DETECT_DBG0               0x3A6C
+#define SENINF4_CSI2_DETECT_DBG1               0x3A70
+#define SENINF4_CSI2_RESYNC_MERGE_CTL          0x3A74
+#define SENINF4_CSI2_CTRL_TRIO_MUX             0x3A78
+#define SENINF4_CSI2_CTRL_TRIO_CON             0x3A7C
+#define SENINF4_FIX_ADDR_CPHY0_DBG             0x3A80
+#define SENINF4_FIX_ADDR_CPHY1_DBG             0x3A84
+#define SENINF4_FIX_ADDR_CPHY2_DBG             0x3A88
+#define SENINF4_FIX_ADDR_DBG                   0x3A8C
+#define SENINF4_WIRE_STATE_DECODE_CPHY0_DBG0   0x3A90
+#define SENINF4_WIRE_STATE_DECODE_CPHY0_DBG1   0x3A94
+#define SENINF4_WIRE_STATE_DECODE_CPHY1_DBG0   0x3A98
+#define SENINF4_WIRE_STATE_DECODE_CPHY1_DBG1   0x3A9C
+#define SENINF4_WIRE_STATE_DECODE_CPHY2_DBG0   0x3AA0
+#define SENINF4_WIRE_STATE_DECODE_CPHY2_DBG1   0x3AA4
+#define SENINF4_SYNC_RESYNC_CTL                0x3AA8
+#define SENINF4_POST_DETECT_CTL                0x3AAC
+#define SENINF4_WIRE_STATE_DECODE_CONFIG       0x3AB0
+#define SENINF4_CSI2_CPHY_LNRD_FSM             0x3AB4
+#define SENINF4_FIX_ADDR_CPHY0_DBG0            0x3AB8
+#define SENINF4_FIX_ADDR_CPHY0_DBG1            0x3ABC
+#define SENINF4_FIX_ADDR_CPHY0_DBG2            0x3AC0
+#define SENINF4_FIX_ADDR_CPHY1_DBG0            0x3AC4
+#define SENINF4_FIX_ADDR_CPHY1_DBG1            0x3AC8
+#define SENINF4_FIX_ADDR_CPHY1_DBG2            0x3ACC
+#define SENINF4_FIX_ADDR_CPHY2_DBG0            0x3AD0
+#define SENINF4_FIX_ADDR_CPHY2_DBG1            0x3AD4
+#define SENINF4_FIX_ADDR_CPHY2_DBG2            0x3AD8
+#define SENINF4_FIX_ADDR_DBG0                  0x3ADC
+#define SENINF4_FIX_ADDR_DBG1                  0x3AE0
+#define SENINF4_FIX_ADDR_DBG2                  0x3AE4
+#define SENINF4_CSI2_MODE                      0x3AE8
+#define rsv_3AEC                               0x3AEC
+#define SENINF4_CSI2_DI_EXT                    0x3AF0
+#define SENINF4_CSI2_DI_CTRL_EXT               0x3AF4
+#define SENINF4_CSI2_CPHY_LOOPBACK             0x3AF8
+#define rsv_3AFC                               0x3AFC
+#define SENINF4_CSI2_PROGSEQ_0                 0x3B00
+#define SENINF4_CSI2_PROGSEQ_1                 0x3B04
+#define rsv_3B08_2                             0x3B08
+#define SENINF4_CSI2_INT_EN_EXT                0x3B10
+#define SENINF4_CSI2_INT_STATUS_EXT            0x3B14
+#define SENINF4_CSI2_CPHY_FIX_POINT_RST        0x3B18
+#define SENINF4_CSI2_RLR3_CON0                 0x3B1C
+#define SENINF4_CSI2_DPHY_SYNC                 0x3B20
+#define SENINF4_CSI2_DESKEW_SYNC               0x3B24
+#define SENINF4_CSI2_DETECT_DBG2               0x3B28
+#define rsv_3B2C                               0x3B2C
+#define SENINF4_FIX_ADDR_CPHY3_DBG0            0x3B30
+#define SENINF4_FIX_ADDR_CPHY3_DBG1            0x3B34
+#define SENINF4_FIX_ADDR_CPHY3_DBG2            0x3B38
+#define SENINF4_CSI2_DI_EXT_2                  0x3B3C
+#define SENINF4_CSI2_DI_CTRL_EXT_2             0x3B40
+#define SENINF4_WIRE_STATE_DECODE_CPHY3_DBG0   0x3B44
+#define SENINF4_WIRE_STATE_DECODE_CPHY3_DBG1   0x3B48
+#define rsv_3B4C_109                           0x3B4C
+#define SENINF4_MUX_CTRL                       0x3D00
+#define SENINF4_MUX_INTEN                      0x3D04
+#define SENINF4_MUX_INTSTA                     0x3D08
+#define SENINF4_MUX_SIZE                       0x3D0C
+#define SENINF4_MUX_DEBUG_1                    0x3D10
+#define SENINF4_MUX_DEBUG_2                    0x3D14
+#define SENINF4_MUX_DEBUG_3                    0x3D18
+#define SENINF4_MUX_DEBUG_4                    0x3D1C
+#define SENINF4_MUX_DEBUG_5                    0x3D20
+#define SENINF4_MUX_DEBUG_6                    0x3D24
+#define SENINF4_MUX_DEBUG_7                    0x3D28
+#define SENINF4_MUX_SPARE                      0x3D2C
+#define SENINF4_MUX_DATA                       0x3D30
+#define SENINF4_MUX_DATA_CNT                   0x3D34
+#define SENINF4_MUX_CROP                       0x3D38
+#define SENINF4_MUX_CTRL_EXT                   0x3D3C
+#define rsv_3D40_304                           0x3D40
+#define SENINF5_CTRL                           0x4200
+#define SENINF5_CTRL_EXT                       0x4204
+#define SENINF5_ASYNC_CTRL                     0x4208
+#define rsv_420C_253                           0x420C
+#define SENINF_TG5_PH_CNT                      0x4600
+#define SENINF_TG5_SEN_CK                      0x4604
+#define SENINF_TG5_TM_CTL                      0x4608
+#define SENINF_TG5_TM_SIZE                     0x460C
+#define SENINF_TG5_TM_CLK                      0x4610
+#define SENINF_TG5_TM_STP                      0x4614
+#define rsv_4618_131                           0x4618
+#define MIPI_RX_CON24_CSI4                     0x4824
+#define MIPI_RX_CON28_CSI4                     0x4828
+#define rsv_482C_2                             0x482C
+#define MIPI_RX_CON34_CSI4                     0x4834
+#define MIPI_RX_CON38_CSI4                     0x4838
+#define MIPI_RX_CON3C_CSI4                     0x483C
+#define rsv_4840_15                            0x4840
+#define MIPI_RX_CON7C_CSI4                     0x487C
+#define MIPI_RX_CON80_CSI4                     0x4880
+#define MIPI_RX_CON84_CSI4                     0x4884
+#define MIPI_RX_CON88_CSI4                     0x4888
+#define MIPI_RX_CON8C_CSI4                     0x488C
+#define MIPI_RX_CON90_CSI4                     0x4890
+#define MIPI_RX_CON94_CSI4                     0x4894
+#define MIPI_RX_CON98_CSI4                     0x4898
+#define rsv_489C                               0x489C
+#define MIPI_RX_CONA0_CSI4                     0x48A0
+#define rsv_48A4_3                             0x48A4
+#define MIPI_RX_CONB0_CSI4                     0x48B0
+#define MIPI_RX_CONB4_CSI4                     0x48B4
+#define MIPI_RX_CONB8_CSI4                     0x48B8
+#define MIPI_RX_CONBC_CSI4                     0x48BC
+#define MIPI_RX_CONC0_CSI4                     0x48C0
+#define MIPI_RX_CONC4_CSI4                     0x48C4
+#define MIPI_RX_CONC8_CSI4                     0x48C8
+#define MIPI_RX_CONCC_CSI4                     0x48CC
+#define MIPI_RX_COND0_CSI4                     0x48D0
+#define rsv_48D4_75                            0x48D4
+#define SENINF5_CSI2_CTL                       0x4A00
+#define SENINF5_CSI2_LNRC_TIMING               0x4A04
+#define SENINF5_CSI2_LNRD_TIMING               0x4A08
+#define SENINF5_CSI2_DPCM                      0x4A0C
+#define SENINF5_CSI2_INT_EN                    0x4A10
+#define SENINF5_CSI2_INT_STATUS                0x4A14
+#define SENINF5_CSI2_DGB_SEL                   0x4A18
+#define SENINF5_CSI2_DBG_PORT                  0x4A1C
+#define SENINF5_CSI2_SPARE0                    0x4A20
+#define SENINF5_CSI2_SPARE1                    0x4A24
+#define SENINF5_CSI2_LNRC_FSM                  0x4A28
+#define SENINF5_CSI2_LNRD_FSM                  0x4A2C
+#define SENINF5_CSI2_FRAME_LINE_NUM            0x4A30
+#define SENINF5_CSI2_GENERIC_SHORT             0x4A34
+#define SENINF5_CSI2_HSRX_DBG                  0x4A38
+#define SENINF5_CSI2_DI                        0x4A3C
+#define SENINF5_CSI2_HS_TRAIL                  0x4A40
+#define SENINF5_CSI2_DI_CTRL                   0x4A44
+#define rsv_4A48                               0x4A48
+#define SENINF5_CSI2_DETECT_CON1               0x4A4C
+#define SENINF5_CSI2_DETECT_CON2               0x4A50
+#define SENINF5_CSI2_DETECT_CON3               0x4A54
+#define SENINF5_CSI2_RLR0_CON0                 0x4A58
+#define SENINF5_CSI2_RLR1_CON0                 0x4A5C
+#define SENINF5_CSI2_RLR2_CON0                 0x4A60
+#define SENINF5_CSI2_RLR_CON0                  0x4A64
+#define SENINF5_CSI2_MUX_CON                   0x4A68
+#define SENINF5_CSI2_DETECT_DBG0               0x4A6C
+#define SENINF5_CSI2_DETECT_DBG1               0x4A70
+#define SENINF5_CSI2_RESYNC_MERGE_CTL          0x4A74
+#define SENINF5_CSI2_CTRL_TRIO_MUX             0x4A78
+#define SENINF5_CSI2_CTRL_TRIO_CON             0x4A7C
+#define SENINF5_FIX_ADDR_CPHY0_DBG             0x4A80
+#define SENINF5_FIX_ADDR_CPHY1_DBG             0x4A84
+#define SENINF5_FIX_ADDR_CPHY2_DBG             0x4A88
+#define SENINF5_FIX_ADDR_DBG                   0x4A8C
+#define SENINF5_WIRE_STATE_DECODE_CPHY0_DBG0   0x4A90
+#define SENINF5_WIRE_STATE_DECODE_CPHY0_DBG1   0x4A94
+#define SENINF5_WIRE_STATE_DECODE_CPHY1_DBG0   0x4A98
+#define SENINF5_WIRE_STATE_DECODE_CPHY1_DBG1   0x4A9C
+#define SENINF5_WIRE_STATE_DECODE_CPHY2_DBG0   0x4AA0
+#define SENINF5_WIRE_STATE_DECODE_CPHY2_DBG1   0x4AA4
+#define SENINF5_SYNC_RESYNC_CTL                0x4AA8
+#define SENINF5_POST_DETECT_CTL                0x4AAC
+#define SENINF5_WIRE_STATE_DECODE_CONFIG       0x4AB0
+#define SENINF5_CSI2_CPHY_LNRD_FSM             0x4AB4
+#define SENINF5_FIX_ADDR_CPHY0_DBG0            0x4AB8
+#define SENINF5_FIX_ADDR_CPHY0_DBG1            0x4ABC
+#define SENINF5_FIX_ADDR_CPHY0_DBG2            0x4AC0
+#define SENINF5_FIX_ADDR_CPHY1_DBG0            0x4AC4
+#define SENINF5_FIX_ADDR_CPHY1_DBG1            0x4AC8
+#define SENINF5_FIX_ADDR_CPHY1_DBG2            0x4ACC
+#define SENINF5_FIX_ADDR_CPHY2_DBG0            0x4AD0
+#define SENINF5_FIX_ADDR_CPHY2_DBG1            0x4AD4
+#define SENINF5_FIX_ADDR_CPHY2_DBG2            0x4AD8
+#define SENINF5_FIX_ADDR_DBG0                  0x4ADC
+#define SENINF5_FIX_ADDR_DBG1                  0x4AE0
+#define SENINF5_FIX_ADDR_DBG2                  0x4AE4
+#define SENINF5_CSI2_MODE                      0x4AE8
+#define rsv_4AEC                               0x4AEC
+#define SENINF5_CSI2_DI_EXT                    0x4AF0
+#define SENINF5_CSI2_DI_CTRL_EXT               0x4AF4
+#define SENINF5_CSI2_CPHY_LOOPBACK             0x4AF8
+#define rsv_4AFC                               0x4AFC
+#define SENINF5_CSI2_PROGSEQ_0                 0x4B00
+#define SENINF5_CSI2_PROGSEQ_1                 0x4B04
+#define rsv_4B08_2                             0x4B08
+#define SENINF5_CSI2_INT_EN_EXT                0x4B10
+#define SENINF5_CSI2_INT_STATUS_EXT            0x4B14
+#define SENINF5_CSI2_CPHY_FIX_POINT_RST        0x4B18
+#define SENINF5_CSI2_RLR3_CON0                 0x4B1C
+#define SENINF5_CSI2_DPHY_SYNC                 0x4B20
+#define SENINF5_CSI2_DESKEW_SYNC               0x4B24
+#define SENINF5_CSI2_DETECT_DBG2               0x4B28
+#define rsv_4B2C                               0x4B2C
+#define SENINF5_FIX_ADDR_CPHY3_DBG0            0x4B30
+#define SENINF5_FIX_ADDR_CPHY3_DBG1            0x4B34
+#define SENINF5_FIX_ADDR_CPHY3_DBG2            0x4B38
+#define SENINF5_CSI2_DI_EXT_2                  0x4B3C
+#define SENINF5_CSI2_DI_CTRL_EXT_2             0x4B40
+#define SENINF5_WIRE_STATE_DECODE_CPHY3_DBG0   0x4B44
+#define SENINF5_WIRE_STATE_DECODE_CPHY3_DBG1   0x4B48
+#define rsv_4B4C_109                           0x4B4C
+#define SENINF5_MUX_CTRL                       0x4D00
+#define SENINF5_MUX_INTEN                      0x4D04
+#define SENINF5_MUX_INTSTA                     0x4D08
+#define SENINF5_MUX_SIZE                       0x4D0C
+#define SENINF5_MUX_DEBUG_1                    0x4D10
+#define SENINF5_MUX_DEBUG_2                    0x4D14
+#define SENINF5_MUX_DEBUG_3                    0x4D18
+#define SENINF5_MUX_DEBUG_4                    0x4D1C
+#define SENINF5_MUX_DEBUG_5                    0x4D20
+#define SENINF5_MUX_DEBUG_6                    0x4D24
+#define SENINF5_MUX_DEBUG_7                    0x4D28
+#define SENINF5_MUX_SPARE                      0x4D2C
+#define SENINF5_MUX_DATA                       0x4D30
+#define SENINF5_MUX_DATA_CNT                   0x4D34
+#define SENINF5_MUX_CROP                       0x4D38
+#define SENINF5_MUX_CTRL_EXT                   0x4D3C
+#define rsv_4D40_1008                          0x4D40
+#define SENINF6_MUX_CTRL                       0x5D00
+#define SENINF6_MUX_INTEN                      0x5D04
+#define SENINF6_MUX_INTSTA                     0x5D08
+#define SENINF6_MUX_SIZE                       0x5D0C
+#define SENINF6_MUX_DEBUG_1                    0x5D10
+#define SENINF6_MUX_DEBUG_2                    0x5D14
+#define SENINF6_MUX_DEBUG_3                    0x5D18
+#define SENINF6_MUX_DEBUG_4                    0x5D1C
+#define SENINF6_MUX_DEBUG_5                    0x5D20
+#define SENINF6_MUX_DEBUG_6                    0x5D24
+#define SENINF6_MUX_DEBUG_7                    0x5D28
+#define SENINF6_MUX_SPARE                      0x5D2C
+#define SENINF6_MUX_DATA                       0x5D30
+#define SENINF6_MUX_DATA_CNT                   0x5D34
+#define SENINF6_MUX_CROP                       0x5D38
+#define SENINF6_MUX_CTRL_EXT                   0x5D3C
+#define rsv_5D40_1008                          0x5D40
+#define SENINF7_MUX_CTRL                       0x6D00
+#define SENINF7_MUX_INTEN                      0x6D04
+#define SENINF7_MUX_INTSTA                     0x6D08
+#define SENINF7_MUX_SIZE                       0x6D0C
+#define SENINF7_MUX_DEBUG_1                    0x6D10
+#define SENINF7_MUX_DEBUG_2                    0x6D14
+#define SENINF7_MUX_DEBUG_3                    0x6D18
+#define SENINF7_MUX_DEBUG_4                    0x6D1C
+#define SENINF7_MUX_DEBUG_5                    0x6D20
+#define SENINF7_MUX_DEBUG_6                    0x6D24
+#define SENINF7_MUX_DEBUG_7                    0x6D28
+#define SENINF7_MUX_SPARE                      0x6D2C
+#define SENINF7_MUX_DATA                       0x6D30
+#define SENINF7_MUX_DATA_CNT                   0x6D34
+#define SENINF7_MUX_CROP                       0x6D38
+#define SENINF7_MUX_CTRL_EXT                   0x6D3C
+#define rsv_6D40_1008                          0x6D40
+#define SENINF8_MUX_CTRL                       0x7D00
+#define SENINF8_MUX_INTEN                      0x7D04
+#define SENINF8_MUX_INTSTA                     0x7D08
+#define SENINF8_MUX_SIZE                       0x7D0C
+#define SENINF8_MUX_DEBUG_1                    0x7D10
+#define SENINF8_MUX_DEBUG_2                    0x7D14
+#define SENINF8_MUX_DEBUG_3                    0x7D18
+#define SENINF8_MUX_DEBUG_4                    0x7D1C
+#define SENINF8_MUX_DEBUG_5                    0x7D20
+#define SENINF8_MUX_DEBUG_6                    0x7D24
+#define SENINF8_MUX_DEBUG_7                    0x7D28
+#define SENINF8_MUX_SPARE                      0x7D2C
+#define SENINF8_MUX_DATA                       0x7D30
+#define SENINF8_MUX_DATA_CNT                   0x7D34
+#define SENINF8_MUX_CROP                       0x7D38
+#define SENINF8_MUX_CTRL_EXT                   0x7D3C
+#define rsv_7D40_20                            0x7D40
+
+#endif /* _SENINF_REG_H_ */
diff --git a/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c b/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c
index 723a233e2b5f..a8804c18baf8 100644
--- a/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c
+++ b/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.c
@@ -21,7 +21,6 @@
 #include <media/v4l2-ioctl.h>
 #include <media/videobuf2-core.h>
 #include <media/videobuf2-dma-contig.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_jpeg_hw.h"
 #include "mtk_jpeg_core.h"
@@ -893,11 +892,6 @@ static int mtk_jpeg_queue_init(void *priv, struct vb2_queue *src_vq,
 
 static void mtk_jpeg_clk_on(struct mtk_jpeg_dev *jpeg)
 {
-	int ret;
-
-	ret = mtk_smi_larb_get(jpeg->larb);
-	if (ret)
-		dev_err(jpeg->dev, "mtk_smi_larb_get larbvdec fail %d\n", ret);
 	clk_prepare_enable(jpeg->clk_jdec_smi);
 	clk_prepare_enable(jpeg->clk_jdec);
 }
@@ -906,7 +900,6 @@ static void mtk_jpeg_clk_off(struct mtk_jpeg_dev *jpeg)
 {
 	clk_disable_unprepare(jpeg->clk_jdec);
 	clk_disable_unprepare(jpeg->clk_jdec_smi);
-	mtk_smi_larb_put(jpeg->larb);
 }
 
 static irqreturn_t mtk_jpeg_dec_irq(int irq, void *priv)
@@ -1051,21 +1044,6 @@ static const struct v4l2_file_operations mtk_jpeg_fops = {
 
 static int mtk_jpeg_clk_init(struct mtk_jpeg_dev *jpeg)
 {
-	struct device_node *node;
-	struct platform_device *pdev;
-
-	node = of_parse_phandle(jpeg->dev->of_node, "mediatek,larb", 0);
-	if (!node)
-		return -EINVAL;
-	pdev = of_find_device_by_node(node);
-	if (WARN_ON(!pdev)) {
-		of_node_put(node);
-		return -EINVAL;
-	}
-	of_node_put(node);
-
-	jpeg->larb = &pdev->dev;
-
 	jpeg->clk_jdec = devm_clk_get(jpeg->dev, "jpgdec");
 	if (IS_ERR(jpeg->clk_jdec))
 		return PTR_ERR(jpeg->clk_jdec);
diff --git a/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.h b/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.h
index 999bd1427809..85794942b4f3 100644
--- a/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.h
+++ b/drivers/media/platform/mtk-jpeg/mtk_jpeg_core.h
@@ -47,7 +47,6 @@ enum mtk_jpeg_ctx_state {
  * @dec_reg_base:	JPEG registers mapping
  * @clk_jdec:		JPEG hw working clock
  * @clk_jdec_smi:	JPEG SMI bus clock
- * @larb:		SMI device
  */
 struct mtk_jpeg_dev {
 	struct mutex		lock;
@@ -61,7 +60,6 @@ struct mtk_jpeg_dev {
 	void __iomem		*dec_reg_base;
 	struct clk		*clk_jdec;
 	struct clk		*clk_jdec_smi;
-	struct device		*larb;
 };
 
 /**
diff --git a/drivers/media/platform/mtk-mdp/mtk_mdp_comp.c b/drivers/media/platform/mtk-mdp/mtk_mdp_comp.c
index 9afe8161a8c0..5985a9b4ed9d 100644
--- a/drivers/media/platform/mtk-mdp/mtk_mdp_comp.c
+++ b/drivers/media/platform/mtk-mdp/mtk_mdp_comp.c
@@ -9,7 +9,6 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_mdp_comp.h"
 
@@ -58,14 +57,6 @@ void mtk_mdp_comp_clock_on(struct device *dev, struct mtk_mdp_comp *comp)
 {
 	int i, err;
 
-	if (comp->larb_dev) {
-		err = mtk_smi_larb_get(comp->larb_dev);
-		if (err)
-			dev_err(dev,
-				"failed to get larb, err %d. type:%d id:%d\n",
-				err, comp->type, comp->id);
-	}
-
 	for (i = 0; i < ARRAY_SIZE(comp->clk); i++) {
 		if (IS_ERR(comp->clk[i]))
 			continue;
@@ -86,16 +77,11 @@ void mtk_mdp_comp_clock_off(struct device *dev, struct mtk_mdp_comp *comp)
 			continue;
 		clk_disable_unprepare(comp->clk[i]);
 	}
-
-	if (comp->larb_dev)
-		mtk_smi_larb_put(comp->larb_dev);
 }
 
 int mtk_mdp_comp_init(struct device *dev, struct device_node *node,
 		      struct mtk_mdp_comp *comp, enum mtk_mdp_comp_id comp_id)
 {
-	struct device_node *larb_node;
-	struct platform_device *larb_pdev;
 	int i;
 
 	if (comp_id < 0 || comp_id >= MTK_MDP_COMP_ID_MAX) {
@@ -116,30 +102,6 @@ int mtk_mdp_comp_init(struct device *dev, struct device_node *node,
 			break;
 	}
 
-	/* Only DMA capable components need the LARB property */
-	comp->larb_dev = NULL;
-	if (comp->type != MTK_MDP_RDMA &&
-	    comp->type != MTK_MDP_WDMA &&
-	    comp->type != MTK_MDP_WROT)
-		return 0;
-
-	larb_node = of_parse_phandle(node, "mediatek,larb", 0);
-	if (!larb_node) {
-		dev_err(dev,
-			"Missing mediadek,larb phandle in %pOF node\n", node);
-		return -EINVAL;
-	}
-
-	larb_pdev = of_find_device_by_node(larb_node);
-	if (!larb_pdev) {
-		dev_warn(dev, "Waiting for larb device %pOF\n", larb_node);
-		of_node_put(larb_node);
-		return -EPROBE_DEFER;
-	}
-	of_node_put(larb_node);
-
-	comp->larb_dev = &larb_pdev->dev;
-
 	return 0;
 }
 
diff --git a/drivers/media/platform/mtk-mdp/mtk_mdp_comp.h b/drivers/media/platform/mtk-mdp/mtk_mdp_comp.h
index 998a4b953025..a2da8df12caa 100644
--- a/drivers/media/platform/mtk-mdp/mtk_mdp_comp.h
+++ b/drivers/media/platform/mtk-mdp/mtk_mdp_comp.h
@@ -39,7 +39,6 @@ enum mtk_mdp_comp_id {
  * @dev_node:	component device node
  * @clk:	clocks required for component
  * @regs:	Mapped address of component registers.
- * @larb_dev:	SMI device required for component
  * @type:	component type
  * @id:		component ID
  */
@@ -47,7 +46,6 @@ struct mtk_mdp_comp {
 	struct device_node	*dev_node;
 	struct clk		*clk[2];
 	void __iomem		*regs;
-	struct device		*larb_dev;
 	enum mtk_mdp_comp_type	type;
 	enum mtk_mdp_comp_id	id;
 };
diff --git a/drivers/media/platform/mtk-mdp/mtk_mdp_core.c b/drivers/media/platform/mtk-mdp/mtk_mdp_core.c
index fc9faec85edb..c237ed99ef82 100644
--- a/drivers/media/platform/mtk-mdp/mtk_mdp_core.c
+++ b/drivers/media/platform/mtk-mdp/mtk_mdp_core.c
@@ -17,7 +17,6 @@
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/workqueue.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_mdp_core.h"
 #include "mtk_mdp_m2m.h"
diff --git a/drivers/media/platform/mtk-mdp3/Makefile b/drivers/media/platform/mtk-mdp3/Makefile
new file mode 100644
index 000000000000..cd1de4ef7f42
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/Makefile
@@ -0,0 +1,15 @@
+# SPDX-License-Identifier: GPL-2.0
+mtk-mdp3-y += mtk-mdp3-core.o mtk-mdp3-vpu.o mtk-mdp3-regs.o
+mtk-mdp3-y += mtk-mdp3-m2m.o
+mtk-mdp3-y += mtk-mdp3-comp.o mtk-mdp3-cmdq.o
+
+ccflags-y += -DMDP_DEBUG
+mtk-mdp3-y += mtk-mdp3-debug.o
+
+ccflags-y += -DMDP_UT
+mtk-mdp3-y += mtk-mdp3-ut.o
+
+obj-$(CONFIG_VIDEO_MEDIATEK_MDP3) += mtk-mdp3.o
+
+ccflags-y += -I$(srctree)/drivers/media/platform/mtk-vpu
+
diff --git a/drivers/media/platform/mtk-mdp3/isp_reg.h b/drivers/media/platform/mtk-mdp3/isp_reg.h
new file mode 100644
index 000000000000..93552943c323
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/isp_reg.h
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ */
+
+#ifndef __ISP_REG_H__
+#define __ISP_REG_H__
+
+enum ISP_DIP_CQ {
+	ISP_DRV_DIP_CQ_THRE0 = 0,
+	ISP_DRV_DIP_CQ_THRE1,
+	ISP_DRV_DIP_CQ_THRE2,
+	ISP_DRV_DIP_CQ_THRE3,
+	ISP_DRV_DIP_CQ_THRE4,
+	ISP_DRV_DIP_CQ_THRE5,
+	ISP_DRV_DIP_CQ_THRE6,
+	ISP_DRV_DIP_CQ_THRE7,
+	ISP_DRV_DIP_CQ_THRE8,
+	ISP_DRV_DIP_CQ_THRE9,
+	ISP_DRV_DIP_CQ_THRE10,
+	ISP_DRV_DIP_CQ_THRE11,
+	ISP_DRV_DIP_CQ_NUM,
+	ISP_DRV_DIP_CQ_NONE,
+	/* we only need 12 CQ threads in this chip,
+	 *so we move the following enum behind ISP_DRV_DIP_CQ_NUM
+	 */
+	ISP_DRV_DIP_CQ_THRE12,
+	ISP_DRV_DIP_CQ_THRE13,
+	ISP_DRV_DIP_CQ_THRE14,
+	ISP_DRV_DIP_CQ_THRE15,	/* CQ_THREAD15 does not connect to GCE */
+	ISP_DRV_DIP_CQ_THRE16,	/* CQ_THREAD16 does not connect to GCE */
+	ISP_DRV_DIP_CQ_THRE17,	/* CQ_THREAD17 does not connect to GCE */
+	ISP_DRV_DIP_CQ_THRE18,	/* CQ_THREAD18 does not connect to GCE */
+};
+
+#endif  // __ISP_REG_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp-platform.h b/drivers/media/platform/mtk-mdp3/mdp-platform.h
new file mode 100644
index 000000000000..6926c3a754fa
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp-platform.h
@@ -0,0 +1,67 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MDP_PLATFORM_H__
+#define __MDP_PLATFORM_H__
+
+#include "mtk-mdp3-comp.h"
+
+/* CAM */
+#define MDP_WPEI           MDP_COMP_WPEI
+#define MDP_WPEO           MDP_COMP_WPEO
+#define MDP_WPEI2          MDP_COMP_WPEI2
+#define MDP_WPEO2          MDP_COMP_WPEO2
+#define MDP_IMGI           MDP_COMP_ISP_IMGI
+#define MDP_IMGO           MDP_COMP_ISP_IMGO
+#define MDP_IMG2O          MDP_COMP_ISP_IMG2O
+
+/* IPU */
+#define MDP_IPUI           MDP_COMP_NONE
+#define MDP_IPUO           MDP_COMP_NONE
+
+/* MDP */
+#define MDP_CAMIN          MDP_COMP_CAMIN
+#define MDP_CAMIN2         MDP_COMP_CAMIN2
+#define MDP_RDMA0          MDP_COMP_RDMA0
+#define MDP_RDMA1          MDP_COMP_NONE
+#define MDP_AAL0           MDP_COMP_AAL0
+#define MDP_CCORR0         MDP_COMP_CCORR0
+#define MDP_SCL0           MDP_COMP_RSZ0
+#define MDP_SCL1           MDP_COMP_RSZ1
+#define MDP_SCL2           MDP_COMP_NONE
+#define MDP_TDSHP0         MDP_COMP_TDSHP0
+#define MDP_COLOR0         MDP_COMP_COLOR0
+#define MDP_WROT0          MDP_COMP_WROT0
+#define MDP_WROT1          MDP_COMP_NONE
+#define MDP_WDMA           MDP_COMP_WDMA
+#define MDP_PATH0_SOUT     MDP_COMP_PATH0_SOUT
+#define MDP_PATH1_SOUT     MDP_COMP_PATH1_SOUT
+
+#define MDP_TOTAL          (MDP_COMP_WDMA + 1)
+
+/* Platform options */
+#define ESL_SETTING			1
+#define RDMA_SUPPORT_10BIT		1
+#define RDMA0_RSZ1_SRAM_SHARING		1
+#define RDMA_UPSAMPLE_REPEAT_ONLY	1
+#define RSZ_DISABLE_DCM_SMALL_TILE	0
+#define WROT_FILTER_CONSTRAINT		0
+#define WROT0_DISP_SRAM_SHARING		0
+
+#define MM_MUTEX_MOD_OFFSET	0x30
+#define MM_MUTEX_SOF_OFFSET	0x2c
+
+#endif  /* __MDP_PLATFORM_H__ */
+
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_ccorr.h b/drivers/media/platform/mtk-mdp3/mdp_reg_ccorr.h
new file mode 100644
index 000000000000..e3340726e6d4
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_ccorr.h
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ */
+
+#ifndef __MDP_REG_CCORR_H__
+#define __MDP_REG_CCORR_H__
+
+#include "mmsys_reg_base.h"
+
+#define MDP_CCORR_EN                0x000
+#define MDP_CCORR_RESET             0x004
+#define MDP_CCORR_INTEN             0x008
+#define MDP_CCORR_INTSTA            0x00c
+#define MDP_CCORR_STATUS            0x010
+#define MDP_CCORR_CFG               0x020
+#define MDP_CCORR_INPUT_COUNT       0x024
+#define MDP_CCORR_OUTPUT_COUNT      0x028
+#define MDP_CCORR_CHKSUM            0x02c
+#define MDP_CCORR_SIZE              0x030
+#define MDP_CCORR_Y2R_00            0x034
+#define MDP_CCORR_Y2R_01            0x038
+#define MDP_CCORR_Y2R_02            0x03c
+#define MDP_CCORR_Y2R_03            0x040
+#define MDP_CCORR_Y2R_04            0x044
+#define MDP_CCORR_Y2R_05            0x048
+#define MDP_CCORR_R2Y_00            0x04c
+#define MDP_CCORR_R2Y_01            0x050
+#define MDP_CCORR_R2Y_02            0x054
+#define MDP_CCORR_R2Y_03            0x058
+#define MDP_CCORR_R2Y_04            0x05c
+#define MDP_CCORR_R2Y_05            0x060
+#define MDP_CCORR_COEF_0            0x080
+#define MDP_CCORR_COEF_1            0x084
+#define MDP_CCORR_COEF_2            0x088
+#define MDP_CCORR_COEF_3            0x08c
+#define MDP_CCORR_COEF_4            0x090
+#define MDP_CCORR_SHADOW            0x0a0
+#define MDP_CCORR_DUMMY_REG         0x0c0
+#define MDP_CCORR_ATPG              0x0fc
+
+/* MASK */
+#define MDP_CCORR_EN_MASK           0x00000001
+#define MDP_CCORR_RESET_MASK        0x00000001
+#define MDP_CCORR_INTEN_MASK        0x00000003
+#define MDP_CCORR_INTSTA_MASK       0x00000003
+#define MDP_CCORR_STATUS_MASK       0xfffffff3
+#define MDP_CCORR_CFG_MASK          0x70001317
+#define MDP_CCORR_INPUT_COUNT_MASK  0x1fff1fff
+#define MDP_CCORR_OUTPUT_COUNT_MASK 0x1fff1fff
+#define MDP_CCORR_CHKSUM_MASK       0xffffffff
+#define MDP_CCORR_SIZE_MASK         0x1fff1fff
+#define MDP_CCORR_Y2R_00_MASK       0x01ff01ff
+#define MDP_CCORR_Y2R_01_MASK       0x1fff01ff
+#define MDP_CCORR_Y2R_02_MASK       0x1fff1fff
+#define MDP_CCORR_Y2R_03_MASK       0x1fff1fff
+#define MDP_CCORR_Y2R_04_MASK       0x1fff1fff
+#define MDP_CCORR_Y2R_05_MASK       0x1fff1fff
+#define MDP_CCORR_R2Y_00_MASK       0x01ff01ff
+#define MDP_CCORR_R2Y_01_MASK       0x07ff01ff
+#define MDP_CCORR_R2Y_02_MASK       0x07ff07ff
+#define MDP_CCORR_R2Y_03_MASK       0x07ff07ff
+#define MDP_CCORR_R2Y_04_MASK       0x07ff07ff
+#define MDP_CCORR_R2Y_05_MASK       0x07ff07ff
+#define MDP_CCORR_COEF_0_MASK       0x1fff1fff
+#define MDP_CCORR_COEF_1_MASK       0x1fff1fff
+#define MDP_CCORR_COEF_2_MASK       0x1fff1fff
+#define MDP_CCORR_COEF_3_MASK       0x1fff1fff
+#define MDP_CCORR_COEF_4_MASK       0x1fff1fff
+#define MDP_CCORR_SHADOW_MASK       0x00000007
+#define MDP_CCORR_DUMMY_REG_MASK    0xffffffff
+#define MDP_CCORR_ATPG_MASK         0x00000003
+
+#endif  // __MDP_REG_CCORR_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_rdma.h b/drivers/media/platform/mtk-mdp3/mdp_reg_rdma.h
new file mode 100644
index 000000000000..5625d9f7810d
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_rdma.h
@@ -0,0 +1,207 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ */
+
+#ifndef __MDP_REG_RDMA_H__
+#define __MDP_REG_RDMA_H__
+
+#include "mmsys_reg_base.h"
+
+#define MDP_RDMA_EN                     0x000
+#define MDP_RDMA_RESET                  0x008
+#define MDP_RDMA_INTERRUPT_ENABLE       0x010
+#define MDP_RDMA_INTERRUPT_STATUS       0x018
+#define MDP_RDMA_CON                    0x020
+#define MDP_RDMA_GMCIF_CON              0x028
+#define MDP_RDMA_SRC_CON                0x030
+#define MDP_RDMA_SRC_BASE_0             0xf00
+#define MDP_RDMA_SRC_BASE_1             0xf08
+#define MDP_RDMA_SRC_BASE_2             0xf10
+#define MDP_RDMA_UFO_DEC_LENGTH_BASE_Y  0xf20
+#define MDP_RDMA_UFO_DEC_LENGTH_BASE_C  0xf28
+#define MDP_RDMA_MF_BKGD_SIZE_IN_BYTE   0x060
+#define MDP_RDMA_MF_BKGD_SIZE_IN_PXL    0x068
+#define MDP_RDMA_MF_SRC_SIZE            0x070
+#define MDP_RDMA_MF_CLIP_SIZE           0x078
+#define MDP_RDMA_MF_OFFSET_1            0x080
+#define MDP_RDMA_MF_PAR                 0x088
+#define MDP_RDMA_SF_BKGD_SIZE_IN_BYTE   0x090
+#define MDP_RDMA_SF_PAR                 0x0b8
+#define MDP_RDMA_MB_DEPTH               0x0c0
+#define MDP_RDMA_MB_BASE                0x0c8
+#define MDP_RDMA_MB_CON                 0x0d0
+#define MDP_RDMA_SB_DEPTH               0x0d8
+#define MDP_RDMA_SB_BASE                0x0e0
+#define MDP_RDMA_SB_CON                 0x0e8
+#define MDP_RDMA_VC1_RANGE              0x0f0
+#define MDP_RDMA_SRC_END_0              0x100
+#define MDP_RDMA_SRC_END_1              0x108
+#define MDP_RDMA_SRC_END_2              0x110
+#define MDP_RDMA_SRC_OFFSET_0           0x118
+#define MDP_RDMA_SRC_OFFSET_1           0x120
+#define MDP_RDMA_SRC_OFFSET_2           0x128
+#define MDP_RDMA_SRC_OFFSET_W_0         0x130
+#define MDP_RDMA_SRC_OFFSET_W_1         0x138
+#define MDP_RDMA_SRC_OFFSET_W_2         0x140
+#define MDP_RDMA_SRC_OFFSET_0_P         0x148
+#define MDP_RDMA_TRANSFORM_0            0x200
+#define MDP_RDMA_TRANSFORM_1            0x208
+#define MDP_RDMA_TRANSFORM_2            0x210
+#define MDP_RDMA_TRANSFORM_3            0x218
+#define MDP_RDMA_TRANSFORM_4            0x220
+#define MDP_RDMA_TRANSFORM_5            0x228
+#define MDP_RDMA_TRANSFORM_6            0x230
+#define MDP_RDMA_TRANSFORM_7            0x238
+#define MDP_RDMA_DMABUF_CON_0           0x240
+#define MDP_RDMA_DMAULTRA_CON_0         0x248
+#define MDP_RDMA_DMABUF_CON_1           0x250
+#define MDP_RDMA_DMAULTRA_CON_1         0x258
+#define MDP_RDMA_DMABUF_CON_2           0x260
+#define MDP_RDMA_DMAULTRA_CON_2         0x268
+#define MDP_RDMA_DITHER_CON             0x288
+#define MDP_RDMA_RESV_DUMMY_0           0x2a0
+#define MDP_RDMA_CHKS_EXTR              0x300
+#define MDP_RDMA_CHKS_INTW              0x308
+#define MDP_RDMA_CHKS_INTR              0x310
+#define MDP_RDMA_CHKS_ROTO              0x318
+#define MDP_RDMA_CHKS_SRIY              0x320
+#define MDP_RDMA_CHKS_SRIU              0x328
+#define MDP_RDMA_CHKS_SRIV              0x330
+#define MDP_RDMA_CHKS_SROY              0x338
+#define MDP_RDMA_CHKS_SROU              0x340
+#define MDP_RDMA_CHKS_SROV              0x348
+#define MDP_RDMA_CHKS_VUPI              0x350
+#define MDP_RDMA_CHKS_VUPO              0x358
+#define MDP_RDMA_DEBUG_CON              0x380
+#define MDP_RDMA_MON_STA_0              0x400
+#define MDP_RDMA_MON_STA_1              0x408
+#define MDP_RDMA_MON_STA_2              0x410
+#define MDP_RDMA_MON_STA_3              0x418
+#define MDP_RDMA_MON_STA_4              0x420
+#define MDP_RDMA_MON_STA_5              0x428
+#define MDP_RDMA_MON_STA_6              0x430
+#define MDP_RDMA_MON_STA_7              0x438
+#define MDP_RDMA_MON_STA_8              0x440
+#define MDP_RDMA_MON_STA_9              0x448
+#define MDP_RDMA_MON_STA_10             0x450
+#define MDP_RDMA_MON_STA_11             0x458
+#define MDP_RDMA_MON_STA_12             0x460
+#define MDP_RDMA_MON_STA_13             0x468
+#define MDP_RDMA_MON_STA_14             0x470
+#define MDP_RDMA_MON_STA_15             0x478
+#define MDP_RDMA_MON_STA_16             0x480
+#define MDP_RDMA_MON_STA_17             0x488
+#define MDP_RDMA_MON_STA_18             0x490
+#define MDP_RDMA_MON_STA_19             0x498
+#define MDP_RDMA_MON_STA_20             0x4a0
+#define MDP_RDMA_MON_STA_21             0x4a8
+#define MDP_RDMA_MON_STA_22             0x4b0
+#define MDP_RDMA_MON_STA_23             0x4b8
+#define MDP_RDMA_MON_STA_24             0x4c0
+#define MDP_RDMA_MON_STA_25             0x4c8
+#define MDP_RDMA_MON_STA_26             0x4d0
+#define MDP_RDMA_MON_STA_27             0x4d8
+#define MDP_RDMA_MON_STA_28             0x4e0
+
+/* MASK */
+#define MDP_RDMA_EN_MASK                    0x00000001
+#define MDP_RDMA_RESET_MASK                 0x00000001
+#define MDP_RDMA_INTERRUPT_ENABLE_MASK      0x00000007
+#define MDP_RDMA_INTERRUPT_STATUS_MASK      0x00000007
+#define MDP_RDMA_CON_MASK                   0x00001110
+#define MDP_RDMA_GMCIF_CON_MASK             0xfffb3771
+#define MDP_RDMA_SRC_CON_MASK               0xf3ffffff
+#define MDP_RDMA_SRC_BASE_0_MASK            0xffffffff
+#define MDP_RDMA_SRC_BASE_1_MASK            0xffffffff
+#define MDP_RDMA_SRC_BASE_2_MASK            0xffffffff
+#define MDP_RDMA_UFO_DEC_LENGTH_BASE_Y_MASK 0xffffffff
+#define MDP_RDMA_UFO_DEC_LENGTH_BASE_C_MASK 0xffffffff
+#define MDP_RDMA_MF_BKGD_SIZE_IN_BYTE_MASK  0x001fffff
+#define MDP_RDMA_MF_BKGD_SIZE_IN_PXL_MASK   0x001fffff
+#define MDP_RDMA_MF_SRC_SIZE_MASK           0x1fff1fff
+#define MDP_RDMA_MF_CLIP_SIZE_MASK          0x1fff1fff
+#define MDP_RDMA_MF_OFFSET_1_MASK           0x003f001f
+#define MDP_RDMA_MF_PAR_MASK                0x1ffff3ff
+#define MDP_RDMA_SF_BKGD_SIZE_IN_BYTE_MASK  0x001fffff
+#define MDP_RDMA_SF_PAR_MASK                0x1ffff3ff
+#define MDP_RDMA_MB_DEPTH_MASK              0x0000007f
+#define MDP_RDMA_MB_BASE_MASK               0x0000ffff
+#define MDP_RDMA_MB_CON_MASK                0x3fff1fff
+#define MDP_RDMA_SB_DEPTH_MASK              0x0000007f
+#define MDP_RDMA_SB_BASE_MASK               0x0000ffff
+#define MDP_RDMA_SB_CON_MASK                0x3fff1fff
+#define MDP_RDMA_VC1_RANGE_MASK             0x001f1f11
+#define MDP_RDMA_SRC_END_0_MASK             0xffffffff
+#define MDP_RDMA_SRC_END_1_MASK             0xffffffff
+#define MDP_RDMA_SRC_END_2_MASK             0xffffffff
+#define MDP_RDMA_SRC_OFFSET_0_MASK          0xffffffff
+#define MDP_RDMA_SRC_OFFSET_1_MASK          0xffffffff
+#define MDP_RDMA_SRC_OFFSET_2_MASK          0xffffffff
+#define MDP_RDMA_SRC_OFFSET_W_0_MASK        0x0000ffff
+#define MDP_RDMA_SRC_OFFSET_W_1_MASK        0x0000ffff
+#define MDP_RDMA_SRC_OFFSET_W_2_MASK        0x0000ffff
+#define MDP_RDMA_SRC_OFFSET_0_P_MASK        0xffffffff
+#define MDP_RDMA_TRANSFORM_0_MASK           0xff110777
+#define MDP_RDMA_TRANSFORM_1_MASK           0x1ff7fdff
+#define MDP_RDMA_TRANSFORM_2_MASK           0x1ff7fdff
+#define MDP_RDMA_TRANSFORM_3_MASK           0x1fff1fff
+#define MDP_RDMA_TRANSFORM_4_MASK           0x1fff1fff
+#define MDP_RDMA_TRANSFORM_5_MASK           0x1fff1fff
+#define MDP_RDMA_TRANSFORM_6_MASK           0x1fff1fff
+#define MDP_RDMA_TRANSFORM_7_MASK           0x00001fff
+#define MDP_RDMA_DMABUF_CON_0_MASK          0x077f007f
+#define MDP_RDMA_DMAULTRA_CON_0_MASK        0x7f7f7f7f
+#define MDP_RDMA_DMABUF_CON_1_MASK          0x073f003f
+#define MDP_RDMA_DMAULTRA_CON_1_MASK        0x3f3f3f3f
+#define MDP_RDMA_DMABUF_CON_2_MASK          0x071f001f
+#define MDP_RDMA_DMAULTRA_CON_2_MASK        0x1f1f1f1f
+
+#define MDP_RDMA_DITHER_CON_MASK            0xffffffff
+#define MDP_RDMA_RESV_DUMMY_0_MASK          0xffffffff
+#define MDP_RDMA_CHKS_EXTR_MASK             0xffffff01
+#define MDP_RDMA_CHKS_INTW_MASK             0xffffff01
+#define MDP_RDMA_CHKS_INTR_MASK             0xffffff01
+#define MDP_RDMA_CHKS_ROTO_MASK             0xffffff01
+#define MDP_RDMA_CHKS_SRIY_MASK             0xffffff01
+#define MDP_RDMA_CHKS_SRIU_MASK             0xffffff01
+#define MDP_RDMA_CHKS_SRIV_MASK             0xffffff01
+#define MDP_RDMA_CHKS_SROY_MASK             0xffffff01
+#define MDP_RDMA_CHKS_SROU_MASK             0xffffff01
+#define MDP_RDMA_CHKS_SROV_MASK             0xffffff01
+#define MDP_RDMA_CHKS_VUPI_MASK             0xffffff01
+#define MDP_RDMA_CHKS_VUPO_MASK             0xffffff01
+#define MDP_RDMA_DEBUG_CON_MASK             0x00001f11
+#define MDP_RDMA_MON_STA_0_MASK             0xffffffff
+#define MDP_RDMA_MON_STA_1_MASK             0xffffffff
+#define MDP_RDMA_MON_STA_2_MASK             0xffffffff
+#define MDP_RDMA_MON_STA_3_MASK             0xffffffff
+#define MDP_RDMA_MON_STA_4_MASK             0xffffffff
+#define MDP_RDMA_MON_STA_5_MASK             0xffffffff
+#define MDP_RDMA_MON_STA_6_MASK             0xffffffff
+#define MDP_RDMA_MON_STA_7_MASK             0xffffffff
+#define MDP_RDMA_MON_STA_8_MASK             0xffffffff
+#define MDP_RDMA_MON_STA_9_MASK             0xffffffff
+#define MDP_RDMA_MON_STA_10_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_11_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_12_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_13_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_14_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_15_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_16_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_17_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_18_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_19_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_20_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_21_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_22_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_23_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_24_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_25_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_26_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_27_MASK            0xffffffff
+#define MDP_RDMA_MON_STA_28_MASK            0xffffffff
+
+#endif  // __MDP_REG_RDMA_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_rsz.h b/drivers/media/platform/mtk-mdp3/mdp_reg_rsz.h
new file mode 100644
index 000000000000..407b7691e9d1
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_rsz.h
@@ -0,0 +1,110 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ */
+
+#ifndef __MDP_REG_RSZ_H__
+#define __MDP_REG_RSZ_H__
+
+#include "mmsys_reg_base.h"
+
+#define PRZ_ENABLE                                        0x000
+#define PRZ_CONTROL_1                                     0x004
+#define PRZ_CONTROL_2                                     0x008
+#define PRZ_INT_FLAG                                      0x00c
+#define PRZ_INPUT_IMAGE                                   0x010
+#define PRZ_OUTPUT_IMAGE                                  0x014
+#define PRZ_HORIZONTAL_COEFF_STEP                         0x018
+#define PRZ_VERTICAL_COEFF_STEP                           0x01c
+#define PRZ_LUMA_HORIZONTAL_INTEGER_OFFSET                0x020
+#define PRZ_LUMA_HORIZONTAL_SUBPIXEL_OFFSET               0x024
+#define PRZ_LUMA_VERTICAL_INTEGER_OFFSET                  0x028
+#define PRZ_LUMA_VERTICAL_SUBPIXEL_OFFSET                 0x02c
+#define PRZ_CHROMA_HORIZONTAL_INTEGER_OFFSET              0x030
+#define PRZ_CHROMA_HORIZONTAL_SUBPIXEL_OFFSET             0x034
+#define PRZ_RSV                                           0x040
+#define PRZ_DEBUG_SEL                                     0x044
+#define PRZ_DEBUG                                         0x048
+#define PRZ_TAP_ADAPT                                     0x04c
+#define PRZ_IBSE_SOFTCLIP                                 0x050
+#define PRZ_IBSE_YLEVEL_1                                 0x054
+#define PRZ_IBSE_YLEVEL_2                                 0x058
+#define PRZ_IBSE_YLEVEL_3                                 0x05c
+#define PRZ_IBSE_YLEVEL_4                                 0x060
+#define PRZ_IBSE_YLEVEL_5                                 0x064
+#define PRZ_IBSE_GAINCONTROL_1                            0x068
+#define PRZ_IBSE_GAINCONTROL_2                            0x06c
+#define PRZ_DEMO_IN_HMASK                                 0x070
+#define PRZ_DEMO_IN_VMASK                                 0x074
+#define PRZ_DEMO_OUT_HMASK                                0x078
+#define PRZ_DEMO_OUT_VMASK                                0x07c
+#define PRZ_ATPG                                          0x0fc
+#define PRZ_PAT1_GEN_SET                                  0x100
+#define PRZ_PAT1_GEN_FRM_SIZE                             0x104
+#define PRZ_PAT1_GEN_COLOR0                               0x108
+#define PRZ_PAT1_GEN_COLOR1                               0x10c
+#define PRZ_PAT1_GEN_COLOR2                               0x110
+#define PRZ_PAT1_GEN_POS                                  0x114
+#define PRZ_PAT1_GEN_TILE_POS                             0x124
+#define PRZ_PAT1_GEN_TILE_OV                              0x128
+#define PRZ_PAT2_GEN_SET                                  0x200
+#define PRZ_PAT2_GEN_COLOR0                               0x208
+#define PRZ_PAT2_GEN_COLOR1                               0x20c
+#define PRZ_PAT2_GEN_POS                                  0x214
+#define PRZ_PAT2_GEN_CURSOR_RB0                           0x218
+#define PRZ_PAT2_GEN_CURSOR_RB1                           0x21c
+#define PRZ_PAT2_GEN_TILE_POS                             0x224
+#define PRZ_PAT2_GEN_TILE_OV                              0x228
+
+/* MASK */
+#define PRZ_ENABLE_MASK                                   0x00010001
+#define PRZ_CONTROL_1_MASK                                0xfffffff3
+#define PRZ_CONTROL_2_MASK                                0x0ffffaff
+#define PRZ_INT_FLAG_MASK                                 0x00000033
+#define PRZ_INPUT_IMAGE_MASK                              0xffffffff
+#define PRZ_OUTPUT_IMAGE_MASK                             0xffffffff
+#define PRZ_HORIZONTAL_COEFF_STEP_MASK                    0x007fffff
+#define PRZ_VERTICAL_COEFF_STEP_MASK                      0x007fffff
+#define PRZ_LUMA_HORIZONTAL_INTEGER_OFFSET_MASK           0x0000ffff
+#define PRZ_LUMA_HORIZONTAL_SUBPIXEL_OFFSET_MASK          0x001fffff
+#define PRZ_LUMA_VERTICAL_INTEGER_OFFSET_MASK             0x0000ffff
+#define PRZ_LUMA_VERTICAL_SUBPIXEL_OFFSET_MASK            0x001fffff
+#define PRZ_CHROMA_HORIZONTAL_INTEGER_OFFSET_MASK         0x0000ffff
+#define PRZ_CHROMA_HORIZONTAL_SUBPIXEL_OFFSET_MASK        0x001fffff
+#define PRZ_RSV_MASK                                      0xffffffff
+#define PRZ_DEBUG_SEL_MASK                                0x0000000f
+#define PRZ_DEBUG_MASK                                    0xffffffff
+#define PRZ_TAP_ADAPT_MASK                                0x03ffffff
+#define PRZ_IBSE_SOFTCLIP_MASK                            0x000fffff
+#define PRZ_IBSE_YLEVEL_1_MASK                            0xffffffff
+#define PRZ_IBSE_YLEVEL_2_MASK                            0xffffffff
+#define PRZ_IBSE_YLEVEL_3_MASK                            0xffffffff
+#define PRZ_IBSE_YLEVEL_4_MASK                            0xffffffff
+#define PRZ_IBSE_YLEVEL_5_MASK                            0x0000ff3f
+#define PRZ_IBSE_GAINCONTROL_1_MASK                       0xffffffff
+#define PRZ_IBSE_GAINCONTROL_2_MASK                       0x0fffff0f
+#define PRZ_DEMO_IN_HMASK_MASK                            0xffffffff
+#define PRZ_DEMO_IN_VMASK_MASK                            0xffffffff
+#define PRZ_DEMO_OUT_HMASK_MASK                           0xffffffff
+#define PRZ_DEMO_OUT_VMASK_MASK                           0xffffffff
+#define PRZ_ATPG_MASK                                     0x00000003
+#define PRZ_PAT1_GEN_SET_MASK                             0x00ff00fd
+#define PRZ_PAT1_GEN_FRM_SIZE_MASK                        0x1fff1fff
+#define PRZ_PAT1_GEN_COLOR0_MASK                          0x00ff00ff
+#define PRZ_PAT1_GEN_COLOR1_MASK                          0x00ff00ff
+#define PRZ_PAT1_GEN_COLOR2_MASK                          0x00ff00ff
+#define PRZ_PAT1_GEN_POS_MASK                             0x1fff1fff
+#define PRZ_PAT1_GEN_TILE_POS_MASK                        0x1fff1fff
+#define PRZ_PAT1_GEN_TILE_OV_MASK                         0x0000ffff
+#define PRZ_PAT2_GEN_SET_MASK                             0x00ff0003
+#define PRZ_PAT2_GEN_COLOR0_MASK                          0x00ff00ff
+#define PRZ_PAT2_GEN_COLOR1_MASK                          0x000000ff
+#define PRZ_PAT2_GEN_POS_MASK                             0x1fff1fff
+#define PRZ_PAT2_GEN_CURSOR_RB0_MASK                      0x00ff00ff
+#define PRZ_PAT2_GEN_CURSOR_RB1_MASK                      0x000000ff
+#define PRZ_PAT2_GEN_TILE_POS_MASK                        0x1fff1fff
+#define PRZ_PAT2_GEN_TILE_OV_MASK                         0x0000ffff
+
+#endif // __MDP_REG_RSZ_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_wdma.h b/drivers/media/platform/mtk-mdp3/mdp_reg_wdma.h
new file mode 100644
index 000000000000..7a3b857953e2
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_wdma.h
@@ -0,0 +1,126 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ */
+
+#ifndef __MDP_REG_WDMA_H__
+#define __MDP_REG_WDMA_H__
+
+#include "mmsys_reg_base.h"
+
+#define WDMA_INTEN              0x000
+#define WDMA_INTSTA             0x004
+#define WDMA_EN                 0x008
+#define WDMA_RST                0x00c
+#define WDMA_SMI_CON            0x010
+#define WDMA_CFG                0x014
+#define WDMA_SRC_SIZE           0x018
+#define WDMA_CLIP_SIZE          0x01c
+#define WDMA_CLIP_COORD         0x020
+#define WDMA_DST_ADDR           0xf00
+#define WDMA_DST_W_IN_BYTE      0x028
+#define WDMA_ALPHA              0x02c
+#define WDMA_BUF_CON1           0x038
+#define WDMA_BUF_CON2           0x03c
+#define WDMA_C00                0x040
+#define WDMA_C02                0x044
+#define WDMA_C10                0x048
+#define WDMA_C12                0x04c
+#define WDMA_C20                0x050
+#define WDMA_C22                0x054
+#define WDMA_PRE_ADD0           0x058
+#define WDMA_PRE_ADD2           0x05c
+#define WDMA_POST_ADD0          0x060
+#define WDMA_POST_ADD2          0x064
+#define WDMA_DST_U_ADDR         0xf04
+#define WDMA_DST_V_ADDR         0xf08
+#define WDMA_DST_UV_PITCH       0x078
+#define WDMA_DST_ADDR_OFFSET    0x080
+#define WDMA_DST_U_ADDR_OFFSET  0x084
+#define WDMA_DST_V_ADDR_OFFSET  0x088
+#define PROC_TRACK_CON_0        0x090
+#define PROC_TRACK_CON_1        0x094
+#define PROC_TRACK_CON_2        0x098
+#define WDMA_FLOW_CTRL_DBG      0x0a0
+#define WDMA_EXEC_DBG           0x0a4
+#define WDMA_CT_DBG             0x0a8
+#define WDMA_SMI_TRAFFIC_DBG    0x0ac
+#define WDMA_PROC_TRACK_DBG_0   0x0b0
+#define WDMA_PROC_TRACK_DBG_1   0x0b4
+#define WDMA_DEBUG              0x0b8
+#define WDMA_DUMMY              0x100
+#define WDMA_DITHER_0           0xe00
+#define WDMA_DITHER_5           0xe14
+#define WDMA_DITHER_6           0xe18
+#define WDMA_DITHER_7           0xe1c
+#define WDMA_DITHER_8           0xe20
+#define WDMA_DITHER_9           0xe24
+#define WDMA_DITHER_10          0xe28
+#define WDMA_DITHER_11          0xe2c
+#define WDMA_DITHER_12          0xe30
+#define WDMA_DITHER_13          0xe34
+#define WDMA_DITHER_14          0xe38
+#define WDMA_DITHER_15          0xe3c
+#define WDMA_DITHER_16          0xe40
+#define WDMA_DITHER_17          0xe44
+
+/* MASK */
+#define WDMA_INTEN_MASK             0x00000003
+#define WDMA_INTSTA_MASK            0x00000003
+#define WDMA_EN_MASK                0x00000001
+#define WDMA_RST_MASK               0x00000001
+#define WDMA_SMI_CON_MASK           0x0fffffff
+#define WDMA_CFG_MASK               0xff03bff0
+#define WDMA_SRC_SIZE_MASK          0x3fff3fff
+#define WDMA_CLIP_SIZE_MASK         0x3fff3fff
+#define WDMA_CLIP_COORD_MASK        0x3fff3fff
+#define WDMA_DST_ADDR_MASK          0xffffffff
+#define WDMA_DST_W_IN_BYTE_MASK     0x0000ffff
+#define WDMA_ALPHA_MASK             0x800000ff
+#define WDMA_BUF_CON1_MASK          0xd1ff01ff
+#define WDMA_BUF_CON2_MASK          0xffffffff
+#define WDMA_C00_MASK               0x1fff1fff
+#define WDMA_C02_MASK               0x00001fff
+#define WDMA_C10_MASK               0x1fff1fff
+#define WDMA_C12_MASK               0x00001fff
+#define WDMA_C20_MASK               0x1fff1fff
+#define WDMA_C22_MASK               0x00001fff
+#define WDMA_PRE_ADD0_MASK          0x01ff01ff
+#define WDMA_PRE_ADD2_MASK          0x000001ff
+#define WDMA_POST_ADD0_MASK         0x01ff01ff
+#define WDMA_POST_ADD2_MASK         0x000001ff
+#define WDMA_DST_U_ADDR_MASK        0xffffffff
+#define WDMA_DST_V_ADDR_MASK        0xffffffff
+#define WDMA_DST_UV_PITCH_MASK      0x0000ffff
+#define WDMA_DST_ADDR_OFFSET_MASK   0x0fffffff
+#define WDMA_DST_U_ADDR_OFFSET_MASK 0x0fffffff
+#define WDMA_DST_V_ADDR_OFFSET_MASK 0x0fffffff
+#define PROC_TRACK_CON_0_MASK       0x70000fff
+#define PROC_TRACK_CON_1_MASK       0x00ffffff
+#define PROC_TRACK_CON_2_MASK       0x00ffffff
+#define WDMA_FLOW_CTRL_DBG_MASK     0x0000f3ff
+#define WDMA_EXEC_DBG_MASK          0x003f003f
+#define WDMA_CT_DBG_MASK            0x3fff3fff
+#define WDMA_SMI_TRAFFIC_DBG_MASK   0xffffffff
+#define WDMA_PROC_TRACK_DBG_0_MASK  0xffffffff
+#define WDMA_PROC_TRACK_DBG_1_MASK  0xffffffff
+#define WDMA_DEBUG_MASK             0xffffffff
+#define WDMA_DUMMY_MASK             0xffffffff
+#define WDMA_DITHER_0_MASK          0x0111ff11
+#define WDMA_DITHER_5_MASK          0x0000ffff
+#define WDMA_DITHER_6_MASK          0x0001f3ff
+#define WDMA_DITHER_7_MASK          0x00000333
+#define WDMA_DITHER_8_MASK          0x03ff0001
+#define WDMA_DITHER_9_MASK          0x03ff03ff
+#define WDMA_DITHER_10_MASK         0x00000733
+#define WDMA_DITHER_11_MASK         0x00003331
+#define WDMA_DITHER_12_MASK         0xffff0031
+#define WDMA_DITHER_13_MASK         0x00000777
+#define WDMA_DITHER_14_MASK         0x00000371
+#define WDMA_DITHER_15_MASK         0x77770001
+#define WDMA_DITHER_16_MASK         0x77777777
+#define WDMA_DITHER_17_MASK         0x0001ffff
+
+#endif  // __MDP_REG_WDMA_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_wrot.h b/drivers/media/platform/mtk-mdp3/mdp_reg_wrot.h
new file mode 100644
index 000000000000..376bc85c7703
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_wrot.h
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ */
+
+#ifndef __MDP_REG_WROT_H__
+#define __MDP_REG_WROT_H__
+
+#include "mmsys_reg_base.h"
+
+#define VIDO_CTRL                   0x000
+#define VIDO_DMA_PERF               0x004
+#define VIDO_MAIN_BUF_SIZE          0x008
+#define VIDO_SOFT_RST               0x010
+#define VIDO_SOFT_RST_STAT          0x014
+#define VIDO_INT_EN                 0x018
+#define VIDO_INT                    0x01c
+#define VIDO_CROP_OFST              0x020
+#define VIDO_TAR_SIZE               0x024
+#define VIDO_BASE_ADDR              0xf00
+#define VIDO_OFST_ADDR              0x02c
+#define VIDO_STRIDE                 0x030
+#define VIDO_BASE_ADDR_C            0xf04
+#define VIDO_OFST_ADDR_C            0x038
+#define VIDO_STRIDE_C               0x03c
+#define VIDO_DITHER                 0x054
+#define VIDO_BASE_ADDR_V            0xf08
+#define VIDO_OFST_ADDR_V            0x068
+#define VIDO_STRIDE_V               0x06c
+#define VIDO_RSV_1                  0x070
+#define VIDO_DMA_PREULTRA           0x074
+#define VIDO_IN_SIZE                0x078
+#define VIDO_ROT_EN                 0x07c
+#define VIDO_FIFO_TEST              0x080
+#define VIDO_MAT_CTRL               0x084
+#define VIDO_MAT_RMY                0x088
+#define VIDO_MAT_RMV                0x08c
+#define VIDO_MAT_GMY                0x090
+#define VIDO_MAT_BMY                0x094
+#define VIDO_MAT_BMV                0x098
+#define VIDO_MAT_PREADD             0x09c
+#define VIDO_MAT_POSTADD            0x0a0
+#define VIDO_DITHER_00              0x0a4
+#define VIDO_DITHER_02              0x0ac
+#define VIDO_DITHER_03              0x0b0
+#define VIDO_DITHER_04              0x0b4
+#define VIDO_DITHER_05              0x0b8
+#define VIDO_DITHER_06              0x0bc
+#define VIDO_DITHER_07              0x0c0
+#define VIDO_DITHER_08              0x0c4
+#define VIDO_DITHER_09              0x0c8
+#define VIDO_DITHER_10              0x0cc
+#define VIDO_DEBUG                  0x0d0
+#define VIDO_ARB_SW_CTL             0x0d4
+#define MDP_WROT_TRACK_CTL          0x0e0
+#define MDP_WROT_TRACK_WINDOW       0x0e4
+#define MDP_WROT_TRACK_TARGET       0x0e8
+#define MDP_WROT_TRACK_STOP         0x0ec
+#define MDP_WROT_TRACK_PROC_CNT0    0x0f0
+#define MDP_WROT_TRACK_PROC_CNT1    0x0f4
+
+/* MASK */
+#define VIDO_CTRL_MASK                  0xf530711f
+#define VIDO_DMA_PERF_MASK              0x3fffffff
+#define VIDO_MAIN_BUF_SIZE_MASK         0x1fff7f77
+#define VIDO_SOFT_RST_MASK              0x00000001
+#define VIDO_SOFT_RST_STAT_MASK         0x00000001
+#define VIDO_INT_EN_MASK                0x00003f07
+#define VIDO_INT_MASK                   0x00000007
+#define VIDO_CROP_OFST_MASK             0x1fff1fff
+#define VIDO_TAR_SIZE_MASK              0x1fff1fff
+#define VIDO_BASE_ADDR_MASK             0xffffffff
+#define VIDO_OFST_ADDR_MASK             0x0fffffff
+#define VIDO_STRIDE_MASK                0x0000ffff
+#define VIDO_BASE_ADDR_C_MASK           0xffffffff
+#define VIDO_OFST_ADDR_C_MASK           0x0fffffff
+#define VIDO_STRIDE_C_MASK              0x0000ffff
+#define VIDO_DITHER_MASK                0xff000001
+#define VIDO_BASE_ADDR_V_MASK           0xffffffff
+#define VIDO_OFST_ADDR_V_MASK           0x0fffffff
+#define VIDO_STRIDE_V_MASK              0x0000ffff
+#define VIDO_RSV_1_MASK                 0xffffffff
+#define VIDO_DMA_PREULTRA_MASK          0x00ffffff
+#define VIDO_IN_SIZE_MASK               0x1fff1fff
+#define VIDO_ROT_EN_MASK                0x00000001
+#define VIDO_FIFO_TEST_MASK             0x00000fff
+#define VIDO_MAT_CTRL_MASK              0x000000f3
+#define VIDO_MAT_RMY_MASK               0x1fff1fff
+#define VIDO_MAT_RMV_MASK               0x1fff1fff
+#define VIDO_MAT_GMY_MASK               0x1fff1fff
+#define VIDO_MAT_BMY_MASK               0x1fff1fff
+#define VIDO_MAT_BMV_MASK               0x00001fff
+#define VIDO_MAT_PREADD_MASK            0x1ff7fdff
+#define VIDO_MAT_POSTADD_MASK           0x1ff7fdff
+#define VIDO_DITHER_00_MASK             0x0000ff3f
+#define VIDO_DITHER_02_MASK             0xffff3fff
+#define VIDO_DITHER_03_MASK             0x0000003f
+#define VIDO_DITHER_04_MASK             0xbfffffff
+#define VIDO_DITHER_05_MASK             0xffff7fff
+#define VIDO_DITHER_06_MASK             0x003ff773
+#define VIDO_DITHER_07_MASK             0x00007777
+#define VIDO_DITHER_08_MASK             0x00007777
+#define VIDO_DITHER_09_MASK             0x00007777
+#define VIDO_DITHER_10_MASK             0x0001ffff
+#define VIDO_DEBUG_MASK                 0xffffffff
+#define VIDO_ARB_SW_CTL_MASK            0x00000007
+#define MDP_WROT_TRACK_CTL_MASK         0x0000001f
+#define MDP_WROT_TRACK_WINDOW_MASK      0x00000fff
+#define MDP_WROT_TRACK_TARGET_MASK      0x00ffffff
+#define MDP_WROT_TRACK_STOP_MASK        0x00ffffff
+#define MDP_WROT_TRACK_PROC_CNT0_MASK   0xffffffff
+#define MDP_WROT_TRACK_PROC_CNT1_MASK   0x00000001
+
+#endif  // __MDP_REG_WROT_H__
diff --git a/drivers/media/platform/mtk-mdp3/mmsys_config.h b/drivers/media/platform/mtk-mdp3/mmsys_config.h
new file mode 100644
index 000000000000..d1328840bbf2
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mmsys_config.h
@@ -0,0 +1,189 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ */
+
+#ifndef __MMSYS_CONFIG_H__
+#define __MMSYS_CONFIG_H__
+
+#include "mmsys_reg_base.h"
+
+#define MMSYS_INTEN                   0x000
+#define MMSYS_INTSTA                  0x004
+#define MJC_APB_TX_CON                0x00c
+
+#define ISP_MOUT_EN                   0xf80
+#define MDP_RDMA0_MOUT_EN             0xf84
+#define MDP_RDMA1_MOUT_EN             0xf88
+#define MDP_PRZ0_MOUT_EN              0xf8c
+#define MDP_PRZ1_MOUT_EN              0xf90
+#define MDP_COLOR_MOUT_EN             0xf94
+#define IPU_MOUT_EN                   0xf98
+#define DISP_TO_WROT_SOUT_SEL         0xfa0
+#define MDP_COLOR_IN_SOUT_SEL         0xfa4
+#define MDP_PATH0_SOUT_SEL            0xfa8
+#define MDP_PATH1_SOUT_SEL            0xfac
+#define MDP_TDSHP_SOUT_SEL            0xfb0
+
+#define DISP_OVL0_MOUT_EN             0xf00
+#define DISP_OVL0_2L_MOUT_EN          0xf04
+#define DISP_OVL1_2L_MOUT_EN          0xf08
+#define DISP_DITHER0_MOUT_EN          0xf0c
+#define DISP_RSZ_MOUT_EN              0xf10
+
+#define MMSYS_MOUT_RST                0x048
+#define MDP_PRZ0_SEL_IN               0xfc0
+#define MDP_PRZ1_SEL_IN               0xfc4
+#define MDP_TDSHP_SEL_IN              0xfc8
+#define DISP_WDMA0_SEL_IN             0xfcc
+#define MDP_WROT0_SEL_IN              0xfd0
+#define MDP_WDMA_SEL_IN               0xfd4
+#define MDP_COLOR_OUT_SEL_IN          0xfd8
+#define MDP_COLOR_SEL_IN              0xfdc
+#define MDP_PATH0_SEL_IN              0xfe0
+#define MDP_PATH1_SEL_IN              0xfe4
+
+#define DISP_COLOR_OUT_SEL_IN         0xf20
+#define DISP_PATH0_SEL_IN             0xf24
+#define DISP_WDMA0_PRE_SEL_IN         0xf28
+#define DSI0_SEL_IN                   0xf2c
+#define DSI1_SEL_IN                   0xf30
+#define DISP_OVL0_SEL_IN              0xf34
+#define DISP_OVL0_2L_SEL_IN           0xf38
+#define OVL_TO_RSZ_SEL_IN             0xf3c
+#define OVL_TO_WDMA_SEL_IN            0xf40
+#define OVL_TO_WROT_SEL_IN            0xf44
+#define DISP_RSZ_SEL_IN               0xf48
+#define DISP_RDMA0_SOUT_SEL_IN        0xf50
+#define DISP_RDMA1_SOUT_SEL_IN        0xf54
+#define MDP_TO_DISP0_SOUT_SEL_IN      0xf58
+#define MDP_TO_DISP1_SOUT_SEL_IN      0xf5c
+#define DISP_RDMA0_RSZ_IN_SOUT_SEL_IN 0xf60
+#define DISP_RDMA0_RSZ_OUT_SEL_IN     0xf64
+#define MDP_AAL_MOUT_EN               0xfe8
+#define MDP_AAL_SEL_IN                0xfec
+#define MDP_CCORR_SEL_IN              0xff0
+#define MDP_CCORR_SOUT_SEL            0xff4
+
+#define MMSYS_MISC                    0x0f0
+#define MMSYS_SMI_LARB_SEL            0x0f4
+#define MMSYS_SODI_REQ_MASK           0x0f8
+#define MMSYS_CG_CON0                 0x100
+#define MMSYS_CG_SET0                 0x104
+#define MMSYS_CG_CLR0                 0x108
+#define MMSYS_CG_CON1                 0x110
+#define MMSYS_CG_SET1                 0x114
+#define MMSYS_CG_CLR1                 0x118
+#define MMSYS_HW_DCM_DIS0             0x120
+#define MMSYS_HW_DCM_DIS_SET0         0x124
+#define MMSYS_HW_DCM_DIS_CLR0         0x128
+#define MMSYS_HW_DCM_DIS1             0x130
+#define MMSYS_HW_DCM_DIS_SET1         0x134
+#define MMSYS_HW_DCM_DIS_CLR1         0x138
+#define MMSYS_HW_DCM_EVENT_CTL1       0x13c
+#define MMSYS_SW0_RST_B               0x140
+#define MMSYS_SW1_RST_B               0x144
+#define MMSYS_LCM_RST_B               0x150
+#define LARB6_AXI_ASIF_CFG_WD         0x180
+#define LARB6_AXI_ASIF_CFG_RD         0x184
+#define PROC_TRACK_EMI_BUSY_CON       0x190
+#define DISP_FAKE_ENG_EN              0x200
+#define DISP_FAKE_ENG_RST             0x204
+#define DISP_FAKE_ENG_CON0            0x208
+#define DISP_FAKE_ENG_CON1            0x20c
+#define DISP_FAKE_ENG_RD_ADDR         0x210
+#define DISP_FAKE_ENG_WR_ADDR         0x214
+#define DISP_FAKE_ENG_STATE           0x218
+#define DISP_FAKE_ENG2_EN             0x220
+#define DISP_FAKE_ENG2_RST            0x224
+#define DISP_FAKE_ENG2_CON0           0x228
+#define DISP_FAKE_ENG2_CON1           0x22c
+#define DISP_FAKE_ENG2_RD_ADDR        0x230
+#define DISP_FAKE_ENG2_WR_ADDR        0x234
+#define DISP_FAKE_ENG2_STATE          0x238
+#define MMSYS_MBIST_CON               0x800
+#define MMSYS_MBIST_DONE              0x804
+#define MMSYS_MBIST_HOLDB             0x808
+#define MMSYS_MBIST_MODE              0x80c
+#define MMSYS_MBIST_FAIL0             0x810
+#define MMSYS_MBIST_FAIL1             0x814
+#define MMSYS_MBIST_FAIL2             0x818
+#define MMSYS_MBIST_DEBUG             0x820
+#define MMSYS_MBIST_DIAG_SCANOUT      0x824
+#define MMSYS_MBIST_PRE_FUSE          0x828
+#define MMSYS_MBIST_BSEL0             0x82c
+#define MMSYS_MBIST_BSEL1             0x830
+#define MMSYS_MBIST_BSEL2             0x834
+#define MMSYS_MBIST_BSEL3             0x838
+#define MMSYS_MBIST_HDEN              0x83c
+#define MDP_RDMA0_MEM_DELSEL          0x840
+#define MDP_RDMA1_MEM_DELSEL          0x844
+#define MDP_RSZ_MEM_DELSEL            0x848
+#define MDP_TDSHP_MEM_DELSEL          0x84c
+#define MDP_AAL_MEM_DELSEL            0x850
+
+#define MDP_WROT0_MEM_DELSEL          0x854
+#define MDP_WDMA_MEM_DELSEL           0x858
+#define DISP_OVL_MEM_DELSEL           0x85c
+#define DISP_OVL_2L_MEM_DELSEL        0x860
+#define DISP_RDMA_MEM_DELSEL          0x864
+#define DISP_WDMA0_MEM_DELSEL         0x868
+#define DISP_GAMMA_MEM_DELSEL         0x870
+#define DSI_MEM_DELSEL                0x874
+#define DISP_SPLIT_MEM_DELSEL         0x878
+#define DISP_DSC_MEM_DELSEL           0x87c
+#define MMSYS_DEBUG_OUT_SEL           0x88c
+#define MMSYS_MBIST_RP_RST_B          0x890
+#define MMSYS_MBIST_RP_FAIL0          0x894
+#define MMSYS_MBIST_RP_FAIL1          0x898
+#define MMSYS_MBIST_RP_OK0            0x89c
+#define MMSYS_MBIST_RP_OK1            0x8a0
+#define MMSYS_DUMMY0                  0x8a4
+#define MMSYS_DUMMY1                  0x8a8
+#define MMSYS_DUMMY2                  0x8ac
+#define MMSYS_DUMMY3                  0x8b0
+#define DISP_DL_VALID_0               0x8b4
+#define DISP_DL_VALID_1               0x8b8
+#define DISP_DL_VALID_2               0x8bc
+#define DISP_DL_READY_0               0x8c0
+#define DISP_DL_READY_1               0x8c4
+#define DISP_DL_READY_2               0x8C8
+#define MDP_DL_VALID_0                0x8cc
+#define MDP_DL_VALID_1                0x8d0
+#define MDP_DL_READY_0                0x8d4
+#define MDP_DL_READY_1                0x8d8
+#define SMI_LARB0_GREQ                0x8dc
+#define DISP_MOUT_MASK                0x8e0
+#define DISP_MOUT_MASK1               0x8e4
+#define MDP_MOUT_MASK                 0x8e8
+#define MMSYS_POWER_READ              0x8ec
+#define TOP_RELAY_FSM_RD              0x960
+#define MDP_ASYNC_CFG_WD              0x934
+#define MDP_ASYNC_CFG_RD              0x938
+#define MDP_ASYNC_IPU_CFG_WD          0x93C
+#define MDP_ASYNC_CFG_IPU_RD          0x940
+#define MDP_ASYNC_CFG_OUT_RD          0x958
+#define MDP_ASYNC_IPU_CFG_OUT_RD      0x95C
+#define ISP_RELAY_CFG_WD              0x994
+#define ISP_RELAY_CNT_RD              0x998
+#define ISP_RELAY_CNT_LATCH_RD        0x99c
+#define IPU_RELAY_CFG_WD              0x9a0
+#define IPU_RELAY_CNT_RD              0x9a4
+#define IPU_RELAY_CNT_LATCH_RD        0x9a8
+
+/* MASK */
+#define MMSYS_SW0_RST_B_MASK          0xffffffff
+#define MMSYS_SW1_RST_B_MASK          0xffffffff
+#define MDP_COLOR_IN_SOUT_SEL_MASK    0x0000000f
+#define DISP_COLOR_OUT_SEL_IN_MASK    0xffffffff
+#define MDP_ASYNC_CFG_WD_MASK         0xffffffff
+#define MDP_ASYNC_IPU_CFG_WD_MASK     0xffffffff
+#define MMSYS_HW_DCM_DIS0_MASK        0xffffffff
+#define MMSYS_HW_DCM_DIS1_MASK        0xffffffff
+#define MDP_ASYNC_CFG_WD_MASK         0xffffffff
+#define ISP_RELAY_CFG_WD_MASK         0xffffffff
+#define IPU_RELAY_CFG_WD_MASK         0xffffffff
+
+#endif  // __MMSYS_CONFIG_H__
diff --git a/drivers/media/platform/mtk-mdp3/mmsys_mutex.h b/drivers/media/platform/mtk-mdp3/mmsys_mutex.h
new file mode 100644
index 000000000000..9ff382cc37c8
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mmsys_mutex.h
@@ -0,0 +1,36 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ */
+
+#ifndef __MMSYS_MUTEX_H__
+#define __MMSYS_MUTEX_H__
+
+#include "mmsys_reg_base.h"
+#include "mdp-platform.h"
+
+#define MM_MUTEX_INTEN              0x00
+#define MM_MUTEX_INTSTA             0x04
+#define MM_MUTEX_CFG                0x08
+
+#define MM_MUTEX_EN                 (0x20 + mutex_id * 0x20)
+#define MM_MUTEX_GET                (0x24 + mutex_id * 0x20)
+#define MM_MUTEX_RST                (0x28 + mutex_id * 0x20)
+#define MM_MUTEX_MOD                (MM_MUTEX_MOD_OFFSET + mutex_id * 0x20)
+#define MM_MUTEX_SOF                (MM_MUTEX_SOF_OFFSET + mutex_id * 0x20)
+
+// MASK
+#define MM_MUTEX_INTEN_MASK         0x0fff
+#define MM_MUTEX_INTSTA_MASK        0x0fff
+#define MM_MUTEX_DEBUG_OUT_SEL_MASK 0x03
+#define MM_MUTEX_CFG_MASK           0x01
+
+#define MM_MUTEX_EN_MASK            0x01
+#define MM_MUTEX_GET_MASK           0x03
+#define MM_MUTEX_RST_MASK           0x01
+#define MM_MUTEX_MOD_MASK           0x07ffffff
+#define MM_MUTEX_SOF_MASK           0x0f
+
+#endif  // __MMSYS_MUTEX_H__
diff --git a/drivers/media/platform/mtk-mdp3/mmsys_reg_base.h b/drivers/media/platform/mtk-mdp3/mmsys_reg_base.h
new file mode 100644
index 000000000000..441cb56fcbba
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mmsys_reg_base.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ */
+
+#ifndef __MMSYS_REG_BASE_H__
+#define __MMSYS_REG_BASE_H__
+
+#define MM_REG_WRITE_MASK(cmd, id, base, ofst, val, mask, ...) \
+	cmdq_pkt_write_mask(cmd->pkt, id, \
+		(base) + (ofst), (val), (mask), ##__VA_ARGS__)
+#define MM_REG_WRITE(cmd, id, base, ofst, val, mask, ...) \
+	MM_REG_WRITE_MASK(cmd, id, base, ofst, val, \
+		(((mask) & (ofst##_MASK)) == (ofst##_MASK)) ? \
+			(0xffffffff) : (mask), ##__VA_ARGS__)
+
+#define MM_REG_WAIT(cmd, evt) \
+	cmdq_pkt_wfe(cmd->pkt, cmd->event[(evt)])
+
+#define MM_REG_WAIT_NO_CLEAR(cmd, evt) \
+	cmdq_pkt_wait_no_clear(cmd->pkt, cmd->event[(evt)])
+
+#define MM_REG_CLEAR(cmd, evt) \
+	cmdq_pkt_clear_event(cmd->pkt, cmd->event[(evt)])
+
+#define MM_REG_SET_EVENT(cmd, evt) \
+	cmdq_pkt_set_event(cmd->pkt, cmd->event[(evt)])
+
+#define MM_REG_POLL_MASK(cmd, id, base, ofst, val, mask, ...) \
+	cmdq_pkt_poll(cmd->pkt, id, \
+		(base) + (ofst), (val), (mask), ##__VA_ARGS__)
+#define MM_REG_POLL(cmd, id, base, ofst, val, mask, ...) \
+	MM_REG_POLL_MASK(cmd, id, base, ofst, val, \
+		(((mask) & (ofst##_MASK)) == (ofst##_MASK)) ? \
+			(0xffffffff) : (mask), ##__VA_ARGS__)
+
+#endif  // __MM_REG_BASE_H__
diff --git a/drivers/media/platform/mtk-mdp3/mtk-img-ipi.h b/drivers/media/platform/mtk-mdp3/mtk-img-ipi.h
new file mode 100644
index 000000000000..0721e2175031
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-img-ipi.h
@@ -0,0 +1,282 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Holmes Chiou <holmes.chiou@mediatek.com>
+ *         Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_IMG_IPI_H__
+#define __MTK_IMG_IPI_H__
+
+#include <linux/types.h>
+
+/* ISP-MDP generic input information */
+
+#define IMG_MAX_HW_INPUTS	3
+
+#define IMG_MAX_HW_OUTPUTS	4
+
+#define IMG_MAX_PLANES		3
+
+#define IMG_IPI_INIT    1
+#define IMG_IPI_DEINIT  2
+#define IMG_IPI_FRAME   3
+#define IMG_IPI_DEBUG   4
+
+struct img_addr {
+	u64	va;	/* Used by Linux OS access */
+	u32	pa;	/* Used by CM4 access */
+	u32	iova;	/* Used by IOMMU HW access */
+} __attribute__ ((__packed__));
+
+struct img_sw_addr {
+	u64	va;	/* Used by APMCU access */
+	u32	pa;	/* Used by CM4 access */
+} __attribute__ ((__packed__));
+
+struct img_plane_format {
+	u32	size;
+	u16	stride;
+} __attribute__ ((__packed__));
+
+struct img_pix_format {
+	u16		width;
+	u16		height;
+	u32		colorformat;	/* enum mdp_color */
+	u16		ycbcr_prof;	/* enum mdp_ycbcr_profile */
+	struct img_plane_format	plane_fmt[IMG_MAX_PLANES];
+} __attribute__ ((__packed__));
+
+struct img_image_buffer {
+	struct img_pix_format	format;
+	u32		iova[IMG_MAX_PLANES];
+	/* enum mdp_buffer_usage, FD or advanced ISP usages */
+	u32		usage;
+} __attribute__ ((__packed__));
+
+#define IMG_SUBPIXEL_SHIFT	20
+
+struct img_crop {
+	s16		left;
+	s16		top;
+	u16	width;
+	u16	height;
+	u32	left_subpix;
+	u32	top_subpix;
+	u32	width_subpix;
+	u32	height_subpix;
+} __attribute__ ((__packed__));
+
+#define IMG_CTRL_FLAG_HFLIP	BIT(0)
+#define IMG_CTRL_FLAG_DITHER	BIT(1)
+#define IMG_CTRL_FLAG_SHARPNESS	BIT(4)
+#define IMG_CTRL_FLAG_HDR	BIT(5)
+#define IMG_CTRL_FLAG_DRE	BIT(6)
+
+struct img_input {
+	struct img_image_buffer	buffer;
+	u16		flags;	/* HDR, DRE, dither */
+} __attribute__ ((__packed__));
+
+struct img_output {
+	struct img_image_buffer	buffer;
+	struct img_crop		crop;
+	s16			rotation;
+	u16		flags;	/* H-flip, sharpness, dither */
+} __attribute__ ((__packed__));
+
+struct img_ipi_frameparam {
+	u32		index;
+	u32		frame_no;
+	u64		timestamp;
+	u8			type;	/* enum mdp_stream_type */
+	u8			state;
+	u8			num_inputs;
+	u8			num_outputs;
+	u64		drv_data;
+	struct img_input	inputs[IMG_MAX_HW_INPUTS];
+	struct img_output	outputs[IMG_MAX_HW_OUTPUTS];
+	struct img_addr		tuning_data;
+	struct img_addr		subfrm_data;
+	struct img_sw_addr	config_data;
+	struct img_sw_addr  self_data;
+	/* u8		pq_data[]; */
+} __attribute__ ((__packed__));
+
+struct img_ipi_param {
+	u8	usage;
+	struct	img_sw_addr frm_param;
+} __attribute__ ((__packed__));
+
+struct img_frameparam {
+	struct list_head	list_entry;
+	struct img_ipi_frameparam frameparam;
+};
+
+/* ISP-MDP generic output information */
+
+struct img_comp_frame {
+	u32	output_disable:1;
+	u32	bypass:1;
+	u16	in_width;
+	u16	in_height;
+	u16	out_width;
+	u16	out_height;
+	struct img_crop	crop;
+	u16	in_total_width;
+	u16	out_total_width;
+} __attribute__ ((__packed__));
+
+struct img_region {
+	s16	left;
+	s16	right;
+	s16	top;
+	s16	bottom;
+} __attribute__ ((__packed__));
+
+struct img_offset {
+	s16		left;
+	s16		top;
+	u32	left_subpix;
+	u32	top_subpix;
+} __attribute__ ((__packed__));
+
+struct img_comp_subfrm {
+	u32		tile_disable:1;
+	struct img_region	in;
+	struct img_region	out;
+	struct img_offset	luma;
+	struct img_offset	chroma;
+	s16			out_vertical;	/* Output vertical index */
+	s16			out_horizontal;	/* Output horizontal index */
+} __attribute__ ((__packed__));
+
+#define IMG_MAX_SUBFRAMES	14
+
+struct mdp_rdma_subfrm {
+	u32	offset[IMG_MAX_PLANES];
+	u32	offset_0_p;
+	u32	src;
+	u32	clip;
+	u32	clip_ofst;
+} __attribute__ ((__packed__));
+
+struct mdp_rdma_data {
+	u32		src_ctrl;
+	u32		control;
+	u32		iova[IMG_MAX_PLANES];
+	u32		iova_end[IMG_MAX_PLANES];
+	u32		mf_bkgd;
+	u32		mf_bkgd_in_pxl;
+	u32		sf_bkgd;
+	u32		ufo_dec_y;
+	u32		ufo_dec_c;
+	u32		transform;
+	struct mdp_rdma_subfrm	subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct mdp_rsz_subfrm {
+	u32	control2;
+	u32	src;
+	u32	clip;
+} __attribute__ ((__packed__));
+
+struct mdp_rsz_data {
+	u32		coeff_step_x;
+	u32		coeff_step_y;
+	u32		control1;
+	u32		control2;
+	struct mdp_rsz_subfrm	subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct mdp_wrot_subfrm {
+	u32	offset[IMG_MAX_PLANES];
+	u32	src;
+	u32	clip;
+	u32	clip_ofst;
+	u32	main_buf;
+} __attribute__ ((__packed__));
+
+struct mdp_wrot_data {
+	u32		iova[IMG_MAX_PLANES];
+	u32		control;
+	u32		stride[IMG_MAX_PLANES];
+	u32		mat_ctrl;
+	u32		fifo_test;
+	u32		filter;
+	struct mdp_wrot_subfrm	subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct mdp_wdma_subfrm {
+	u32	offset[IMG_MAX_PLANES];
+	u32	src;
+	u32	clip;
+	u32	clip_ofst;
+} __attribute__ ((__packed__));
+
+struct mdp_wdma_data {
+	u32		wdma_cfg;
+	u32		iova[IMG_MAX_PLANES];
+	u32		w_in_byte;
+	u32		uv_stride;
+	struct mdp_wdma_subfrm	subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct isp_data {
+	u64	dl_flags;	/* 1 << (enum mdp_comp_type) */
+	u32	smxi_iova[4];
+	u32	cq_idx;
+	u32	cq_iova;
+	u32	tpipe_iova[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct img_compparam {
+	u16		type;	/* enum mdp_comp_type */
+	u16		id;	/* enum mdp_comp_id */
+	u32		input;
+	u32		outputs[IMG_MAX_HW_OUTPUTS];
+	u32		num_outputs;
+	struct img_comp_frame	frame;
+	struct img_comp_subfrm	subfrms[IMG_MAX_SUBFRAMES];
+	u32		num_subfrms;
+	union {
+		struct mdp_rdma_data	rdma;
+		struct mdp_rsz_data	rsz;
+		struct mdp_wrot_data	wrot;
+		struct mdp_wdma_data	wdma;
+		/* struct mdp_hdr_data	hdr; */
+		struct isp_data		isp;
+		/* struct wpe_data	wpe; */
+	};
+} __attribute__ ((__packed__));
+
+#define IMG_MAX_COMPONENTS	20
+
+struct img_mux {
+	u32	reg;
+	u32	value;
+};
+
+struct img_mmsys_ctrl {
+	struct img_mux	sets[IMG_MAX_COMPONENTS * 2];
+	u32	num_sets;
+};
+
+struct img_config {
+	struct img_compparam	components[IMG_MAX_COMPONENTS];
+	u32		num_components;
+	struct img_mmsys_ctrl	ctrls[IMG_MAX_SUBFRAMES];
+	u32		num_subfrms;
+} __attribute__ ((__packed__));
+
+#endif  /* __MTK_IMG_IPI_H__ */
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.c
new file mode 100644
index 000000000000..fc380cfa8070
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.c
@@ -0,0 +1,507 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/platform_device.h>
+#include "mtk-mdp3-cmdq.h"
+#include "mtk-mdp3-comp.h"
+#include "mtk-mdp3-core.h"
+#ifdef MDP_DEBUG
+#include "mtk-mdp3-debug.h"
+#endif
+
+#include "mdp-platform.h"
+#include "mmsys_mutex.h"
+
+#define DISP_MUTEX_MDP_FIRST	(5)
+#define DISP_MUTEX_MDP_COUNT	(5)
+
+#define MDP_PATH_MAX_COMPS	IMG_MAX_COMPONENTS
+
+struct mdp_path {
+	struct mdp_dev		*mdp_dev;
+	struct mdp_comp_ctx	comps[MDP_PATH_MAX_COMPS];
+	u32			num_comps;
+	const struct img_config	*config;
+	const struct img_ipi_frameparam *param;
+	const struct v4l2_rect	*composes[IMG_MAX_HW_OUTPUTS];
+	struct v4l2_rect	bounds[IMG_MAX_HW_OUTPUTS];
+};
+
+#define has_op(ctx, op) \
+	(ctx->comp->ops && ctx->comp->ops->op)
+#define call_op(ctx, op, ...) \
+	(has_op(ctx, op) ? ctx->comp->ops->op(ctx, ##__VA_ARGS__) : 0)
+
+struct mdp_path_subfrm {
+	s32	mutex_id;
+	u32	mutex_mod;
+	s32	sofs[MDP_PATH_MAX_COMPS];
+	u32	num_sofs;
+};
+
+bool is_output_disable(const struct img_compparam *param, u32 count)
+{
+	return (count < param->num_subfrms) ?
+		(param->frame.output_disable ||
+		param->subfrms[count].tile_disable) :
+		true;
+}
+
+int mdp_path_subfrm_require(struct mdp_path_subfrm *subfrm,
+			    const struct mdp_path *path, struct mdp_cmd *cmd,
+			    u32 count)
+{
+	const struct img_config *config = path->config;
+	const struct mdp_comp_ctx *ctx;
+	phys_addr_t mm_mutex = path->mdp_dev->mm_mutex.reg_base;
+	s32 mutex_id = -1;
+	u32 mutex_sof = 0;
+	int mdp_color = 0;
+	int index;
+	u8 subsys_id = path->mdp_dev->mm_mutex.subsys_id;
+
+	/* Default value */
+	memset(subfrm, 0, sizeof(*subfrm));
+
+	for (index = 0; index < config->num_components; index++) {
+		ctx = &path->comps[index];
+		if (is_output_disable(ctx->param, count))
+			continue;
+		switch (ctx->comp->id) {
+		/**********************************************
+		 * Name            MSB LSB
+		 * DISP_MUTEX_MOD   23   0
+		 *
+		 * Specifies which modules are in this mutex.
+		 * Every bit denotes a module. Bit definition:
+		 *  2 mdp_rdma0
+		 *  4 mdp_rsz0
+		 *  5 mdp_rsz1
+		 *  6 mdp_tdshp
+		 *  7 mdp_wrot0
+		 *  8 mdp_wdma
+		 *  13 mdp_color
+		 *  23 mdp_aal
+		 *  24 mdp_ccorr
+		 **********************************************/
+		case MDP_AAL0:
+			subfrm->mutex_mod |= 1 << 23;
+			break;
+		case MDP_CCORR0:
+			subfrm->mutex_mod |= 1 << 24;
+			break;
+		case MDP_COLOR0:
+			if (mdp_color)
+				subfrm->mutex_mod |= 1 << 13;
+			break;
+		case MDP_WDMA:
+			subfrm->mutex_mod |= 1 << 8;
+			subfrm->sofs[subfrm->num_sofs++] = MDP_WDMA;
+			break;
+		case MDP_WROT0:
+			subfrm->mutex_mod |= 1 << 7;
+			subfrm->sofs[subfrm->num_sofs++] = MDP_WROT0;
+			break;
+		case MDP_TDSHP0:
+			subfrm->mutex_mod |= 1 << 6;
+			subfrm->sofs[subfrm->num_sofs++] = MDP_TDSHP0;
+			break;
+		case MDP_SCL1:
+			subfrm->mutex_mod |= 1 << 5;
+			subfrm->sofs[subfrm->num_sofs++] = MDP_SCL1;
+			break;
+		case MDP_SCL0:
+			subfrm->mutex_mod |= 1 << 4;
+			subfrm->sofs[subfrm->num_sofs++] = MDP_SCL0;
+			break;
+		case MDP_RDMA0:
+			mutex_id = DISP_MUTEX_MDP_FIRST + 1;
+			subfrm->mutex_mod |= 1 << 2;
+			subfrm->sofs[subfrm->num_sofs++] = MDP_RDMA0;
+			break;
+		case MDP_IMGI:
+			mutex_id = DISP_MUTEX_MDP_FIRST;
+			break;
+		case MDP_WPEI:
+			mutex_id = DISP_MUTEX_MDP_FIRST + 3;
+			break;
+		case MDP_WPEI2:
+			mutex_id = DISP_MUTEX_MDP_FIRST + 4;
+			break;
+		default:
+			break;
+		}
+	}
+
+	subfrm->mutex_id = mutex_id;
+	if (-1 == mutex_id) {
+		mdp_err("No mutex assigned");
+		return -EINVAL;
+	}
+
+	if (subfrm->mutex_mod) {
+		/* Set mutex modules */
+		MM_REG_WRITE(cmd, subsys_id, mm_mutex, MM_MUTEX_MOD,
+			     subfrm->mutex_mod, 0x07FFFFFF);
+		MM_REG_WRITE(cmd, subsys_id, mm_mutex, MM_MUTEX_SOF,
+			     mutex_sof, 0x00000007);
+	}
+	return 0;
+}
+
+int mdp_path_subfrm_run(const struct mdp_path_subfrm *subfrm,
+			const struct mdp_path *path, struct mdp_cmd *cmd)
+{
+	phys_addr_t mm_mutex = path->mdp_dev->mm_mutex.reg_base;
+	s32 mutex_id = subfrm->mutex_id;
+	u8 subsys_id = path->mdp_dev->mm_mutex.subsys_id;
+
+	if (-1 == mutex_id) {
+		mdp_err("Incorrect mutex id");
+		return -EINVAL;
+	}
+
+	if (subfrm->mutex_mod) {
+		int index;
+
+		/* Wait WROT SRAM shared to DISP RDMA */
+		/* Clear SOF event for each engine */
+		for (index = 0; index < subfrm->num_sofs; index++) {
+			switch (subfrm->sofs[index]) {
+			case MDP_RDMA0:
+				MM_REG_CLEAR(cmd, RDMA0_SOF);
+				MM_REG_CLEAR(cmd, RDMA0_DONE);
+				break;
+			case MDP_TDSHP0:
+				MM_REG_CLEAR(cmd, TDSHP0_SOF);
+				break;
+			case MDP_SCL0:
+				MM_REG_CLEAR(cmd, RSZ0_SOF);
+				break;
+			case MDP_SCL1:
+				MM_REG_CLEAR(cmd, RSZ1_SOF);
+				break;
+			case MDP_WDMA:
+				MM_REG_CLEAR(cmd, WDMA0_SOF);
+				MM_REG_CLEAR(cmd, WDMA0_DONE);
+				break;
+			case MDP_WROT0:
+#if WROT0_DISP_SRAM_SHARING
+				MM_REG_WAIT_NO_CLEAR(cmd, WROT0_SRAM_READY);
+#endif
+				MM_REG_CLEAR(cmd, WROT0_SOF);
+				MM_REG_CLEAR(cmd, WROT0_DONE);
+				break;
+			default:
+				break;
+			}
+		}
+
+		/* Enable the mutex */
+		MM_REG_WRITE(cmd, subsys_id, mm_mutex, MM_MUTEX_EN, 0x1,
+			     0x00000001);
+
+		/* Wait SOF events and clear mutex modules (optional) */
+		for (index = 0; index < subfrm->num_sofs; index++) {
+			switch (subfrm->sofs[index]) {
+			case MDP_RDMA0:
+				MM_REG_WAIT(cmd, RDMA0_SOF);
+				break;
+			case MDP_TDSHP0:
+				MM_REG_WAIT(cmd, TDSHP0_SOF);
+				break;
+			case MDP_SCL0:
+				MM_REG_WAIT(cmd, RSZ0_SOF);
+				break;
+			case MDP_SCL1:
+				MM_REG_WAIT(cmd, RSZ1_SOF);
+				break;
+			case MDP_WDMA:
+				MM_REG_WAIT(cmd, WDMA0_SOF);
+				break;
+			case MDP_WROT0:
+				MM_REG_WAIT(cmd, WROT0_SOF);
+				break;
+			default:
+				break;
+			}
+		}
+	}
+	return 0;
+}
+
+static int mdp_path_config_subfrm(struct mdp_cmd *cmd, struct mdp_path *path,
+				  u32 count)
+{
+	struct mdp_path_subfrm subfrm;
+	const struct img_config *config = path->config;
+	const struct img_mmsys_ctrl *ctrl = &config->ctrls[count];
+	const struct img_mux *set;
+	struct mdp_comp_ctx *ctx;
+	phys_addr_t mmsys = path->mdp_dev->mmsys.reg_base;
+	int index, ret;
+	u8 subsys_id = path->mdp_dev->mmsys.subsys_id;
+
+	/* Acquire components */
+	ret = mdp_path_subfrm_require(&subfrm, path, cmd, count);
+	if (ret)
+		return ret;
+	/* Enable mux settings */
+	for (index = 0; index < ctrl->num_sets; index++) {
+		set = &ctrl->sets[index];
+		MM_REG_WRITE_MASK(cmd, subsys_id, mmsys, set->reg, set->value,
+				  0xFFFFFFFF);
+	}
+	/* Config sub-frame information */
+	for (index = (config->num_components - 1); index >= 0; index--) {
+		ctx = &path->comps[index];
+		if (is_output_disable(ctx->param, count))
+			continue;
+		ret = call_op(ctx, config_subfrm, cmd, count);
+		if (ret)
+			return ret;
+	}
+	/* Run components */
+	ret = mdp_path_subfrm_run(&subfrm, path, cmd);
+	if (ret)
+		return ret;
+	/* Wait components done */
+	for (index = 0; index < config->num_components; index++) {
+		ctx = &path->comps[index];
+		if (is_output_disable(ctx->param, count))
+			continue;
+		ret = call_op(ctx, wait_comp_event, cmd);
+		if (ret)
+			return ret;
+	}
+	/* Advance to the next sub-frame */
+	for (index = 0; index < config->num_components; index++) {
+		ctx = &path->comps[index];
+		ret = call_op(ctx, advance_subfrm, cmd, count);
+		if (ret)
+			return ret;
+	}
+	/* Disable mux settings */
+	for (index = 0; index < ctrl->num_sets; index++) {
+		set = &ctrl->sets[index];
+		MM_REG_WRITE_MASK(cmd, subsys_id, mmsys, set->reg, 0,
+				  0xFFFFFFFF);
+	}
+	return 0;
+}
+
+static int mdp_path_config(struct mdp_dev *mdp, struct mdp_cmd *cmd,
+			   struct mdp_path *path)
+{
+	const struct img_config *config = path->config;
+	struct mdp_comp_ctx *ctx;
+	int index, count, ret;
+
+	for (index = 0; index < config->num_components; index++) {
+		ret = mdp_comp_ctx_init(mdp, &path->comps[index],
+					&config->components[index],
+					path->param);
+		if (ret)
+			return ret;
+	}
+
+	/* Config path frame */
+	/* Reset components */
+	for (index = 0; index < config->num_components; index++) {
+		ctx = &path->comps[index];
+		ret = call_op(ctx, init_comp, cmd);
+		if (ret)
+			return ret;
+	}
+	/* Config frame mode */
+	for (index = 0; index < config->num_components; index++) {
+		const struct v4l2_rect *compose =
+			path->composes[ctx->param->outputs[0]];
+
+		ctx = &path->comps[index];
+		ret = call_op(ctx, config_frame, cmd, compose);
+		if (ret)
+			return ret;
+	}
+
+	/* Config path sub-frames */
+	for (count = 0; count < config->num_subfrms; count++) {
+		ret = mdp_path_config_subfrm(cmd, path, count);
+		if (ret)
+			return ret;
+	}
+	/* Post processing information */
+	for (index = 0; index < config->num_components; index++) {
+		ctx = &path->comps[index];
+		ret = call_op(ctx, post_process, cmd);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+static void mdp_auto_release_work(struct work_struct *work)
+{
+	struct mdp_cmdq_cb_param *cb_param;
+
+	cb_param = container_of(work, struct mdp_cmdq_cb_param,
+				autoReleaseWork);
+	if (cb_param->comps && cb_param->num_comps) {
+		struct mdp_dev *mdp = cb_param->mdp;
+		int i;
+
+		for (i = 0; i < cb_param->num_comps; i++)
+			mdp_comp_clock_off(&mdp->pdev->dev,
+					   &cb_param->comps[i]);
+	}
+
+	kfree(cb_param->comps);
+	kfree(cb_param);
+}
+
+void mdp_handle_cmdq_callback(struct cmdq_cb_data data)
+{
+	struct mdp_cmdq_cb_param *cb_param;
+	struct mdp_dev *mdp;
+
+	if (!data.data) {
+		mdp_err("%s:no callback data\n", __func__);
+		return;
+	}
+
+	cb_param = (struct mdp_cmdq_cb_param *)data.data;
+	mdp = cb_param->mdp;
+#ifdef MDP_DEBUG
+	if (data.sta == CMDQ_CB_ERROR) {
+		struct mdp_func_struct *p_func = mdp_get_func();
+
+		p_func->mdp_dump_mmsys_config();
+		mdp_dump_info(~0, 1);
+	}
+#endif
+	INIT_WORK(&cb_param->autoReleaseWork, mdp_auto_release_work);
+	queue_work(mdp->clock_wq, &cb_param->autoReleaseWork);
+
+	if (cb_param->user_cmdq_cb) {
+		struct cmdq_cb_data user_cb_data;
+
+		user_cb_data.sta = data.sta;
+		user_cb_data.data = cb_param->user_cb_data;
+		cb_param->user_cmdq_cb(user_cb_data);
+	}
+
+	cmdq_pkt_destroy(cb_param->pkt);
+}
+
+int mdp_cmdq_send(struct mdp_dev *mdp, struct mdp_cmdq_param *param)
+{
+	struct mdp_cmd cmd;
+	struct mdp_path path;
+	int i, ret;
+
+	cmd.pkt = cmdq_pkt_create(mdp->cmdq_clt, SZ_16K);
+	if (IS_ERR(cmd.pkt))
+		return PTR_ERR(cmd.pkt);
+	cmd.event = &mdp->event[0];
+
+	path.mdp_dev = mdp;
+	path.config = param->config;
+	path.param = param->param;
+	for (i = 0; i < param->param->num_outputs; i++) {
+		path.bounds[i].left = 0;
+		path.bounds[i].top = 0;
+		path.bounds[i].width =
+			param->param->outputs[i].buffer.format.width;
+		path.bounds[i].height =
+			param->param->outputs[i].buffer.format.height;
+		path.composes[i] = param->composes[i] ?
+			param->composes[i] : &path.bounds[i];
+	}
+	ret = mdp_path_config(mdp, &cmd, &path);
+	if (ret)
+		return ret;
+#ifdef MDP_UT
+	/* cmdq_pkt_dump_buf(cmd.pkt, 0); */
+#endif
+
+	// TODO: engine conflict dispatch
+	for (i = 0; i < param->config->num_components; i++)
+		mdp_comp_clock_on(&mdp->pdev->dev, path.comps[i].comp);
+
+	if (param->wait) {
+		ret = cmdq_pkt_flush(cmd.pkt);
+		cmdq_pkt_destroy(cmd.pkt);
+		for (i = 0; i < param->config->num_components; i++)
+			mdp_comp_clock_off(&mdp->pdev->dev, path.comps[i].comp);
+	} else {
+		struct mdp_cmdq_cb_param *cb_param;
+		struct mdp_comp *comps;
+
+		cb_param = kzalloc(sizeof(struct mdp_cmdq_cb_param),
+				   GFP_KERNEL);
+		if (!cb_param) {
+			mdp_err("%s:cb_param alloc fail!\n", __func__);
+			return -ENOMEM;
+		}
+		comps = kzalloc(param->config->num_components *
+				sizeof(struct mdp_comp), GFP_KERNEL);
+		if (!comps) {
+			kfree(cb_param);
+			mdp_err("%s:comps alloc fail!\n", __func__);
+			return -ENOMEM;
+		}
+
+		for (i = 0; i < param->config->num_components; i++)
+			memcpy(&comps[i], path.comps[i].comp,
+			       sizeof(struct mdp_comp));
+		cb_param->mdp = mdp;
+		cb_param->user_cmdq_cb = param->cmdq_cb;
+		cb_param->user_cb_data = param->cb_data;
+		cb_param->pkt = cmd.pkt;
+		cb_param->comps = comps;
+		cb_param->num_comps = param->config->num_components;
+
+		ret = cmdq_pkt_flush_async(cmd.pkt,
+					   mdp_handle_cmdq_callback,
+					   (void *)cb_param);
+		if (ret) {
+			mdp_err("%s:cmdq_pkt_flush_async fail!\n", __func__);
+			kfree(cb_param);
+			kfree(comps);
+		}
+		// TODO: destroy & clock-off after callback
+	}
+	return ret;
+}
+
+int mdp_cmdq_sendtask(struct platform_device *pdev, struct img_config *config,
+		      struct img_ipi_frameparam *param,
+		      struct v4l2_rect *compose, unsigned int wait,
+		      void (*cmdq_cb)(struct cmdq_cb_data data), void *cb_data)
+{
+	struct mdp_dev *mdp = platform_get_drvdata(pdev);
+	struct mdp_cmdq_param task = {
+		.config = config,
+		.param = param,
+		.composes[0] = compose,
+		.wait = wait,
+		.cmdq_cb = cmdq_cb,
+		.cb_data = cb_data,
+	};
+
+	return mdp_cmdq_send(mdp, &task);
+}
+EXPORT_SYMBOL_GPL(mdp_cmdq_sendtask);
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.h b/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.h
new file mode 100644
index 000000000000..0ef2911ece24
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_MDP3_CMDQ_H__
+#define __MTK_MDP3_CMDQ_H__
+
+#include <linux/platform_device.h>
+#include <linux/videodev2.h>
+#include <linux/soc/mediatek/mtk-cmdq.h>
+#include "mtk-img-ipi.h"
+
+struct platform_device *mdp_get_plat_device(struct platform_device *pdev);
+
+int mdp_cmdq_sendtask(struct platform_device *pdev, struct img_config *config,
+		      struct img_ipi_frameparam *param,
+		      struct v4l2_rect *compose, unsigned int wait,
+		      void (*cmdq_cb)(struct cmdq_cb_data data), void *cb_data);
+
+struct mdp_cmd {
+	struct cmdq_pkt *pkt;
+	s32 *event;
+};
+
+struct mdp_cmdq_param {
+	struct img_config	*config;
+	struct img_ipi_frameparam *param;
+	const struct v4l2_rect	*composes[IMG_MAX_HW_OUTPUTS];
+	unsigned int		wait;
+
+	void (*cmdq_cb)(struct cmdq_cb_data data);
+	void *cb_data;
+};
+
+struct mdp_cmdq_cb_param {
+	struct work_struct autoReleaseWork;
+	struct mdp_dev *mdp;
+	void (*user_cmdq_cb)(struct cmdq_cb_data data);
+	void *user_cb_data;
+	struct cmdq_pkt *pkt;
+	struct mdp_comp *comps;
+	u8 num_comps;
+};
+
+struct mdp_dev;
+
+int mdp_cmdq_send(struct mdp_dev *mdp, struct mdp_cmdq_param *param);
+
+#endif  /* __MTK_MDP3_CMDQ_H__ */
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.c
new file mode 100644
index 000000000000..60a97a73cc66
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.c
@@ -0,0 +1,1336 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/pm_runtime.h>
+#include "mtk-mdp3-comp.h"
+#include "mtk-mdp3-core.h"
+#include "mtk-mdp3-regs.h"
+
+#include "mdp-platform.h"
+#include "mmsys_config.h"
+#include "mdp_reg_rdma.h"
+#include "mdp_reg_ccorr.h"
+#include "mdp_reg_rsz.h"
+#include "mdp_reg_wrot.h"
+#include "mdp_reg_wdma.h"
+#include "isp_reg.h"
+
+static s64 get_comp_flag(const struct mdp_comp_ctx *ctx)
+{
+#if RDMA0_RSZ1_SRAM_SHARING
+	if (ctx->comp->id == MDP_RDMA0)
+		return (1 << MDP_RDMA0) | (1 << MDP_SCL1);
+#endif
+	return 1 << ctx->comp->id;
+}
+
+static int init_rdma(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+#if RDMA0_RSZ1_SRAM_SHARING
+	struct mdp_comp *prz1 = ctx->comp->mdp_dev->comp[MDP_SCL1];
+
+	/* Disable RSZ1 */
+	if (ctx->comp->id == MDP_RDMA0 && prz1)
+		MM_REG_WRITE(cmd, subsys_id, prz1->reg_base, PRZ_ENABLE,
+			     0x00000000, 0x00000001);
+#endif
+	/* Reset RDMA */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_RESET, 0x00000001,
+		     0x00000001);
+	MM_REG_POLL(cmd, subsys_id, base, MDP_RDMA_MON_STA_1, 0x00000100,
+		    0x00000100);
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_RESET, 0x00000000,
+		     0x00000001);
+	return 0;
+}
+
+static int config_rdma_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			     const struct v4l2_rect *compose)
+{
+	const struct mdp_rdma_data *rdma = &ctx->param->rdma;
+	u32 colorformat = ctx->input->buffer.format.colorformat;
+	bool block10bit = MDP_COLOR_IS_10BIT_PACKED(colorformat);
+	bool en_ufo = MDP_COLOR_IS_UFP(colorformat);
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+#if RDMA_SUPPORT_10BIT
+	if (block10bit)
+		MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_RESV_DUMMY_0,
+			     0x00000007, 0x00000007);
+	else
+		MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_RESV_DUMMY_0,
+			     0x00000000, 0x00000007);
+#endif
+
+	/* Setup smi control */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_GMCIF_CON,
+		     (1 <<  0) +
+		     (7 <<  4) + //burst type to 8
+		     (1 << 16),  //enable pre-ultra
+		     0x00030071);
+
+	/* Setup source frame info */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_CON, rdma->src_ctrl,
+		     0x03C8FE0F);
+#if RDMA_SUPPORT_10BIT
+	if (en_ufo) {
+		/* Setup source buffer base */
+		MM_REG_WRITE(cmd, subsys_id,
+			     base, MDP_RDMA_UFO_DEC_LENGTH_BASE_Y,
+			     rdma->ufo_dec_y, 0xFFFFFFFF);
+		MM_REG_WRITE(cmd, subsys_id,
+			     base, MDP_RDMA_UFO_DEC_LENGTH_BASE_C,
+			     rdma->ufo_dec_c, 0xFFFFFFFF);
+		/* Set 10bit source frame pitch */
+		if (block10bit)
+			MM_REG_WRITE(cmd, subsys_id,
+				     base, MDP_RDMA_MF_BKGD_SIZE_IN_PXL,
+				     rdma->mf_bkgd_in_pxl, 0x001FFFFF);
+	}
+#endif
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_CON, rdma->control,
+		     0x00001110);
+	/* Setup source buffer base */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_BASE_0, rdma->iova[0],
+		     0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_BASE_1, rdma->iova[1],
+		     0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_BASE_2, rdma->iova[2],
+		     0xFFFFFFFF);
+	/* Setup source buffer end */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_END_0,
+		     rdma->iova_end[0], 0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_END_1,
+		     rdma->iova_end[1], 0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_END_2,
+		     rdma->iova_end[2], 0xFFFFFFFF);
+	/* Setup source frame pitch */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_MF_BKGD_SIZE_IN_BYTE,
+		     rdma->mf_bkgd, 0x001FFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SF_BKGD_SIZE_IN_BYTE,
+		     rdma->sf_bkgd, 0x001FFFFF);
+	/* Setup color transform */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_TRANSFORM_0,
+		     rdma->transform, 0x0F110000);
+
+	return 0;
+}
+
+static int config_rdma_subfrm(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index)
+{
+	const struct mdp_rdma_subfrm *subfrm = &ctx->param->rdma.subfrms[index];
+	const struct img_comp_subfrm *csf = &ctx->param->subfrms[index];
+	u32 colorformat = ctx->input->buffer.format.colorformat;
+	bool block10bit = MDP_COLOR_IS_10BIT_PACKED(colorformat);
+	bool en_ufo = MDP_COLOR_IS_UFP(colorformat);
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	/* Enable RDMA */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_EN, 0x00000001,
+		     0x00000001);
+
+	/* Set Y pixel offset */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_OFFSET_0,
+		     subfrm->offset[0], 0xFFFFFFFF);
+#if RDMA_SUPPORT_10BIT
+	/* Set 10bit UFO mode */
+	if (block10bit && en_ufo)
+		MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_OFFSET_0_P,
+			     subfrm->offset_0_p, 0xFFFFFFFF);
+#endif
+	/* Set U pixel offset */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_OFFSET_1,
+		     subfrm->offset[1], 0xFFFFFFFF);
+	/* Set V pixel offset */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_OFFSET_2,
+		     subfrm->offset[2], 0xFFFFFFFF);
+	/* Set source size */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_MF_SRC_SIZE, subfrm->src,
+		     0x1FFF1FFF);
+	/* Set target size */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_MF_CLIP_SIZE,
+		     subfrm->clip, 0x1FFF1FFF);
+	/* Set crop offset */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_MF_OFFSET_1,
+		     subfrm->clip_ofst, 0x003F001F);
+
+#if RDMA_UPSAMPLE_REPEAT_ONLY
+	if ((csf->in.right - csf->in.left + 1) > 320)
+		MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_RESV_DUMMY_0,
+			     0x00000004, 0x00000004);
+#endif
+
+	return 0;
+}
+
+static int wait_rdma_event(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	if (ctx->comp->alias_id == 0)
+		MM_REG_WAIT(cmd, RDMA0_DONE);
+	else
+		pr_err("Do not support RDMA1_DONE event\n");
+
+	/* Disable RDMA */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_EN, 0x00000000,
+		     0x00000001);
+	return 0;
+}
+
+static const struct mdp_comp_ops rdma_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_rdma,
+	.config_frame = config_rdma_frame,
+	.config_subfrm = config_rdma_subfrm,
+	/* .reconfig_frame = reconfig_rdma_frame, */
+	/* .reconfig_subfrms = reconfig_rdma_subfrms, */
+	.wait_comp_event = wait_rdma_event,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
+static int init_rsz(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	/* Reset RSZ */
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_ENABLE, 0x00010000,
+		     0x00010000);
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_ENABLE, 0x00000000,
+		     0x00010000);
+	/* Enable RSZ */
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_ENABLE, 0x00000001,
+		     0x00000001);
+	return 0;
+}
+
+static int config_rsz_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			    const struct v4l2_rect *compose)
+{
+	const struct mdp_rsz_data *rsz = &ctx->param->rsz;
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	if (ctx->param->frame.bypass) {
+		/* Disable RSZ */
+		MM_REG_WRITE(cmd, subsys_id, base, PRZ_ENABLE, 0x00000000,
+			     0x00000001);
+		return 0;
+	}
+
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_1, rsz->control1,
+		     0x03FFFDF3);
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_2, rsz->control2,
+		     0x0FFFC290);
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_HORIZONTAL_COEFF_STEP,
+		     rsz->coeff_step_x, 0x007FFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_VERTICAL_COEFF_STEP,
+		     rsz->coeff_step_y, 0x007FFFFF);
+	return 0;
+}
+
+static int config_rsz_subfrm(struct mdp_comp_ctx *ctx,
+			     struct mdp_cmd *cmd, u32 index)
+{
+	const struct mdp_rsz_subfrm *subfrm = &ctx->param->rsz.subfrms[index];
+	const struct img_comp_subfrm *csf = &ctx->param->subfrms[index];
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_2, subfrm->control2,
+		     0x00003800);
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_INPUT_IMAGE, subfrm->src,
+		     0xFFFFFFFF);
+#if RSZ_DISABLE_DCM_SMALL_TILE
+	if ((csf->in.right - csf->in.left + 1) <= 16)
+		MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_1, 1 << 27,
+			     1 << 27);
+#endif
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_LUMA_HORIZONTAL_INTEGER_OFFSET,
+		     csf->luma.left, 0x0000FFFF);
+	MM_REG_WRITE(cmd, subsys_id,
+		     base, PRZ_LUMA_HORIZONTAL_SUBPIXEL_OFFSET,
+		     csf->luma.left_subpix, 0x001FFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_LUMA_VERTICAL_INTEGER_OFFSET,
+		     csf->luma.top, 0x0000FFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_LUMA_VERTICAL_SUBPIXEL_OFFSET,
+		     csf->luma.top_subpix, 0x001FFFFF);
+	MM_REG_WRITE(cmd, subsys_id,
+		     base, PRZ_CHROMA_HORIZONTAL_INTEGER_OFFSET,
+		     csf->chroma.left, 0x0000FFFF);
+	MM_REG_WRITE(cmd, subsys_id,
+		     base, PRZ_CHROMA_HORIZONTAL_SUBPIXEL_OFFSET,
+		     csf->chroma.left_subpix, 0x001FFFFF);
+
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_OUTPUT_IMAGE, subfrm->clip,
+		     0xFFFFFFFF);
+
+	return 0;
+}
+
+static int advance_rsz_subfrm(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index)
+{
+#if RSZ_DISABLE_DCM_SMALL_TILE
+	const struct img_comp_subfrm *csf = &ctx->param->subfrms[index];
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	if ((csf->in.right - csf->in.left + 1) <= 16)
+		MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_1, 0, 1 << 27);
+#endif
+	return 0;
+}
+
+static const struct mdp_comp_ops rsz_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_rsz,
+	.config_frame = config_rsz_frame,
+	.config_subfrm = config_rsz_subfrm,
+	/* .reconfig_frame = NULL, */
+	/* .reconfig_subfrms = NULL, */
+	.wait_comp_event = NULL,
+	.advance_subfrm = advance_rsz_subfrm,
+	.post_process = NULL,
+};
+
+static int init_wrot(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+#if WROT_FILTER_CONSTRAINT
+	/* Wait WROT SRAM shared to DISP RDMA */
+	if (ctx->comp->alias_id == 0)
+		pr_err("Do not support WROT0_SRAM_READY event\n");
+	else
+		pr_err("Do not support WROT1_SRAM_READY event\n");
+#endif
+	/* Reset WROT */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_SOFT_RST, 0x01, 0x00000001);
+	MM_REG_POLL(cmd, subsys_id, base, VIDO_SOFT_RST_STAT, 0x01,
+		    0x00000001);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_SOFT_RST, 0x00, 0x00000001);
+	MM_REG_POLL(cmd, subsys_id, base, VIDO_SOFT_RST_STAT, 0x00,
+		    0x00000001);
+	return 0;
+}
+
+static int config_wrot_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			     const struct v4l2_rect *compose)
+{
+	const struct mdp_wrot_data *wrot = &ctx->param->wrot;
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	/* Write frame base address */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR, wrot->iova[0],
+		     0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR_C, wrot->iova[1],
+		     0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR_V, wrot->iova[2],
+		     0xFFFFFFFF);
+	/* Write frame related registers */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_CTRL, wrot->control,
+		     0xF131510F);
+	/* Write frame Y pitch */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE, wrot->stride[0],
+		     0x0000FFFF);
+	/* Write frame UV pitch */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE_C, wrot->stride[1],
+		     0x0000FFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE_V, wrot->stride[2],
+		     0x0000FFFF);
+	/* Write matrix control */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAT_CTRL, wrot->mat_ctrl,
+		     0x000000F3);
+
+	/* Set the fixed ALPHA as 0xFF */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_DITHER, 0xFF000000,
+		     0xFF000000);
+	/* Set VIDO_EOL_SEL */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_RSV_1, 0x80000000,
+		     0x80000000);
+	/* Set VIDO_FIFO_TEST */
+	if (wrot->fifo_test != 0)
+		MM_REG_WRITE(cmd, subsys_id, base, VIDO_FIFO_TEST,
+			     wrot->fifo_test, 0x00000FFF);
+
+#if WROT_FILTER_CONSTRAINT
+	/* Filter enable */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE, wrot->filter,
+		     0x00000077);
+#endif
+
+	return 0;
+}
+
+static int config_wrot_subfrm(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index)
+{
+	const struct mdp_wrot_subfrm *subfrm = &ctx->param->wrot.subfrms[index];
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	/* Write Y pixel offset */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR,
+		     subfrm->offset[0], 0x0FFFFFFF);
+	/* Write U pixel offset */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR_C,
+		     subfrm->offset[1], 0x0FFFFFFF);
+	/* Write V pixel offset */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR_V,
+		     subfrm->offset[2], 0x0FFFFFFF);
+	/* Write source size */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_IN_SIZE, subfrm->src,
+		     0x1FFF1FFF);
+	/* Write target size */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_TAR_SIZE, subfrm->clip,
+		     0x1FFF1FFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_CROP_OFST, subfrm->clip_ofst,
+		     0x1FFF1FFF);
+
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE,
+		     subfrm->main_buf, 0x1FFF7F00);
+
+	/* Enable WROT */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_ROT_EN, 0x01, 0x00000001);
+
+	return 0;
+}
+
+static int wait_wrot_event(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	if (ctx->comp->alias_id == 0)
+		MM_REG_WAIT(cmd, WROT0_DONE);
+	else
+		pr_err("Do not support WROT1_DONE event\n");
+#if WROT_FILTER_CONSTRAINT
+	/* Filter disable */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE,
+		     (0 << 4) +
+		(0 << 0),
+		0x00000077);
+#endif
+	/* Disable WROT */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_ROT_EN, 0x00, 0x00000001);
+
+	return 0;
+}
+
+static const struct mdp_comp_ops wrot_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_wrot,
+	.config_frame = config_wrot_frame,
+	.config_subfrm = config_wrot_subfrm,
+	/* .reconfig_frame = reconfig_wrot_frame, */
+	/* .reconfig_subfrms = reconfig_wrot_subfrms, */
+	.wait_comp_event = wait_wrot_event,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
+static int init_wdma(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	/* Reset WDMA */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_RST, 0x1, 0x00000001);
+	MM_REG_POLL(cmd, subsys_id, base, WDMA_FLOW_CTRL_DBG, 0x01,
+		    0x00000001);
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_RST, 0x0, 0x00000001);
+	return 0;
+}
+
+static int config_wdma_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			     const struct v4l2_rect *compose)
+{
+	const struct mdp_wdma_data *wdma = &ctx->param->wdma;
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_BUF_CON2, 0x10101050,
+		     0xFFFFFFFF);
+
+	/* Setup frame information */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_CFG, wdma->wdma_cfg,
+		     0x0F01B8F0);
+	/* Setup frame base address */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_ADDR,   wdma->iova[0],
+		     0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_U_ADDR, wdma->iova[1],
+		     0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_V_ADDR, wdma->iova[2],
+		     0xFFFFFFFF);
+	/* Setup Y pitch */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_W_IN_BYTE,
+		     wdma->w_in_byte, 0x0000FFFF);
+	/* Setup UV pitch */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_UV_PITCH,
+		     wdma->uv_stride, 0x0000FFFF);
+	/* Set the fixed ALPHA as 0xFF */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_ALPHA, 0x800000FF,
+		     0x800000FF);
+
+	return 0;
+}
+
+static int config_wdma_subfrm(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index)
+{
+	const struct mdp_wdma_subfrm *subfrm = &ctx->param->wdma.subfrms[index];
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	/* Write Y pixel offset */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_ADDR_OFFSET,
+		     subfrm->offset[0], 0x0FFFFFFF);
+	/* Write U pixel offset */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_U_ADDR_OFFSET,
+		     subfrm->offset[1], 0x0FFFFFFF);
+	/* Write V pixel offset */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_V_ADDR_OFFSET,
+		     subfrm->offset[2], 0x0FFFFFFF);
+	/* Write source size */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_SRC_SIZE, subfrm->src,
+		     0x3FFF3FFF);
+	/* Write target size */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_CLIP_SIZE, subfrm->clip,
+		     0x3FFF3FFF);
+	/* Write clip offset */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_CLIP_COORD, subfrm->clip_ofst,
+		     0x3FFF3FFF);
+
+	/* Enable WDMA */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_EN, 0x01, 0x00000001);
+
+	return 0;
+}
+
+static int wait_wdma_event(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	MM_REG_WAIT(cmd, WDMA0_DONE);
+	/* Disable WDMA */
+	MM_REG_WRITE(cmd, subsys_id, base, WDMA_EN, 0x00, 0x00000001);
+	return 0;
+}
+
+static const struct mdp_comp_ops wdma_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_wdma,
+	.config_frame = config_wdma_frame,
+	.config_subfrm = config_wdma_subfrm,
+	/* .reconfig_frame = reconfig_wdma_frame, */
+	/* .reconfig_subfrms = reconfig_wdma_subfrms, */
+	.wait_comp_event = wait_wdma_event,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
+static int init_ccorr(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	/* CCORR enable */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_CCORR_EN, 0x1, 0x1);
+	/* Relay mode */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_CCORR_CFG, 0x1, 0x1);
+	return 0;
+}
+
+static int config_ccorr_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			      const struct v4l2_rect *compose)
+{
+	/* Disabled function */
+	return 0;
+}
+
+static int config_ccorr_subfrm(struct mdp_comp_ctx *ctx,
+			       struct mdp_cmd *cmd, u32 index)
+{
+	const struct img_comp_subfrm *csf = &ctx->param->subfrms[index];
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+	u32 hsize, vsize;
+
+	hsize = csf->in.right - csf->in.left + 1;
+	vsize = csf->in.bottom - csf->in.top + 1;
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_CCORR_SIZE,
+		     (hsize << 16) + (vsize <<  0), 0x1FFF1FFF);
+	return 0;
+}
+
+static const struct mdp_comp_ops ccorr_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_ccorr,
+	.config_frame = config_ccorr_frame,
+	.config_subfrm = config_ccorr_subfrm,
+	/* .reconfig_frame = NULL, */
+	/* .reconfig_subfrms = NULL, */
+	.wait_comp_event = NULL,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
+static int init_isp(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	const struct isp_data *isp = &ctx->param->isp;
+	phys_addr_t mmsys = ctx->comp->mdp_dev->mmsys.reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	/* Direct link */
+	if (isp->dl_flags & (1 << MDP_CAMIN)) {
+		mdp_dbg(2, "SW_RST ASYNC");
+		/* Reset MDP_DL_ASYNC_TX */
+		/* Bit  3: MDP_DL_ASYNC_TX / MDP_RELAY */
+		MM_REG_WRITE(cmd, subsys_id, mmsys, MMSYS_SW0_RST_B, 0x0,
+			     0x00000008);
+		MM_REG_WRITE(cmd, subsys_id, mmsys, MMSYS_SW0_RST_B, 1 << 3,
+			     0x00000008);
+		/* Reset MDP_DL_ASYNC_RX */
+		/* Bit  10: MDP_DL_ASYNC_RX */
+		MM_REG_WRITE(cmd, subsys_id, mmsys, MMSYS_SW1_RST_B, 0x0,
+			     0x00000400);
+		MM_REG_WRITE(cmd, subsys_id, mmsys, MMSYS_SW1_RST_B, 1 << 10,
+			     0x00000400);
+
+		/* Enable sof mode */
+		MM_REG_WRITE(cmd, subsys_id, mmsys, ISP_RELAY_CFG_WD, 0 << 31,
+			     0x80000000);
+	}
+
+	if (isp->dl_flags & (1 << MDP_CAMIN2)) {
+		mdp_dbg(2, "SW_RST ASYNC2");
+		/* Reset MDP_DL_ASYNC2_TX */
+		/* Bit  4: MDP_DL_ASYNC2_TX / MDP_RELAY2 */
+		MM_REG_WRITE(cmd, subsys_id, mmsys, MMSYS_SW0_RST_B, 0x0,
+			     0x00000010);
+		MM_REG_WRITE(cmd, subsys_id, mmsys, MMSYS_SW0_RST_B, 1 << 4,
+			     0x00000010);
+		/* Reset MDP_DL_ASYNC2_RX */
+		/* Bit  11: MDP_DL_ASYNC2_RX */
+		MM_REG_WRITE(cmd, subsys_id, mmsys, MMSYS_SW1_RST_B, 0x0,
+			     0x00000800);
+		MM_REG_WRITE(cmd, subsys_id, mmsys, MMSYS_SW1_RST_B, 1 << 11,
+			     0x00000800);
+
+		/* Enable sof mode */
+		MM_REG_WRITE(cmd, subsys_id, mmsys, IPU_RELAY_CFG_WD, 0 << 31,
+			     0x80000000);
+	}
+
+	return 0;
+}
+
+static int config_isp_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			    const struct v4l2_rect *compose)
+{
+	const struct isp_data *isp = &ctx->param->isp;
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	/* DIP_X_SMX1I_BASE_ADDR, DIP_X_SMX1O_BASE_ADDR */
+	MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2890, isp->smxi_iova[0],
+			  0xFFFFFFFF);
+	MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x27D0, isp->smxi_iova[0],
+			  0xFFFFFFFF);
+	/* DIP_X_SMX2I_BASE_ADDR, DIP_X_SMX2O_BASE_ADDR */
+	MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x28C0, isp->smxi_iova[1],
+			  0xFFFFFFFF);
+	MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2800, isp->smxi_iova[1],
+			  0xFFFFFFFF);
+	/* DIP_X_SMX3I_BASE_ADDR, DIP_X_SMX3O_BASE_ADDR */
+	MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x28F0, isp->smxi_iova[2],
+			  0xFFFFFFFF);
+	MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2830, isp->smxi_iova[2],
+			  0xFFFFFFFF);
+	/* DIP_X_SMX4I_BASE_ADDR, DIP_X_SMX4O_BASE_ADDR */
+	MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2920, isp->smxi_iova[3],
+			  0xFFFFFFFF);
+	MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2860, isp->smxi_iova[3],
+			  0xFFFFFFFF);
+
+	switch (isp->cq_idx) {
+	case ISP_DRV_DIP_CQ_THRE0:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2208,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE1:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2214,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE2:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2220,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE3:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x222C,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE4:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2238,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE5:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2244,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE6:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2250,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE7:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x225C,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE8:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2268,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE9:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2274,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE10:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2280,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE11:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x228C,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE12:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2298,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE13:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x22A4,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	case ISP_DRV_DIP_CQ_THRE14:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x22B0,
+				  isp->cq_iova, 0xFFFFFFFF);
+		break;
+	/* From CQ15 to CQ18, these do not connect to GCE */
+	default:
+		mdp_err("Do not support this cq (%d)", isp->cq_idx);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int config_isp_subfrm(struct mdp_comp_ctx *ctx,
+			     struct mdp_cmd *cmd, u32 index)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2304,
+			  ctx->param->isp.tpipe_iova[index], 0xFFFFFFFF);
+	return 0;
+}
+
+static int wait_isp_event(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	const struct isp_data *isp = &ctx->param->isp;
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+
+	/* MDP_DL_SEL: select MDP_CROP */
+	if (isp->dl_flags & (1 << MDP_CAMIN))
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x0030, 0x00000000,
+				  0x00000200);
+	/* MDP2_DL_SEL: select MDP_CROP2 */
+	if (isp->dl_flags & (1 << MDP_CAMIN2))
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x0030, 0x00000000,
+				  0x00000C00);
+
+	switch (isp->cq_idx) {
+	case ISP_DRV_DIP_CQ_THRE0:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0001,
+				  0x00000001);
+		MM_REG_WAIT(cmd, ISP_P2_0_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE1:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0002,
+				  0x00000002);
+		MM_REG_WAIT(cmd, ISP_P2_1_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE2:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0004,
+				  0x00000004);
+		MM_REG_WAIT(cmd, ISP_P2_2_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE3:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0008,
+				  0x00000008);
+		MM_REG_WAIT(cmd, ISP_P2_3_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE4:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0010,
+				  0x00000010);
+		MM_REG_WAIT(cmd, ISP_P2_4_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE5:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0020,
+				  0x00000020);
+		MM_REG_WAIT(cmd, ISP_P2_5_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE6:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0040,
+				  0x00000040);
+		MM_REG_WAIT(cmd, ISP_P2_6_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE7:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0080,
+				  0x00000080);
+		MM_REG_WAIT(cmd, ISP_P2_7_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE8:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0100,
+				  0x00000100);
+		MM_REG_WAIT(cmd, ISP_P2_8_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE9:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0200,
+				  0x00000200);
+		MM_REG_WAIT(cmd, ISP_P2_9_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE10:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0400,
+				  0x00000400);
+		MM_REG_WAIT(cmd, ISP_P2_10_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE11:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0800,
+				  0x00000800);
+		MM_REG_WAIT(cmd, ISP_P2_11_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE12:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x1000,
+				  0x00001000);
+		MM_REG_WAIT(cmd, ISP_P2_12_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE13:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x2000,
+				  0x00002000);
+		MM_REG_WAIT(cmd, ISP_P2_13_DONE);
+		break;
+	case ISP_DRV_DIP_CQ_THRE14:
+		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x4000,
+				  0x00004000);
+		MM_REG_WAIT(cmd, ISP_P2_14_DONE);
+		break;
+	/* From CQ15 to CQ18, these do not connect to GCE */
+	default:
+		mdp_err("Do not support this cq (%d)", isp->cq_idx);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct mdp_comp_ops imgi_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_isp,
+	.config_frame = config_isp_frame,
+	.config_subfrm = config_isp_subfrm,
+	/* .reconfig_frame = reconfig_isp_frame, */
+	/* .reconfig_subfrms = reconfig_isp_subfrms, */
+	.wait_comp_event = wait_isp_event,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
+static int config_camin_subfrm(struct mdp_comp_ctx *ctx,
+			       struct mdp_cmd *cmd, u32 index)
+{
+	const struct img_comp_subfrm *csf = &ctx->param->subfrms[index];
+	phys_addr_t base = ctx->comp->reg_base;
+	u8 subsys_id = ctx->comp->subsys_id;
+	u32 isp_dl_w, isp_dl_h;
+
+	isp_dl_w = csf->in.right - csf->in.left + 1;
+	isp_dl_h = csf->in.bottom - csf->in.top + 1;
+
+	/* Config for direct link */
+	if (ctx->comp->alias_id == 0) {
+#ifdef MDP_ASYNC_CFG_WD
+		MM_REG_WRITE(cmd, subsys_id, base, MDP_ASYNC_CFG_WD,
+			     (isp_dl_h << 16) + isp_dl_w, 0x3FFF3FFF);
+#endif
+#ifdef ISP_RELAY_CFG_WD
+		MM_REG_WRITE(cmd, subsys_id, base, ISP_RELAY_CFG_WD,
+			     (isp_dl_h << 16) + isp_dl_w, 0x3FFF3FFF);
+#endif
+	} else {
+#ifdef MDP_ASYNC_IPU_CFG_WD
+		MM_REG_WRITE(cmd, subsys_id, base, MDP_ASYNC_IPU_CFG_WD,
+			     (isp_dl_h << 16) + isp_dl_w, 0x3FFF3FFF);
+#endif
+#ifdef IPU_RELAY_CFG_WD
+		MM_REG_WRITE(cmd, subsys_id, base, IPU_RELAY_CFG_WD,
+			     (isp_dl_h << 16) + isp_dl_w, 0x3FFF3FFF);
+#endif
+	}
+
+	return 0;
+}
+
+static const struct mdp_comp_ops camin_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = NULL,
+	.config_frame = NULL,
+	.config_subfrm = config_camin_subfrm,
+	/* .reconfig_frame = NULL, */
+	/* .reconfig_subfrms = NULL, */
+	.wait_comp_event = NULL,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
+static const struct mdp_comp_ops *mdp_comp_ops[MDP_COMP_TYPE_COUNT] = {
+	[MDP_COMP_TYPE_RDMA] =		&rdma_ops,
+	[MDP_COMP_TYPE_RSZ] =		&rsz_ops,
+	[MDP_COMP_TYPE_WROT] =		&wrot_ops,
+	[MDP_COMP_TYPE_WDMA] =		&wdma_ops,
+	[MDP_COMP_TYPE_PATH] =		NULL,
+
+	[MDP_COMP_TYPE_CCORR] =		&ccorr_ops,
+
+	[MDP_COMP_TYPE_IMGI] =		&imgi_ops,
+	[MDP_COMP_TYPE_EXTO] =		NULL,
+	[MDP_COMP_TYPE_DL_PATH] =	&camin_ops,
+};
+
+struct mdp_comp_match {
+	enum mdp_comp_type	type;
+	u32			alias_id;
+};
+
+static const struct mdp_comp_match mdp_comp_matches[MDP_MAX_COMP_COUNT] = {
+	[MDP_COMP_WPEI] =	{ MDP_COMP_TYPE_WPEI, 0 },
+	[MDP_COMP_WPEO] =	{ MDP_COMP_TYPE_EXTO, 2 },
+	[MDP_COMP_WPEI2] =	{ MDP_COMP_TYPE_WPEI, 1 },
+	[MDP_COMP_WPEO2] =	{ MDP_COMP_TYPE_EXTO, 3 },
+	[MDP_COMP_ISP_IMGI] =	{ MDP_COMP_TYPE_IMGI, 0 },
+	[MDP_COMP_ISP_IMGO] =	{ MDP_COMP_TYPE_EXTO, 0 },
+	[MDP_COMP_ISP_IMG2O] =	{ MDP_COMP_TYPE_EXTO, 1 },
+
+	[MDP_COMP_CAMIN] =	{ MDP_COMP_TYPE_DL_PATH, 0 },
+	[MDP_COMP_CAMIN2] =	{ MDP_COMP_TYPE_DL_PATH, 1 },
+	[MDP_COMP_RDMA0] =	{ MDP_COMP_TYPE_RDMA, 0 },
+	[MDP_COMP_CCORR0] =	{ MDP_COMP_TYPE_CCORR, 0 },
+	[MDP_COMP_RSZ0] =	{ MDP_COMP_TYPE_RSZ, 0 },
+	[MDP_COMP_RSZ1] =	{ MDP_COMP_TYPE_RSZ, 1 },
+	[MDP_COMP_PATH0_SOUT] =	{ MDP_COMP_TYPE_PATH, 0 },
+	[MDP_COMP_PATH1_SOUT] =	{ MDP_COMP_TYPE_PATH, 1 },
+	[MDP_COMP_WROT0] =	{ MDP_COMP_TYPE_WROT, 0 },
+	[MDP_COMP_WDMA] =	{ MDP_COMP_TYPE_WDMA, 0 },
+};
+
+static const char * const gce_event_names[MDP_MAX_EVENT_COUNT] = {
+	[RDMA0_SOF] = "rdma0_sof",
+	[RDMA0_DONE] = "rdma0_done",
+	[RSZ0_SOF] = "rsz0_sof",
+	[RSZ1_SOF] = "rsz1_sof",
+	[TDSHP0_SOF] = "tdshp0_sof",
+	[WROT0_SOF] = "wrot0_sof",
+	[WROT0_DONE] = "wrot0_done",
+	[WDMA0_SOF] = "wdma0_sof",
+	[WDMA0_DONE] = "wdma0_done",
+
+	[ISP_P2_0_DONE] = "isp_p2_0_done",
+	[ISP_P2_1_DONE] = "isp_p2_1_done",
+	[ISP_P2_2_DONE] = "isp_p2_2_done",
+	[ISP_P2_3_DONE] = "isp_p2_3_done",
+	[ISP_P2_4_DONE] = "isp_p2_4_done",
+	[ISP_P2_5_DONE] = "isp_p2_5_done",
+	[ISP_P2_6_DONE] = "isp_p2_6_done",
+	[ISP_P2_7_DONE] = "isp_p2_7_done",
+	[ISP_P2_8_DONE] = "isp_p2_8_done",
+	[ISP_P2_9_DONE] = "isp_p2_9_done",
+	[ISP_P2_10_DONE] = "isp_p2_10_done",
+	[ISP_P2_11_DONE] = "isp_p2_11_done",
+	[ISP_P2_12_DONE] = "isp_p2_12_done",
+	[ISP_P2_13_DONE] = "isp_p2_13_done",
+	[ISP_P2_14_DONE] = "isp_p2_14_done",
+
+	[WPE_DONE] = "wpe_done",
+	[WPE_B_DONE] = "wpe_b_done",
+};
+
+static const struct of_device_id mdp_comp_dt_ids[] = {
+	{
+		.compatible = "mediatek,mt8183-mdp-rdma",
+		.data = (void *)MDP_COMP_TYPE_RDMA,
+	}, {
+		.compatible = "mediatek,mt8183-mdp-ccorr",
+		.data = (void *)MDP_COMP_TYPE_CCORR,
+	}, {
+		.compatible = "mediatek,mt8183-mdp-rsz",
+		.data = (void *)MDP_COMP_TYPE_RSZ,
+	}, {
+		.compatible = "mediatek,mt8183-mdp-wrot",
+		.data = (void *)MDP_COMP_TYPE_WROT,
+	}, {
+		.compatible = "mediatek,mt8183-mdp-wdma",
+		.data = (void *)MDP_COMP_TYPE_WDMA,
+	}, {
+		.compatible = "mediatek,mt8183-mdp-path",
+		.data = (void *)MDP_COMP_TYPE_PATH,
+	}, {
+		.compatible = "mediatek,mt8183-mdp-imgi",
+		.data = (void *)MDP_COMP_TYPE_IMGI,
+	}, {
+		.compatible = "mediatek,mt8183-mdp-exto",
+		.data = (void *)MDP_COMP_TYPE_EXTO,
+	}, {
+		.compatible = "mediatek,mt8183-mdp-dl",
+		.data = (void *)MDP_COMP_TYPE_DL_PATH,
+	},
+};
+
+static int mdp_comp_get_id(struct device *dev, struct device_node *node,
+			   enum mdp_comp_type type)
+{
+	u32 alias_id;
+	int i, ret;
+
+	ret = of_property_read_u32(node, "mediatek,mdp-id", &alias_id);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < ARRAY_SIZE(mdp_comp_matches); i++)
+		if (mdp_comp_matches[i].type == type &&
+		    mdp_comp_matches[i].alias_id == alias_id)
+			return i;
+
+	dev_err(dev, "Failed to get id. type: %d, alias: %d\n", type, alias_id);
+	return -EINVAL;
+}
+
+void mdp_comp_clock_on(struct device *dev, struct mdp_comp *comp)
+{
+	int i, err;
+
+	if (comp->larb_dev) {
+		err = pm_runtime_get_sync(comp->larb_dev);
+		if (err < 0)
+			dev_err(dev,
+				"Failed to get larb, err %d. type:%d id:%d\n",
+				err, comp->type, comp->id);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(comp->clks); i++) {
+		if (IS_ERR(comp->clks[i]))
+			break;
+		err = clk_prepare_enable(comp->clks[i]);
+		if (err)
+			dev_err(dev,
+				"Failed to enable clock %d, err %d. type:%d id:%d\n",
+				i, err, comp->type, comp->id);
+	}
+}
+
+void mdp_comp_clock_off(struct device *dev, struct mdp_comp *comp)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(comp->clks); i++) {
+		if (IS_ERR(comp->clks[i]))
+			break;
+		clk_disable_unprepare(comp->clks[i]);
+	}
+
+	if (comp->larb_dev)
+		pm_runtime_put_sync(comp->larb_dev);
+}
+
+static int mdp_get_subsys_id(struct device *dev, struct device_node *node,
+			     struct mdp_comp *comp)
+{
+	struct platform_device *comp_pdev;
+	struct cmdq_client_reg  *cmdq_reg;
+	int ret = 0;
+
+	if (!dev || !node || !comp)
+		return -EINVAL;
+
+	comp_pdev = of_find_device_by_node(node);
+
+	if (!comp_pdev) {
+		dev_err(dev, "get comp_pdev fail! comp id=%d type=%d\n",
+			comp->id, comp->type);
+		return -ENODEV;
+	}
+
+	cmdq_reg = kzalloc(sizeof(*cmdq_reg), GFP_KERNEL);
+	if (!cmdq_reg) {
+		dev_err(&comp_pdev->dev, "cmdq_reg kzalloc fail!\n");
+		return -EINVAL;
+	}
+
+	ret = cmdq_dev_get_client_reg(&comp_pdev->dev, cmdq_reg, 0);
+	if (ret != 0) {
+		dev_err(&comp_pdev->dev,
+			"cmdq_dev_get_subsys fail!\n");
+		kfree(cmdq_reg);
+		return -EINVAL;
+	}
+
+	comp->subsys_id = cmdq_reg->subsys;
+	dev_err(&comp_pdev->dev, "subsys id=%d\n", cmdq_reg->subsys);
+
+	kfree(cmdq_reg);
+
+	return 0;
+}
+
+static void __mdp_comp_init(struct mdp_dev *mdp, struct device_node *node,
+			    struct mdp_comp *comp)
+{
+	struct resource res;
+	phys_addr_t base;
+
+	if (of_address_to_resource(node, 0, &res) < 0)
+		base = 0L;
+	else
+		base = 0L | res.start;
+
+	comp->mdp_dev = mdp;
+	/* comp->dev_node = of_node_get(node); */
+	comp->regs = of_iomap(node, 0);
+	comp->reg_base = base;
+}
+
+static int mdp_mm_init(struct device *dev, struct mdp_dev *mdp,
+		       struct mdp_comp *comp, const char *ref_name)
+{
+	struct device_node *node;
+
+	node = of_parse_phandle(dev->of_node, ref_name, 0);
+	if (!node) {
+		dev_err(dev, "Failed to parse dt %s\n", ref_name);
+		return -EINVAL;
+	}
+
+	__mdp_comp_init(mdp, node, comp);
+	mdp_get_subsys_id(dev, node, comp);
+	of_node_put(node);
+	if (!comp->reg_base) {
+		dev_err(dev, "Failed to init %s base\n", ref_name);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int mdp_comp_init(struct device *dev, struct mdp_dev *mdp,
+			 struct device_node *node, struct mdp_comp *comp,
+			 enum mdp_comp_id id)
+{
+	struct device_node *larb_node;
+	struct platform_device *larb_pdev;
+	int i;
+
+	if (id < 0 || id >= MDP_MAX_COMP_COUNT) {
+		dev_err(dev, "Invalid component id %d\n", id);
+		return -EINVAL;
+	}
+
+	__mdp_comp_init(mdp, node, comp);
+	comp->type = mdp_comp_matches[id].type;
+	comp->id = id;
+	comp->alias_id = mdp_comp_matches[id].alias_id;
+	comp->ops = mdp_comp_ops[comp->type];
+
+	for (i = 0; i < ARRAY_SIZE(comp->clks); i++) {
+		comp->clks[i] = of_clk_get(node, i);
+		if (IS_ERR(comp->clks[i]))
+			break;
+	}
+
+	mdp_get_subsys_id(dev, node, comp);
+
+	/* Only DMA capable components need the LARB property */
+	comp->larb_dev = NULL;
+	if (comp->type != MDP_COMP_TYPE_RDMA &&
+	    comp->type != MDP_COMP_TYPE_WROT &&
+		comp->type != MDP_COMP_TYPE_WDMA)
+		return 0;
+
+	larb_node = of_parse_phandle(node, "mediatek,larb", 0);
+	if (!larb_node) {
+		dev_err(dev, "Missing mediatek,larb phandle in %pOF node\n",
+			node);
+		return -EINVAL;
+	}
+
+	larb_pdev = of_find_device_by_node(larb_node);
+	if (!larb_pdev) {
+		dev_warn(dev, "Waiting for larb device %pOF\n", larb_node);
+		of_node_put(larb_node);
+		return -EPROBE_DEFER;
+	}
+	of_node_put(larb_node);
+
+	comp->larb_dev = &larb_pdev->dev;
+
+	return 0;
+}
+
+static void mdp_comp_deinit(struct device *dev, struct mdp_comp *comp)
+{
+	iounmap(comp->regs);
+	/* of_node_put(comp->dev_node); */
+}
+
+void mdp_component_deinit(struct device *dev, struct mdp_dev *mdp)
+{
+	int i;
+
+	mdp_comp_deinit(dev, &mdp->mmsys);
+	mdp_comp_deinit(dev, &mdp->mm_mutex);
+	for (i = 0; i < ARRAY_SIZE(mdp->comp); i++) {
+		if (mdp->comp[i]) {
+			mdp_comp_deinit(dev, mdp->comp[i]);
+			kfree(mdp->comp[i]);
+		}
+	}
+}
+
+int mdp_component_init(struct device *dev, struct mdp_dev *mdp)
+{
+	struct device_node *node, *parent;
+	int i, ret;
+
+	for (i = RDMA0_SOF; i < MDP_MAX_EVENT_COUNT; i++) {
+		s32 event_id;
+
+		if (!dev)
+			return -EINVAL;
+		if (of_property_read_u32_index(dev->of_node,
+					       "mediatek,gce-events",
+					       i, &event_id)) {
+			dev_err(dev, "can't parse gce-events property");
+
+			return -ENODEV;
+		}
+		mdp->event[i] = (event_id < 0) ? -i : event_id;
+		dev_info(dev, "Get event %s id:%d\n",
+			 gce_event_names[i], mdp->event[i]);
+	}
+
+	ret = mdp_mm_init(dev, mdp, &mdp->mmsys, "mediatek,mmsys");
+	if (ret)
+		goto err_init_mm;
+
+	ret = mdp_mm_init(dev, mdp, &mdp->mm_mutex, "mediatek,mm-mutex");
+	if (ret)
+		goto err_init_mm;
+
+	parent = dev->of_node->parent;
+	/* Iterate over sibling MDP function blocks */
+	for_each_child_of_node(parent, node) {
+		const struct of_device_id *of_id;
+		enum mdp_comp_type type;
+		int id;
+		struct mdp_comp *comp;
+
+		of_id = of_match_node(mdp_comp_dt_ids, node);
+		if (!of_id)
+			continue;
+
+		if (!of_device_is_available(node)) {
+			dev_err(dev, "Skipping disabled component %pOF\n",
+				node);
+			continue;
+		}
+
+		type = (enum mdp_comp_type)of_id->data;
+		id = mdp_comp_get_id(dev, node, type);
+		if (id < 0) {
+			dev_warn(dev, "Skipping unknown component %pOF\n",
+				 node);
+			continue;
+		}
+
+		comp = devm_kzalloc(dev, sizeof(*comp), GFP_KERNEL);
+		if (!comp) {
+			ret = -ENOMEM;
+			goto err_init_comps;
+		}
+		mdp->comp[id] = comp;
+
+		ret = mdp_comp_init(dev, mdp, node, comp, id);
+		if (ret)
+			goto err_init_comps;
+
+		dev_info(dev, "%s type:%d alias:%d id:%d base:%#x regs:%p\n",
+			 of_id->compatible, type, comp->alias_id, id,
+			(u32)comp->reg_base, comp->regs);
+	}
+	return 0;
+
+err_init_comps:
+	mdp_component_deinit(dev, mdp);
+err_init_mm:
+	return ret;
+}
+
+int mdp_comp_ctx_init(struct mdp_dev *mdp, struct mdp_comp_ctx *ctx,
+		      const struct img_compparam *param,
+	const struct img_ipi_frameparam *frame)
+{
+	int i;
+
+	if (param->type < 0 || param->type >= MDP_MAX_COMP_COUNT) {
+		mdp_err("Invalid component id %d", param->type);
+		return -EINVAL;
+	}
+
+	ctx->comp = mdp->comp[param->type];
+	if (!ctx->comp) {
+		mdp_err("Uninit component id %d", param->type);
+		return -EINVAL;
+	}
+
+	ctx->param = param;
+	ctx->input = &frame->inputs[param->input];
+	for (i = 0; i < param->num_outputs; i++)
+		ctx->outputs[i] = &frame->outputs[param->outputs[i]];
+	return 0;
+}
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.h b/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.h
new file mode 100644
index 000000000000..18cafcb925ed
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.h
@@ -0,0 +1,170 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_MDP3_COMP_H__
+#define __MTK_MDP3_COMP_H__
+
+#include "mtk-mdp3-cmdq.h"
+
+enum mdp_comp_type {
+	MDP_COMP_TYPE_INVALID = 0,
+
+	MDP_COMP_TYPE_RDMA,
+	MDP_COMP_TYPE_RSZ,
+	MDP_COMP_TYPE_WROT,
+	MDP_COMP_TYPE_WDMA,
+	MDP_COMP_TYPE_PATH,
+
+	MDP_COMP_TYPE_TDSHP,
+	MDP_COMP_TYPE_COLOR,
+	MDP_COMP_TYPE_DRE,
+	MDP_COMP_TYPE_CCORR,
+	MDP_COMP_TYPE_HDR,
+
+	MDP_COMP_TYPE_IMGI,
+	MDP_COMP_TYPE_WPEI,
+	MDP_COMP_TYPE_EXTO,	/* External path */
+	MDP_COMP_TYPE_DL_PATH,	/* Direct-link path */
+
+	MDP_COMP_TYPE_COUNT	/* ALWAYS keep at the end */
+};
+
+enum mdp_comp_id {
+	MDP_COMP_NONE = -1,	/* Invalid engine */
+
+	/* ISP */
+	MDP_COMP_WPEI = 0,
+	MDP_COMP_WPEO,		/* 1 */
+	MDP_COMP_WPEI2,		/* 2 */
+	MDP_COMP_WPEO2,		/* 3 */
+	MDP_COMP_ISP_IMGI,	/* 4 */
+	MDP_COMP_ISP_IMGO,	/* 5 */
+	MDP_COMP_ISP_IMG2O,	/* 6 */
+
+	/* IPU */
+	MDP_COMP_IPUI,		/* 7 */
+	MDP_COMP_IPUO,		/* 8 */
+
+	/* MDP */
+	MDP_COMP_CAMIN,		/* 9 */
+	MDP_COMP_CAMIN2,	/* 10 */
+	MDP_COMP_RDMA0,		/* 11 */
+	MDP_COMP_AAL0,		/* 12 */
+	MDP_COMP_CCORR0,	/* 13 */
+	MDP_COMP_RSZ0,		/* 14 */
+	MDP_COMP_RSZ1,		/* 15 */
+	MDP_COMP_TDSHP0,	/* 16 */
+	MDP_COMP_COLOR0,	/* 17 */
+	MDP_COMP_PATH0_SOUT,	/* 18 */
+	MDP_COMP_PATH1_SOUT,	/* 19 */
+	MDP_COMP_WROT0,		/* 20 */
+	MDP_COMP_WDMA,		/* 21 */
+
+	/* Dummy Engine */
+	MDP_COMP_RDMA1,		/* 22 */
+	MDP_COMP_RSZ2,		/* 23 */
+	MDP_COMP_TDSHP1,	/* 24 */
+	MDP_COMP_WROT1,		/* 25 */
+
+	MDP_MAX_COMP_COUNT	/* ALWAYS keep at the end */
+};
+
+enum mdp_comp_event {
+	RDMA0_SOF,
+	RDMA0_DONE,
+	RSZ0_SOF,
+	RSZ1_SOF,
+	TDSHP0_SOF,
+	WROT0_SOF,
+	WROT0_DONE,
+	WDMA0_SOF,
+	WDMA0_DONE,
+
+	ISP_P2_0_DONE,
+	ISP_P2_1_DONE,
+	ISP_P2_2_DONE,
+	ISP_P2_3_DONE,
+	ISP_P2_4_DONE,
+	ISP_P2_5_DONE,
+	ISP_P2_6_DONE,
+	ISP_P2_7_DONE,
+	ISP_P2_8_DONE,
+	ISP_P2_9_DONE,
+	ISP_P2_10_DONE,
+	ISP_P2_11_DONE,
+	ISP_P2_12_DONE,
+	ISP_P2_13_DONE,
+	ISP_P2_14_DONE,
+
+	WPE_DONE,
+	WPE_B_DONE,
+
+	MDP_MAX_EVENT_COUNT	/* ALWAYS keep at the end */
+};
+
+struct mdp_comp_ops;
+
+struct mdp_comp {
+	struct mdp_dev		*mdp_dev;
+	/* struct device_node	*dev_node; */
+	void __iomem		*regs;
+	phys_addr_t		reg_base;
+	u8			subsys_id;
+	struct clk		*clks[2];
+	struct device		*larb_dev;
+	enum mdp_comp_type	type;
+	enum mdp_comp_id	id;
+	u32			alias_id;
+	const struct mdp_comp_ops *ops;
+};
+
+struct mdp_comp_ctx {
+	struct mdp_comp			*comp;
+	const struct img_compparam	*param;
+	const struct img_input		*input;
+	const struct img_output		*outputs[IMG_MAX_HW_OUTPUTS];
+};
+
+struct mdp_comp_ops {
+	s64 (*get_comp_flag)(const struct mdp_comp_ctx *ctx);
+	/* s64 (*query_feature)(void); */
+	int (*init_comp)(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd);
+	int (*config_frame)(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			    const struct v4l2_rect *compose);
+	/* int (*config_frame_end)(struct mdp_comp_ctx *ctx,
+	 *      struct mdp_cmd *cmd);
+	 */
+	int (*config_subfrm)(struct mdp_comp_ctx *ctx,
+			     struct mdp_cmd *cmd, u32 index);
+	int (*wait_comp_event)(struct mdp_comp_ctx *ctx,
+			       struct mdp_cmd *cmd);
+	int (*advance_subfrm)(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index);
+	int (*post_process)(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd);
+	/* void (*release)(struct mdp_comp_ctx *ctx); */
+};
+
+struct mdp_dev;
+
+int mdp_component_init(struct device *dev, struct mdp_dev *mdp);
+void mdp_component_deinit(struct device *dev, struct mdp_dev *mdp);
+void mdp_comp_clock_on(struct device *dev, struct mdp_comp *comp);
+void mdp_comp_clock_off(struct device *dev, struct mdp_comp *comp);
+int mdp_comp_ctx_init(struct mdp_dev *mdp, struct mdp_comp_ctx *ctx,
+		      const struct img_compparam *param,
+	const struct img_ipi_frameparam *frame);
+
+#endif  /* __MTK_MDP3_COMP_H__ */
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.c
new file mode 100644
index 000000000000..c1a242493297
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.c
@@ -0,0 +1,295 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include <linux/platform_data/mtk_scp.h>
+#include <media/videobuf2-dma-contig.h>
+#include "mtk-mdp3-core.h"
+#ifdef MDP_DEBUG
+#include "mtk-mdp3-debug.h"
+#endif
+#include "mtk-mdp3-m2m.h"
+
+
+/* MDP debug log level (0-3). 3 shows all the logs. */
+int mtk_mdp_debug;
+EXPORT_SYMBOL(mtk_mdp_debug);
+module_param_named(debug, mtk_mdp_debug, int, 0644);
+
+static const struct of_device_id mdp_of_ids[] = {
+	{ .compatible = "mediatek,mt8183-mdp3", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mdp_of_ids);
+
+#ifdef MDP_UT
+extern ssize_t mdp_ut_run(struct device *dev, struct device_attribute *attr,
+			  char *buf);
+
+ssize_t ut_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	return mdp_ut_run(dev, attr, buf);
+}
+
+static DEVICE_ATTR_RO(ut);
+#endif
+
+struct platform_device *mdp_get_plat_device(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *mdp_node;
+	struct platform_device *mdp_pdev;
+
+	mdp_node = of_parse_phandle(dev->of_node, "mediatek,mdp3", 0);
+	if (!mdp_node) {
+		dev_err(dev, "can't get mdp node\n");
+		return NULL;
+	}
+
+	mdp_pdev = of_find_device_by_node(mdp_node);
+	if (WARN_ON(!mdp_pdev)) {
+		dev_err(dev, "mdp pdev failed\n");
+		of_node_put(mdp_node);
+		return NULL;
+	}
+
+	return mdp_pdev;
+}
+EXPORT_SYMBOL_GPL(mdp_get_plat_device);
+
+int mdp_vpu_get_locked(struct mdp_dev *mdp)
+{
+	int ret = 0;
+
+	if (mdp->vpu_count++ == 0) {
+		ret = rproc_boot(mdp->rproc_handle);
+		if (ret < 0) {
+			dev_err(&mdp->pdev->dev,
+				"vpu_load_firmware failed %d\n", ret);
+			goto err_load_vpu;
+		}
+		ret = mdp_vpu_register(mdp->vpu_dev);
+		if (ret < 0) {
+			dev_err(&mdp->pdev->dev,
+				"mdp_vpu register failed %d\n", ret);
+			goto err_reg_vpu;
+		}
+		ret = mdp_vpu_dev_init(&mdp->vpu, mdp->vpu_dev, &mdp->vpu_lock);
+		if (ret) {
+			dev_err(&mdp->pdev->dev,
+				"mdp_vpu device init failed %d\n", ret);
+			goto err_init_vpu;
+		}
+	}
+	return 0;
+
+err_init_vpu:
+	mdp_vpu_unregister(mdp->vpu_dev);
+err_reg_vpu:
+err_load_vpu:
+	mdp->vpu_count--;
+	return ret;
+}
+
+void mdp_vpu_put_locked(struct mdp_dev *mdp)
+{
+	if (--mdp->vpu_count == 0) {
+		mdp_vpu_dev_deinit(&mdp->vpu);
+		mdp_vpu_unregister(mdp->vpu_dev);
+	}
+}
+
+static int mdp_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mdp_dev *mdp;
+	phandle rproc_phandle;
+	int ret;
+
+	mdp = devm_kzalloc(dev, sizeof(*mdp), GFP_KERNEL);
+	if (!mdp)
+		return -ENOMEM;
+
+	mdp->pdev = pdev;
+	ret = mdp_component_init(dev, mdp);
+	if (ret) {
+		dev_err(dev, "Failed to initialize mdp components\n");
+		goto err_init_comp;
+	}
+
+	mdp->job_wq = create_singlethread_workqueue(MDP_MODULE_NAME);
+	if (!mdp->job_wq) {
+		dev_err(dev, "Unable to create job workqueue\n");
+		ret = -ENOMEM;
+		goto err_create_job_wq;
+	}
+
+	mdp->clock_wq = create_singlethread_workqueue(MDP_MODULE_NAME"-clock");
+	if (!mdp->clock_wq) {
+		dev_err(dev, "Unable to create clock workqueue\n");
+		ret = -ENOMEM;
+		goto err_create_clock_wq;
+	}
+
+	mdp->vpu_dev = scp_get_pdev(pdev);
+
+	if (of_property_read_u32(pdev->dev.of_node, "mediatek,scp",
+				 &rproc_phandle))
+		dev_err(&pdev->dev, "Could not get scp device\n");
+	else
+		dev_info(&pdev->dev, "Find mediatek,scp phandle:%llx\n",
+			 (unsigned long long)rproc_phandle);
+
+	mdp->rproc_handle = rproc_get_by_phandle(rproc_phandle);
+
+	dev_info(&pdev->dev, "MDP rproc_handle: %llx",
+		 (unsigned long long)mdp->rproc_handle);
+
+	if (!mdp->rproc_handle)
+		dev_err(&pdev->dev, "Could not get MDP's rproc_handle\n");
+
+	/* vpu_wdt_reg_handler(mdp->vpu_dev, mdp_reset_handler, mdp,
+	 *		       VPU_RST_MDP);
+	 */
+	mutex_init(&mdp->vpu_lock);
+	mdp->vpu_count = 0;
+	mdp->id_count = 0;
+
+	mdp->cmdq_clt = cmdq_mbox_create(dev, 0, 1200);
+	if (IS_ERR(mdp->cmdq_clt))
+		goto err_mbox_create;
+
+	ret = v4l2_device_register(dev, &mdp->v4l2_dev);
+	if (ret) {
+		dev_err(dev, "Failed to register v4l2 device\n");
+		ret = -EINVAL;
+		goto err_v4l2_register;
+	}
+
+	ret = mdp_m2m_device_register(mdp);
+	if (ret) {
+		v4l2_err(&mdp->v4l2_dev, "Failed to register m2m device\n");
+		goto err_m2m_register;
+	}
+	mutex_init(&mdp->m2m_lock);
+
+	platform_set_drvdata(pdev, mdp);
+
+#ifdef MDP_DEBUG
+	mdp_debug_init(pdev);
+#endif
+
+	vb2_dma_contig_set_max_seg_size(&pdev->dev, DMA_BIT_MASK(32));
+	pm_runtime_enable(dev);
+	dev_dbg(dev, "mdp-%d registered successfully\n", pdev->id);
+#ifdef MDP_UT
+	device_create_file(&pdev->dev, &dev_attr_ut);
+#endif
+	return 0;
+
+err_m2m_register:
+	v4l2_device_unregister(&mdp->v4l2_dev);
+err_v4l2_register:
+err_mbox_create:
+err_create_clock_wq:
+	destroy_workqueue(mdp->clock_wq);
+err_create_job_wq:
+	destroy_workqueue(mdp->job_wq);
+err_init_comp:
+	kfree(mdp);
+
+	dev_dbg(dev, "Errno %d\n", ret);
+	return ret;
+}
+
+static int mdp_remove(struct platform_device *pdev)
+{
+	struct mdp_dev *mdp = platform_get_drvdata(pdev);
+
+	pm_runtime_disable(&pdev->dev);
+	vb2_dma_contig_clear_max_seg_size(&pdev->dev);
+	mdp_m2m_device_unregister(mdp);
+	v4l2_device_unregister(&mdp->v4l2_dev);
+
+	flush_workqueue(mdp->job_wq);
+	destroy_workqueue(mdp->job_wq);
+
+	flush_workqueue(mdp->clock_wq);
+	destroy_workqueue(mdp->clock_wq);
+
+	mdp_component_deinit(&pdev->dev, mdp);
+	kfree(mdp);
+
+	dev_dbg(&pdev->dev, "%s driver unloaded\n", pdev->name);
+#ifdef MDP_UT
+	device_remove_file(&pdev->dev, &dev_attr_ut);
+#endif
+	return 0;
+}
+
+static int __maybe_unused mdp_pm_suspend(struct device *dev)
+{
+	// TODO: mdp clock off
+	return 0;
+}
+
+static int __maybe_unused mdp_pm_resume(struct device *dev)
+{
+	// TODO: mdp clock on
+	return 0;
+}
+
+static int __maybe_unused mdp_suspend(struct device *dev)
+{
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	return mdp_pm_suspend(dev);
+}
+
+static int __maybe_unused mdp_resume(struct device *dev)
+{
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	return mdp_pm_resume(dev);
+}
+
+static const struct dev_pm_ops mdp_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mdp_suspend, mdp_resume)
+	SET_RUNTIME_PM_OPS(mdp_pm_suspend, mdp_pm_resume, NULL)
+};
+
+static struct platform_driver mdp_driver = {
+	.probe		= mdp_probe,
+	.remove		= mdp_remove,
+	.driver = {
+		.name	= MDP_MODULE_NAME,
+		.pm	= &mdp_pm_ops,
+		.of_match_table = mdp_of_ids,
+	},
+};
+
+module_platform_driver(mdp_driver);
+
+MODULE_AUTHOR("Ping-Hsun Wu <ping-hsun.wu@mediatek.com>");
+MODULE_DESCRIPTION("Mediatek image processor 3 driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.h b/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.h
new file mode 100644
index 000000000000..c9d62bc56c26
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.h
@@ -0,0 +1,89 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_MDP3_CORE_H__
+#define __MTK_MDP3_CORE_H__
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-mem2mem.h>
+#include "mtk-mdp3-comp.h"
+#include "mtk-mdp3-vpu.h"
+
+#define MDP_MODULE_NAME	"mtk-mdp3"
+
+enum mdp_buffer_usage {
+	MDP_BUFFER_USAGE_HW_READ,
+	MDP_BUFFER_USAGE_MDP,
+	MDP_BUFFER_USAGE_MDP2,
+	MDP_BUFFER_USAGE_ISP,
+	MDP_BUFFER_USAGE_WPE,
+};
+
+struct mdp_dev {
+	struct platform_device	*pdev;
+	struct mdp_comp		mmsys;
+	struct mdp_comp		mm_mutex;
+	struct mdp_comp		*comp[MDP_MAX_COMP_COUNT];
+	s32			event[MDP_MAX_EVENT_COUNT];
+
+	struct workqueue_struct	*job_wq;
+	struct workqueue_struct	*clock_wq;
+	struct mdp_vpu_dev	vpu;
+	struct platform_device	*vpu_dev;
+	struct rproc *rproc_handle;
+
+	struct mutex		vpu_lock;
+	s32			vpu_count;
+	u32			id_count;
+	struct cmdq_client	*cmdq_clt;
+
+	struct v4l2_device	v4l2_dev;
+	struct video_device	*m2m_vdev;
+	struct v4l2_m2m_dev	*m2m_dev;
+	/* synchronization protect for m2m device operation */
+	struct mutex		m2m_lock;
+};
+
+int mdp_vpu_get_locked(struct mdp_dev *mdp);
+void mdp_vpu_put_locked(struct mdp_dev *mdp);
+
+extern int mtk_mdp_debug;
+
+#define DEBUG
+#if defined(DEBUG)
+
+#define mdp_dbg(level, fmt, ...)\
+	do {\
+		if (mtk_mdp_debug >= (level))\
+			pr_info("[MTK-MDP3] %d %s:%d: " fmt "\n",\
+				level, __func__, __LINE__, ##__VA_ARGS__);\
+	} while (0)
+
+#define mdp_err(fmt, ...)\
+	pr_err("[MTK-MDP3][ERR] %s:%d: " fmt "\n", __func__, __LINE__,\
+		##__VA_ARGS__)
+
+#else
+
+#define mdp_dbg(level, fmt, ...)	do {} while (0)
+#define mdp_err(fmt, ...)		do {} while (0)
+
+#endif
+
+#define mdp_dbg_enter() mdp_dbg(3, "+")
+#define mdp_dbg_leave() mdp_dbg(3, "-")
+
+#endif  /* __MTK_MDP3_CORE_H__ */
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-debug.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-debug.c
new file mode 100644
index 000000000000..0a97836aa71a
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-debug.c
@@ -0,0 +1,1102 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Daoyuan Huang <daoyuan.huang@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/compiler_types.h>
+#include <linux/of_address.h>
+
+#include "mmsys_reg_base.h"
+#include "mtk-mdp3-core.h"
+#include "mtk-mdp3-debug.h"
+#include "mtk-mdp3-regs.h"
+
+struct mdp_module_base_va {
+	void __iomem *MDP_RDMA0;
+	void __iomem *MDP_RSZ0;
+	void __iomem *MDP_RSZ1;
+	void __iomem *MDP_TDSHP;
+	void __iomem *MDP_COLOR;
+	void __iomem *MDP_AAL;
+	void __iomem *MDP_CCORR;
+	void __iomem *MDP_WROT0;
+	void __iomem *MDP_WDMA;
+	void __iomem *VENC;
+	void __iomem *SMI_LARB0;
+};
+
+struct RegDef {
+	int offset;
+	const char *name;
+};
+
+struct mdp_debug_context {
+	struct platform_device *mdp_device;
+	struct mdp_func_struct mdp_func_pointer;
+	struct mdp_module_base_va mdp_mod_base_va;
+	void __iomem *mdp_mmsys_base_va;
+};
+
+#define MMSYS_CONFIG_BASE	mdp_get_module_base_VA_MMSYS_CONFIG()
+#define MDP_RDMA0_BASE		mdp_get_module_base_VA_MDP_RDMA0()
+#define MDP_RSZ0_BASE		mdp_get_module_base_VA_MDP_RSZ0()
+#define MDP_RSZ1_BASE		mdp_get_module_base_VA_MDP_RSZ1()
+#define MDP_TDSHP_BASE		mdp_get_module_base_VA_MDP_TDSHP()
+#define MDP_COLOR_BASE		mdp_get_module_base_VA_MDP_COLOR()
+#define MDP_AAL_BASE		mdp_get_module_base_VA_MDP_AAL()
+#define MDP_CCORR_BASE		mdp_get_module_base_VA_MDP_CCORR()
+#define MDP_WROT0_BASE		mdp_get_module_base_VA_MDP_WROT0()
+#define MDP_WDMA_BASE		mdp_get_module_base_VA_MDP_WDMA()
+#define VENC_BASE		mdp_get_module_base_VA_VENC()
+
+
+static struct mdp_debug_context g_mdp_debug;
+
+struct mdp_debug_context *mdp_get_mdp_debug(void)
+{
+	return &g_mdp_debug;
+}
+
+void __iomem *mdp_get_module_base_VA_MMSYS_CONFIG(void)
+{
+	return g_mdp_debug.mdp_mmsys_base_va;
+}
+
+void __iomem *mdp_get_module_base_VA_MDP_RDMA0(void)
+{
+	return g_mdp_debug.mdp_mod_base_va.MDP_RDMA0;
+}
+void __iomem *mdp_get_module_base_VA_MDP_RSZ0(void)
+{
+	return g_mdp_debug.mdp_mod_base_va.MDP_RSZ0;
+}
+void __iomem *mdp_get_module_base_VA_MDP_RSZ1(void)
+{
+	return g_mdp_debug.mdp_mod_base_va.MDP_RSZ1;
+}
+void __iomem *mdp_get_module_base_VA_MDP_TDSHP(void)
+{
+	return g_mdp_debug.mdp_mod_base_va.MDP_TDSHP;
+}
+void __iomem *mdp_get_module_base_VA_MDP_COLOR(void)
+{
+	return g_mdp_debug.mdp_mod_base_va.MDP_COLOR;
+}
+void __iomem *mdp_get_module_base_VA_MDP_AAL(void)
+{
+	return g_mdp_debug.mdp_mod_base_va.MDP_AAL;
+}
+void __iomem *mdp_get_module_base_VA_MDP_CCORR(void)
+{
+	return g_mdp_debug.mdp_mod_base_va.MDP_CCORR;
+}
+void __iomem *mdp_get_module_base_VA_MDP_WROT0(void)
+{
+	return g_mdp_debug.mdp_mod_base_va.MDP_WROT0;
+}
+void __iomem *mdp_get_module_base_VA_MDP_WDMA(void)
+{
+	return g_mdp_debug.mdp_mod_base_va.MDP_WDMA;
+}
+void __iomem *mdp_get_module_base_VA_VENC(void)
+{
+	return g_mdp_debug.mdp_mod_base_va.VENC;
+}
+
+
+struct mdp_func_struct *mdp_get_func(void)
+{
+	return &g_mdp_debug.mdp_func_pointer;
+}
+
+void __iomem *mdp_alloc_reference_VA_by_name(const char *ref_name)
+{
+	struct device_node *node = NULL;
+	struct device *dev = &(g_mdp_debug.mdp_device->dev);
+	void __iomem *VA = 0L;
+
+	node = of_parse_phandle(dev->of_node, ref_name, 0);
+	if (node) {
+		VA = of_iomap(node, 0);
+		of_node_put(node);
+		mdp_dbg(2, "DEV: VA ref(%s): 0x%lx\n", ref_name, VA);
+	} else {
+		mdp_err("DEV: cannot parse node name:%s\n", ref_name);
+	}
+	return VA;
+}
+
+void mdp_free_module_base_VA(void __iomem *VA)
+{
+	iounmap(VA);
+}
+
+void mdp_init_module_base_VA(void)
+{
+	struct mdp_module_base_va *mod_base_va = &(g_mdp_debug.mdp_mod_base_va);
+	struct device_node *rdma_node = g_mdp_debug.mdp_device->dev.of_node;
+	void __iomem *va = 0L;
+
+	memset(mod_base_va, 0, sizeof(struct mdp_module_base_va));
+
+	//mod_base_va->MDP_RDMA0 = mdp_alloc_reference_VA_by_name("mdp_rdma0");
+	if (rdma_node) {
+		va = of_iomap(rdma_node, 0);
+		of_node_put(rdma_node);
+		mod_base_va->MDP_RDMA0 = va;
+		mdp_dbg(2, "MDP_RDMA va: 0x%lx\n", va);
+	} else
+		mdp_err("%s:MDP_RDMA node missing!\n", __func__);
+
+	mod_base_va->MDP_RSZ0 = mdp_alloc_reference_VA_by_name("mdp_rsz0");
+	mod_base_va->MDP_RSZ1 = mdp_alloc_reference_VA_by_name("mdp_rsz1");
+	mod_base_va->MDP_WROT0 = mdp_alloc_reference_VA_by_name("mdp_wrot0");
+	mod_base_va->MDP_WDMA = mdp_alloc_reference_VA_by_name("mdp_wdma0");
+	mod_base_va->MDP_TDSHP = mdp_alloc_reference_VA_by_name("mdp_tdshp0");
+	mod_base_va->MDP_COLOR = mdp_alloc_reference_VA_by_name("mdp_color0");
+	mod_base_va->MDP_AAL = mdp_alloc_reference_VA_by_name("mdp_aal0");
+	mod_base_va->MDP_CCORR = mdp_alloc_reference_VA_by_name("mdp_ccorr0");
+	mod_base_va->VENC = mdp_alloc_reference_VA_by_name("venc");
+	mod_base_va->SMI_LARB0 =
+		mdp_alloc_reference_VA_by_name("mediatek,larb");
+}
+
+void mdp_deinit_module_base_VA(void)
+{
+	struct mdp_module_base_va *mod_base_va = &(g_mdp_debug.mdp_mod_base_va);
+
+	mdp_free_module_base_VA(mod_base_va->MDP_RDMA0);
+	mdp_free_module_base_VA(mod_base_va->MDP_RSZ0);
+	mdp_free_module_base_VA(mod_base_va->MDP_RSZ1);
+	mdp_free_module_base_VA(mod_base_va->MDP_WROT0);
+	mdp_free_module_base_VA(mod_base_va->MDP_WDMA);
+	mdp_free_module_base_VA(mod_base_va->MDP_TDSHP);
+	mdp_free_module_base_VA(mod_base_va->MDP_COLOR);
+	mdp_free_module_base_VA(mod_base_va->MDP_AAL);
+	mdp_free_module_base_VA(mod_base_va->MDP_CCORR);
+	mdp_free_module_base_VA(mod_base_va->VENC);
+	mdp_free_module_base_VA(mod_base_va->SMI_LARB0);
+	memset(mod_base_va, 0, sizeof(struct mdp_module_base_va));
+}
+
+void mdp_map_mmsys_VA(void)
+{
+	g_mdp_debug.mdp_mmsys_base_va =
+		mdp_alloc_reference_VA_by_name("mediatek,mmsys");
+}
+
+void mdp_unmap_mmsys_VA(void)
+{
+	mdp_free_module_base_VA(g_mdp_debug.mdp_mmsys_base_va);
+}
+
+uint32_t mdp_rdma_get_reg_offset_src_addr_virtual(void)
+{
+	return 0;
+}
+
+uint32_t mdp_wrot_get_reg_offset_dst_addr_virtual(void)
+{
+	return 0;
+}
+
+uint32_t mdp_wdma_get_reg_offset_dst_addr_virtual(void)
+{
+	return 0;
+}
+
+/* MDP engine dump */
+void mdp_dump_rsz_common(void __iomem *base, const char *label)
+{
+	uint32_t value[8] = { 0 };
+	uint32_t request[8] = { 0 };
+	uint32_t state = 0;
+
+	if (base == 0) {
+		mdp_err("=============== [MDP] %s Status ===============\n",
+			label);
+		mdp_err("%s:base=0!\n", __func__);
+		return;
+	}
+
+	value[0] = MDP_REG_GET32(base + 0x004);
+	value[1] = MDP_REG_GET32(base + 0x00C);
+	value[2] = MDP_REG_GET32(base + 0x010);
+	value[3] = MDP_REG_GET32(base + 0x014);
+	value[4] = MDP_REG_GET32(base + 0x018);
+	MDP_REG_SET32(base + 0x040, 0x00000001);
+	value[5] = MDP_REG_GET32(base + 0x044);
+	MDP_REG_SET32(base + 0x040, 0x00000002);
+	value[6] = MDP_REG_GET32(base + 0x044);
+	MDP_REG_SET32(base + 0x040, 0x00000003);
+	value[7] = MDP_REG_GET32(base + 0x044);
+
+	mdp_err("=============== [MDP] %s Status ===============\n",
+		label);
+	mdp_err("RSZ_CONTROL: 0x%08x, RSZ_INPUT_IMAGE: 0x%08x\n",
+		 value[0], value[1]);
+	mdp_err("RSZ_OUTPUT_IMAGE: 0x%08x RSZ_VERTICAL_COEFF_STEP: 0x%08x\n",
+		 value[2], value[3]);
+	mdp_err("RSZ_HORIZONTAL_COEFF_STEP: 0x%08x, RSZ_DEBUG_1: 0x%08x\n",
+		 value[4], value[5]);
+	mdp_err(", RSZ_DEBUG_2: 0x%08x, RSZ_DEBUG_3: 0x%08x\n",
+		 value[6], value[7]);
+
+	/* parse state */
+	/* .valid=1/request=1: upstream module sends data */
+	/* .ready=1: downstream module receives data */
+	state = value[6] & 0xF;
+	request[0] = state & (0x1);	/* out valid */
+	request[1] = (state & (0x1 << 1)) >> 1;	/* out ready */
+	request[2] = (state & (0x1 << 2)) >> 2;	/* in valid */
+	request[3] = (state & (0x1 << 3)) >> 3;	/* in ready */
+	request[4] = (value[1] & 0x1FFF);	/* input_width */
+	request[5] = (value[1] >> 16) & 0x1FFF;	/* input_height */
+	request[6] = (value[2] & 0x1FFF);	/* output_width */
+	request[7] = (value[2] >> 16) & 0x1FFF;	/* output_height */
+
+	mdp_err("RSZ inRdy,inRsq,outRdy,outRsq: %d,%d,%d,%d (%s)\n",
+		request[3], request[2], request[1], request[0],
+		mdp_get_rsz_state(state));
+	mdp_err("RSZ input_width,input_height,output_width,output_height:");
+	mdp_err("%d,%d,%d,%d\n",
+		 request[4], request[5], request[6], request[7]);
+}
+
+void mdp_dump_tdshp_common(void __iomem *base, const char *label)
+{
+	uint32_t value[8] = { 0 };
+
+	if (base == 0) {
+		mdp_err("=============== [MDP] %s Status ===============\n",
+			label);
+		mdp_err("%s:base=0!\n", __func__);
+		return;
+	}
+
+	value[0] = MDP_REG_GET32(base + 0x114);
+	value[1] = MDP_REG_GET32(base + 0x11C);
+	value[2] = MDP_REG_GET32(base + 0x104);
+	value[3] = MDP_REG_GET32(base + 0x108);
+	value[4] = MDP_REG_GET32(base + 0x10C);
+	value[5] = MDP_REG_GET32(base + 0x120);
+	value[6] = MDP_REG_GET32(base + 0x128);
+	value[7] = MDP_REG_GET32(base + 0x110);
+
+	mdp_err("=============== [MDP] %s Status ===============\n",
+		label);
+	mdp_err("TDSHP INPUT_CNT: 0x%08x, OUTPUT_CNT: 0x%08x\n",
+		value[0], value[1]);
+	mdp_err("TDSHP INTEN: 0x%08x, INTSTA: 0x%08x, 0x10C: 0x%08x\n",
+		value[2], value[3], value[4]);
+	mdp_err("TDSHP CFG: 0x%08x, IN_SIZE: 0x%08x, OUT_SIZE: 0x%08x\n",
+		value[7], value[5], value[6]);
+}
+
+void mdp_virtual_function_setting(void)
+{
+	struct mdp_func_struct *pfunc = mdp_get_func();
+
+	pfunc->mdp_dump_rsz = mdp_dump_rsz_common;
+	pfunc->mdp_dump_tdshp = mdp_dump_tdshp_common;
+	pfunc->mdp_rdma_get_src_base_addr =
+		mdp_rdma_get_reg_offset_src_addr_virtual;
+	pfunc->mdp_wrot_get_reg_offset_dst_addr =
+		mdp_wrot_get_reg_offset_dst_addr_virtual;
+	pfunc->mdp_wdma_get_reg_offset_dst_addr =
+		mdp_wdma_get_reg_offset_dst_addr_virtual;
+}
+
+void mdp_dump_mmsys_config(void)
+{
+	int i = 0;
+	uint32_t value = 0;
+	static const struct RegDef configRegisters[] = {
+		{0xF80, "ISP_MOUT_EN"},
+		{0xF84, "MDP_RDMA0_MOUT_EN"},
+		{0xF8C, "MDP_PRZ0_MOUT_EN"},
+		{0xF90, "MDP_PRZ1_MOUT_EN"},
+		{0xF94, "MDP_COLOR_MOUT_EN"},
+		{0xF98, "IPU_MOUT_EN"},
+		{0xFE8, "MDP_AAL_MOUT_EN"},
+		/* {0x02C, "MDP_TDSHP_MOUT_EN"},*/
+		{0xF00, "DISP_OVL0_MOUT_EN"},
+		{0xF04, "DISP_OVL0_2L_MOUT_EN"},
+		{0xF08, "DISP_OVL1_2L_MOUT_EN"},
+		{0xF0C, "DISP_DITHER0_MOUT_EN"},
+		{0xF10, "DISP_RSZ_MOUT_EN"},
+		/* {0x040, "DISP_UFOE_MOUT_EN"}, */
+		/* {0x040, "MMSYS_MOUT_RST"}, */
+		{0xFA0, "DISP_TO_WROT_SOUT_SEL"},
+		{0xFA4, "MDP_COLOR_IN_SOUT_SEL"},
+		{0xFA8, "MDP_PATH0_SOUT_SEL"},
+		{0xFAC, "MDP_PATH1_SOUT_SEL"},
+		{0xFB0, "MDP_TDSHP_SOUT_SEL"},
+		{0xFC0, "MDP_PRZ0_SEL_IN"},
+		{0xFC4, "MDP_PRZ1_SEL_IN"},
+		{0xFC8, "MDP_TDSHP_SEL_IN"},
+		{0xFCC, "DISP_WDMA0_SEL_IN"},
+		{0xFDC, "MDP_COLOR_SEL_IN"},
+		{0xF20, "DISP_COLOR_OUT_SEL_IN"},
+		{0xFD0, "MDP_WROT0_SEL_IN"},
+		{0xFD4, "MDP_WDMA_SEL_IN"},
+		{0xFD8, "MDP_COLOR_OUT_SEL_IN"},
+		{0xFDC, "MDP_COLOR_SEL_IN "},
+		/* {0xFDC, "DISP_COLOR_SEL_IN"}, */
+		{0xFE0, "MDP_PATH0_SEL_IN"},
+		{0xFE4, "MDP_PATH1_SEL_IN"},
+		{0xFEC, "MDP_AAL_SEL_IN"},
+		{0xFF0, "MDP_CCORR_SEL_IN"},
+		{0xFF4, "MDP_CCORR_SOUT_SEL"},
+		/* {0x070, "DISP_WDMA1_SEL_IN"}, */
+		/* {0x074, "DISP_UFOE_SEL_IN"}, */
+		{0xF2C, "DSI0_SEL_IN"},
+		{0xF30, "DSI1_SEL_IN"},
+		{0xF50, "DISP_RDMA0_SOUT_SEL_IN"},
+		{0xF54, "DISP_RDMA1_SOUT_SEL_IN"},
+		{0x0F0, "MMSYS_MISC"},
+		/* ACK and REQ related */
+		{0x8B4, "DISP_DL_VALID_0"},
+		{0x8B8, "DISP_DL_VALID_1"},
+		{0x8C0, "DISP_DL_READY_0"},
+		{0x8C4, "DISP_DL_READY_1"},
+		{0x8CC, "MDP_DL_VALID_0"},
+		{0x8D0, "MDP_DL_VALID_1"},
+		{0x8D4, "MDP_DL_READY_0"},
+		{0x8D8, "MDP_DL_READY_1"},
+		{0x8E8, "MDP_MOUT_MASK"},
+		{0x948, "MDP_DL_VALID_2"},
+		{0x94C, "MDP_DL_READY_2"},
+		{0x950, "DISP_DL_VALID_2"},
+		{0x954, "DISP_DL_READY_2"},
+		{0x100, "MMSYS_CG_CON0"},
+		{0x110, "MMSYS_CG_CON1"},
+		/* Async DL related */
+		{0x960, "TOP_RELAY_FSM_RD"},
+		{0x934, "MDP_ASYNC_CFG_WD"},
+		{0x938, "MDP_ASYNC_CFG_RD"},
+		{0x958, "MDP_ASYNC_CFG_OUT_RD"},
+		{0x95C, "MDP_ASYNC_IPU_CFG_OUT_RD"},
+		{0x994, "ISP_RELAY_CFG_WD"},
+		{0x998, "ISP_RELAY_CNT_RD"},
+		{0x99C, "ISP_RELAY_CNT_LATCH_RD"},
+		{0x9A0, "IPU_RELAY_CFG_WD"},
+		{0x9A4, "IPU_RELAY_CNT_RD"},
+		{0x9A8, "IPU_RELAY_CNT_LATCH_RD"}
+
+
+	};
+
+	if (MMSYS_CONFIG_BASE == 0) {
+		mdp_err("%s:MMSYS_CONFIG_BASE=0!\n", __func__);
+		return;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(configRegisters); i++) {
+		value = MDP_REG_GET32(MMSYS_CONFIG_BASE +
+			configRegisters[i].offset);
+		mdp_err("%s: 0x%08x\n", configRegisters[i].name, value);
+	}
+}
+
+const char *mdp_get_rdma_state(uint32_t state)
+{
+	switch (state) {
+	case 0x1:
+		return "idle";
+	case 0x2:
+		return "wait sof";
+	case 0x4:
+		return "reg update";
+	case 0x8:
+		return "clear0";
+	case 0x10:
+		return "clear1";
+	case 0x20:
+		return "int0";
+	case 0x40:
+		return "int1";
+	case 0x80:
+		return "data running";
+	case 0x100:
+		return "wait done";
+	case 0x200:
+		return "warm reset";
+	case 0x400:
+		return "wait reset";
+	default:
+		return "";
+	}
+}
+
+const char *mdp_get_rsz_state(const uint32_t state)
+{
+	switch (state) {
+	case 0x5:
+		return "downstream hang";	/* 0,1,0,1 */
+	case 0xa:
+		return "upstream hang";	/* 1,0,1,0 */
+	default:
+		return "";
+	}
+}
+
+const char *mdp_get_wdma_state(uint32_t state)
+{
+	switch (state) {
+	case 0x1:
+		return "idle";
+	case 0x2:
+		return "clear";
+	case 0x4:
+		return "prepare";
+	case 0x8:
+		return "prepare";
+	case 0x10:
+		return "data running";
+	case 0x20:
+		return "eof wait";
+	case 0x40:
+		return "soft reset wait";
+	case 0x80:
+		return "eof done";
+	case 0x100:
+		return "sof reset done";
+	case 0x200:
+		return "frame complete";
+	default:
+		return "";
+	}
+}
+
+void mdp_dump_rdma_common(void __iomem *base, const char *label)
+{
+	uint32_t value[17] = { 0 };
+	uint32_t state = 0;
+	uint32_t grep = 0;
+
+	if (base == 0) {
+		mdp_err("=============== [MDP] %s Status ===============\n",
+			label);
+		mdp_err("%s:base=0!\n", __func__);
+		return;
+	}
+
+	value[0] = MDP_REG_GET32(base + 0x030);
+	value[1] = MDP_REG_GET32(base +
+		   mdp_get_func()->mdp_rdma_get_src_base_addr());
+	value[2] = MDP_REG_GET32(base + 0x060);
+	value[3] = MDP_REG_GET32(base + 0x070);
+	value[4] = MDP_REG_GET32(base + 0x078);
+	value[5] = MDP_REG_GET32(base + 0x080);
+	value[6] = MDP_REG_GET32(base + 0x100);
+	value[7] = MDP_REG_GET32(base + 0x118);
+	value[8] = MDP_REG_GET32(base + 0x130);
+	value[9] = MDP_REG_GET32(base + 0x400);
+	value[10] = MDP_REG_GET32(base + 0x408);
+	value[11] = MDP_REG_GET32(base + 0x410);
+	value[12] = MDP_REG_GET32(base + 0x420);
+	value[13] = MDP_REG_GET32(base + 0x430);
+	value[14] = MDP_REG_GET32(base + 0x440);
+	value[15] = MDP_REG_GET32(base + 0x4D0);
+	value[16] = MDP_REG_GET32(base + 0x0);
+
+	mdp_err("=============== [MDP] %s Status ===============\n",
+		label);
+	mdp_err
+	    ("RDMA_SRC_CON: 0x%08x, RDMA_SRC_BASE_0: 0x%08x\n",
+	     value[0], value[1]);
+	mdp_err
+	    ("RDMA_MF_BKGD_SIZE_IN_BYTE: 0x%08x RDMA_MF_SRC_SIZE: 0x%08x\n",
+	     value[2], value[3]);
+	mdp_err("RDMA_MF_CLIP_SIZE: 0x%08x, RDMA_MF_OFFSET_1: 0x%08x\n",
+		value[4], value[5]);
+	mdp_err("RDMA_SRC_END_0: 0x%08x, RDMA_SRC_OFFSET_0: 0x%08x\n",
+		 value[6], value[7]);
+	mdp_err("RDMA_SRC_OFFSET_W_0: 0x%08x, RDMA_MON_STA_0: 0x%08x\n",
+		 value[8], value[9]);
+	mdp_err("RDMA_MON_STA_1: 0x%08x, RDMA_MON_STA_2: 0x%08x\n",
+		 value[10], value[11]);
+	mdp_err("RDMA_MON_STA_4: 0x%08x, RDMA_MON_STA_6: 0x%08x\n",
+		 value[12], value[13]);
+	mdp_err("RDMA_MON_STA_8: 0x%08x, RDMA_MON_STA_26: 0x%08x\n",
+		 value[14], value[15]);
+	mdp_err("RDMA_EN: 0x%08x\n",
+		 value[16]);
+
+	/* parse state */
+	mdp_err("RDMA ack:%d req:%d\n", (value[9] & (1 << 11)) >> 11,
+		 (value[9] & (1 << 10)) >> 10);
+	state = (value[10] >> 8) & 0x7FF;
+	grep = (value[10] >> 20) & 0x1;
+	mdp_err("RDMA state: 0x%x (%s)\n", state, mdp_get_rdma_state(state));
+	mdp_err("RDMA horz_cnt: %d vert_cnt:%d\n",
+		value[15] & 0xFFF, (value[15] >> 16) & 0xFFF);
+
+	mdp_err("RDMA grep:%d => suggest to ask SMI help:%d\n", grep, grep);
+}
+
+void mdp_dump_rot_common(void __iomem *base, const char *label)
+{
+	uint32_t value[47] = { 0 };
+
+	if (base == 0) {
+		mdp_err("=============== [MDP] %s Status ===============\n",
+			label);
+		mdp_err("%s:base=0!\n", __func__);
+		return;
+	}
+
+	value[0] = MDP_REG_GET32(base + 0x000);
+	value[1] = MDP_REG_GET32(base + 0x008);
+	value[2] = MDP_REG_GET32(base + 0x00C);
+	value[3] = MDP_REG_GET32(base + 0x024);
+	value[4] = MDP_REG_GET32(base +
+		   mdp_get_func()->mdp_wrot_get_reg_offset_dst_addr());
+	value[5] = MDP_REG_GET32(base + 0x02C);
+	value[6] = MDP_REG_GET32(base + 0x004);
+	value[7] = MDP_REG_GET32(base + 0x030);
+	value[8] = MDP_REG_GET32(base + 0x078);
+	value[9] = MDP_REG_GET32(base + 0x070);
+	MDP_REG_SET32(base + 0x018, 0x00000100);
+	value[10] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000200);
+	value[11] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000300);
+	value[12] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000400);
+	value[13] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000500);
+	value[14] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000600);
+	value[15] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000700);
+	value[16] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000800);
+	value[17] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000900);
+	value[18] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000A00);
+	value[19] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000B00);
+	value[20] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000C00);
+	value[21] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000D00);
+	value[22] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000E00);
+	value[23] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00000F00);
+	value[24] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001000);
+	value[25] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001100);
+	value[26] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001200);
+	value[27] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001300);
+	value[28] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001400);
+	value[29] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001500);
+	value[30] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001600);
+	value[31] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001700);
+	value[32] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001800);
+	value[33] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001900);
+	value[34] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001A00);
+	value[35] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001B00);
+	value[36] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001C00);
+	value[37] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001D00);
+	value[38] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001E00);
+	value[39] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00001F00);
+	value[40] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00002000);
+	value[41] = MDP_REG_GET32(base + 0x0D0);
+	MDP_REG_SET32(base + 0x018, 0x00002100);
+	value[42] = MDP_REG_GET32(base + 0x0D0);
+	value[43] = MDP_REG_GET32(base + 0x01C);
+	value[44] = MDP_REG_GET32(base + 0x07C);
+	value[45] = MDP_REG_GET32(base + 0x010);
+	value[46] = MDP_REG_GET32(base + 0x014);
+
+	mdp_err("=============== [MDP] %s Status ===============\n",
+		label);
+	mdp_err("ROT_CTRL: 0x%08x, ROT_MAIN_BUF_SIZE: 0x%08x\n",
+		 value[0], value[1]);
+	mdp_err("ROT_SUB_BUF_SIZE: 0x%08x, ROT_TAR_SIZE: 0x%08x\n",
+		 value[2], value[3]);
+	mdp_err("ROT_BASE_ADDR: 0x%08x, ROT_OFST_ADDR: 0x%08x\n",
+		 value[4], value[5]);
+	mdp_err("ROT_DMA_PERF: 0x%08x, ROT_STRIDE: 0x%08x\n",
+		 value[6], value[7]);
+	mdp_err("ROT_IN_SIZE: 0x%08x, ROT_EOL: 0x%08x\n",
+		 value[8], value[9]);
+	mdp_err("ROT_DBUGG_1: 0x%08x, ROT_DEBUBG_2: 0x%08x\n",
+		 value[10], value[11]);
+	mdp_err("ROT_DBUGG_3: 0x%08x, ROT_DBUGG_4: 0x%08x\n",
+		 value[12], value[13]);
+	mdp_err("ROT_DEBUBG_5: 0x%08x, ROT_DBUGG_6: 0x%08x\n",
+		 value[14], value[15]);
+	mdp_err("ROT_DBUGG_7: 0x%08x, ROT_DEBUBG_8: 0x%08x\n",
+		 value[16], value[17]);
+	mdp_err("ROT_DBUGG_9: 0x%08x, ROT_DBUGG_A: 0x%08x\n",
+		 value[18], value[19]);
+	mdp_err("ROT_DEBUBG_B: 0x%08x, ROT_DBUGG_C: 0x%08x\n",
+		 value[20], value[21]);
+	mdp_err("ROT_DBUGG_D: 0x%08x, ROT_DEBUBG_E: 0x%08x\n",
+		 value[22], value[23]);
+	mdp_err("ROT_DBUGG_F: 0x%08x, ROT_DBUGG_10: 0x%08x\n",
+		 value[24], value[25]);
+	mdp_err("ROT_DEBUBG_11: 0x%08x, ROT_DEBUG_12: 0x%08x\n",
+		 value[26], value[27]);
+	mdp_err("ROT_DBUGG_13: 0x%08x, ROT_DBUGG_14: 0x%08x\n",
+		 value[28], value[29]);
+	mdp_err("ROT_DEBUG_15: 0x%08x, ROT_DBUGG_16: 0x%08x\n",
+		 value[30], value[31]);
+	mdp_err("ROT_DBUGG_17: 0x%08x, ROT_DEBUG_18: 0x%08x\n",
+		 value[32], value[33]);
+	mdp_err("ROT_DBUGG_19: 0x%08x, ROT_DBUGG_1A: 0x%08x\n",
+		 value[34], value[35]);
+	mdp_err("ROT_DEBUG_1B: 0x%08x, ROT_DBUGG_1C: 0x%08x\n",
+		 value[36], value[37]);
+	mdp_err("ROT_DBUGG_1D: 0x%08x, ROT_DEBUG_1E: 0x%08x\n",
+		 value[38], value[39]);
+	mdp_err("ROT_DBUGG_1F: 0x%08x, ROT_DBUGG_20: 0x%08x\n",
+		 value[40], value[41]);
+	mdp_err("ROT_DEBUG_21: 0x%08x\n",
+		 value[42]);
+	mdp_err("VIDO_INT: 0x%08x, VIDO_ROT_EN: 0x%08x\n",
+		value[43], value[44]);
+	mdp_err("VIDO_SOFT_RST: 0x%08x, VIDO_SOFT_RST_STAT: 0x%08x\n",
+		value[45], value[46]);
+}
+
+void mdp_dump_color_common(void __iomem *base, const char *label)
+{
+	uint32_t value[13] = { 0 };
+
+	if (base == 0) {
+		mdp_err("=============== [MDP] %s Status ===============\n",
+			label);
+		mdp_err("%s:base=0!\n", __func__);
+		return;
+	}
+
+	value[0] = MDP_REG_GET32(base + 0x400);
+	value[1] = MDP_REG_GET32(base + 0x404);
+	value[2] = MDP_REG_GET32(base + 0x408);
+	value[3] = MDP_REG_GET32(base + 0x40C);
+	value[4] = MDP_REG_GET32(base + 0x410);
+	value[5] = MDP_REG_GET32(base + 0x420);
+	value[6] = MDP_REG_GET32(base + 0xC00);
+	value[7] = MDP_REG_GET32(base + 0xC04);
+	value[8] = MDP_REG_GET32(base + 0xC08);
+	value[9] = MDP_REG_GET32(base + 0xC0C);
+	value[10] = MDP_REG_GET32(base + 0xC10);
+	value[11] = MDP_REG_GET32(base + 0xC50);
+	value[12] = MDP_REG_GET32(base + 0xC54);
+
+	mdp_err("=============== [MDP] %s Status ===============\n",
+		label);
+	mdp_err("COLOR CFG_MAIN: 0x%08x\n", value[0]);
+	mdp_err("COLOR PXL_CNT_MAIN: 0x%08x, LINE_CNT_MAIN: 0x%08x\n",
+		value[1], value[2]);
+	mdp_err("COLOR WIN_X_MAIN: 0x%08x, WIN_Y_MAIN: 0x%08x\n",
+		value[3], value[4]);
+	mdp_err("DBG_CFG_MAIN: 0x%08x, COLOR START: 0x%08x\n",
+		value[5], value[6]);
+	mdp_err("INTEN: 0x%08x, INTSTA: 0x%08x\n",
+		value[7], value[8]);
+	mdp_err("COLOR OUT_SEL: 0x%08x, FRAME_DONE_DEL: 0x%08x\n",
+		value[9], value[10]);
+	mdp_err
+	    ("COLOR INTERNAL_IP_WIDTH: 0x%08x, INTERNAL_IP_HEIGHT: 0x%08x\n",
+	     value[11], value[12]);
+}
+
+void mdp_dump_wdma_common(void __iomem *base, const char *label)
+{
+	uint32_t value[56] = { 0 };
+	uint32_t state = 0;
+	/* grep bit = 1, WDMA has sent request to SMI,
+	 *and not receive done yet
+	 */
+	uint32_t grep = 0;
+	uint32_t isFIFOFull = 0;	/* 1 for WDMA FIFO full */
+
+	if (base == 0) {
+		mdp_err("=============== [MDP] %s Status ===============\n",
+			label);
+		mdp_err("%s:base=0!\n", __func__);
+		return;
+	}
+
+	value[0] = MDP_REG_GET32(base + 0x014);
+	value[1] = MDP_REG_GET32(base + 0x018);
+	value[2] = MDP_REG_GET32(base + 0x028);
+	value[3] = MDP_REG_GET32(base +
+		   mdp_get_func()->mdp_wdma_get_reg_offset_dst_addr());
+	value[4] = MDP_REG_GET32(base + 0x078);
+	value[5] = MDP_REG_GET32(base + 0x080);
+	value[6] = MDP_REG_GET32(base + 0x0A0);
+	value[7] = MDP_REG_GET32(base + 0x0A8);
+
+	MDP_REG_SET32(base + 0x014, (value[0] & (0x0FFFFFFF)));
+	value[8] = MDP_REG_GET32(base + 0x014);
+	value[9] = MDP_REG_GET32(base + 0x0AC);
+	value[40] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0x10000000 | (value[0] & (0x0FFFFFFF)));
+	value[10] = MDP_REG_GET32(base + 0x014);
+	value[11] = MDP_REG_GET32(base + 0x0AC);
+	value[41] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0x20000000 | (value[0] & (0x0FFFFFFF)));
+	value[12] = MDP_REG_GET32(base + 0x014);
+	value[13] = MDP_REG_GET32(base + 0x0AC);
+	value[42] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0x30000000 | (value[0] & (0x0FFFFFFF)));
+	value[14] = MDP_REG_GET32(base + 0x014);
+	value[15] = MDP_REG_GET32(base + 0x0AC);
+	value[43] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0x40000000 | (value[0] & (0x0FFFFFFF)));
+	value[16] = MDP_REG_GET32(base + 0x014);
+	value[17] = MDP_REG_GET32(base + 0x0AC);
+	value[44] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0x50000000 | (value[0] & (0x0FFFFFFF)));
+	value[18] = MDP_REG_GET32(base + 0x014);
+	value[19] = MDP_REG_GET32(base + 0x0AC);
+	value[45] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0x60000000 | (value[0] & (0x0FFFFFFF)));
+	value[20] = MDP_REG_GET32(base + 0x014);
+	value[21] = MDP_REG_GET32(base + 0x0AC);
+	value[46] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0x70000000 | (value[0] & (0x0FFFFFFF)));
+	value[22] = MDP_REG_GET32(base + 0x014);
+	value[23] = MDP_REG_GET32(base + 0x0AC);
+	value[47] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0x80000000 | (value[0] & (0x0FFFFFFF)));
+	value[24] = MDP_REG_GET32(base + 0x014);
+	value[25] = MDP_REG_GET32(base + 0x0AC);
+	value[48] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0x90000000 | (value[0] & (0x0FFFFFFF)));
+	value[26] = MDP_REG_GET32(base + 0x014);
+	value[27] = MDP_REG_GET32(base + 0x0AC);
+	value[49] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0xA0000000 | (value[0] & (0x0FFFFFFF)));
+	value[28] = MDP_REG_GET32(base + 0x014);
+	value[29] = MDP_REG_GET32(base + 0x0AC);
+	value[50] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0xB0000000 | (value[0] & (0x0FFFFFFF)));
+	value[30] = MDP_REG_GET32(base + 0x014);
+	value[31] = MDP_REG_GET32(base + 0x0AC);
+	value[51] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0xC0000000 | (value[0] & (0x0FFFFFFF)));
+	value[32] = MDP_REG_GET32(base + 0x014);
+	value[33] = MDP_REG_GET32(base + 0x0AC);
+	value[52] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0xD0000000 | (value[0] & (0x0FFFFFFF)));
+	value[34] = MDP_REG_GET32(base + 0x014);
+	value[35] = MDP_REG_GET32(base + 0x0AC);
+	value[53] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0xE0000000 | (value[0] & (0x0FFFFFFF)));
+	value[36] = MDP_REG_GET32(base + 0x014);
+	value[37] = MDP_REG_GET32(base + 0x0AC);
+	value[54] = MDP_REG_GET32(base + 0x0B8);
+	MDP_REG_SET32(base + 0x014, 0xF0000000 | (value[0] & (0x0FFFFFFF)));
+	value[38] = MDP_REG_GET32(base + 0x014);
+	value[39] = MDP_REG_GET32(base + 0x0AC);
+	value[55] = MDP_REG_GET32(base + 0x0B8);
+
+	mdp_err("=============== [MDP] %s Status ===============\n",
+		label);
+	mdp_err("[MDP]WDMA_CFG: 0x%08x, WDMA_SRC_SIZE: 0x%08x\n",
+		 value[0], value[1]);
+	mdp_err("WDMA_DST_W_IN_BYTE = 0x%08x, [MDP]WDMA_DST_ADDR0: 0x%08x\n",
+		 value[2], value[3]);
+	mdp_err
+	    ("WDMA_DST_UV_PITCH: 0x%08x, WDMA_DST_ADDR_OFFSET0 = 0x%08x\n",
+	     value[4], value[5]);
+	mdp_err("[MDP]WDMA_STATUS: 0x%08x, WDMA_INPUT_CNT: 0x%08x\n",
+		value[6], value[7]);
+
+	/* Dump Addtional WDMA debug info */
+	mdp_err("WDMA_DEBUG_0 +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[8], value[9], value[40]);
+	mdp_err("WDMA_DEBUG_1 +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[10], value[11], value[41]);
+	mdp_err("WDMA_DEBUG_2 +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[12], value[13], value[42]);
+	mdp_err("WDMA_DEBUG_3 +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[14], value[15], value[43]);
+	mdp_err("WDMA_DEBUG_4 +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[16], value[17], value[44]);
+	mdp_err("WDMA_DEBUG_5 +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[18], value[19], value[45]);
+	mdp_err("WDMA_DEBUG_6 +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[20], value[21], value[46]);
+	mdp_err("WDMA_DEBUG_7 +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[22], value[23], value[47]);
+	mdp_err("WDMA_DEBUG_8 +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[24], value[25], value[48]);
+	mdp_err("WDMA_DEBUG_9 +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[26], value[27], value[49]);
+	mdp_err("WDMA_DEBUG_A +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[28], value[29], value[50]);
+	mdp_err("WDMA_DEBUG_B +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[30], value[31], value[51]);
+	mdp_err("WDMA_DEBUG_C +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[32], value[33], value[52]);
+	mdp_err("WDMA_DEBUG_D +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[34], value[35], value[53]);
+	mdp_err("WDMA_DEBUG_E +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[36], value[37], value[54]);
+	mdp_err("WDMA_DEBUG_F +014: 0x%08x , +0ac: 0x%08x , +0b8: 0x%08x\n",
+		value[38], value[39], value[55]);
+
+	/* parse WDMA state */
+	state = value[6] & 0x3FF;
+	grep = (value[6] >> 13) & 0x1;
+	isFIFOFull = (value[6] >> 12) & 0x1;
+
+	mdp_err("WDMA state:0x%x (%s)\n", state, mdp_get_wdma_state(state));
+	mdp_err("WDMA in_req:%d in_ack:%d\n", (value[6] >> 15) & 0x1,
+		(value[6] >> 14) & 0x1);
+
+	/* note WDMA send request(i.e command) to SMI first,
+	 * then SMI takes request data from WDMA FIFO
+	 */
+	/* if SMI dose not process request and upstream HWs */
+	/* such as MDP_RSZ send data to WDMA, WDMA FIFO will full finally */
+	mdp_err("WDMA grep:%d, FIFO full:%d\n", grep, isFIFOFull);
+	mdp_err("WDMA suggest: Need SMI help:%d, Need check WDMA config:%d\n",
+		(grep), ((grep == 0) && (isFIFOFull == 1)));
+}
+
+void mdp_dump_rsz(void __iomem *base, const char *label)
+{
+	uint32_t value[11] = { 0 };
+	uint32_t request[4] = { 0 };
+	uint32_t state = 0;
+
+	if (base == 0) {
+		mdp_err("=============== [MDP] %s Status ===============\n",
+			label);
+		mdp_err("%s:base=0!\n", __func__);
+		return;
+	}
+
+	value[0] = MDP_REG_GET32(base + 0x004);
+	value[1] = MDP_REG_GET32(base + 0x008);
+	value[2] = MDP_REG_GET32(base + 0x010);
+	value[3] = MDP_REG_GET32(base + 0x014);
+	value[4] = MDP_REG_GET32(base + 0x018);
+	value[5] = MDP_REG_GET32(base + 0x01C);
+	MDP_REG_SET32(base + 0x044, 0x00000001);
+	value[6] = MDP_REG_GET32(base + 0x048);
+	MDP_REG_SET32(base + 0x044, 0x00000002);
+	value[7] = MDP_REG_GET32(base + 0x048);
+	MDP_REG_SET32(base + 0x044, 0x00000003);
+	value[8] = MDP_REG_GET32(base + 0x048);
+	value[9] = MDP_REG_GET32(base + 0x100);
+	value[10] = MDP_REG_GET32(base + 0x200);
+	mdp_err("=============== [MDP] %s Status ===============\n",
+		label);
+	mdp_err("RSZ_CONTROL_1: 0x%08x, RSZ_CONTROL_2: 0x%08x\n",
+		 value[0], value[1]);
+	mdp_err("RSZ_INPUT_IMAGE: 0x%08x, RSZ_OUTPUT_IMAGE: 0x%08x\n",
+		 value[2], value[3]);
+	mdp_err("RSZ_HORIZONTAL_COEFF_STEP: 0x%08x\n", value[4]);
+	mdp_err("RSZ_VERTICAL_COEFF_STEP: 0x%08x\n", value[5]);
+	mdp_err
+	    ("RSZ_DEBUG_1: 0x%08x, RSZ_DEBUG_2: 0x%08x, RSZ_DEBUG_3: 0x%08x\n",
+	     value[6], value[7], value[8]);
+	mdp_err("PAT1_GEN_SET: 0x%08x, PAT2_GEN_SET: 0x%08x\n",
+		value[9], value[10]);
+	/* parse state */
+	/* .valid=1/request=1: upstream module sends data */
+	/* .ready=1: downstream module receives data */
+	state = value[7] & 0xF;
+	request[0] = state & (0x1);	/* out valid */
+	request[1] = (state & (0x1 << 1)) >> 1;	/* out ready */
+	request[2] = (state & (0x1 << 2)) >> 2;	/* in valid */
+	request[3] = (state & (0x1 << 3)) >> 3;	/* in ready */
+	mdp_err("RSZ inRdy,inRsq,outRdy,outRsq: %d,%d,%d,%d (%s)\n",
+		request[3], request[2], request[1], request[0],
+		mdp_get_rsz_state(state));
+}
+void mdp_dump_tdshp(void __iomem *base, const char *label)
+{
+	uint32_t value[10] = { 0 };
+
+	if (base == 0) {
+		mdp_err("=============== [MDP] %s Status ===============\n",
+			label);
+		mdp_err("%s:base=0!\n", __func__);
+		return;
+	}
+
+	value[0] = MDP_REG_GET32(base + 0x114);
+	value[1] = MDP_REG_GET32(base + 0x11C);
+	value[2] = MDP_REG_GET32(base + 0x104);
+	value[3] = MDP_REG_GET32(base + 0x108);
+	value[4] = MDP_REG_GET32(base + 0x10C);
+	value[5] = MDP_REG_GET32(base + 0x110);
+	value[6] = MDP_REG_GET32(base + 0x120);
+	value[7] = MDP_REG_GET32(base + 0x124);
+	value[8] = MDP_REG_GET32(base + 0x128);
+	value[9] = MDP_REG_GET32(base + 0x12C);
+	mdp_err("=============== [MDP] %s Status ===============\n",
+		label);
+	mdp_err("TDSHP INPUT_CNT: 0x%08x, OUTPUT_CNT: 0x%08x\n",
+		value[0], value[1]);
+	mdp_err("TDSHP INTEN: 0x%08x, INTSTA: 0x%08x, STATUS: 0x%08x\n",
+		value[2], value[3], value[4]);
+	mdp_err("TDSHP CFG: 0x%08x, IN_SIZE: 0x%08x, OUT_SIZE: 0x%08x\n",
+		value[5], value[6], value[8]);
+	mdp_err("TDSHP OUTPUT_OFFSET: 0x%08x, BLANK_WIDTH: 0x%08x\n",
+		value[7], value[9]);
+}
+
+void mdp_dump_aal(void __iomem *base, const char *label)
+{
+	uint32_t value[9] = { 0 };
+
+	if (base == 0) {
+		mdp_err("=============== [MDP] %s Status ===============\n",
+			label);
+		mdp_err("%s:base=0!\n", __func__);
+		return;
+	}
+
+	value[0] = MDP_REG_GET32(base + 0x00C);    /* MDP_AAL_INTSTA       */
+	value[1] = MDP_REG_GET32(base + 0x010);    /* MDP_AAL_STATUS       */
+	value[2] = MDP_REG_GET32(base + 0x024);    /* MDP_AAL_INPUT_COUNT  */
+	value[3] = MDP_REG_GET32(base + 0x028);    /* MDP_AAL_OUTPUT_COUNT */
+	value[4] = MDP_REG_GET32(base + 0x030);    /* MDP_AAL_SIZE         */
+	value[5] = MDP_REG_GET32(base + 0x034);    /* MDP_AAL_OUTPUT_SIZE  */
+	value[6] = MDP_REG_GET32(base + 0x038);    /* MDP_AAL_OUTPUT_OFFSET*/
+	value[7] = MDP_REG_GET32(base + 0x4EC);    /* MDP_AAL_TILE_00      */
+	value[8] = MDP_REG_GET32(base + 0x4F0);    /* MDP_AAL_TILE_01      */
+	mdp_err("=============== [MDP] %s Status ===============\n",
+		label);
+	mdp_err("AAL_INTSTA: 0x%08x, AAL_STATUS: 0x%08x\n",
+		value[0], value[1]);
+	mdp_err("AAL_INPUT_COUNT: 0x%08x, AAL_OUTPUT_COUNT: 0x%08x\n",
+		value[2], value[3]);
+	mdp_err("AAL_SIZE: 0x%08x\n", value[4]);
+	mdp_err("AAL_OUTPUT_SIZE: 0x%08x, AAL_OUTPUT_OFFSET: 0x%08x\n",
+		value[5], value[6]);
+	mdp_err("AAL_TILE_00: 0x%08x, AAL_TILE_01: 0x%08x\n",
+		value[7], value[8]);
+}
+void mdp_dump_ccorr(void __iomem *base, const char *label)
+{
+	uint32_t value[5] = { 0 };
+
+	if (base == 0) {
+		mdp_err("=============== [MDP] %s Status ===============\n",
+			label);
+		mdp_err("%s:base=0!\n", __func__);
+		return;
+	}
+
+	value[0] = MDP_REG_GET32(base + 0x00C);/* MDP_CCORR_INTSTA         */
+	value[1] = MDP_REG_GET32(base + 0x010);/* MDP_CCORR_STATUS         */
+	value[2] = MDP_REG_GET32(base + 0x024);/* MDP_CCORR_INPUT_COUNT    */
+	value[3] = MDP_REG_GET32(base + 0x028);/* MDP_CCORR_OUTPUT_COUNT   */
+	value[4] = MDP_REG_GET32(base + 0x030);/* MDP_CCORR_SIZE       */
+	mdp_err("=============== [MDP] %s Status ===============\n",
+		label);
+	mdp_err("CCORR_INTSTA: 0x%08x, CCORR_STATUS: 0x%08x\n",
+		value[0], value[1]);
+	mdp_err("CCORR_INPUT_COUNT: 0x%08x, CCORR_OUTPUT_COUNT: 0x%08x\n",
+		value[2], value[3]);
+	mdp_err("CCORR_SIZE: 0x%08x\n",
+		value[4]);
+}
+
+uint32_t mdp_rdma_get_reg_offset_src_addr(void)
+{
+	return 0xF00;
+}
+
+uint32_t mdp_wrot_get_reg_offset_dst_addr(void)
+{
+	return 0xF00;
+}
+
+uint32_t mdp_wdma_get_reg_offset_dst_addr(void)
+{
+	return 0xF00;
+}
+
+void mdp_platform_function_setting(void)
+{
+	struct mdp_func_struct *pFunc = mdp_get_func();
+
+	pFunc->mdp_dump_mmsys_config = mdp_dump_mmsys_config;
+	pFunc->mdp_dump_rsz = mdp_dump_rsz;
+	pFunc->mdp_dump_tdshp = mdp_dump_tdshp;
+	pFunc->mdp_rdma_get_src_base_addr = mdp_rdma_get_reg_offset_src_addr;
+	pFunc->mdp_wrot_get_reg_offset_dst_addr =
+		mdp_wrot_get_reg_offset_dst_addr;
+	pFunc->mdp_wdma_get_reg_offset_dst_addr =
+		mdp_wdma_get_reg_offset_dst_addr;
+}
+
+int32_t mdp_dump_info(uint64_t comp_flag, int log_level)
+{
+	if (comp_flag & (1LL << MDP_COMP_RDMA0))
+		mdp_dump_rdma_common(MDP_RDMA0_BASE, "RDMA0");
+	if (comp_flag & (1LL << MDP_COMP_AAL0))
+		mdp_dump_aal(MDP_AAL_BASE, "AAL0");
+	if (comp_flag & (1LL << MDP_COMP_CCORR0))
+		mdp_dump_ccorr(MDP_CCORR_BASE, "CCORR0");
+	if (comp_flag & (1LL << MDP_COMP_RSZ0))
+		mdp_get_func()->mdp_dump_rsz(MDP_RSZ0_BASE, "RSZ0");
+	if (comp_flag & (1LL << MDP_COMP_RSZ1))
+		mdp_get_func()->mdp_dump_rsz(MDP_RSZ1_BASE, "RSZ1");
+	if (comp_flag & (1LL << MDP_COMP_TDSHP0))
+		mdp_get_func()->mdp_dump_tdshp(MDP_TDSHP_BASE, "TDSHP");
+	if (comp_flag & (1LL << MDP_COMP_COLOR0))
+		mdp_dump_color_common(MDP_COLOR_BASE, "COLOR0");
+	if (comp_flag & (1LL << MDP_COMP_WROT0))
+		mdp_dump_rot_common(MDP_WROT0_BASE, "WROT0");
+	if (comp_flag & (1LL << MDP_COMP_WDMA))
+		mdp_dump_wdma_common(MDP_WDMA_BASE, "WDMA");
+
+	return 0;
+}
+
+void mdp_debug_init(struct platform_device *pDevice)
+{
+	pr_err("%s:start\n", __func__);
+	g_mdp_debug.mdp_device = pDevice;
+
+	mdp_init_module_base_VA();
+	mdp_map_mmsys_VA();
+	mdp_virtual_function_setting();
+	mdp_platform_function_setting();
+
+	pr_err("%s:end\n", __func__);
+}
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-debug.h b/drivers/media/platform/mtk-mdp3/mtk-mdp3-debug.h
new file mode 100644
index 000000000000..537602f42209
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-debug.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Daoyuan Huang <daoyuan.huang@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_MDP3_DEBUG_H__
+#define __MTK_MDP3_DEBUG_H__
+
+#include <linux/soc/mediatek/mtk-cmdq.h>
+
+struct mdp_func_struct {
+	void (*mdp_dump_mmsys_config)(void);
+	void (*mdp_dump_rsz)(void __iomem *base, const char *label);
+	void (*mdp_dump_tdshp)(void __iomem *base, const char *label);
+	uint32_t (*mdp_rdma_get_src_base_addr)(void);
+	uint32_t (*mdp_wrot_get_reg_offset_dst_addr)(void);
+	uint32_t (*mdp_wdma_get_reg_offset_dst_addr)(void);
+};
+
+void mdp_debug_init(struct platform_device *pDevice);
+struct mdp_func_struct *mdp_get_func(void);
+const char *mdp_get_rsz_state(const uint32_t state);
+void mdp_dump_rdma_common(void __iomem *base, const char *label);
+void mdp_dump_rot_common(void __iomem *base, const char *label);
+void mdp_dump_color_common(void __iomem *base, const char *label);
+int32_t mdp_dump_info(uint64_t comp_flag, int log_level);
+
+
+#endif  /* __MTK_MDP3_DEBUG_H__ */
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-m2m.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-m2m.c
new file mode 100644
index 000000000000..98a9cfa770a8
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-m2m.c
@@ -0,0 +1,824 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/platform_device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-event.h>
+#include <media/videobuf2-dma-contig.h>
+#include "mtk-mdp3-m2m.h"
+#ifdef MDP_UT
+int mdp_ut(struct mdp_dev *mdp);
+#endif
+
+static inline struct mdp_m2m_ctx *fh_to_ctx(struct v4l2_fh *fh)
+{
+	return container_of(fh, struct mdp_m2m_ctx, fh);
+}
+
+static inline struct mdp_m2m_ctx *ctrl_to_ctx(struct v4l2_ctrl *ctrl)
+{
+	return container_of(ctrl->handler, struct mdp_m2m_ctx, ctrl_handler);
+}
+
+static inline struct mdp_frame *ctx_get_frame(struct mdp_m2m_ctx *ctx,
+					      enum v4l2_buf_type type)
+{
+	if (V4L2_TYPE_IS_OUTPUT(type))
+		return &ctx->curr_param->output;
+	return &ctx->curr_param->captures[0];
+}
+
+static void mdp_m2m_ctx_set_state(struct mdp_m2m_ctx *ctx, u32 state)
+{
+	mutex_lock(&ctx->curr_param->lock);
+	ctx->curr_param->state |= state;
+	mutex_unlock(&ctx->curr_param->lock);
+}
+
+static bool mdp_m2m_ctx_is_state_set(struct mdp_m2m_ctx *ctx, u32 mask)
+{
+	bool ret;
+
+	mutex_lock(&ctx->curr_param->lock);
+	ret = (ctx->curr_param->state & mask) == mask;
+	mutex_unlock(&ctx->curr_param->lock);
+	return ret;
+}
+
+static void mdp_m2m_ctx_lock(struct vb2_queue *q)
+{
+	struct mdp_m2m_ctx *ctx = vb2_get_drv_priv(q);
+
+	mutex_lock(&ctx->mdp_dev->m2m_lock);
+}
+
+static void mdp_m2m_ctx_unlock(struct vb2_queue *q)
+{
+	struct mdp_m2m_ctx *ctx = vb2_get_drv_priv(q);
+
+	mutex_unlock(&ctx->mdp_dev->m2m_lock);
+}
+
+static void mdp_m2m_job_abort(void *priv)
+{
+}
+
+static void mdp_m2m_process_done(void *priv, int vb_state)
+{
+	struct mdp_m2m_ctx *ctx = priv;
+	struct vb2_v4l2_buffer *src_vbuf, *dst_vbuf;
+	u32 valid_output_flags = V4L2_BUF_FLAG_TIMECODE |
+				 V4L2_BUF_FLAG_TSTAMP_SRC_MASK |
+				 V4L2_BUF_FLAG_KEYFRAME |
+				 V4L2_BUF_FLAG_PFRAME |V4L2_BUF_FLAG_BFRAME;
+
+	src_vbuf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);
+	dst_vbuf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);
+
+	src_vbuf->sequence = ctx->frame_count;
+	dst_vbuf->sequence = src_vbuf->sequence;
+	dst_vbuf->timecode = src_vbuf->timecode;
+	dst_vbuf->flags &= ~valid_output_flags;
+	dst_vbuf->flags |= src_vbuf->flags & valid_output_flags;
+
+	v4l2_m2m_buf_done(src_vbuf, vb_state);
+	v4l2_m2m_buf_done(dst_vbuf, vb_state);
+	v4l2_m2m_job_finish(ctx->mdp_dev->m2m_dev, ctx->m2m_ctx);
+
+	ctx->curr_param->frame_no = ctx->frame_count++;
+}
+
+static void mdp_m2m_worker(struct work_struct *work)
+{
+	struct mdp_m2m_ctx *ctx = container_of(work, struct mdp_m2m_ctx, work);
+	struct mdp_frame *frame;
+	struct vb2_v4l2_buffer *src_vb, *dst_vb;
+	struct img_ipi_frameparam param = {0};
+	struct mdp_cmdq_param task = {0};
+	enum vb2_buffer_state vb_state = VB2_BUF_STATE_ERROR;
+	int ret;
+
+	if (mdp_m2m_ctx_is_state_set(ctx, MDP_M2M_CTX_ERROR)) {
+		dev_err(&ctx->mdp_dev->pdev->dev,
+			"mdp_m2m_ctx is in error state\n");
+		goto worker_end;
+	}
+
+	param.frame_no = ctx->curr_param->frame_no;
+	param.type = ctx->curr_param->type;
+	param.num_inputs = 1;
+	param.num_outputs = 1;
+
+	frame = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+	src_vb = v4l2_m2m_next_src_buf(ctx->m2m_ctx);
+	mdp_set_src_config(&param.inputs[0], frame, &src_vb->vb2_buf);
+
+	frame = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	dst_vb = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);
+	mdp_set_dst_config(&param.outputs[0], frame, &dst_vb->vb2_buf);
+
+	dst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;
+	param.timestamp = src_vb->vb2_buf.timestamp;
+
+	ret = mdp_vpu_process(&ctx->vpu, &param);
+	if (ret) {
+		dev_err(&ctx->mdp_dev->pdev->dev,
+			"VPU MDP process failed: %d\n", ret);
+		goto worker_end;
+	}
+
+	task.config = ctx->vpu.config;
+	task.param = &param;
+	task.composes[0] = &frame->compose;
+	task.wait = 1;
+	task.cmdq_cb = NULL;
+	task.cb_data = NULL;
+
+	ret = mdp_cmdq_send(ctx->mdp_dev, &task);
+	if (ret) {
+		dev_err(&ctx->mdp_dev->pdev->dev,
+			"CMDQ sendtask failed: %d\n", ret);
+		goto worker_end;
+	}
+
+	vb_state = VB2_BUF_STATE_DONE;
+
+worker_end:
+	mdp_m2m_process_done(ctx, vb_state);
+}
+
+static void mdp_m2m_device_run(void *priv)
+{
+	struct mdp_m2m_ctx *ctx = priv;
+
+	queue_work(ctx->mdp_dev->job_wq, &ctx->work);
+}
+
+static int mdp_m2m_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct mdp_m2m_ctx *ctx = vb2_get_drv_priv(q);
+	int ret;
+
+	ret = 0;//pm_runtime_get_sync(&ctx->mdp_dev->pdev->dev);
+	if (ret < 0)
+		mdp_dbg(1, "[%d] pm_runtime_get_sync failed:%d", ctx->id, ret);
+
+	ctx->frame_count = 0;
+
+	return 0;
+}
+
+static struct vb2_v4l2_buffer *mdp_m2m_buf_remove(struct mdp_m2m_ctx *ctx,
+						  unsigned int type)
+{
+	if (V4L2_TYPE_IS_OUTPUT(type))
+		return v4l2_m2m_src_buf_remove(ctx->m2m_ctx);
+	return v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);
+}
+
+static void mdp_m2m_stop_streaming(struct vb2_queue *q)
+{
+	struct mdp_m2m_ctx *ctx = vb2_get_drv_priv(q);
+	struct vb2_v4l2_buffer *vb;
+
+	vb = mdp_m2m_buf_remove(ctx, q->type);
+	while (vb) {
+		v4l2_m2m_buf_done(vb, VB2_BUF_STATE_ERROR);
+		vb = mdp_m2m_buf_remove(ctx, q->type);
+	}
+
+	//pm_runtime_put(&ctx->mdp_dev->pdev->dev);
+}
+
+static int mdp_m2m_queue_setup(struct vb2_queue *q,
+			       unsigned int *num_buffers,
+			       unsigned int *num_planes, unsigned int sizes[],
+			       struct device *alloc_devs[])
+{
+	struct mdp_m2m_ctx *ctx = vb2_get_drv_priv(q);
+	struct v4l2_pix_format_mplane *pix_mp;
+	u32 i;
+
+	pix_mp = &ctx_get_frame(ctx, q->type)->format.fmt.pix_mp;
+
+	/* from VIDIOC_CREATE_BUFS */
+	if (*num_planes) {
+		if (*num_planes != pix_mp->num_planes)
+			return -EINVAL;
+		for (i = 0; i < pix_mp->num_planes; ++i)
+			if (sizes[i] < pix_mp->plane_fmt[i].sizeimage)
+				return -EINVAL;
+	} else {/* from VIDIOC_REQBUFS */
+		*num_planes = pix_mp->num_planes;
+		for (i = 0; i < pix_mp->num_planes; ++i)
+			sizes[i] = pix_mp->plane_fmt[i].sizeimage;
+	}
+
+	mdp_dbg(2, "[%d] type:%d, planes:%u, buffers:%u, size:%u,%u,%u",
+		ctx->id, q->type, *num_planes, *num_buffers,
+		sizes[0], sizes[1], sizes[2]);
+	return 0;
+}
+
+static int mdp_m2m_buf_prepare(struct vb2_buffer *vb)
+{
+	struct mdp_m2m_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
+	struct v4l2_pix_format_mplane *pix_mp;
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+	u32 i;
+
+	v4l2_buf->field = V4L2_FIELD_NONE;
+
+	if (!V4L2_TYPE_IS_OUTPUT(vb->type)) {
+		pix_mp = &ctx_get_frame(ctx, vb->type)->format.fmt.pix_mp;
+		for (i = 0; i < pix_mp->num_planes; ++i) {
+			vb2_set_plane_payload(vb, i,
+					      pix_mp->plane_fmt[i].sizeimage);
+		}
+	}
+	return 0;
+}
+
+static int mdp_m2m_buf_out_validate(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+
+	v4l2_buf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static void mdp_m2m_buf_queue(struct vb2_buffer *vb)
+{
+	struct mdp_m2m_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+
+	v4l2_buf->field = V4L2_FIELD_NONE;
+
+	v4l2_m2m_buf_queue(ctx->m2m_ctx, to_vb2_v4l2_buffer(vb));
+}
+
+static const struct vb2_ops mdp_m2m_qops = {
+	.queue_setup	= mdp_m2m_queue_setup,
+	.wait_prepare	= mdp_m2m_ctx_unlock,
+	.wait_finish	= mdp_m2m_ctx_lock,
+	.buf_prepare	= mdp_m2m_buf_prepare,
+	.start_streaming = mdp_m2m_start_streaming,
+	.stop_streaming	= mdp_m2m_stop_streaming,
+	.buf_queue	= mdp_m2m_buf_queue,
+	.buf_out_validate = mdp_m2m_buf_out_validate,
+};
+
+static int mdp_m2m_querycap(struct file *file, void *fh,
+			    struct v4l2_capability *cap)
+{
+	struct mdp_m2m_ctx *ctx = fh_to_ctx(fh);
+
+	strlcpy(cap->driver, MDP_MODULE_NAME, sizeof(cap->driver));
+	strlcpy(cap->card, ctx->mdp_dev->pdev->name, sizeof(cap->card));
+	strlcpy(cap->bus_info, "platform:mt8183", sizeof(cap->bus_info));
+	cap->capabilities = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING |
+			V4L2_CAP_DEVICE_CAPS; /* | V4L2_CAP_META_OUTPUT */
+	cap->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;
+	return 0;
+}
+
+static int mdp_m2m_enum_fmt_mplane(struct file *file, void *fh,
+				   struct v4l2_fmtdesc *f)
+{
+	return mdp_enum_fmt_mplane(f);
+}
+
+static int mdp_m2m_g_fmt_mplane(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct mdp_m2m_ctx *ctx = fh_to_ctx(fh);
+	struct mdp_frame *frame;
+	struct v4l2_pix_format_mplane *pix_mp;
+
+	frame = ctx_get_frame(ctx, f->type);
+	*f = frame->format;
+	pix_mp = &f->fmt.pix_mp;
+	pix_mp->colorspace = ctx->curr_param->colorspace;
+	pix_mp->xfer_func = ctx->curr_param->xfer_func;
+	pix_mp->ycbcr_enc = ctx->curr_param->ycbcr_enc;
+	pix_mp->quantization = ctx->curr_param->quant;
+
+	mdp_dbg(2, "[%d] type:%d, frame:%ux%u colorspace=%d", ctx->id, f->type,
+		f->fmt.pix_mp.width, f->fmt.pix_mp.height,
+		f->fmt.pix_mp.colorspace);
+	return 0;
+}
+
+static int mdp_m2m_s_fmt_mplane(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct mdp_m2m_ctx *ctx = fh_to_ctx(fh);
+	struct mdp_frame *frame = ctx_get_frame(ctx, f->type);
+	struct mdp_frame *capture;
+	const struct mdp_format *fmt;
+	struct vb2_queue *vq;
+
+	mdp_dbg(2, "[%d] type:%d", ctx->id, f->type);
+
+	fmt = mdp_try_fmt_mplane(f, ctx->curr_param, ctx->id);
+	if (!fmt) {
+		mdp_err("[%d] try_fmt failed, type:%d", ctx->id, f->type);
+		return -EINVAL;
+	}
+
+	vq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);
+	if (vb2_is_streaming(vq)) {
+		dev_info(&ctx->mdp_dev->pdev->dev, "Queue %d busy\n", f->type);
+		return -EBUSY;
+	}
+
+	frame->format = *f;
+	frame->mdp_fmt = fmt;
+	frame->ycbcr_prof = mdp_map_ycbcr_prof_mplane(f, fmt->mdp_color);
+	frame->usage = V4L2_TYPE_IS_OUTPUT(f->type) ?
+		MDP_BUFFER_USAGE_HW_READ : MDP_BUFFER_USAGE_MDP;
+
+	capture = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	if (V4L2_TYPE_IS_OUTPUT(f->type)) {
+		capture->crop.c.left = 0;
+		capture->crop.c.top = 0;
+		capture->crop.c.width = f->fmt.pix_mp.width;
+		capture->crop.c.height = f->fmt.pix_mp.height;
+		ctx->curr_param->colorspace = f->fmt.pix_mp.colorspace;
+		ctx->curr_param->ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;
+		ctx->curr_param->quant = f->fmt.pix_mp.quantization;
+		ctx->curr_param->xfer_func = f->fmt.pix_mp.xfer_func;
+
+		mdp_m2m_ctx_set_state(ctx, MDP_M2M_SRC_FMT);
+	} else {
+		capture->compose.left = 0;
+		capture->compose.top = 0;
+		capture->compose.width = f->fmt.pix_mp.width;
+		capture->compose.height = f->fmt.pix_mp.height;
+
+		mdp_m2m_ctx_set_state(ctx, MDP_M2M_DST_FMT);
+	}
+
+	ctx->frame_count = 0;
+
+	mdp_dbg(2, "[%d] type:%d, frame:%ux%u", ctx->id, f->type,
+		f->fmt.pix_mp.width, f->fmt.pix_mp.height);
+	return 0;
+}
+
+static int mdp_m2m_try_fmt_mplane(struct file *file, void *fh,
+				  struct v4l2_format *f)
+{
+	struct mdp_m2m_ctx *ctx = fh_to_ctx(fh);
+
+	if (!mdp_try_fmt_mplane(f, ctx->curr_param, ctx->id))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int mdp_m2m_reqbufs(struct file *file, void *fh,
+			   struct v4l2_requestbuffers *reqbufs)
+{
+	struct mdp_m2m_ctx *ctx = fh_to_ctx(fh);
+
+	return v4l2_m2m_reqbufs(file, ctx->m2m_ctx, reqbufs);
+}
+
+static int mdp_m2m_streamon(struct file *file, void *fh,
+			    enum v4l2_buf_type type)
+{
+	struct mdp_m2m_ctx *ctx = fh_to_ctx(fh);
+	int ret;
+
+	/* The source and target color formats need to be set */
+	if (V4L2_TYPE_IS_OUTPUT(type)) {
+		if (!mdp_m2m_ctx_is_state_set(ctx, MDP_M2M_SRC_FMT))
+			return -EINVAL;
+	} else {
+		if (!mdp_m2m_ctx_is_state_set(ctx, MDP_M2M_DST_FMT))
+			return -EINVAL;
+	}
+
+	if (!mdp_m2m_ctx_is_state_set(ctx, MDP_VPU_INIT)) {
+		ret = mdp_vpu_ctx_init(&ctx->vpu, &ctx->mdp_dev->vpu,
+				       MDP_DEV_M2M);
+		if (ret) {
+			dev_err(&ctx->mdp_dev->pdev->dev,
+				"VPU init failed %d\n", ret);
+			return -EINVAL;
+		}
+		mdp_m2m_ctx_set_state(ctx, MDP_VPU_INIT);
+	}
+
+	return v4l2_m2m_streamon(file, ctx->m2m_ctx, type);
+}
+
+static int mdp_m2m_g_selection(struct file *file, void *fh,
+			       struct v4l2_selection *s)
+{
+	struct mdp_m2m_ctx *ctx = fh_to_ctx(fh);
+	struct mdp_frame *frame;
+	bool valid = false;
+
+	if (s->type <= V4L2_BUF_TYPE_META_OUTPUT) {
+		if (V4L2_TYPE_IS_OUTPUT(s->type))
+			valid = mdp_target_is_crop(s->target);
+		else
+			valid = mdp_target_is_compose(s->target);
+	}
+
+	if (!valid) {
+		mdp_dbg(1, "[%d] invalid type:%u target:%u", ctx->id, s->type,
+			s->target);
+		return -EINVAL;
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		frame = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+		s->r = frame->crop.c;
+		return 0;
+	case V4L2_SEL_TGT_COMPOSE:
+		frame = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+		s->r = frame->compose;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+		frame = ctx_get_frame(ctx, s->type);
+		s->r.left = 0;
+		s->r.top = 0;
+		s->r.width = frame->format.fmt.pix_mp.width;
+		s->r.height = frame->format.fmt.pix_mp.height;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int mdp_m2m_s_selection(struct file *file, void *fh,
+			       struct v4l2_selection *s)
+{
+	struct mdp_m2m_ctx *ctx = fh_to_ctx(fh);
+	struct mdp_frame *frame = ctx_get_frame(ctx, s->type);
+	struct mdp_frame *capture;
+	struct v4l2_rect r;
+	bool valid = false;
+	int ret;
+
+	if (s->type <= V4L2_BUF_TYPE_META_OUTPUT) {
+		if (V4L2_TYPE_IS_OUTPUT(s->type))
+			valid = (s->target == V4L2_SEL_TGT_CROP);
+		else
+			valid = (s->target == V4L2_SEL_TGT_COMPOSE);
+	}
+	if (!valid) {
+		mdp_dbg(1, "[%d] invalid type:%u target:%u", ctx->id, s->type,
+			s->target);
+		return -EINVAL;
+	}
+
+	ret = mdp_try_crop(&r, s, frame, ctx->id);
+	if (ret)
+		return ret;
+	capture = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+
+	/* Check to see if scaling ratio is within supported range */
+	if (mdp_m2m_ctx_is_state_set(ctx, MDP_M2M_DST_FMT | MDP_M2M_SRC_FMT)) {
+		if (mdp_target_is_crop(s->target)) {
+			ret = mdp_check_scaling_ratio(&r, &capture->compose,
+						      capture->rotation,
+						      ctx->curr_param->limit);
+		} else {
+			ret = mdp_check_scaling_ratio(&capture->crop.c, &r,
+						      capture->rotation,
+						      ctx->curr_param->limit);
+		}
+
+		if (ret) {
+			dev_info(&ctx->mdp_dev->pdev->dev,
+				 "Out of scaling range\n");
+			return ret;
+		}
+	}
+
+	if (mdp_target_is_crop(s->target))
+		capture->crop.c = r;
+	else
+		capture->compose = r;
+
+	s->r = r;
+	memset(s->reserved, 0, sizeof(s->reserved));
+
+	ctx->frame_count = 0;
+	return 0;
+}
+
+static const struct v4l2_ioctl_ops mdp_m2m_ioctl_ops = {
+	.vidioc_querycap		= mdp_m2m_querycap,
+	.vidioc_enum_fmt_vid_cap	= mdp_m2m_enum_fmt_mplane,
+	.vidioc_enum_fmt_vid_out	= mdp_m2m_enum_fmt_mplane,
+	.vidioc_g_fmt_vid_cap_mplane	= mdp_m2m_g_fmt_mplane,
+	.vidioc_g_fmt_vid_out_mplane	= mdp_m2m_g_fmt_mplane,
+	.vidioc_s_fmt_vid_cap_mplane	= mdp_m2m_s_fmt_mplane,
+	.vidioc_s_fmt_vid_out_mplane	= mdp_m2m_s_fmt_mplane,
+	.vidioc_try_fmt_vid_cap_mplane	= mdp_m2m_try_fmt_mplane,
+	.vidioc_try_fmt_vid_out_mplane	= mdp_m2m_try_fmt_mplane,
+	.vidioc_reqbufs			= mdp_m2m_reqbufs,
+	.vidioc_querybuf		= v4l2_m2m_ioctl_querybuf,
+	.vidioc_qbuf			= v4l2_m2m_ioctl_qbuf,
+	.vidioc_expbuf			= v4l2_m2m_ioctl_expbuf,
+	.vidioc_dqbuf			= v4l2_m2m_ioctl_dqbuf,
+	.vidioc_create_bufs		= v4l2_m2m_ioctl_create_bufs,
+	.vidioc_streamon		= mdp_m2m_streamon,
+	.vidioc_streamoff		= v4l2_m2m_ioctl_streamoff,
+	.vidioc_g_selection		= mdp_m2m_g_selection,
+	.vidioc_s_selection		= mdp_m2m_s_selection,
+	.vidioc_subscribe_event		= v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event	= v4l2_event_unsubscribe,
+};
+
+static int mdp_m2m_queue_init(void *priv,
+			      struct vb2_queue *src_vq,
+			      struct vb2_queue *dst_vq)
+{
+	struct mdp_m2m_ctx *ctx = priv;
+	int ret;
+
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	src_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	src_vq->ops = &mdp_m2m_qops;
+	src_vq->mem_ops = &vb2_dma_contig_memops;
+	src_vq->drv_priv = ctx;
+	src_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
+	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	src_vq->dev = &ctx->mdp_dev->pdev->dev;
+
+	ret = vb2_queue_init(src_vq);
+	if (ret)
+		return ret;
+
+	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	dst_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	dst_vq->ops = &mdp_m2m_qops;
+	dst_vq->mem_ops = &vb2_dma_contig_memops;
+	dst_vq->drv_priv = ctx;
+	dst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
+	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	dst_vq->dev = &ctx->mdp_dev->pdev->dev;
+
+	return vb2_queue_init(dst_vq);
+}
+
+static int mdp_m2m_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mdp_m2m_ctx *ctx = ctrl_to_ctx(ctrl);
+	struct mdp_frame *capture;
+
+	if (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)
+		return 0;
+
+	capture = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	switch (ctrl->id) {
+	case V4L2_CID_HFLIP:
+		capture->hflip = ctrl->val;
+		break;
+	case V4L2_CID_VFLIP:
+		capture->vflip = ctrl->val;
+		break;
+	case V4L2_CID_ROTATE:
+		if (mdp_m2m_ctx_is_state_set(ctx,
+					     MDP_M2M_DST_FMT |
+					     MDP_M2M_SRC_FMT)) {
+			int ret = mdp_check_scaling_ratio(&capture->crop.c,
+				&capture->compose, ctrl->val,
+				ctx->curr_param->limit);
+
+			if (ret)
+				return ret;
+		}
+		capture->rotation = ctrl->val;
+		break;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops mdp_m2m_ctrl_ops = {
+	.s_ctrl	= mdp_m2m_s_ctrl,
+};
+
+static int mdp_m2m_ctrls_create(struct mdp_m2m_ctx *ctx)
+{
+	v4l2_ctrl_handler_init(&ctx->ctrl_handler, MDP_MAX_CTRLS);
+	ctx->ctrls.hflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,
+					     &mdp_m2m_ctrl_ops, V4L2_CID_HFLIP,
+					     0, 1, 1, 0);
+	ctx->ctrls.vflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,
+					     &mdp_m2m_ctrl_ops, V4L2_CID_VFLIP,
+					     0, 1, 1, 0);
+	ctx->ctrls.rotate = v4l2_ctrl_new_std(&ctx->ctrl_handler,
+					      &mdp_m2m_ctrl_ops,
+					      V4L2_CID_ROTATE, 0, 270, 90, 0);
+
+	if (ctx->ctrl_handler.error) {
+		int err = ctx->ctrl_handler.error;
+
+		v4l2_ctrl_handler_free(&ctx->ctrl_handler);
+		dev_err(&ctx->mdp_dev->pdev->dev,
+			"Failed to create control handler\n");
+		return err;
+	}
+	return 0;
+}
+
+static int mdp_m2m_open(struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct mdp_dev *mdp = video_get_drvdata(vdev);
+	struct mdp_m2m_ctx *ctx;
+	int ret;
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	if (mutex_lock_interruptible(&mdp->m2m_lock)) {
+		ret = -ERESTARTSYS;
+		goto err_lock;
+	}
+
+	ctx->id = mdp->id_count++;
+	ctx->mdp_dev = mdp;
+
+	v4l2_fh_init(&ctx->fh, vdev);
+	vdev->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;
+	file->private_data = &ctx->fh;
+	ret = mdp_m2m_ctrls_create(ctx);
+	if (ret)
+		goto err_ctrls_create;
+
+	/* Use separate control handler per file handle */
+	ctx->fh.ctrl_handler = &ctx->ctrl_handler;
+	v4l2_fh_add(&ctx->fh);
+
+	ctx->m2m_ctx = v4l2_m2m_ctx_init(mdp->m2m_dev, ctx, mdp_m2m_queue_init);
+	if (IS_ERR(ctx->m2m_ctx)) {
+		dev_err(&mdp->pdev->dev, "Failed to initialize m2m context\n");
+		ret = PTR_ERR(ctx->m2m_ctx);
+		goto err_m2m_ctx;
+	}
+	ctx->fh.m2m_ctx = ctx->m2m_ctx;
+
+	INIT_WORK(&ctx->work, mdp_m2m_worker);
+	ctx->frame_count = 0;
+
+	ctx->curr_param = mdp_frameparam_init();
+	if (IS_ERR(ctx->curr_param)) {
+		dev_err(&mdp->pdev->dev,
+			"Failed to initialize mdp parameter\n");
+		ret = PTR_ERR(ctx->curr_param);
+		goto err_param_init;
+	}
+	ctx->curr_param->type = MDP_STREAM_TYPE_BITBLT;
+
+	INIT_LIST_HEAD(&ctx->param_list);
+	list_add_tail(&ctx->curr_param->list, &ctx->param_list);
+
+	ret = mdp_vpu_get_locked(mdp);
+	if (ret < 0)
+		goto err_load_vpu;
+
+	mutex_unlock(&mdp->m2m_lock);
+
+	mdp_dbg(0, "%s [%d]", dev_name(&mdp->pdev->dev), ctx->id);
+
+	return 0;
+
+err_load_vpu:
+	mdp_frameparam_release(ctx->curr_param);
+err_param_init:
+	v4l2_m2m_ctx_release(ctx->m2m_ctx);
+err_m2m_ctx:
+	v4l2_ctrl_handler_free(&ctx->ctrl_handler);
+	v4l2_fh_del(&ctx->fh);
+err_ctrls_create:
+	v4l2_fh_exit(&ctx->fh);
+	mutex_unlock(&mdp->m2m_lock);
+err_lock:
+	kfree(ctx);
+
+	return ret;
+}
+
+static int mdp_m2m_release(struct file *file)
+{
+	struct mdp_m2m_ctx *ctx = fh_to_ctx(file->private_data);
+	struct mdp_dev *mdp = video_drvdata(file);
+	struct mdp_frameparam *param, *n;
+
+	flush_workqueue(mdp->job_wq);
+	mutex_lock(&mdp->m2m_lock);
+	if (mdp_m2m_ctx_is_state_set(ctx, MDP_VPU_INIT))
+		mdp_vpu_ctx_deinit(&ctx->vpu);
+	mdp_vpu_put_locked(mdp);
+	list_for_each_entry_safe(param, n, &ctx->param_list, list) {
+		mdp_frameparam_release(param);
+	}
+
+	v4l2_m2m_ctx_release(ctx->m2m_ctx);
+	v4l2_ctrl_handler_free(&ctx->ctrl_handler);
+	v4l2_fh_del(&ctx->fh);
+	v4l2_fh_exit(&ctx->fh);
+	mutex_unlock(&mdp->m2m_lock);
+
+	mdp_dbg(0, "%s [%d]", dev_name(&mdp->pdev->dev), ctx->id);
+	kfree(ctx);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations mdp_m2m_fops = {
+	.owner		= THIS_MODULE,
+	.poll		= v4l2_m2m_fop_poll,
+	.unlocked_ioctl	= video_ioctl2,
+	.mmap		= v4l2_m2m_fop_mmap,
+	.open		= mdp_m2m_open,
+	.release	= mdp_m2m_release,
+};
+
+static const struct v4l2_m2m_ops mdp_m2m_ops = {
+	.device_run	= mdp_m2m_device_run,
+	.job_abort	= mdp_m2m_job_abort,
+};
+
+int mdp_m2m_device_register(struct mdp_dev *mdp)
+{
+	struct device *dev = &mdp->pdev->dev;
+	int ret = 0;
+
+	mdp->m2m_vdev = video_device_alloc();
+	if (!mdp->m2m_vdev) {
+		dev_err(dev, "Failed to allocate video device\n");
+		ret = -ENOMEM;
+		goto err_video_alloc;
+	}
+	//mdp->m2m_vdev->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE |
+	//	V4L2_CAP_STREAMING;
+	mdp->m2m_vdev->fops = &mdp_m2m_fops;
+	mdp->m2m_vdev->ioctl_ops = &mdp_m2m_ioctl_ops;
+	mdp->m2m_vdev->release = video_device_release;
+	mdp->m2m_vdev->lock = &mdp->m2m_lock;
+	mdp->m2m_vdev->vfl_dir = VFL_DIR_M2M;
+	mdp->m2m_vdev->v4l2_dev = &mdp->v4l2_dev;
+	snprintf(mdp->m2m_vdev->name, sizeof(mdp->m2m_vdev->name), "%s:m2m",
+		 MDP_MODULE_NAME);
+	video_set_drvdata(mdp->m2m_vdev, mdp);
+
+	mdp->m2m_dev = v4l2_m2m_init(&mdp_m2m_ops);
+	if (IS_ERR(mdp->m2m_dev)) {
+		dev_err(dev, "Failed to initialize v4l2-m2m device\n");
+		ret = PTR_ERR(mdp->m2m_dev);
+		goto err_m2m_init;
+	}
+
+	ret = video_register_device(mdp->m2m_vdev, VFL_TYPE_GRABBER, 2);
+	if (ret) {
+		dev_err(dev, "Failed to register video device\n");
+		goto err_video_register;
+	}
+
+	v4l2_info(&mdp->v4l2_dev, "Driver registered as /dev/video%d",
+		  mdp->m2m_vdev->num);
+	return 0;
+
+err_video_register:
+	v4l2_m2m_release(mdp->m2m_dev);
+err_m2m_init:
+	video_device_release(mdp->m2m_vdev);
+err_video_alloc:
+
+	return ret;
+}
+
+void mdp_m2m_device_unregister(struct mdp_dev *mdp)
+{
+	video_unregister_device(mdp->m2m_vdev);
+	video_device_release(mdp->m2m_vdev);
+	v4l2_m2m_release(mdp->m2m_dev);
+}
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-m2m.h b/drivers/media/platform/mtk-mdp3/mtk-mdp3-m2m.h
new file mode 100644
index 000000000000..1f681b48c2ad
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-m2m.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_MDP3_M2M_H__
+#define __MTK_MDP3_M2M_H__
+
+#include <media/v4l2-ctrls.h>
+#include "mtk-mdp3-core.h"
+#include "mtk-mdp3-vpu.h"
+#include "mtk-mdp3-regs.h"
+
+#define MDP_MAX_CTRLS	10
+
+struct mdp_m2m_ctrls {
+	struct v4l2_ctrl	*hflip;
+	struct v4l2_ctrl	*vflip;
+	/* struct v4l2_ctrl	*sharpness; */
+	struct v4l2_ctrl	*rotate;
+};
+
+struct mdp_m2m_ctx {
+	u32				id;
+	struct mdp_dev			*mdp_dev;
+	struct v4l2_fh			fh;
+	struct v4l2_ctrl_handler	ctrl_handler;
+	struct mdp_m2m_ctrls		ctrls;
+	struct v4l2_m2m_ctx		*m2m_ctx;
+	struct mdp_vpu_ctx		vpu;
+	struct work_struct		work;
+	u32				frame_count;
+
+	struct mdp_frameparam		*curr_param;
+	struct list_head		param_list;
+};
+
+int mdp_m2m_device_register(struct mdp_dev *mdp);
+void mdp_m2m_device_unregister(struct mdp_dev *mdp);
+
+#endif  /* __MTK_MDP3_M2M_H__ */
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.c
new file mode 100644
index 000000000000..b623eda06c7d
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.c
@@ -0,0 +1,757 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <media/v4l2-common.h>
+#include <media/videobuf2-v4l2.h>
+#include <media/videobuf2-dma-contig.h>
+#include "mtk-mdp3-core.h"
+#include "mtk-mdp3-regs.h"
+
+static const struct mdp_format mdp_formats[] = {
+	{
+		.pixelformat	= V4L2_PIX_FMT_GREY,
+		.mdp_color	= MDP_COLOR_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_RGB565X,
+		.mdp_color	= MDP_COLOR_RGB565,
+		.depth		= { 16 },
+		.row_depth	= { 16 },
+		.num_planes	= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_RGB565,
+		.mdp_color	= MDP_COLOR_BGR565,
+		.depth		= { 16 },
+		.row_depth	= { 16 },
+		.num_planes	= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_RGB24,
+		.mdp_color	= MDP_COLOR_RGB888,
+		.depth		= { 24 },
+		.row_depth	= { 24 },
+		.num_planes	= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_BGR24,
+		.mdp_color	= MDP_COLOR_BGR888,
+		.depth		= { 24 },
+		.row_depth	= { 24 },
+		.num_planes	= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_ABGR32,
+		.mdp_color	= MDP_COLOR_BGRA8888,
+		.depth		= { 32 },
+		.row_depth	= { 32 },
+		.num_planes	= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_ARGB32,
+		.mdp_color	= MDP_COLOR_ARGB8888,
+		.depth		= { 32 },
+		.row_depth	= { 32 },
+		.num_planes	= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_UYVY,
+		.mdp_color	= MDP_COLOR_UYVY,
+		.depth		= { 16 },
+		.row_depth	= { 16 },
+		.num_planes	= 1,
+		.walign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_VYUY,
+		.mdp_color	= MDP_COLOR_VYUY,
+		.depth		= { 16 },
+		.row_depth	= { 16 },
+		.num_planes	= 1,
+		.walign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_YUYV,
+		.mdp_color	= MDP_COLOR_YUYV,
+		.depth		= { 16 },
+		.row_depth	= { 16 },
+		.num_planes	= 1,
+		.walign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_YVYU,
+		.mdp_color	= MDP_COLOR_YVYU,
+		.depth		= { 16 },
+		.row_depth	= { 16 },
+		.num_planes	= 1,
+		.walign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_YUV420,
+		.mdp_color	= MDP_COLOR_I420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.walign		= 1,
+		.halign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_YVU420,
+		.mdp_color	= MDP_COLOR_YV12,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.walign		= 1,
+		.halign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_NV12,
+		.mdp_color	= MDP_COLOR_NV12,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.walign		= 1,
+		.halign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_NV21,
+		.mdp_color	= MDP_COLOR_NV21,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.walign		= 1,
+		.halign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_NV16,
+		.mdp_color	= MDP_COLOR_NV16,
+		.depth		= { 16 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.walign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_NV61,
+		.mdp_color	= MDP_COLOR_NV61,
+		.depth		= { 16 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.walign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_NV24,
+		.mdp_color	= MDP_COLOR_NV24,
+		.depth		= { 24 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_NV42,
+		.mdp_color	= MDP_COLOR_NV42,
+		.depth		= { 24 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_MT21C,
+		.mdp_color	= MDP_COLOR_420_BLK_UFO,
+		.depth		= { 8, 4 },
+		.row_depth	= { 8, 8 },
+		.num_planes	= 2,
+		.walign		= 4,
+		.halign		= 5,
+		.flags		= MDP_FMT_FLAG_OUTPUT,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_NV12MT,
+		.mdp_color	= MDP_COLOR_420_BLK,
+		.depth		= { 8, 4 },
+		.row_depth	= { 8, 8 },
+		.num_planes	= 2,
+		.walign		= 4,
+		.halign		= 5,
+		.flags		= MDP_FMT_FLAG_OUTPUT,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_NV12M,
+		.mdp_color	= MDP_COLOR_NV12,
+		.depth		= { 8, 4 },
+		.row_depth	= { 8, 8 },
+		.num_planes	= 2,
+		.walign		= 1,
+		.halign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_NV21M,
+		.mdp_color	= MDP_COLOR_NV21,
+		.depth		= { 8, 4 },
+		.row_depth	= { 8, 8 },
+		.num_planes	= 2,
+		.walign		= 1,
+		.halign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_NV16M,
+		.mdp_color	= MDP_COLOR_NV16,
+		.depth		= { 8, 8 },
+		.row_depth	= { 8, 8 },
+		.num_planes	= 2,
+		.walign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_NV61M,
+		.mdp_color	= MDP_COLOR_NV61,
+		.depth		= { 8, 8 },
+		.row_depth	= { 8, 8 },
+		.num_planes	= 2,
+		.walign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_YUV420M,
+		.mdp_color	= MDP_COLOR_I420,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.walign		= 1,
+		.halign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}, {
+		.pixelformat	= V4L2_PIX_FMT_YVU420M,
+		.mdp_color	= MDP_COLOR_YV12,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.walign		= 1,
+		.halign		= 1,
+		.flags		= MDP_FMT_FLAG_OUTPUT | MDP_FMT_FLAG_CAPTURE,
+	}
+};
+
+static const struct mdp_limit mdp_def_limit = {
+	.out_limit = {
+		.wmin	= 16,
+		.hmin	= 16,
+		.wmax	= 8176,
+		.hmax	= 8176,
+	},
+	.cap_limit = {
+		.wmin	= 2,
+		.hmin	= 2,
+		.wmax	= 8176,
+		.hmax	= 8176,
+	},
+	.h_scale_up_max = 32,
+	.v_scale_up_max = 32,
+	.h_scale_down_max = 20,
+	.v_scale_down_max = 128,
+};
+
+static const struct mdp_format *mdp_find_fmt(u32 pixelformat, u32 type)
+{
+	u32 i, flag;
+
+	flag = V4L2_TYPE_IS_OUTPUT(type) ? MDP_FMT_FLAG_OUTPUT :
+					MDP_FMT_FLAG_CAPTURE;
+	for (i = 0; i < ARRAY_SIZE(mdp_formats); ++i) {
+		if (!(mdp_formats[i].flags & flag))
+			continue;
+		if (mdp_formats[i].pixelformat == pixelformat)
+			return &mdp_formats[i];
+	}
+	return NULL;
+}
+
+static const struct mdp_format *mdp_find_fmt_by_index(u32 index, u32 type)
+{
+	u32 i, flag, num = 0;
+
+	flag = V4L2_TYPE_IS_OUTPUT(type) ? MDP_FMT_FLAG_OUTPUT :
+					MDP_FMT_FLAG_CAPTURE;
+	for (i = 0; i < ARRAY_SIZE(mdp_formats); ++i) {
+		if (!(mdp_formats[i].flags & flag))
+			continue;
+		if (index == num)
+			return &mdp_formats[i];
+		num++;
+	}
+	return NULL;
+}
+
+enum mdp_ycbcr_profile mdp_map_ycbcr_prof_mplane(struct v4l2_format *f,
+						 u32 mdp_color)
+{
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+
+	if (MDP_COLOR_IS_RGB(mdp_color))
+		return MDP_YCBCR_PROFILE_FULL_BT601;
+
+	switch (pix_mp->colorspace) {
+	case V4L2_COLORSPACE_JPEG:
+		return MDP_YCBCR_PROFILE_JPEG;
+	case V4L2_COLORSPACE_REC709:
+	case V4L2_COLORSPACE_DCI_P3:
+		if (pix_mp->quantization == V4L2_QUANTIZATION_FULL_RANGE)
+			return MDP_YCBCR_PROFILE_FULL_BT709;
+		return MDP_YCBCR_PROFILE_BT709;
+	case V4L2_COLORSPACE_BT2020:
+		if (pix_mp->quantization == V4L2_QUANTIZATION_FULL_RANGE)
+			return MDP_YCBCR_PROFILE_FULL_BT2020;
+		return MDP_YCBCR_PROFILE_BT2020;
+	}
+	/* V4L2_COLORSPACE_SRGB or else */
+	if (pix_mp->quantization == V4L2_QUANTIZATION_FULL_RANGE)
+		return MDP_YCBCR_PROFILE_FULL_BT601;
+	return MDP_YCBCR_PROFILE_BT601;
+}
+
+static void mdp_bound_align_image(u32 *w, unsigned int wmin, unsigned int wmax,
+				  unsigned int walign,
+				u32 *h, unsigned int hmin, unsigned int hmax,
+				unsigned int halign, unsigned int salign)
+{
+	unsigned int org_w, org_h, wstep, hstep;
+
+	org_w = *w;
+	org_h = *h;
+	v4l_bound_align_image(w, wmin, wmax, walign, h, hmin, hmax, halign,
+			      salign);
+
+	wstep = 1 << walign;
+	hstep = 1 << halign;
+	if (*w < org_w && (*w + wstep) <= wmax)
+		*w += wstep;
+	if (*h < org_h && (*h + hstep) <= hmax)
+		*h += hstep;
+}
+
+static int mdp_clamp_align(s32 *x, int min, int max, unsigned int align)
+{
+	unsigned int mask;
+
+	if (min < 0 || max < 0)
+		return -ERANGE;
+
+	/* Bits that must be zero to be aligned */
+	mask = ~((1 << align) - 1);
+
+	min = 0 ? 0 : ((min + ~mask) & mask);
+	max = max & mask;
+	if ((unsigned int)min > (unsigned int)max)
+		return -ERANGE;
+
+	/* Clamp to aligned min and max */
+	*x = clamp(*x, min, max);
+
+	/* Round to nearest aligned value */
+	if (align)
+		*x = (*x + (1 << (align - 1))) & mask;
+	return 0;
+}
+
+int mdp_enum_fmt_mplane(struct v4l2_fmtdesc *f)
+{
+	const struct mdp_format *fmt;
+
+	if (!V4L2_TYPE_IS_MULTIPLANAR(f->type))
+		return -EINVAL;
+
+	fmt = mdp_find_fmt_by_index(f->index, f->type);
+	if (!fmt)
+		return -EINVAL;
+
+	/* f->description */
+	f->pixelformat = fmt->pixelformat;
+	return 0;
+}
+
+const struct mdp_format *mdp_try_fmt_mplane(struct v4l2_format *f,
+					    struct mdp_frameparam *param,
+					    u32 ctx_id)
+{
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	const struct mdp_format *fmt;
+	const struct mdp_pix_limit *pix_limit;
+	u32 wmin, wmax, hmin, hmax, org_w, org_h;
+	unsigned int i;
+
+	if (!V4L2_TYPE_IS_MULTIPLANAR(f->type))
+		return NULL;
+
+	fmt = mdp_find_fmt(pix_mp->pixelformat, f->type);
+	if (!fmt)
+		fmt = mdp_find_fmt_by_index(0, f->type);
+	if (!fmt) {
+		mdp_dbg(0, "[%d] pixelformat %c%c%c%c invalid", ctx_id,
+			(pix_mp->pixelformat & 0xff),
+			(pix_mp->pixelformat >>  8) & 0xff,
+			(pix_mp->pixelformat >> 16) & 0xff,
+			(pix_mp->pixelformat >> 24) & 0xff);
+		return NULL;
+	}
+
+	pix_mp->field = V4L2_FIELD_NONE;
+	pix_mp->flags = 0;
+	pix_mp->pixelformat = fmt->pixelformat;
+	if (!V4L2_TYPE_IS_OUTPUT(f->type)) {
+		pix_mp->colorspace = param->colorspace;
+		pix_mp->xfer_func = param->xfer_func;
+		pix_mp->ycbcr_enc = param->ycbcr_enc;
+		pix_mp->quantization = param->quant;
+	}
+	memset(pix_mp->reserved, 0, sizeof(pix_mp->reserved));
+
+	pix_limit = V4L2_TYPE_IS_OUTPUT(f->type) ? &param->limit->out_limit :
+		&param->limit->cap_limit;
+	wmin = pix_limit->wmin;
+	wmax = pix_limit->wmax;
+	hmin = pix_limit->hmin;
+	hmax = pix_limit->hmax;
+	org_w = pix_mp->width;
+	org_h = pix_mp->height;
+
+	mdp_bound_align_image(&pix_mp->width, wmin, wmax, fmt->walign,
+			      &pix_mp->height, hmin, hmax, fmt->halign,
+				fmt->salign);
+	if (org_w != pix_mp->width || org_h != pix_mp->height)
+		mdp_dbg(1, "[%d] size change: %ux%u to %ux%u", ctx_id,
+			org_w, org_h, pix_mp->width, pix_mp->height);
+
+	if (pix_mp->num_planes && pix_mp->num_planes != fmt->num_planes)
+		mdp_dbg(1, "[%d] num of planes change: %u to %u", ctx_id,
+			pix_mp->num_planes, fmt->num_planes);
+	pix_mp->num_planes = fmt->num_planes;
+
+	for (i = 0; i < pix_mp->num_planes; ++i) {
+		u32 min_bpl = (pix_mp->width * fmt->row_depth[i]) / 8;
+		u32 bpl = pix_mp->plane_fmt[i].bytesperline;
+		u32 si;
+
+		if (bpl < min_bpl)
+			bpl = min_bpl;
+		si = (bpl * pix_mp->height * fmt->depth[i]) / fmt->row_depth[i];
+
+		pix_mp->plane_fmt[i].bytesperline = bpl;
+		if (pix_mp->plane_fmt[i].sizeimage < si)
+			pix_mp->plane_fmt[i].sizeimage = si;
+		memset(pix_mp->plane_fmt[i].reserved, 0,
+		       sizeof(pix_mp->plane_fmt[i].reserved));
+		mdp_dbg(2, "[%d] p%u, bpl:%u (%u), sizeimage:%u (%u)", ctx_id,
+			i, bpl, min_bpl, pix_mp->plane_fmt[i].sizeimage, si);
+	}
+
+	return fmt;
+}
+
+static inline int mdp_clamp_start(s32 *x, int min, int max, unsigned int align,
+				  u32 flags)
+{
+	if (flags & V4L2_SEL_FLAG_GE)
+		max = *x;
+	if (flags & V4L2_SEL_FLAG_LE)
+		min = *x;
+	return mdp_clamp_align(x, min, max, align);
+}
+
+static inline int mdp_clamp_end(s32 *x, int min, int max, unsigned int align,
+				u32 flags)
+{
+	if (flags & V4L2_SEL_FLAG_GE)
+		min = *x;
+	if (flags & V4L2_SEL_FLAG_LE)
+		max = *x;
+	return mdp_clamp_align(x, min, max, align);
+}
+
+int mdp_try_crop(struct v4l2_rect *r, const struct v4l2_selection *s,
+		 struct mdp_frame *frame, u32 ctx_id)
+{
+	s32 left, top, right, bottom;
+	u32 framew, frameh, walign, halign;
+	int ret;
+
+	mdp_dbg(2, "[%d] target:%d, set:(%d,%d) %ux%u", ctx_id, s->target,
+		s->r.left, s->r.top, s->r.width, s->r.height);
+
+	left = s->r.left;
+	top = s->r.top;
+	right = s->r.left + s->r.width;
+	bottom = s->r.top + s->r.height;
+	framew = frame->format.fmt.pix_mp.width;
+	frameh = frame->format.fmt.pix_mp.height;
+
+	if (mdp_target_is_crop(s->target)) {
+		walign = 1;
+		halign = 1;
+	} else {
+		walign = frame->mdp_fmt->walign;
+		halign = frame->mdp_fmt->halign;
+	}
+
+	mdp_dbg(2, "[%d] align:%u,%u, bound:%ux%u", ctx_id,
+		walign, halign, framew, frameh);
+
+	ret = mdp_clamp_start(&left, 0, right, walign, s->flags);
+	if (ret)
+		return ret;
+	ret = mdp_clamp_start(&top, 0, bottom, halign, s->flags);
+	if (ret)
+		return ret;
+	ret = mdp_clamp_end(&right, left, framew, walign, s->flags);
+	if (ret)
+		return ret;
+	ret = mdp_clamp_end(&bottom, top, frameh, halign, s->flags);
+	if (ret)
+		return ret;
+
+	r->left = left;
+	r->top = top;
+	r->width = right - left;
+	r->height = bottom - top;
+
+	mdp_dbg(2, "[%d] crop:(%d,%d) %ux%u", ctx_id,
+		r->left, r->top, r->width, r->height);
+	return 0;
+}
+
+int mdp_check_scaling_ratio(const struct v4l2_rect *crop,
+			    const struct v4l2_rect *compose, s32 rotation,
+	const struct mdp_limit *limit)
+{
+	u32 crop_w, crop_h, comp_w, comp_h;
+
+	crop_w = crop->width;
+	crop_h = crop->height;
+	if (90 == rotation || 270 == rotation) {
+		comp_w = compose->height;
+		comp_h = compose->width;
+	} else {
+		comp_w = compose->width;
+		comp_h = compose->height;
+	}
+
+	if ((crop_w / comp_w) > limit->h_scale_down_max ||
+	    (crop_h / comp_h) > limit->v_scale_down_max ||
+	    (comp_w / crop_w) > limit->h_scale_up_max ||
+	    (comp_h / crop_h) > limit->v_scale_up_max)
+		return -ERANGE;
+	return 0;
+}
+
+/* Stride that is accepted by MDP HW */
+static u32 mdp_fmt_get_stride(const struct mdp_format *fmt,
+			      u32 bytesperline, unsigned int plane)
+{
+	enum mdp_color c = fmt->mdp_color;
+	u32 stride;
+
+	stride = (bytesperline * MDP_COLOR_BITS_PER_PIXEL(c))
+		/ fmt->row_depth[0];
+	if (plane == 0)
+		return stride;
+	if (plane < MDP_COLOR_GET_PLANE_COUNT(c)) {
+		if (MDP_COLOR_IS_BLOCK_MODE(c))
+			stride = stride / 2;
+		return stride;
+	}
+	return 0;
+}
+
+/* Stride that is accepted by MDP HW of format with contiguous planes */
+static u32 mdp_fmt_get_stride_contig(const struct mdp_format *fmt,
+				     u32 pix_stride, unsigned int plane)
+{
+	enum mdp_color c = fmt->mdp_color;
+	u32 stride = pix_stride;
+
+	if (plane == 0)
+		return stride;
+	if (plane < MDP_COLOR_GET_PLANE_COUNT(c)) {
+		stride = stride >> MDP_COLOR_GET_H_SUBSAMPLE(c);
+		if (MDP_COLOR_IS_UV_COPLANE(c) && !MDP_COLOR_IS_BLOCK_MODE(c))
+			stride = stride * 2;
+		return stride;
+	}
+	return 0;
+}
+
+/* Plane size that is accepted by MDP HW */
+static u32 mdp_fmt_get_plane_size(const struct mdp_format *fmt,
+				  u32 stride, u32 height, unsigned int plane)
+{
+	enum mdp_color c = fmt->mdp_color;
+	u32 bytesperline;
+
+	bytesperline = (stride * fmt->row_depth[0])
+		/ MDP_COLOR_BITS_PER_PIXEL(c);
+	if (plane == 0)
+		return bytesperline * height;
+	if (plane < MDP_COLOR_GET_PLANE_COUNT(c)) {
+		height = height >> MDP_COLOR_GET_V_SUBSAMPLE(c);
+		if (MDP_COLOR_IS_BLOCK_MODE(c))
+			bytesperline = bytesperline * 2;
+		return bytesperline * height;
+	}
+	return 0;
+}
+
+static void mdp_prepare_buffer(struct img_image_buffer *b,
+			       struct mdp_frame *frame, struct vb2_buffer *vb)
+{
+	struct v4l2_pix_format_mplane *pix_mp = &frame->format.fmt.pix_mp;
+	unsigned int i;
+
+	b->format.colorformat = frame->mdp_fmt->mdp_color;
+	b->format.ycbcr_prof = frame->ycbcr_prof;
+	for (i = 0; i < pix_mp->num_planes; ++i) {
+		u32 stride = mdp_fmt_get_stride(frame->mdp_fmt,
+			pix_mp->plane_fmt[i].bytesperline, i);
+
+		b->format.plane_fmt[i].stride = stride;
+		b->format.plane_fmt[i].size =
+			mdp_fmt_get_plane_size(frame->mdp_fmt, stride,
+					       pix_mp->height, i);
+		b->iova[i] = vb2_dma_contig_plane_dma_addr(vb, i);
+	}
+	for (; i < MDP_COLOR_GET_PLANE_COUNT(b->format.colorformat); ++i) {
+		u32 stride = mdp_fmt_get_stride_contig(frame->mdp_fmt,
+			b->format.plane_fmt[0].stride, i);
+
+		b->format.plane_fmt[i].stride = stride;
+		b->format.plane_fmt[i].size =
+			mdp_fmt_get_plane_size(frame->mdp_fmt, stride,
+					       pix_mp->height, i);
+		b->iova[i] = b->iova[i - 1] + b->format.plane_fmt[i - 1].size;
+	}
+	b->usage = frame->usage;
+}
+
+void mdp_set_src_config(struct img_input *in,
+			struct mdp_frame *frame, struct vb2_buffer *vb)
+{
+	in->buffer.format.width = frame->format.fmt.pix_mp.width;
+	in->buffer.format.height = frame->format.fmt.pix_mp.height;
+	mdp_prepare_buffer(&in->buffer, frame, vb);
+
+	/* in->flags |= ; */	/* HDR, DRE, dither */
+}
+
+static u32 mdp_to_fixed(u32 *r, struct v4l2_fract *f)
+{
+	u32 q;
+
+	if (f->denominator == 0) {
+		*r = 0;
+		return 0;
+	}
+
+	q = f->numerator / f->denominator;
+	*r = (((u64)f->numerator - q * f->denominator) << IMG_SUBPIXEL_SHIFT)
+		/ f->denominator;
+	return q;
+}
+
+static void mdp_set_src_crop(struct img_crop *c, struct mdp_crop *crop)
+{
+	c->left = crop->c.left
+		+ mdp_to_fixed(&c->left_subpix, &crop->left_subpix);
+	c->top = crop->c.top
+		+ mdp_to_fixed(&c->top_subpix, &crop->top_subpix);
+	c->width = crop->c.width
+		+ mdp_to_fixed(&c->width_subpix, &crop->width_subpix);
+	c->height = crop->c.height
+		+ mdp_to_fixed(&c->height_subpix, &crop->height_subpix);
+}
+
+static void mdp_set_orientation(struct img_output *out,
+				s32 rotation, bool hflip, bool vflip)
+{
+	u8 flip = 0;
+
+	if (hflip)
+		flip ^= 1;
+	if (vflip) {
+		/*
+		 * A vertical flip is equivalent to
+		 * a 180-degree rotation with a horizontal flip
+		 */
+		rotation += 180;
+		flip ^= 1;
+	}
+
+	out->rotation = rotation % 360;
+	if (flip != 0)
+		out->flags |= IMG_CTRL_FLAG_HFLIP;
+	else
+		out->flags &= ~IMG_CTRL_FLAG_HFLIP;
+}
+
+void mdp_set_dst_config(struct img_output *out,
+			struct mdp_frame *frame, struct vb2_buffer *vb)
+{
+	out->buffer.format.width = frame->compose.width;
+	out->buffer.format.height = frame->compose.height;
+	mdp_prepare_buffer(&out->buffer, frame, vb);
+	mdp_set_src_crop(&out->crop, &frame->crop);
+	mdp_set_orientation(out, frame->rotation, frame->hflip, frame->vflip);
+
+	/* out->flags |= ; */	/* sharpness, dither */
+}
+
+struct mdp_frameparam *mdp_frameparam_init(void)
+{
+	struct mdp_frameparam *param;
+	struct mdp_frame *frame;
+
+	param = kzalloc(sizeof(*param), GFP_KERNEL);
+	if (!param)
+		return ERR_PTR(-ENOMEM);
+
+	INIT_LIST_HEAD(&param->list);
+	mutex_init(&param->lock);
+	param->state = 0;
+	param->limit = &mdp_def_limit;
+	param->type = MDP_STREAM_TYPE_UNKNOWN;
+	param->frame_no = 0;
+
+	frame = &param->output;
+	frame->format.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	frame->mdp_fmt = mdp_try_fmt_mplane(&frame->format, param, 0);
+	frame->ycbcr_prof =
+		mdp_map_ycbcr_prof_mplane(&frame->format,
+					  frame->mdp_fmt->mdp_color);
+	frame->usage = MDP_BUFFER_USAGE_HW_READ;
+
+	param->num_captures = 1;
+	frame = &param->captures[0];
+	frame->format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	frame->mdp_fmt = mdp_try_fmt_mplane(&frame->format, param, 0);
+	frame->ycbcr_prof =
+		mdp_map_ycbcr_prof_mplane(&frame->format,
+					  frame->mdp_fmt->mdp_color);
+	frame->usage = MDP_BUFFER_USAGE_MDP;
+	frame->crop.c.width = param->output.format.fmt.pix_mp.width;
+	frame->crop.c.height = param->output.format.fmt.pix_mp.height;
+	frame->compose.width = frame->format.fmt.pix_mp.width;
+	frame->compose.height = frame->format.fmt.pix_mp.height;
+
+	return param;
+}
+
+void mdp_frameparam_release(struct mdp_frameparam *param)
+{
+	kfree(param);
+}
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.h b/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.h
new file mode 100644
index 000000000000..859b4df48856
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.h
@@ -0,0 +1,392 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_MDP3_REGS_H__
+#define __MTK_MDP3_REGS_H__
+
+#include <linux/io.h>
+#include <linux/videodev2.h>
+#include <media/videobuf2-core.h>
+#include "mtk-img-ipi.h"
+
+/*
+ * MDP native color code
+ * Plane count: 1, 2, 3
+ * H-subsample: 0, 1, 2
+ * V-subsample: 0, 1
+ * Color group: 0-RGB, 1-YUV, 2-raw
+ */
+#define MDP_COLOR(PACKED, LOOSE, VIDEO, PLANE, HF, VF, BITS, GROUP, SWAP, ID)\
+	(((PACKED) << 27) | ((LOOSE) << 26) | ((VIDEO) << 23) |\
+	 ((PLANE) << 21) | ((HF) << 19) | ((VF) << 18) | ((BITS) << 8) |\
+	 ((GROUP) << 6) | ((SWAP) << 5) | ((ID) << 0))
+
+#define MDP_COLOR_IS_10BIT_PACKED(c)    ((0x08000000 & (c)) >> 27)
+#define MDP_COLOR_IS_10BIT_LOOSE(c)    (((0x0c000000 & (c)) >> 26) == 1)
+#define MDP_COLOR_IS_10BIT_TILE(c)     (((0x0c000000 & (c)) >> 26) == 3)
+#define MDP_COLOR_IS_UFP(c)             ((0x02000000 & (c)) >> 25)
+#define MDP_COLOR_IS_INTERLACED(c)      ((0x01000000 & (c)) >> 24)
+#define MDP_COLOR_IS_BLOCK_MODE(c)      ((0x00800000 & (c)) >> 23)
+#define MDP_COLOR_GET_PLANE_COUNT(c)    ((0x00600000 & (c)) >> 21)
+#define MDP_COLOR_GET_H_SUBSAMPLE(c)    ((0x00180000 & (c)) >> 19)
+#define MDP_COLOR_GET_V_SUBSAMPLE(c)    ((0x00040000 & (c)) >> 18)
+#define MDP_COLOR_BITS_PER_PIXEL(c)     ((0x0003ff00 & (c)) >>  8)
+#define MDP_COLOR_GET_GROUP(c)          ((0x000000c0 & (c)) >>  6)
+#define MDP_COLOR_IS_SWAPPED(c)         ((0x00000020 & (c)) >>  5)
+#define MDP_COLOR_GET_UNIQUE_ID(c)      ((0x0000001f & (c)) >>  0)
+#define MDP_COLOR_GET_HW_FORMAT(c)      ((0x0000001f & (c)) >>  0)
+
+#define MDP_COLOR_IS_RGB(c)		(MDP_COLOR_GET_GROUP(c) == 0)
+#define MDP_COLOR_IS_YUV(c)		(MDP_COLOR_GET_GROUP(c) == 1)
+#define MDP_COLOR_IS_UV_COPLANE(c)	((MDP_COLOR_GET_PLANE_COUNT(c) == 2) &&\
+					 MDP_COLOR_IS_YUV(c))
+
+#define MDP_REG_GET32(addr)	(readl((void *)addr) & 0xffffffff)
+#define MDP_REG_GET16(addr)	(readl((void *)addr) & 0x0000ffff)
+
+#define MDP_REG_SET32(addr, val)	writel(val, addr)
+
+enum mdp_color {
+	MDP_COLOR_UNKNOWN	= 0,
+
+	//MDP_COLOR_FULLG8,
+	MDP_COLOR_FULLG8_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0,  8, 2,  0, 21),
+	MDP_COLOR_FULLG8_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1,  8, 2,  0, 21),
+	MDP_COLOR_FULLG8_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0,  8, 2,  0, 21),
+	MDP_COLOR_FULLG8_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1,  8, 2,  0, 21),
+	MDP_COLOR_FULLG8	= MDP_COLOR_FULLG8_BGGR,
+
+	//MDP_COLOR_FULLG10,
+	MDP_COLOR_FULLG10_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0, 10, 2,  0, 21),
+	MDP_COLOR_FULLG10_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1, 10, 2,  0, 21),
+	MDP_COLOR_FULLG10_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0, 10, 2,  0, 21),
+	MDP_COLOR_FULLG10_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1, 10, 2,  0, 21),
+	MDP_COLOR_FULLG10	= MDP_COLOR_FULLG10_BGGR,
+
+	//MDP_COLOR_FULLG12,
+	MDP_COLOR_FULLG12_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0, 12, 2,  0, 21),
+	MDP_COLOR_FULLG12_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1, 12, 2,  0, 21),
+	MDP_COLOR_FULLG12_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0, 12, 2,  0, 21),
+	MDP_COLOR_FULLG12_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1, 12, 2,  0, 21),
+	MDP_COLOR_FULLG12	= MDP_COLOR_FULLG12_BGGR,
+
+	//MDP_COLOR_FULLG14,
+	MDP_COLOR_FULLG14_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0, 14, 2,  0, 21),
+	MDP_COLOR_FULLG14_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1, 14, 2,  0, 21),
+	MDP_COLOR_FULLG14_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0, 14, 2,  0, 21),
+	MDP_COLOR_FULLG14_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1, 14, 2,  0, 21),
+	MDP_COLOR_FULLG14	= MDP_COLOR_FULLG14_BGGR,
+
+	MDP_COLOR_UFO10		= MDP_COLOR(0, 0, 0, 1, 0, 0, 10, 2,  0, 24),
+
+	//MDP_COLOR_BAYER8,
+	MDP_COLOR_BAYER8_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0,  8, 2,  0, 20),
+	MDP_COLOR_BAYER8_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1,  8, 2,  0, 20),
+	MDP_COLOR_BAYER8_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0,  8, 2,  0, 20),
+	MDP_COLOR_BAYER8_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1,  8, 2,  0, 20),
+	MDP_COLOR_BAYER8	= MDP_COLOR_BAYER8_BGGR,
+
+	//MDP_COLOR_BAYER10,
+	MDP_COLOR_BAYER10_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0, 10, 2,  0, 20),
+	MDP_COLOR_BAYER10_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1, 10, 2,  0, 20),
+	MDP_COLOR_BAYER10_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0, 10, 2,  0, 20),
+	MDP_COLOR_BAYER10_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1, 10, 2,  0, 20),
+	MDP_COLOR_BAYER10	= MDP_COLOR_BAYER10_BGGR,
+
+	//MDP_COLOR_BAYER12,
+	MDP_COLOR_BAYER12_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0, 12, 2,  0, 20),
+	MDP_COLOR_BAYER12_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1, 12, 2,  0, 20),
+	MDP_COLOR_BAYER12_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0, 12, 2,  0, 20),
+	MDP_COLOR_BAYER12_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1, 12, 2,  0, 20),
+	MDP_COLOR_BAYER12	= MDP_COLOR_BAYER12_BGGR,
+
+	MDP_COLOR_RGB48		= MDP_COLOR(0, 0, 0, 1, 0, 0, 48, 0,  0, 23),
+	/* For bayer+mono raw-16 */
+	MDP_COLOR_RGB565_RAW	= MDP_COLOR(0, 0, 0, 1, 0, 0, 16, 2,  0, 0),
+
+	MDP_COLOR_BAYER8_UNPAK	= MDP_COLOR(0, 0, 0, 1, 0, 0,  8, 2,  0, 22),
+	MDP_COLOR_BAYER10_UNPAK	= MDP_COLOR(0, 0, 0, 1, 0, 0, 10, 2,  0, 22),
+	MDP_COLOR_BAYER12_UNPAK	= MDP_COLOR(0, 0, 0, 1, 0, 0, 12, 2,  0, 22),
+	MDP_COLOR_BAYER14_UNPAK	= MDP_COLOR(0, 0, 0, 1, 0, 0, 14, 2,  0, 22),
+
+	/* Unified formats */
+	MDP_COLOR_GREY		= MDP_COLOR(0, 0, 0, 1, 0, 0,  8, 1,  0, 7),
+
+	MDP_COLOR_RGB565	= MDP_COLOR(0, 0, 0, 1, 0, 0, 16, 0,  0, 0),
+	MDP_COLOR_BGR565	= MDP_COLOR(0, 0, 0, 1, 0, 0, 16, 0,  1, 0),
+	MDP_COLOR_RGB888	= MDP_COLOR(0, 0, 0, 1, 0, 0, 24, 0,  1, 1),
+	MDP_COLOR_BGR888	= MDP_COLOR(0, 0, 0, 1, 0, 0, 24, 0,  0, 1),
+	MDP_COLOR_RGBA8888	= MDP_COLOR(0, 0, 0, 1, 0, 0, 32, 0,  1, 2),
+	MDP_COLOR_BGRA8888	= MDP_COLOR(0, 0, 0, 1, 0, 0, 32, 0,  0, 2),
+	MDP_COLOR_ARGB8888	= MDP_COLOR(0, 0, 0, 1, 0, 0, 32, 0,  1, 3),
+	MDP_COLOR_ABGR8888	= MDP_COLOR(0, 0, 0, 1, 0, 0, 32, 0,  0, 3),
+
+	MDP_COLOR_UYVY		= MDP_COLOR(0, 0, 0, 1, 1, 0, 16, 1,  0, 4),
+	MDP_COLOR_VYUY		= MDP_COLOR(0, 0, 0, 1, 1, 0, 16, 1,  1, 4),
+	MDP_COLOR_YUYV		= MDP_COLOR(0, 0, 0, 1, 1, 0, 16, 1,  0, 5),
+	MDP_COLOR_YVYU		= MDP_COLOR(0, 0, 0, 1, 1, 0, 16, 1,  1, 5),
+
+	MDP_COLOR_I420		= MDP_COLOR(0, 0, 0, 3, 1, 1,  8, 1,  0, 8),
+	MDP_COLOR_YV12		= MDP_COLOR(0, 0, 0, 3, 1, 1,  8, 1,  1, 8),
+	MDP_COLOR_I422		= MDP_COLOR(0, 0, 0, 3, 1, 0,  8, 1,  0, 9),
+	MDP_COLOR_YV16		= MDP_COLOR(0, 0, 0, 3, 1, 0,  8, 1,  1, 9),
+	MDP_COLOR_I444		= MDP_COLOR(0, 0, 0, 3, 0, 0,  8, 1,  0, 10),
+	MDP_COLOR_YV24		= MDP_COLOR(0, 0, 0, 3, 0, 0,  8, 1,  1, 10),
+
+	MDP_COLOR_NV12		= MDP_COLOR(0, 0, 0, 2, 1, 1,  8, 1,  0, 12),
+	MDP_COLOR_NV21		= MDP_COLOR(0, 0, 0, 2, 1, 1,  8, 1,  1, 12),
+	MDP_COLOR_NV16		= MDP_COLOR(0, 0, 0, 2, 1, 0,  8, 1,  0, 13),
+	MDP_COLOR_NV61		= MDP_COLOR(0, 0, 0, 2, 1, 0,  8, 1,  1, 13),
+	MDP_COLOR_NV24		= MDP_COLOR(0, 0, 0, 2, 0, 0,  8, 1,  0, 14),
+	MDP_COLOR_NV42		= MDP_COLOR(0, 0, 0, 2, 0, 0,  8, 1,  1, 14),
+
+	/* Mediatek proprietary formats */
+	/* UFO encoded block mode */
+	MDP_COLOR_420_BLK_UFO	= MDP_COLOR(0, 0, 5, 2, 1, 1, 256, 1, 0, 12),
+	/* Block mode */
+	MDP_COLOR_420_BLK	= MDP_COLOR(0, 0, 1, 2, 1, 1, 256, 1, 0, 12),
+	/* Block mode + field mode */
+	MDP_COLOR_420_BLKI	= MDP_COLOR(0, 0, 3, 2, 1, 1, 256, 1, 0, 12),
+	/* Block mode */
+	MDP_COLOR_422_BLK	= MDP_COLOR(0, 0, 1, 1, 1, 0, 512, 1, 0, 4),
+
+	MDP_COLOR_IYU2		= MDP_COLOR(0, 0, 0, 1, 0, 0, 24,  1, 0, 25),
+	MDP_COLOR_YUV444	= MDP_COLOR(0, 0, 0, 1, 0, 0, 24,  1, 0, 30),
+
+	/* Packed 10-bit formats */
+	MDP_COLOR_RGBA1010102	= MDP_COLOR(1, 0, 0, 1, 0, 0, 32,  0, 1, 2),
+	MDP_COLOR_BGRA1010102	= MDP_COLOR(1, 0, 0, 1, 0, 0, 32,  0, 0, 2),
+	/* Packed 10-bit UYVY */
+	MDP_COLOR_UYVY_10P	= MDP_COLOR(1, 0, 0, 1, 1, 0, 20,  1, 0, 4),
+	/* Packed 10-bit NV21 */
+	MDP_COLOR_NV21_10P	= MDP_COLOR(1, 0, 0, 2, 1, 1, 10,  1, 1, 12),
+	/* 10-bit block mode */
+	MDP_COLOR_420_BLK_10_H	= MDP_COLOR(1, 0, 1, 2, 1, 1, 320, 1, 0, 12),
+	/* 10-bit HEVC tile mode */
+	MDP_COLOR_420_BLK_10_V	= MDP_COLOR(1, 1, 1, 2, 1, 1, 320, 1, 0, 12),
+	/* UFO encoded 10-bit block mode */
+	MDP_COLOR_420_BLK_U10_H	= MDP_COLOR(1, 0, 5, 2, 1, 1, 320, 1, 0, 12),
+	/* UFO encoded 10-bit HEVC tile mode */
+	MDP_COLOR_420_BLK_U10_V	= MDP_COLOR(1, 1, 5, 2, 1, 1, 320, 1, 0, 12),
+
+	/* Loose 10-bit formats */
+	MDP_COLOR_UYVY_10L	= MDP_COLOR(0, 1, 0, 1, 1, 0, 20,  1, 0, 4),
+	MDP_COLOR_VYUY_10L	= MDP_COLOR(0, 1, 0, 1, 1, 0, 20,  1, 1, 4),
+	MDP_COLOR_YUYV_10L	= MDP_COLOR(0, 1, 0, 1, 1, 0, 20,  1, 0, 5),
+	MDP_COLOR_YVYU_10L	= MDP_COLOR(0, 1, 0, 1, 1, 0, 20,  1, 1, 5),
+	MDP_COLOR_NV12_10L	= MDP_COLOR(0, 1, 0, 2, 1, 1, 10,  1, 0, 12),
+	MDP_COLOR_NV21_10L	= MDP_COLOR(0, 1, 0, 2, 1, 1, 10,  1, 1, 12),
+	MDP_COLOR_NV16_10L	= MDP_COLOR(0, 1, 0, 2, 1, 0, 10,  1, 0, 13),
+	MDP_COLOR_NV61_10L	= MDP_COLOR(0, 1, 0, 2, 1, 0, 10,  1, 1, 13),
+	MDP_COLOR_YV12_10L	= MDP_COLOR(0, 1, 0, 3, 1, 1, 10,  1, 1, 8),
+	MDP_COLOR_I420_10L	= MDP_COLOR(0, 1, 0, 3, 1, 1, 10,  1, 0, 8),
+};
+
+/* Minimum Y stride that is accepted by MDP HW */
+static inline u32 mdp_color_get_min_y_stride(enum mdp_color c, u32 width)
+{
+	return ((MDP_COLOR_BITS_PER_PIXEL(c) * width) + 4) >> 3;
+}
+
+/* Minimum UV stride that is accepted by MDP HW */
+static inline u32 mdp_color_get_min_uv_stride(enum mdp_color c, u32 width)
+{
+	u32 min_stride;
+
+	if (MDP_COLOR_GET_PLANE_COUNT(c) == 1)
+		return 0;
+	min_stride = mdp_color_get_min_y_stride(c, width)
+		>> MDP_COLOR_GET_H_SUBSAMPLE(c);
+	if (MDP_COLOR_IS_UV_COPLANE(c) && !MDP_COLOR_IS_BLOCK_MODE(c))
+		min_stride = min_stride * 2;
+	return min_stride;
+}
+
+/* Minimum Y plane size that is necessary in buffer */
+static inline u32 mdp_color_get_min_y_size(enum mdp_color c,
+					   u32 width, u32 height)
+{
+	if (MDP_COLOR_IS_BLOCK_MODE(c))
+		return ((MDP_COLOR_BITS_PER_PIXEL(c) * width) >> 8) * height;
+	return mdp_color_get_min_y_stride(c, width) * height;
+}
+
+/* Minimum UV plane size that is necessary in buffer */
+static inline u32 mdp_color_get_min_uv_size(enum mdp_color c,
+					    u32 width, u32 height)
+{
+	height = height >> MDP_COLOR_GET_V_SUBSAMPLE(c);
+	if (MDP_COLOR_IS_BLOCK_MODE(c) && (MDP_COLOR_GET_PLANE_COUNT(c) > 1))
+		return ((MDP_COLOR_BITS_PER_PIXEL(c) * width) >> 8) * height;
+	return mdp_color_get_min_uv_stride(c, width) * height;
+}
+
+/* Combine colorspace, xfer_func, ycbcr_encoding, and quantization */
+enum mdp_ycbcr_profile {
+	/* V4L2_YCBCR_ENC_601 and V4L2_QUANTIZATION_LIM_RANGE */
+	MDP_YCBCR_PROFILE_BT601,
+	/* V4L2_YCBCR_ENC_709 and V4L2_QUANTIZATION_LIM_RANGE */
+	MDP_YCBCR_PROFILE_BT709,
+	/* V4L2_YCBCR_ENC_601 and V4L2_QUANTIZATION_FULL_RANGE */
+	MDP_YCBCR_PROFILE_JPEG,
+	MDP_YCBCR_PROFILE_FULL_BT601 = MDP_YCBCR_PROFILE_JPEG,
+
+	/* Colorspaces not support for capture */
+	/* V4L2_YCBCR_ENC_BT2020 and V4L2_QUANTIZATION_LIM_RANGE */
+	MDP_YCBCR_PROFILE_BT2020,
+	/* V4L2_YCBCR_ENC_709 and V4L2_QUANTIZATION_FULL_RANGE */
+	MDP_YCBCR_PROFILE_FULL_BT709,
+	/* V4L2_YCBCR_ENC_BT2020 and V4L2_QUANTIZATION_FULL_RANGE */
+	MDP_YCBCR_PROFILE_FULL_BT2020,
+};
+
+#define MDP_FMT_FLAG_OUTPUT	BIT(0)
+#define MDP_FMT_FLAG_CAPTURE	BIT(1)
+
+struct mdp_format {
+	u32	pixelformat;
+	u32	mdp_color;
+	u8	depth[VIDEO_MAX_PLANES];
+	u8	row_depth[VIDEO_MAX_PLANES];
+	u8	num_planes;
+	u8	walign;
+	u8	halign;
+	u8	salign;
+	u32	flags;
+};
+
+struct mdp_pix_limit {
+	u32	wmin;
+	u32	hmin;
+	u32	wmax;
+	u32	hmax;
+};
+
+struct mdp_limit {
+	struct mdp_pix_limit	out_limit;
+	struct mdp_pix_limit	cap_limit;
+	u32			h_scale_up_max;
+	u32			v_scale_up_max;
+	u32			h_scale_down_max;
+	u32			v_scale_down_max;
+};
+
+enum mdp_stream_type {
+	MDP_STREAM_TYPE_UNKNOWN,
+
+	MDP_STREAM_TYPE_BITBLT,
+	MDP_STREAM_TYPE_GPU_BITBLT,
+	MDP_STREAM_TYPE_DUAL_BITBLT,
+	MDP_STREAM_TYPE_2ND_BITBLT,
+
+	/* MDP_STREAM_TYPE_FRAG, */
+	/* MDP_STREAM_TYPE_FRAG_JPEGDEC, */
+
+	MDP_STREAM_TYPE_ISP_IC,
+	MDP_STREAM_TYPE_ISP_VR,
+	MDP_STREAM_TYPE_ISP_ZSD,
+	MDP_STREAM_TYPE_ISP_IP,
+	MDP_STREAM_TYPE_ISP_VSS,
+	MDP_STREAM_TYPE_ISP_ZSD_SLOW,
+	/* MDP_STREAM_TYPE_ISP_ZSD_ONE, */
+
+	MDP_STREAM_TYPE_WPE,
+	MDP_STREAM_TYPE_WPE2,
+};
+
+struct mdp_crop {
+	struct v4l2_rect	c;
+	struct v4l2_fract	left_subpix;
+	struct v4l2_fract	top_subpix;
+	struct v4l2_fract	width_subpix;
+	struct v4l2_fract	height_subpix;
+};
+
+struct mdp_frame {
+	struct v4l2_format	format;
+	const struct mdp_format	*mdp_fmt;
+	u32			ycbcr_prof;	/* enum mdp_ycbcr_profile */
+	u32			usage;		/* enum mdp_buffer_usage */
+	struct mdp_crop		crop;
+	struct v4l2_rect	compose;
+	s32			rotation;
+	u32			hflip:1;
+	u32			vflip:1;
+	u32			hdr:1;
+	u32			dre:1;
+	u32			sharpness:1;
+	u32			dither:1;
+};
+
+static inline bool mdp_target_is_crop(u32 target)
+{
+	return (target == V4L2_SEL_TGT_CROP) ||
+		(target == V4L2_SEL_TGT_CROP_DEFAULT) ||
+		(target == V4L2_SEL_TGT_CROP_BOUNDS);
+}
+
+static inline bool mdp_target_is_compose(u32 target)
+{
+	return (target == V4L2_SEL_TGT_COMPOSE) ||
+		(target == V4L2_SEL_TGT_COMPOSE_DEFAULT) ||
+		(target == V4L2_SEL_TGT_COMPOSE_BOUNDS);
+}
+
+#define MDP_MAX_CAPTURES	IMG_MAX_HW_OUTPUTS
+
+#define MDP_VPU_INIT		BIT(0)
+#define MDP_M2M_SRC_FMT		BIT(1)
+#define MDP_M2M_DST_FMT		BIT(2)
+#define MDP_M2M_CTX_ERROR	BIT(5)
+
+struct mdp_frameparam {
+	struct list_head	list;
+	/* synchronization protect for m2m context state */
+	struct mutex		lock;
+	u32			state;
+	const struct mdp_limit	*limit;
+	u32			type;	/* enum mdp_stream_type */
+	u32			frame_no;
+	struct mdp_frame	output;
+	struct mdp_frame	captures[MDP_MAX_CAPTURES];
+	u32			num_captures;
+	/* __u8			pq_data[]; */
+	enum v4l2_colorspace		colorspace;
+	enum v4l2_ycbcr_encoding	ycbcr_enc;
+	enum v4l2_xfer_func		xfer_func;
+	enum v4l2_quantization		quant;
+};
+
+int mdp_enum_fmt_mplane(struct v4l2_fmtdesc *f);
+const struct mdp_format *mdp_try_fmt_mplane(struct v4l2_format *f,
+					    struct mdp_frameparam *param,
+					    u32 ctx_id);
+enum mdp_ycbcr_profile mdp_map_ycbcr_prof_mplane(struct v4l2_format *f,
+						 u32 mdp_color);
+int mdp_try_crop(struct v4l2_rect *r, const struct v4l2_selection *s,
+		 struct mdp_frame *frame, u32 ctx_id);
+int mdp_check_scaling_ratio(const struct v4l2_rect *crop,
+			    const struct v4l2_rect *compose, s32 rotation,
+	const struct mdp_limit *limit);
+void mdp_set_src_config(struct img_input *in,
+			struct mdp_frame *frame, struct vb2_buffer *vb);
+void mdp_set_dst_config(struct img_output *out,
+			struct mdp_frame *frame, struct vb2_buffer *vb);
+
+struct mdp_frameparam *mdp_frameparam_init(void);
+void mdp_frameparam_release(struct mdp_frameparam *param);
+
+#endif  /* __MTK_MDP3_REGS_H__ */
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-ut.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-ut.c
new file mode 100644
index 000000000000..e259aeca54fb
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-ut.c
@@ -0,0 +1,663 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include "mtk-mdp3-core.h"
+#include "mtk-mdp3-m2m.h"
+#include "mtk-mdp3-vpu.h"
+#include "mtk-mdp3-regs.h"
+#include "mtk-mdp3-comp.h"
+#include "mtk-mdp3-cmdq.h"
+#include "mdp-platform.h"
+
+#include "mmsys_config.h"
+#include "mdp_reg_rdma.h"
+#include "mdp_reg_rsz.h"
+#include "mdp_reg_wrot.h"
+#include "mdp_reg_wdma.h"
+#include "isp_reg.h"
+
+static void dump_config(struct img_config *config)
+{
+	struct img_compparam *comp;
+	struct img_mmsys_ctrl *ctrl;
+	int i, j;
+
+	mdp_dbg(1, "comps:%d subfrms:%d",
+		config->num_components, config->num_subfrms);
+	for (i = 0; i < config->num_components; i++) {
+		comp = &config->components[i];
+		mdp_dbg(1, "comp-%d type:%d input:%d outputs:%d",
+			i, comp->type, comp->input, comp->num_outputs);
+		for (j = 0; j < comp->num_outputs; j++)
+			mdp_dbg(1, "%6c output%d:%d", ' ', j,
+				comp->outputs[j]);
+		mdp_dbg(1, "%6c disable:%d bypass:%d in:%dx%d out:%dx%d", ' ',
+			comp->frame.output_disable, comp->frame.bypass,
+			comp->frame.in_width, comp->frame.in_height,
+			comp->frame.out_width, comp->frame.out_height);
+		mdp_dbg(1, "crop:(%d %d %d %d) total:%d->%d",
+			comp->frame.crop.left, comp->frame.crop.top,
+			comp->frame.crop.width, comp->frame.crop.height,
+			comp->frame.in_total_width,
+			comp->frame.out_total_width);
+		switch (comp->type) {
+		case MDP_RDMA0:
+			mdp_dbg(1, "%6c rdma src:%#08x ctrl:%#08x", ' ',
+				comp->rdma.src_ctrl, comp->rdma.control);
+			mdp_dbg(1, "iova[%#x %#x %#x] mf:%d sf:%d trans:%#08x",
+				comp->rdma.iova[0], comp->rdma.iova[1],
+				comp->rdma.iova[2], comp->rdma.mf_bkgd,
+				comp->rdma.sf_bkgd, comp->rdma.transform);
+			break;
+		case MDP_SCL0:
+		case MDP_SCL1:
+			mdp_dbg(1, "%6c rsz %#08x %#08x", ' ',
+				comp->rsz.coeff_step_x, comp->rsz.coeff_step_y);
+			break;
+		case MDP_WROT0:
+			mdp_dbg(1, "%6c wrot iova[%#x %#x %#x]", ' ',
+				comp->wrot.iova[0], comp->wrot.iova[1],
+				comp->wrot.iova[2]);
+			mdp_dbg(1, "stride[%d %d %d]",
+				comp->wrot.stride[0], comp->wrot.stride[1],
+				comp->wrot.stride[2]);
+			mdp_dbg(1, "ctrl:%#08x mat:%#08x",
+				comp->wrot.control, comp->wrot.mat_ctrl);
+			break;
+		}
+	}
+	for (j = 0; j < config->num_subfrms; j++) {
+		ctrl = &config->ctrls[j];
+		mdp_dbg(1, "%3c sub-%d ctrls:%d", ' ', j, ctrl->num_sets);
+		for (i = 0; i < ctrl->num_sets; i++)
+			mdp_dbg(1, "%9c ctrl %#08x %#x", ' ',
+				ctrl->sets[i].reg, ctrl->sets[i].value);
+		for (i = 0; i < config->num_components; i++) {
+			comp = &config->components[i];
+			mdp_dbg(1, "%9c comp %d disable:%d in:[%d %d %d %d]",
+				' ',
+				comp->type, comp->subfrms[j].tile_disable,
+				comp->subfrms[j].in.left,
+				comp->subfrms[j].in.top,
+				comp->subfrms[j].in.right,
+				comp->subfrms[j].in.bottom);
+			mdp_dbg(1, "out:[%d %d %d %d]",
+				comp->subfrms[j].out.left,
+				comp->subfrms[j].out.top,
+				comp->subfrms[j].out.right,
+				comp->subfrms[j].out.bottom);
+			switch (comp->type) {
+			case MDP_RDMA0:
+				mdp_dbg(1, "%14c rdma ofst[%#x %#x %#x]", ' ',
+					comp->rdma.subfrms[j].offset[0],
+					comp->rdma.subfrms[j].offset[1],
+					comp->rdma.subfrms[j].offset[2]);
+				mdp_dbg(1, "src:%#08x clip:%#08x ofst:%#08x",
+					comp->rdma.subfrms[j].src,
+					comp->rdma.subfrms[j].clip,
+					comp->rdma.subfrms[j].clip_ofst);
+				break;
+			case MDP_SCL0:
+			case MDP_SCL1:
+				mdp_dbg(1, "%14c rsz src:%#08x clip:%#08x", ' ',
+					comp->rsz.subfrms[j].src,
+					comp->rsz.subfrms[j].clip);
+				break;
+			case MDP_WROT0:
+				mdp_dbg(1, "%14c wrot ofst[%#x %#x %#x]", ' ',
+					comp->wrot.subfrms[j].offset[0],
+					comp->wrot.subfrms[j].offset[1],
+					comp->wrot.subfrms[j].offset[2]);
+				mdp_dbg(1, "src:%#08x clip:%#08x ofst:%#08x",
+					comp->wrot.subfrms[j].src,
+					comp->wrot.subfrms[j].clip,
+					comp->wrot.subfrms[j].clip_ofst);
+				break;
+			}
+		}
+	}
+}
+
+#define FRAMEHEIGHT	48
+#define IOVABASE	0x50000000
+#define PLANESIZE	0x00100000
+#define PLANEOFFSET	0x00001000
+#define SRCBASE	(IOVABASE + 0x0)
+#define SRCOFFSET	0x00010000
+#define DSTBASE	(IOVABASE + 0x01000000)
+#define DSTOFFSET	0X00020000
+
+#define CROP { \
+	.width = FRAMEWIDTH, \
+	.height = FRAMEHEIGHT, \
+}
+#define REGION { \
+	.right = FRAMEWIDTH - 1, \
+	.bottom = FRAMEHEIGHT - 1, \
+}
+#define FRAME_STRUCT { \
+	.output_disable = false, \
+	.bypass = false, \
+	.in_width = FRAMEWIDTH, \
+	.in_height = FRAMEHEIGHT, \
+	.out_width = FRAMEWIDTH, \
+	.out_height = FRAMEHEIGHT, \
+	.crop = CROP, \
+	.in_total_width = FRAMEWIDTH, \
+	.out_total_width = FRAMEWIDTH, \
+}
+#define SUBFRM_STRUCT { \
+	.tile_disable = false, \
+	.in = REGION, \
+	.out = REGION, \
+}
+#define COMP_STRUCT { \
+	.input = 0, \
+	.outputs[0] = 0, \
+	.num_outputs = 1, \
+	.frame = FRAME_STRUCT, \
+	.subfrms = { SUBFRM_STRUCT }, \
+	.num_subfrms = 1, \
+}
+#define PIX_FORMAT(colr) { \
+	.width = FRAMEWIDTH, \
+	.height = FRAMEHEIGHT, \
+	.colorformat = (colr), \
+	.plane_fmt = { { \
+		.size = FRAMEWIDTH * FRAMEHEIGHT * 4, \
+		.stride = FRAMEWIDTH * 4, \
+	}, }, \
+}
+#define SRCIOVA { SRCBASE, SRCBASE + PLANESIZE, SRCBASE + PLANESIZE * 2 }
+#define SRCIOVAEND { \
+	SRCBASE + PLANESIZE - 1, \
+	SRCBASE + PLANESIZE * 2 - 1, \
+	SRCBASE + PLANESIZE * 3 - 1 }
+#define SRCSUBOFFSET { \
+	SRCOFFSET, \
+	SRCOFFSET + PLANEOFFSET, \
+	SRCOFFSET + PLANEOFFSET * 2 }
+#define DSTIOVA { DSTBASE, DSTBASE + PLANESIZE, DSTBASE + PLANESIZE * 2 }
+#define DSTSUBOFFSET { \
+	DSTOFFSET, \
+	DSTOFFSET + PLANEOFFSET, \
+	DSTOFFSET + PLANEOFFSET * 2 }
+#define RDMADATA { \
+	.src_ctrl = (MDP_COLOR_GET_HW_FORMAT(SRCCOLR) <<  0) + \
+		(3 <<  9) + \
+		(0 << 11) + \
+		(0 << 12) + \
+		(MDP_COLOR_IS_SWAPPED(SRCCOLR) << 14) + \
+		(MDP_COLOR_IS_BLOCK_MODE(SRCCOLR) << 15) + \
+		(1 << 19) + \
+		(MDP_COLOR_IS_10BIT_PACKED(SRCCOLR) << 22) + \
+		(MDP_COLOR_IS_10BIT_TILE(SRCCOLR) << 23) + \
+		(0 << 24) + \
+		(0 << 25), /* alpha rotation */ \
+	.control = ((!MDP_COLOR_IS_BLOCK_MODE(SRCCOLR)) << 12) + \
+		(0 <<  8) + \
+		(1 <<  4), \
+	.iova = SRCIOVA, \
+	.iova_end = SRCIOVAEND, \
+	.mf_bkgd = FRAMEWIDTH * 4, \
+	.sf_bkgd = 0, \
+	.transform = (0 << 24) + \
+		(0 << 20) + \
+		(0 << 16), \
+	.subfrms = { { \
+		.offset = SRCSUBOFFSET, \
+		.src = (FRAMEHEIGHT << 16) + (FRAMEWIDTH <<  0), \
+		.clip = (FRAMEHEIGHT << 16) + (FRAMEWIDTH <<  0), \
+		.clip_ofst = 0, \
+	}, }, \
+}
+#define WROTDATA { \
+	.iova = DSTIOVA, \
+	.control = (0 << 30) + \
+		(0 << 28) + \
+		(1 << 24) + \
+		(0 << 20) + \
+		(0 << 16) + /* alpha rotation */ \
+		(1 << 14) + \
+		(1 << 12) + \
+		(MDP_COLOR_IS_SWAPPED(DSTCOLR) <<  8) + \
+		(MDP_COLOR_GET_HW_FORMAT(DSTCOLR) <<  0), \
+	.stride = { FRAMEWIDTH * 4, 0, 0 }, \
+	.mat_ctrl = (0 << 4) + \
+		(0 << 1) + \
+		(0 << 0), \
+	.fifo_test = 128, \
+	.filter = (0 << 4) + \
+		(0 << 0), \
+	.subfrms = { { \
+		.offset = DSTSUBOFFSET, \
+		.src = (FRAMEHEIGHT << 16) + (FRAMEWIDTH <<  0), \
+		.clip = (FRAMEHEIGHT << 16) + (FRAMEWIDTH <<  0), \
+		.clip_ofst = 0, \
+		.main_buf = 0x401000, \
+	}, }, \
+}
+#define MDPINPUT { \
+	.buffer = { \
+		.format = PIX_FORMAT(SRCCOLR), \
+		.iova = SRCIOVA, \
+		.usage = MDP_BUFFER_USAGE_HW_READ, \
+	}, \
+	.flags = 0, \
+}
+#define MDPOUTPUT { \
+	.buffer = { \
+		.format = PIX_FORMAT(DSTCOLR), \
+		.iova = DSTIOVA, \
+		.usage = MDP_BUFFER_USAGE_MDP, \
+	}, \
+	.crop = CROP, \
+	.flags = IMG_CTRL_FLAG_HFLIP, \
+}
+#define _PARAM_COMMON \
+	.type = MDP_STREAM_TYPE_BITBLT, \
+	.num_inputs = 1, \
+	.num_outputs = 1, \
+	.inputs = { MDPINPUT }, \
+	.outputs = { MDPOUTPUT }
+#define PARAM_CMDQ { \
+	_PARAM_COMMON, \
+}
+#define PARAM_VPU { \
+	_PARAM_COMMON, \
+	.config_data = { \
+		.va = (unsigned long)vpu->config, \
+		.pa = vpu->inst_addr, \
+	}, \
+}
+#define TASK(cfg) { \
+	.config = (cfg), \
+	.param = &param, \
+	.composes = { &compose, }, \
+	.wait = 1, \
+}
+
+static int mdp_cmdq_alpharot_ut(struct mdp_dev *mdp)
+{
+#undef  SRCCOLR
+#undef  DSTCOLR
+#undef  FRAMEWIDTH
+#define SRCCOLR	MDP_COLOR_RGBA8888
+#define DSTCOLR	MDP_COLOR_ABGR8888
+#define FRAMEWIDTH	64
+	static const struct mdp_rdma_data initrdma = RDMADATA;
+	static const struct mdp_wrot_data initwrot = WROTDATA;
+	static const struct img_config initcfg = {
+		.components = { COMP_STRUCT, COMP_STRUCT, COMP_STRUCT },
+		.num_components = 3,
+		.ctrls = { {
+			.sets = { {
+				.reg = MDP_RDMA0_MOUT_EN,
+				.value = 4,
+			}, {
+				.reg = MDP_PATH0_SEL_IN,
+				.value = 3,
+			}, {
+				.reg = MDP_WROT0_SEL_IN,
+				.value = 0,
+			}, {
+				.reg = MDP_PATH0_SOUT_SEL,
+				.value = 0,
+			}, },
+			.num_sets = 4,
+		}, },
+		.num_subfrms = 1,
+	};
+
+	struct img_config *config = kzalloc(sizeof(*config), GFP_KERNEL);
+	struct img_ipi_frameparam param = PARAM_CMDQ;
+	struct v4l2_rect compose;
+	struct mdp_cmdq_param task = TASK(config);
+	int ret;
+
+	mdp_dbg(1, "");
+	*config = initcfg;
+	config->components[0].type = MDP_RDMA0;
+	config->components[0].id = 0;
+	config->components[0].rdma = initrdma;
+	config->components[0].rdma.src_ctrl |= (1 << 25); /* alpha rotation */
+	config->components[1].type = MDP_PATH0_SOUT;
+	config->components[1].id = 0;
+	config->components[2].type = MDP_WROT0;
+	config->components[2].id = 0;
+	config->components[2].wrot = initwrot;
+	config->components[2].wrot.control &= ~((1 << 16) | (1 << 8));
+	config->components[2].wrot.control |= (1 << 16) + /* alpha rotation */
+		/* workaround for alpha rotation */
+		((MDP_COLOR_IS_SWAPPED(DSTCOLR) ? 0 : 1) <<  8);
+
+	compose.left = param.outputs[0].crop.left;
+	compose.top = param.outputs[0].crop.top;
+	compose.width = param.outputs[0].crop.width;
+	compose.height = param.outputs[0].crop.height;
+
+	ret = mdp_cmdq_send(mdp, &task);
+	if (ret)
+		dev_err(&mdp->pdev->dev, "%s failed: %d\n", __func__, ret);
+	/* print cmdq result */
+	kfree(config);
+	return ret;
+}
+
+static int mdp_vpu_alpharot_ut(struct mdp_dev *mdp, struct mdp_vpu_ctx *vpu)
+{
+#undef  SRCCOLR
+#undef  DSTCOLR
+#undef  FRAMEWIDTH
+#define SRCCOLR	MDP_COLOR_RGBA8888
+#define DSTCOLR	MDP_COLOR_ABGR8888
+#define FRAMEWIDTH	64
+	struct img_ipi_frameparam param = PARAM_VPU;
+	struct v4l2_rect compose;
+	struct mdp_cmdq_param task = TASK(vpu->config);
+	int ret;
+
+	mdp_dbg(1, "");
+	ret = mdp_vpu_process(vpu, &param);
+	if (ret) {
+		dev_err(&mdp->pdev->dev, "%s processing failed: %d\n",
+			__func__, ret);
+		return ret;
+	}
+	dump_config(vpu->config);
+
+	compose.left = param.outputs[0].crop.left;
+	compose.top = param.outputs[0].crop.top;
+	compose.width = param.outputs[0].crop.width;
+	compose.height = param.outputs[0].crop.height;
+
+	ret = mdp_cmdq_send(mdp, &task);
+	if (ret)
+		dev_err(&mdp->pdev->dev, "%s failed: %d\n", __func__, ret);
+	/* print cmdq result */
+	return ret;
+}
+
+static int mdp_cmdq_resizer_ut(struct mdp_dev *mdp)
+{
+#undef  SRCCOLR
+#undef  DSTCOLR
+#undef  FRAMEWIDTH
+#define SRCCOLR	MDP_COLOR_RGBA8888
+#define DSTCOLR	MDP_COLOR_ABGR8888
+#define FRAMEWIDTH	64
+	static const struct mdp_rdma_data initrdma = RDMADATA;
+	static const struct mdp_wrot_data initwrot = WROTDATA;
+	static const struct img_config initcfg = {
+		.components = {
+			COMP_STRUCT, COMP_STRUCT, COMP_STRUCT,
+			COMP_STRUCT, COMP_STRUCT
+		},
+		.num_components = 5,
+		.ctrls = { {
+			.sets = { {
+				.reg = MDP_RDMA0_MOUT_EN,
+				.value = 1,
+			}, {
+				.reg = MDP_PRZ0_MOUT_EN,
+				.value = 1,
+			}, {
+				.reg = MDP_CCORR_SEL_IN,
+				.value = 1,
+			}, {
+				.reg = MDP_PRZ0_SEL_IN,
+				.value = 1,
+			}, {
+				.reg = MDP_PATH0_SEL_IN,
+				.value = 0,
+			}, {
+				.reg = MDP_WROT0_SEL_IN,
+				.value = 0,
+			}, {
+				.reg = MDP_CCORR_SOUT_SEL,
+				.value = 1,
+			}, {
+				.reg = MDP_PATH0_SOUT_SEL,
+				.value = 0,
+			}, },
+			.num_sets = 8,
+		}, },
+		.num_subfrms = 1,
+	};
+
+	struct img_config *config = kzalloc(sizeof(*config), GFP_KERNEL);
+	struct img_ipi_frameparam param = PARAM_CMDQ;
+	struct v4l2_rect compose;
+	struct mdp_cmdq_param task = TASK(config);
+	int ret;
+
+	mdp_dbg(1, "");
+	*config = initcfg;
+	config->components[0].type = MDP_RDMA0;
+	config->components[0].id = 0;
+	config->components[0].rdma = initrdma;
+	config->components[1].type = MDP_CCORR0;
+	config->components[1].id = 0;
+	config->components[2].type = MDP_SCL0;
+	config->components[2].id = 0;
+	config->components[2].frame.bypass = true;
+	config->components[3].type = MDP_PATH0_SOUT;
+	config->components[3].id = 0;
+	config->components[4].type = MDP_WROT0;
+	config->components[4].id = 0;
+	config->components[4].wrot = initwrot;
+
+	compose.left = param.outputs[0].crop.left;
+	compose.top = param.outputs[0].crop.top;
+	compose.width = param.outputs[0].crop.width;
+	compose.height = param.outputs[0].crop.height;
+
+	ret = mdp_cmdq_send(mdp, &task);
+	if (ret)
+		dev_err(&mdp->pdev->dev, "%s failed: %d\n", __func__, ret);
+	/* print cmdq result */
+	kfree(config);
+	return ret;
+}
+
+static int mdp_vpu_resizer_ut(struct mdp_dev *mdp, struct mdp_vpu_ctx *vpu)
+{
+#undef  SRCCOLR
+#undef  DSTCOLR
+#undef  FRAMEWIDTH
+#define SRCCOLR	MDP_COLOR_RGB888
+#define DSTCOLR	MDP_COLOR_ABGR8888
+#define FRAMEWIDTH	64
+	struct img_ipi_frameparam param = PARAM_VPU;
+	struct v4l2_rect compose;
+	struct mdp_cmdq_param task = TASK(vpu->config);
+	int ret;
+
+	mdp_dbg(1, "");
+	ret = mdp_vpu_process(vpu, &param);
+	if (ret) {
+		dev_err(&mdp->pdev->dev, "%s processing failed: %d\n",
+			__func__, ret);
+		return ret;
+	}
+	dump_config(vpu->config);
+
+	compose.left = param.outputs[0].crop.left;
+	compose.top = param.outputs[0].crop.top;
+	compose.width = param.outputs[0].crop.width;
+	compose.height = param.outputs[0].crop.height;
+
+	ret = mdp_cmdq_send(mdp, &task);
+	if (ret)
+		dev_err(&mdp->pdev->dev, "%s failed: %d\n", __func__, ret);
+	/* print cmdq result */
+	return ret;
+}
+
+static int mdp_vpu_tile_ut(struct mdp_dev *mdp, struct mdp_vpu_ctx *vpu)
+{
+#undef  SRCCOLR
+#undef  DSTCOLR
+#undef  FRAMEWIDTH
+#define SRCCOLR	MDP_COLOR_RGB888
+#define DSTCOLR	MDP_COLOR_ABGR8888
+#define FRAMEWIDTH	1920
+	struct img_ipi_frameparam param = PARAM_VPU;
+	struct v4l2_rect compose;
+	struct mdp_cmdq_param task = TASK(vpu->config);
+	int ret;
+
+	mdp_dbg(1, "");
+	ret = mdp_vpu_process(vpu, &param);
+	if (ret) {
+		dev_err(&mdp->pdev->dev, "%s processing failed: %d\n",
+			__func__, ret);
+		return ret;
+	}
+	dump_config(vpu->config);
+
+	compose.left = param.outputs[0].crop.left;
+	compose.top = param.outputs[0].crop.top;
+	compose.width = param.outputs[0].crop.width;
+	compose.height = param.outputs[0].crop.height;
+
+	ret = mdp_cmdq_send(mdp, &task);
+	if (ret)
+		dev_err(&mdp->pdev->dev, "%s failed: %d\n", __func__, ret);
+	/* print cmdq result */
+	return ret;
+}
+
+/* define SMI register settings */
+#define REG_SMI_LARBx_NONSEC_CON(base, port)	((base) + 0x380 + ((port) << 2))
+
+static int mdp_cmdq_ut(struct mdp_dev *mdp)
+{
+	int ret;
+
+	mdp_dbg(1, "");
+	ret = mdp_cmdq_alpharot_ut(mdp);
+	if (ret)
+		return ret;
+	mdp_dbg(1, "pass");
+	ret = mdp_cmdq_resizer_ut(mdp);
+	if (ret)
+		return ret;
+	mdp_dbg(1, "pass");
+	return ret;
+}
+
+static int mdp_vpu_ut(struct mdp_dev *mdp)
+{
+	struct mdp_vpu_ctx vpu;
+	int ret;
+
+	mdp_dbg(1, "");
+	ret = mdp_vpu_ctx_init(&vpu, &mdp->vpu, MDP_DEV_M2M);
+	if (ret) {
+		dev_err(&mdp->pdev->dev, "VPU init failed %d\n", ret);
+		return -EINVAL;
+	}
+
+	ret = mdp_vpu_alpharot_ut(mdp, &vpu);
+	if (ret)
+		goto teardown;
+	mdp_dbg(1, "pass");
+	ret = mdp_vpu_resizer_ut(mdp, &vpu);
+	if (ret)
+		goto teardown;
+	mdp_dbg(1, "pass");
+	ret = mdp_vpu_tile_ut(mdp, &vpu);
+	if (ret)
+		goto teardown;
+	mdp_dbg(1, "pass");
+
+teardown:
+	mdp_vpu_ctx_deinit(&vpu);
+	return ret;
+}
+
+int mdp_ut(struct mdp_dev *mdp)
+{
+	struct device_node *node;
+	void __iomem *va;
+	int ret;
+
+	/* Set SMI LARB to disable MMU (VA) */
+	node = of_parse_phandle(mdp->pdev->dev.of_node, "mediatek,larb", 0);
+	if (!node) {
+		dev_err(&mdp->pdev->dev, "Cannot get SMI larb node\n");
+		return -EINVAL;
+	}
+
+	va = of_iomap(node, 0);
+	of_node_put(node);
+	/* larb0 port6 rdma0 */
+	writel(0, REG_SMI_LARBx_NONSEC_CON(va, 6));
+	/* larb0 port7 wrot0 */
+	writel(0, REG_SMI_LARBx_NONSEC_CON(va, 7));
+	/* larb1 port8 wdma */
+	writel(0, REG_SMI_LARBx_NONSEC_CON(va, 8));
+
+	ret = mdp_cmdq_ut(mdp);
+	if (ret)
+		goto teardown;
+	ret = mdp_vpu_ut(mdp);
+	if (ret)
+		goto teardown;
+	//ret = mdp_m2m_ut(mdp);
+
+teardown:
+	/* larb0 port6 rdma0 */
+	writel(1, REG_SMI_LARBx_NONSEC_CON(va, 6));
+	/* larb0 port7 wrot0 */
+	writel(1, REG_SMI_LARBx_NONSEC_CON(va, 7));
+	/* larb1 port8 wdma */
+	writel(1, REG_SMI_LARBx_NONSEC_CON(va, 8));
+	return ret;
+}
+
+ssize_t mdp_ut_run(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev =
+		container_of(dev, struct platform_device, dev);
+	struct mdp_dev *mdp = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	if (mutex_lock_interruptible(&mdp->m2m_lock)) {
+		ret = -ERESTARTSYS;
+		goto err_lock;
+	}
+
+	ret = mdp_vpu_get_locked(mdp);
+	if (ret < 0)
+		goto err_load_vpu;
+
+	ret = mdp_ut(mdp);
+	if (ret)
+		dev_err(dev, "mdp_ut ret=%d\n", ret);
+
+	mdp_vpu_put_locked(mdp);
+
+err_load_vpu:
+	mutex_unlock(&mdp->m2m_lock);
+
+err_lock:
+
+	return sizeof(buf);
+}
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.c
new file mode 100644
index 000000000000..8cb50754aac4
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.c
@@ -0,0 +1,290 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/remoteproc.h>
+#include <linux/platform_data/mtk_scp.h>
+#include "mtk-mdp3-vpu.h"
+#include "mtk-mdp3-core.h"
+
+#define MDP_VPU_MESSAGE_TIMEOUT 500U
+
+static inline struct mdp_dev *vpu_to_mdp(struct mdp_vpu_dev *vpu)
+{
+	return container_of(vpu, struct mdp_dev, vpu);
+}
+
+static void mdp_vpu_ipi_handle_init_ack(void *data, unsigned int len,
+					void *priv)
+{
+	struct mdp_ipi_init_msg *msg = (struct mdp_ipi_init_msg *)data;
+	struct mdp_vpu_dev *vpu =
+		(struct mdp_vpu_dev *)(unsigned long)msg->drv_data;
+
+	if (!vpu->work_size)
+		vpu->work_size = msg->work_size;
+	else
+		vpu->status = msg->status;
+	complete(&vpu->ipi_acked);
+}
+
+static void mdp_vpu_ipi_handle_deinit_ack(void *data, unsigned int len,
+					  void *priv)
+{
+	struct mdp_ipi_deinit_msg *msg = (struct mdp_ipi_deinit_msg *)data;
+	struct mdp_vpu_dev *vpu =
+		(struct mdp_vpu_dev *)(unsigned long)msg->drv_data;
+
+	vpu->status = msg->status;
+	complete(&vpu->ipi_acked);
+}
+
+static void mdp_vpu_ipi_handle_frame_ack(void *data, unsigned int len,
+					 void *priv)
+{
+	struct img_sw_addr *addr = (struct img_sw_addr *)data;
+	struct img_ipi_frameparam *param =
+		(struct img_ipi_frameparam *)addr->va;
+	struct mdp_vpu_ctx *ctx =
+		(struct mdp_vpu_ctx *)(unsigned long)param->drv_data;
+
+	ctx->failure = param->state;
+	if (ctx->failure) {
+		struct mdp_dev *mdp = vpu_to_mdp(ctx->vpu_dev);
+
+		dev_info(&mdp->pdev->dev, "VPU MDP failure:%d\n", ctx->failure);
+	}
+	complete(&ctx->vpu_dev->ipi_acked);
+}
+
+int mdp_vpu_register(struct platform_device *pdev)
+{
+	int err;
+
+	err = scp_ipi_register(pdev, SCP_IPI_MDP_INIT,
+		mdp_vpu_ipi_handle_init_ack, NULL);
+	if (err) {
+		dev_err(&pdev->dev, "scp_ipi_register failed %d\n", err);
+		goto err_ipi_init;
+	}
+	err = scp_ipi_register(pdev, SCP_IPI_MDP_DEINIT,
+		mdp_vpu_ipi_handle_deinit_ack, NULL);
+	if (err) {
+		dev_err(&pdev->dev, "scp_ipi_register failed %d\n", err);
+		goto err_ipi_deinit;
+	}
+	err = scp_ipi_register(pdev, SCP_IPI_MDP_FRAME,
+		mdp_vpu_ipi_handle_frame_ack, NULL);
+	if (err) {
+		dev_err(&pdev->dev, "scp_ipi_register failed %d\n", err);
+		goto err_ipi_frame;
+	}
+	return 0;
+
+err_ipi_frame:
+	/* vpu_ipi_unregister(IPI_MDP_DEINIT); */
+err_ipi_deinit:
+	/* vpu_ipi_unregister(IPI_MDP_INIT); */
+err_ipi_init:
+
+	return err;
+}
+
+void mdp_vpu_unregister(struct platform_device *pdev)
+{
+	/* vpu_ipi_unregister(IPI_MDP_INIT); */
+	/* vpu_ipi_unregister(IPI_MDP_DEINIT); */
+	/* vpu_ipi_unregister(IPI_MDP_FRAME); */
+}
+
+static int mdp_vpu_sendmsg(struct mdp_vpu_dev *vpu, enum scp_ipi_id id,
+	void *buf, unsigned int len)
+{
+	int ret;
+
+	if (!vpu->pdev) {
+		struct mdp_dev *mdp = vpu_to_mdp(vpu);
+
+		dev_dbg(&mdp->pdev->dev, "vpu pdev is NULL");
+		return -EINVAL;
+	}
+	ret = scp_ipi_send(vpu->pdev, id, buf, len, 2000);
+
+	if (ret) {
+		dev_err(&vpu->pdev->dev, "scp_ipi_send failed %d\n", ret);
+		return -EPERM;
+	}
+	ret =
+	wait_for_completion_timeout(&vpu->ipi_acked,
+				    msecs_to_jiffies(MDP_VPU_MESSAGE_TIMEOUT));
+	if (!ret)
+		ret = -ETIME;
+	else if (vpu->status)
+		ret = -EINVAL;
+	else
+		ret = 0;
+	return ret;
+}
+
+int mdp_vpu_dev_init(struct mdp_vpu_dev *vpu, struct platform_device *pdev,
+		     struct mutex *lock)
+{
+	struct mdp_ipi_init_msg msg = {
+		.drv_data = (unsigned long)vpu,
+	};
+	phys_addr_t mem_size, pool;
+	const size_t pool_size = sizeof(struct mdp_config_pool);
+	struct mdp_dev *mdp = vpu_to_mdp(vpu);
+	int err;
+
+	init_completion(&vpu->ipi_acked);
+	vpu->pdev = pdev;
+	vpu->lock = lock;
+	vpu->work_size = 0;
+	err = mdp_vpu_sendmsg(vpu, SCP_IPI_MDP_INIT, &msg, sizeof(msg));
+	if (err)
+		goto err_work_size;
+	/* vpu work_size was set in mdp_vpu_ipi_handle_init_ack */
+
+	vpu->work = scp_get_reserve_mem_virt(SCP_MDP_MEM_ID);
+	vpu->work_addr = scp_get_reserve_mem_phys(SCP_MDP_MEM_ID);
+	mem_size = scp_get_reserve_mem_size(SCP_MDP_MEM_ID);
+	pool = ALIGN(vpu->work + vpu->work_size, 8);
+	if (pool + pool_size - vpu->work > mem_size) {
+		dev_err(&mdp->pdev->dev,
+			"VPU memory insufficient: %lx + %lx > %llx",
+			vpu->work_size, pool_size, mem_size);
+		err = -ENOMEM;
+		goto err_mem_size;
+	}
+
+	dev_info(&mdp->pdev->dev,
+		 "VPU work:%llx pa:%llx sz:%lx pool:%llx sz:%lx (mem sz:%llx)",
+		vpu->work, vpu->work_addr, vpu->work_size,
+		pool, pool_size, mem_size);
+	vpu->pool = (struct mdp_config_pool *)pool;
+	msg.work_addr = vpu->work_addr;
+	msg.work_size = vpu->work_size;
+	err = mdp_vpu_sendmsg(vpu, SCP_IPI_MDP_INIT, &msg, sizeof(msg));
+	if (err)
+		goto err_work_size;
+	memset(vpu->pool, 0, sizeof(*vpu->pool));
+	return 0;
+
+err_work_size:
+	switch (vpu->status) {
+	case -MDP_IPI_EBUSY:
+		err = -EBUSY;
+		break;
+	case -MDP_IPI_ENOMEM:
+		err = -ENOSPC;	/* -ENOMEM */
+		break;
+	}
+err_mem_size:
+	return err;
+}
+
+int mdp_vpu_dev_deinit(struct mdp_vpu_dev *vpu)
+{
+	struct mdp_ipi_deinit_msg msg = {
+		.drv_data = (unsigned long)vpu,
+		.work_addr = vpu->work_addr,
+	};
+
+	return mdp_vpu_sendmsg(vpu, SCP_IPI_MDP_DEINIT, &msg, sizeof(msg));
+}
+
+static struct img_config *mdp_config_get(struct mdp_vpu_dev *vpu,
+					 enum mdp_config_id id, uint32_t *addr)
+{
+	struct img_config *config;
+
+	if (id < 0 || id >= MDP_CONFIG_POOL_SIZE)
+		return ERR_PTR(-EINVAL);
+	if (vpu->lock)
+		mutex_lock(vpu->lock);
+	vpu->pool->cfg_count[id]++;
+	config = &vpu->pool->configs[id];
+	*addr = vpu->work_addr + ((unsigned long)config - vpu->work);
+	if (vpu->lock)
+		mutex_unlock(vpu->lock);
+	return config;
+}
+
+static int mdp_config_put(struct mdp_vpu_dev *vpu,
+			  enum mdp_config_id id,
+			  const struct img_config *config)
+{
+	int err = 0;
+
+	if (id < 0 || id >= MDP_CONFIG_POOL_SIZE)
+		return -EINVAL;
+	if (vpu->lock)
+		mutex_lock(vpu->lock);
+	if (!vpu->pool->cfg_count[id] || config != &vpu->pool->configs[id])
+		err = -EINVAL;
+	else
+		vpu->pool->cfg_count[id]--;
+	if (vpu->lock)
+		mutex_unlock(vpu->lock);
+	return err;
+}
+
+int mdp_vpu_ctx_init(struct mdp_vpu_ctx *ctx, struct mdp_vpu_dev *vpu,
+		     enum mdp_config_id id)
+{
+	ctx->config = mdp_config_get(vpu, id, &ctx->inst_addr);
+	if (IS_ERR(ctx->config)) {
+		int err = PTR_ERR(ctx->config);
+
+		ctx->config = NULL;
+		return err;
+	}
+	ctx->config_id = id;
+	ctx->vpu_dev = vpu;
+	return 0;
+}
+
+int mdp_vpu_ctx_deinit(struct mdp_vpu_ctx *ctx)
+{
+	int err = mdp_config_put(ctx->vpu_dev, ctx->config_id, ctx->config);
+
+	ctx->config_id = 0;
+	ctx->config = NULL;
+	ctx->inst_addr = 0;
+	return err;
+}
+
+int mdp_vpu_process(struct mdp_vpu_ctx *ctx, struct img_ipi_frameparam *param)
+{
+	struct img_sw_addr addr;
+
+	if (!ctx->vpu_dev->work || !ctx->vpu_dev->work_addr) {
+		ctx->vpu_dev->work = scp_get_reserve_mem_virt(SCP_MDP_MEM_ID);
+		ctx->vpu_dev->work_addr =
+			scp_get_reserve_mem_phys(SCP_MDP_MEM_ID);
+	}
+	memset((void *)ctx->vpu_dev->work, 0, ctx->vpu_dev->work_size);
+	memset(ctx->config, 0, sizeof(*ctx->config));
+	param->config_data.va = (unsigned long)ctx->config;
+	param->config_data.pa = ctx->inst_addr;
+	param->drv_data = (unsigned long)ctx;
+
+	memcpy((void *)ctx->vpu_dev->work, param, sizeof(*param));
+	addr.pa = ctx->vpu_dev->work_addr;
+	addr.va = ctx->vpu_dev->work;
+	return mdp_vpu_sendmsg(ctx->vpu_dev, SCP_IPI_MDP_FRAME,
+		&addr, sizeof(addr));
+}
+
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.h b/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.h
new file mode 100644
index 000000000000..f6551d774902
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.h
@@ -0,0 +1,89 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_MDP3_VPU_H__
+#define __MTK_MDP3_VPU_H__
+
+#include <linux/platform_device.h>
+#include "mtk-img-ipi.h"
+
+enum mdp_ipi_result {
+	MDP_IPI_SUCCESS	= 0,
+	MDP_IPI_ENOMEM	= 12,
+	MDP_IPI_EBUSY	= 16,
+	MDP_IPI_EINVAL	= 22,
+	MDP_IPI_EMINST	= 24,
+	MDP_IPI_ERANGE	= 34,
+	MDP_IPI_NR_ERRNO,
+
+	MDP_IPI_EOTHER	= MDP_IPI_NR_ERRNO,
+	MDP_IPI_PATH_CANT_MERGE,
+	MDP_IPI_OP_FAIL,
+};
+
+struct mdp_ipi_init_msg {
+	u32	status;
+	u64	drv_data;
+	u32	work_addr;	/* [in] working buffer address */
+	u32	work_size;	/* [in] working buffer size */
+} __attribute__ ((__packed__));
+
+struct mdp_ipi_deinit_msg {
+	u32	status;
+	u64	drv_data;
+	u32	work_addr;
+} __attribute__ ((__packed__));
+
+enum mdp_config_id {
+	MDP_DEV_M2M = 0,
+	MDP_CONFIG_POOL_SIZE	/* ALWAYS keep at the end */
+};
+
+struct mdp_config_pool {
+	u64		cfg_count[MDP_CONFIG_POOL_SIZE];
+	struct img_config	configs[MDP_CONFIG_POOL_SIZE];
+};
+
+struct mdp_vpu_dev {
+	struct mutex		*lock;
+	struct platform_device	*pdev;
+	struct completion	ipi_acked;
+	phys_addr_t		work;
+	phys_addr_t		work_addr;
+	size_t			work_size;
+	struct mdp_config_pool	*pool;
+	u32		status;
+};
+
+struct mdp_vpu_ctx {
+	struct mdp_vpu_dev	*vpu_dev;
+	u32		config_id;
+	struct img_config	*config;
+	u32		inst_addr;
+	s32			failure;
+};
+
+int mdp_vpu_register(struct platform_device *pdev);
+void mdp_vpu_unregister(struct platform_device *pdev);
+int mdp_vpu_dev_init(struct mdp_vpu_dev *vpu, struct platform_device *pdev,
+		     struct mutex *lock);
+int mdp_vpu_dev_deinit(struct mdp_vpu_dev *vpu);
+int mdp_vpu_ctx_init(struct mdp_vpu_ctx *ctx, struct mdp_vpu_dev *vpu,
+		     enum mdp_config_id id);
+int mdp_vpu_ctx_deinit(struct mdp_vpu_ctx *ctx);
+int mdp_vpu_process(struct mdp_vpu_ctx *vpu, struct img_ipi_frameparam *param);
+
+#endif  /* __MTK_MDP3_VPU_H__ */
+
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.c
index 5a6ec8fb52da..529b2e3b79c5 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.c
@@ -8,7 +8,6 @@
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
 #include <linux/pm_runtime.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_vcodec_dec_pm.h"
 #include "mtk_vcodec_util.h"
@@ -16,7 +15,6 @@
 
 int mtk_vcodec_init_dec_pm(struct mtk_vcodec_dev *mtkdev)
 {
-	struct device_node *node;
 	struct platform_device *pdev;
 	struct mtk_vcodec_pm *pm;
 	struct mtk_vcodec_clk *dec_clk;
@@ -27,18 +25,7 @@ int mtk_vcodec_init_dec_pm(struct mtk_vcodec_dev *mtkdev)
 	pm = &mtkdev->pm;
 	pm->mtkdev = mtkdev;
 	dec_clk = &pm->vdec_clk;
-	node = of_parse_phandle(pdev->dev.of_node, "mediatek,larb", 0);
-	if (!node) {
-		mtk_v4l2_err("of_parse_phandle mediatek,larb fail!");
-		return -1;
-	}
 
-	pdev = of_find_device_by_node(node);
-	of_node_put(node);
-	if (WARN_ON(!pdev)) {
-		return -1;
-	}
-	pm->larbvdec = &pdev->dev;
 	pdev = mtkdev->plat_dev;
 	pm->dev = &pdev->dev;
 
@@ -114,11 +101,6 @@ void mtk_vcodec_dec_clock_on(struct mtk_vcodec_pm *pm)
 		}
 	}
 
-	ret = mtk_smi_larb_get(pm->larbvdec);
-	if (ret) {
-		mtk_v4l2_err("mtk_smi_larb_get larbvdec fail %d", ret);
-		goto error;
-	}
 	return;
 
 error:
@@ -131,7 +113,6 @@ void mtk_vcodec_dec_clock_off(struct mtk_vcodec_pm *pm)
 	struct mtk_vcodec_clk *dec_clk = &pm->vdec_clk;
 	int i = 0;
 
-	mtk_smi_larb_put(pm->larbvdec);
 	for (i = dec_clk->clk_num - 1; i >= 0; i--)
 		clk_disable_unprepare(dec_clk->clk_info[i].vcodec_clk);
 }
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_drv.h b/drivers/media/platform/mtk-vcodec/mtk_vcodec_drv.h
index c95de5d08dda..61fefa1fa0b1 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_drv.h
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_drv.h
@@ -188,11 +188,8 @@ struct mtk_vcodec_clk {
  */
 struct mtk_vcodec_pm {
 	struct mtk_vcodec_clk	vdec_clk;
-	struct device	*larbvdec;
 
 	struct mtk_vcodec_clk	venc_clk;
-	struct device	*larbvenc;
-	struct device	*larbvenclt;
 	struct device	*dev;
 	struct mtk_vcodec_dev	*mtkdev;
 };
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc.c
index fd8de027e83e..75e0e8505410 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc.c
@@ -8,7 +8,6 @@
 #include <media/v4l2-event.h>
 #include <media/v4l2-mem2mem.h>
 #include <media/videobuf2-dma-contig.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_vcodec_drv.h"
 #include "mtk_vcodec_enc.h"
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc_pm.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc_pm.c
index 3e2bfded79a6..20182f9f126e 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc_pm.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc_pm.c
@@ -8,7 +8,6 @@
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
 #include <linux/pm_runtime.h>
-#include <soc/mediatek/smi.h>
 
 #include "mtk_vcodec_enc_pm.h"
 #include "mtk_vcodec_util.h"
@@ -17,7 +16,6 @@
 
 int mtk_vcodec_init_enc_pm(struct mtk_vcodec_dev *mtkdev)
 {
-	struct device_node *node;
 	struct platform_device *pdev;
 	struct mtk_vcodec_pm *pm;
 	struct mtk_vcodec_clk *enc_clk;
@@ -33,33 +31,6 @@ int mtk_vcodec_init_enc_pm(struct mtk_vcodec_dev *mtkdev)
 	dev = &pdev->dev;
 	enc_clk = &pm->venc_clk;
 
-	node = of_parse_phandle(dev->of_node, "mediatek,larb", 0);
-	if (!node) {
-		mtk_v4l2_err("no mediatek,larb found");
-		return -ENODEV;
-	}
-	pdev = of_find_device_by_node(node);
-	of_node_put(node);
-	if (!pdev) {
-		mtk_v4l2_err("no mediatek,larb device found");
-		return -ENODEV;
-	}
-	pm->larbvenc = &pdev->dev;
-
-	node = of_parse_phandle(dev->of_node, "mediatek,larb", 1);
-	if (!node) {
-		mtk_v4l2_err("no mediatek,larb found");
-		return -ENODEV;
-	}
-
-	pdev = of_find_device_by_node(node);
-	of_node_put(node);
-	if (!pdev) {
-		mtk_v4l2_err("no mediatek,larb device found");
-		return -ENODEV;
-	}
-
-	pm->larbvenclt = &pdev->dev;
 	pdev = mtkdev->plat_dev;
 	pm->dev = &pdev->dev;
 
@@ -115,21 +86,8 @@ void mtk_vcodec_enc_clock_on(struct mtk_vcodec_pm *pm)
 		}
 	}
 
-	ret = mtk_smi_larb_get(pm->larbvenc);
-	if (ret) {
-		mtk_v4l2_err("mtk_smi_larb_get larb3 fail %d", ret);
-		goto larbvencerr;
-	}
-	ret = mtk_smi_larb_get(pm->larbvenclt);
-	if (ret) {
-		mtk_v4l2_err("mtk_smi_larb_get larb4 fail %d", ret);
-		goto larbvenclterr;
-	}
 	return;
 
-larbvenclterr:
-	mtk_smi_larb_put(pm->larbvenc);
-larbvencerr:
 clkerr:
 	for (i -= 1; i >= 0; i--)
 		clk_disable_unprepare(enc_clk->clk_info[i].vcodec_clk);
@@ -140,8 +98,6 @@ void mtk_vcodec_enc_clock_off(struct mtk_vcodec_pm *pm)
 	struct mtk_vcodec_clk *enc_clk = &pm->venc_clk;
 	int i = 0;
 
-	mtk_smi_larb_put(pm->larbvenc);
-	mtk_smi_larb_put(pm->larbvenclt);
 	for (i = enc_clk->clk_num - 1; i >= 0; i--)
 		clk_disable_unprepare(enc_clk->clk_info[i].vcodec_clk);
 }
diff --git a/drivers/media/platform/mtk-vpu/mtk_vpu.c b/drivers/media/platform/mtk-vpu/mtk_vpu.c
index 46706faa2fd2..a7eb55e9eb9c 100644
--- a/drivers/media/platform/mtk-vpu/mtk_vpu.c
+++ b/drivers/media/platform/mtk-vpu/mtk_vpu.c
@@ -41,25 +41,63 @@
 #define VPU_P_FW_SIZE		(VPU_PTCM_SIZE + VPU_EXT_P_SIZE)
 #define VPU_D_FW_SIZE		(VPU_DTCM_SIZE + VPU_EXT_D_SIZE)
 /* the size of share buffer between Host and  VPU */
-#define SHARE_BUF_SIZE		48
 
 /* binary firmware name */
 #define VPU_P_FW		"vpu_p.bin"
 #define VPU_D_FW		"vpu_d.bin"
 
-#define VPU_RESET		0x0
-#define VPU_TCM_CFG		0x0008
-#define VPU_PMEM_EXT0_ADDR	0x000C
-#define VPU_PMEM_EXT1_ADDR	0x0010
-#define VPU_TO_HOST		0x001C
-#define VPU_DMEM_EXT0_ADDR	0x0014
-#define VPU_DMEM_EXT1_ADDR	0x0018
-#define HOST_TO_VPU		0x0024
-#define VPU_PC_REG		0x0060
-#define VPU_WDT_REG		0x0084
+enum vpu_regs_idx {
+	VPU_RESET,
+	VPU_TCM_CFG,
+	VPU_TO_HOST,
+	HOST_TO_VPU,
+	VPU_PC_REG,
+	VPU_WDT_REG,
+
+	/* MT8173 only regs */
+	VPU_PMEM_EXT0_ADDR,
+	VPU_PMEM_EXT1_ADDR,
+	VPU_DMEM_EXT0_ADDR,
+	VPU_DMEM_EXT1_ADDR,
+};
+
+enum vpu_type {
+	VPU_MT8173,
+	VPU_MT8183,
+};
 
-/* vpu inter-processor communication interrupt */
-#define VPU_IPC_INT		BIT(8)
+/**
+ * struct hw_type - VPU hardware type
+ *
+ * @regs:		the register index for VPU configuration
+ * @dtcm_offset:	the offset to get data tcm address
+ * @share_obj_sz:	share object size, including id, len, share_buf
+ * @ptcm_sz:		maximum program TCM (Tightly-Coupled Memory) size
+ * @dtcm_sz:		maximum data TCM (Tightly-Coupled Memory) size
+ * @ext_p_sz:		daynamic allocated maximum extended program memory size
+ * @ext_d_sz:		daynamic allocated maximum extended data memory size
+ * @type:		the soc where VPU embedded
+ * @ext_mem_support:	extended memory support
+ * @fw_p:		program firmware name
+ * @fw_d:		data firmware name
+ * @ipc_int:		inter-processor communication interrupt bit
+ * @wdt_int:		vpu watch dog timer interrupt bit
+ */
+struct hw_type {
+	int *regs;
+	unsigned long dtcm_offset;
+	size_t share_obj_sz;
+	size_t ptcm_sz;
+	size_t dtcm_sz;
+	size_t ext_p_sz;
+	size_t ext_d_sz;
+	u32 type;
+	bool ext_mem_support;
+	char *fw_p;
+	char *fw_d;
+	u32 ipc_int;
+	u32 wdt_int;
+};
 
 /**
  * enum vpu_fw_type - VPU firmware type
@@ -165,7 +203,8 @@ struct vpu_ipi_desc {
 struct share_obj {
 	s32 id;
 	u32 len;
-	unsigned char share_buf[SHARE_BUF_SIZE];
+	 /* "share_buf" must be in the last member of this data structure */
+	unsigned char *share_buf;
 };
 
 /**
@@ -180,6 +219,7 @@ struct share_obj {
  * @send_buf:		VPU DTCM share buffer for sending
  * @dev:		VPU struct device
  * @clk:		VPU clock on/off
+ * @hw:			the different VPU hardware embedded into mtk SoCs
  * @fw_loaded:		indicate VPU firmware loaded
  * @enable_4GB:		VPU 4GB mode on/off
  * @vpu_mutex:		protect mtk_vpu (except recv_buf) and ensure only
@@ -187,7 +227,7 @@ struct share_obj {
  *			suppose a client is using VPU to decode VP8.
  *			If the other client wants to encode VP8,
  *			it has to wait until VP8 decode completes.
- * @wdt_refcnt:		WDT reference count to make sure the watchdog can be
+ * @wdt_refcnt: 	WDT reference count to make sure the watchdog can be
  *			disabled if no other client is using VPU service
  * @ack_wq:		The wait queue for each codec and mdp. When sleeping
  *			processes wake up, they will check the condition
@@ -207,6 +247,7 @@ struct mtk_vpu {
 	struct share_obj *send_buf;
 	struct device *dev;
 	struct clk *clk;
+	const struct hw_type *hw;
 	bool fw_loaded;
 	bool enable_4GB;
 	struct mutex vpu_mutex; /* for protecting vpu data data structure */
@@ -215,14 +256,64 @@ struct mtk_vpu {
 	bool ipi_id_ack[IPI_MAX];
 };
 
+static int mt8173_regs[] = {
+	[VPU_RESET] =		0x0,
+	[VPU_TCM_CFG] =		0x8,
+	[VPU_TO_HOST] =		0x1C,
+	[HOST_TO_VPU] =		0x24,
+	[VPU_PC_REG] =		0x60,
+	[VPU_WDT_REG] =		0x84,
+	[VPU_PMEM_EXT0_ADDR] =	0x0C,
+	[VPU_PMEM_EXT1_ADDR] =	0x10,
+	[VPU_DMEM_EXT0_ADDR] =	0x14,
+	[VPU_DMEM_EXT1_ADDR] =	0x18,
+};
+
+static int mt8183_regs[] = {
+	[VPU_RESET] =		0x0,
+	[VPU_TO_HOST] =		0x1C,
+	[HOST_TO_VPU] =		0x28,
+	[VPU_PC_REG] =		0xB4,
+	[VPU_WDT_REG] =		0x1C,
+};
+
+static const struct hw_type vpu_mt8173 = {
+	.regs = mt8173_regs,
+	.dtcm_offset = 0x18000,
+	.share_obj_sz = (8+48),
+	.ptcm_sz = (96 * SZ_1K),
+	.dtcm_sz = (32 * SZ_1K),
+	.ext_p_sz = SZ_1M,
+	.ext_d_sz = SZ_4M,
+	.type = VPU_MT8173,
+	.ext_mem_support = true,
+	.fw_p = "vpu_p.bin",
+	.fw_d = "vpu_d.bin",
+	.ipc_int = BIT(8),
+};
+
+static const struct hw_type vpu_mt8183 = {
+	.regs = mt8183_regs,
+	.dtcm_offset = 0,
+	.share_obj_sz = (8+288),
+	.ptcm_sz = (512 * SZ_1K),
+	.dtcm_sz = (512 * SZ_1K),
+	.ext_p_sz = 0,
+	.ext_d_sz = 0,
+	.type = VPU_MT8183,
+	.ext_mem_support = false,
+	.ipc_int = BIT(0),
+	.wdt_int = BIT(8),
+};
+
 static inline void vpu_cfg_writel(struct mtk_vpu *vpu, u32 val, u32 offset)
 {
-	writel(val, vpu->reg.cfg + offset);
+	writel(val, vpu->reg.cfg + vpu->hw->regs[offset]);
 }
 
 static inline u32 vpu_cfg_readl(struct mtk_vpu *vpu, u32 offset)
 {
-	return readl(vpu->reg.cfg + offset);
+	return readl(vpu->reg.cfg + vpu->hw->regs[offset]);
 }
 
 static inline bool vpu_running(struct mtk_vpu *vpu)
@@ -287,9 +378,10 @@ int vpu_ipi_register(struct platform_device *pdev,
 }
 EXPORT_SYMBOL_GPL(vpu_ipi_register);
 
-int vpu_ipi_send(struct platform_device *pdev,
+int vpu_ipi_send_sync_async(struct platform_device *pdev,
 		 enum ipi_id id, void *buf,
-		 unsigned int len)
+		 unsigned int len,
+		 unsigned int wait)
 {
 	struct mtk_vpu *vpu = platform_get_drvdata(pdev);
 	struct share_obj *send_obj = vpu->send_buf;
@@ -297,7 +389,7 @@ int vpu_ipi_send(struct platform_device *pdev,
 	int ret = 0;
 
 	if (id <= IPI_VPU_INIT || id >= IPI_MAX ||
-	    len > sizeof(send_obj->share_buf) || !buf) {
+	    len > (vpu->hw->share_obj_sz - 8) || !buf) {
 		dev_err(vpu->dev, "failed to send ipi message\n");
 		return -EINVAL;
 	}
@@ -325,24 +417,27 @@ int vpu_ipi_send(struct platform_device *pdev,
 		}
 	} while (vpu_cfg_readl(vpu, HOST_TO_VPU));
 
-	memcpy((void *)send_obj->share_buf, buf, len);
+	memcpy((void *)&send_obj->share_buf, buf, len);
 	send_obj->len = len;
 	send_obj->id = id;
 
 	vpu->ipi_id_ack[id] = false;
+	mb();
 	/* send the command to VPU */
 	vpu_cfg_writel(vpu, 0x1, HOST_TO_VPU);
 
 	mutex_unlock(&vpu->vpu_mutex);
 
-	/* wait for VPU's ACK */
-	timeout = msecs_to_jiffies(IPI_TIMEOUT_MS);
-	ret = wait_event_timeout(vpu->ack_wq, vpu->ipi_id_ack[id], timeout);
-	vpu->ipi_id_ack[id] = false;
-	if (ret == 0) {
-		dev_err(vpu->dev, "vpu ipi %d ack time out !", id);
-		ret = -EIO;
-		goto clock_disable;
+	if (wait) {
+		/* wait for VPU's ACK */
+		timeout = msecs_to_jiffies(IPI_TIMEOUT_MS);
+		ret = wait_event_timeout(vpu->ack_wq, vpu->ipi_id_ack[id], timeout);
+		vpu->ipi_id_ack[id] = false;
+		if (ret == 0) {
+			dev_err(vpu->dev, "vpu ipi %d ack time out !", id);
+			ret = -EIO;
+			goto clock_disable;
+		}
 	}
 	vpu_clock_disable(vpu);
 
@@ -355,6 +450,15 @@ int vpu_ipi_send(struct platform_device *pdev,
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(vpu_ipi_send_sync_async);
+
+int vpu_ipi_send(struct platform_device *pdev,
+		 enum ipi_id id, void *buf,
+		 unsigned int len)
+{
+	return vpu_ipi_send_sync_async(pdev, id, buf, len, 1);
+
+}
 EXPORT_SYMBOL_GPL(vpu_ipi_send);
 
 static void vpu_wdt_reset_func(struct work_struct *ws)
@@ -434,16 +538,16 @@ void *vpu_mapping_dm_addr(struct platform_device *pdev,
 	struct mtk_vpu *vpu = platform_get_drvdata(pdev);
 
 	if (!dtcm_dmem_addr ||
-	    (dtcm_dmem_addr > (VPU_DTCM_SIZE + VPU_EXT_D_SIZE))) {
+	    (dtcm_dmem_addr > (vpu->hw->dtcm_sz + vpu->hw->ext_d_sz))) {
 		dev_err(vpu->dev, "invalid virtual data memory address\n");
 		return ERR_PTR(-EINVAL);
 	}
 
-	if (dtcm_dmem_addr < VPU_DTCM_SIZE)
+	if (dtcm_dmem_addr < vpu->hw->dtcm_sz)
 		return (__force void *)(dtcm_dmem_addr + vpu->reg.tcm +
-					VPU_DTCM_OFFSET);
+					vpu->hw->dtcm_offset);
 
-	return vpu->extmem[D_FW].va + (dtcm_dmem_addr - VPU_DTCM_SIZE);
+	return vpu->extmem[D_FW].va + (dtcm_dmem_addr - vpu->hw->dtcm_sz);
 }
 EXPORT_SYMBOL_GPL(vpu_mapping_dm_addr);
 
@@ -470,14 +574,144 @@ struct platform_device *vpu_get_plat_device(struct platform_device *pdev)
 }
 EXPORT_SYMBOL_GPL(vpu_get_plat_device);
 
+#if VPU_RESERVED_MEM
+phys_addr_t vpu_mem_base_phys;
+phys_addr_t vpu_mem_base_virt;
+phys_addr_t vpu_mem_size;
+
+#ifdef CONFIG_OF_RESERVED_MEM
+#define VPU_MEM_RESERVED_KEY "mediatek,reserve-memory-vpu_share"
+
+static struct vpu_reserve_mblock vpu_reserve_mblock[] = {
+	{
+		.num = ISP_MEM_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.size = 0x1000000,  /*16MB*/
+	},
+	{
+		.num = MDP_MEM_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.size = 0x400000,   /*4MB*/
+	},
+};
+
+int vpu_reserve_mem_of_init(struct reserved_mem *rmem)
+{
+	enum vpu_reserve_mem_id_t id;
+	phys_addr_t accumlate_memory_size = 0;
+
+	vpu_mem_base_phys = (phys_addr_t) rmem->base;
+	vpu_mem_size = (phys_addr_t) rmem->size;
+	if ((vpu_mem_base_phys >= (0x90000000ULL)) || (vpu_mem_base_phys <= 0x0)) {
+		/*The vpu remap region is fixed, only
+		 * 0x4000_0000ULL~0x9FFF_FFFFULL
+		 * can be accessible
+		 */
+		pr_err("[VPU] The allocated memory(0x%llx) is larger than expected\n", vpu_mem_base_phys);
+		/*should not call WARN_ON() here or there is no log, return -1
+		 * instead.
+		 */
+		return -1;
+	}
+
+	pr_debug("[VPU] phys:0x%llx - 0x%llx (0x%llx)\n", (phys_addr_t)rmem->base,
+			(phys_addr_t)rmem->base + (phys_addr_t)rmem->size, (phys_addr_t)rmem->size);
+	accumlate_memory_size = 0;
+	for (id = 0; id < NUMS_MEM_ID; id++) {
+		vpu_reserve_mblock[id].start_phys = vpu_mem_base_phys + accumlate_memory_size;
+		accumlate_memory_size += vpu_reserve_mblock[id].size;
+		pr_debug("[VPU][reserve_mem:%d]: phys:0x%llx - 0x%llx (0x%llx)\n", id,
+			vpu_reserve_mblock[id].start_phys,
+			vpu_reserve_mblock[id].start_phys+vpu_reserve_mblock[id].size,
+			vpu_reserve_mblock[id].size);
+	}
+	return 0;
+}
+
+RESERVEDMEM_OF_DECLARE(vpu_reserve_mem_init, VPU_MEM_RESERVED_KEY, vpu_reserve_mem_of_init);
+#endif
+
+static int vpu_reserve_memory_ioremap(void)
+{
+	enum vpu_reserve_mem_id_t id;
+	phys_addr_t accumlate_memory_size;
+
+
+	if ((vpu_mem_base_phys >= (0x90000000ULL)) || (vpu_mem_base_phys <= 0x0)) {
+		/*The vpu remap region is fixed, only
+		 * 0x4000_0000ULL~0x8FFF_FFFFULL
+		 * can be accessible
+		 */
+		pr_err("[VPU] The allocated memory(0x%llx) is larger than expected\n", vpu_mem_base_phys);
+		/*call WARN_ON() here to assert the unexpected memory allocation
+		 */
+		WARN_ON(1);
+		return -1;
+	}
+	accumlate_memory_size = 0;
+	vpu_mem_base_virt = (phys_addr_t)(size_t)ioremap_wc(vpu_mem_base_phys, vpu_mem_size);
+	pr_debug("[VPU]reserve mem: virt:0x%llx - 0x%llx (0x%llx)\n", (phys_addr_t)vpu_mem_base_virt,
+		(phys_addr_t)vpu_mem_base_virt + (phys_addr_t)vpu_mem_size, vpu_mem_size);
+	for (id = 0; id < NUMS_MEM_ID; id++) {
+		vpu_reserve_mblock[id].start_virt = vpu_mem_base_virt + accumlate_memory_size;
+		accumlate_memory_size += vpu_reserve_mblock[id].size;
+	}
+	/* the reserved memory should be larger then expected memory
+	 * or vpu_reserve_mblock does not match dts
+	 */
+	WARN_ON(accumlate_memory_size > vpu_mem_size);
+#ifdef DEBUG
+	for (id = 0; id < NUMS_MEM_ID; id++) {
+		pr_info("[VPU][mem_reserve-%d] phys:0x%llx,virt:0x%llx,size:0x%llx\n",
+			id, vpu_get_reserve_mem_phys(id), vpu_get_reserve_mem_virt(id), vpu_get_reserve_mem_size(id));
+	}
+#endif
+	return 0;
+}
+
+phys_addr_t vpu_get_reserve_mem_phys(enum vpu_reserve_mem_id_t id)
+{
+	if (id >= NUMS_MEM_ID) {
+		pr_err("[VPU] no reserve memory for %d", id);
+		return 0;
+	} else
+		return vpu_reserve_mblock[id].start_phys;
+}
+EXPORT_SYMBOL_GPL(vpu_get_reserve_mem_phys);
+
+phys_addr_t vpu_get_reserve_mem_virt(enum vpu_reserve_mem_id_t id)
+{
+	if (id >= NUMS_MEM_ID) {
+		pr_err("[VPU] no reserve memory for %d", id);
+		return 0;
+	} else
+		return vpu_reserve_mblock[id].start_virt;
+}
+EXPORT_SYMBOL_GPL(vpu_get_reserve_mem_virt);
+
+phys_addr_t vpu_get_reserve_mem_size(enum vpu_reserve_mem_id_t id)
+{
+	if (id >= NUMS_MEM_ID) {
+		pr_err("[VPU] no reserve memory for %d", id);
+		return 0;
+	} else
+		return vpu_reserve_mblock[id].size;
+}
+EXPORT_SYMBOL_GPL(vpu_get_reserve_mem_size);
+#endif
+
 /* load vpu program/data memory */
 static int load_requested_vpu(struct mtk_vpu *vpu,
 			      const struct firmware *vpu_fw,
 			      u8 fw_type)
 {
-	size_t tcm_size = fw_type ? VPU_DTCM_SIZE : VPU_PTCM_SIZE;
-	size_t fw_size = fw_type ? VPU_D_FW_SIZE : VPU_P_FW_SIZE;
-	char *fw_name = fw_type ? VPU_D_FW : VPU_P_FW;
+	size_t tcm_size = fw_type ? vpu->hw->dtcm_sz : vpu->hw->ptcm_sz;
+	size_t fw_size = fw_type
+		       ? vpu->hw->dtcm_sz + vpu->hw->ext_d_sz
+		       : vpu->hw->ptcm_sz + vpu->hw->ext_p_sz;
+	char *fw_name = fw_type ? vpu->hw->fw_d : vpu->hw->fw_p;
 	size_t dl_size = 0;
 	size_t extra_fw_size = 0;
 	void *dest;
@@ -511,7 +745,7 @@ static int load_requested_vpu(struct mtk_vpu *vpu,
 	}
 	dest = (__force void *)vpu->reg.tcm;
 	if (fw_type == D_FW)
-		dest += VPU_DTCM_OFFSET;
+		dest += vpu->hw->dtcm_offset;
 	memcpy(dest, vpu_fw->data, dl_size);
 	/* download to extended memory if need */
 	if (extra_fw_size > 0) {
@@ -559,21 +793,33 @@ int vpu_load_firmware(struct platform_device *pdev)
 
 	run->signaled = false;
 	dev_dbg(vpu->dev, "firmware request\n");
-	/* Downloading program firmware to device*/
-	ret = load_requested_vpu(vpu, vpu_fw, P_FW);
-	if (ret < 0) {
-		dev_err(dev, "Failed to request %s, %d\n", VPU_P_FW, ret);
-		goto OUT_LOAD_FW;
+	if (vpu->hw->type == VPU_MT8173) {
+		/* Downloading program firmware to device*/
+		ret = load_requested_vpu(vpu, vpu_fw, P_FW);
+		if (ret < 0) {
+			dev_err(dev, "Failed to request %s, %d\n",
+				vpu->hw->fw_p, ret);
+			goto OUT_LOAD_FW;
+		}
+
+		/* Downloading data firmware to device */
+		ret = load_requested_vpu(vpu, vpu_fw, D_FW);
+		if (ret < 0) {
+			dev_err(dev, "Failed to request %s, %d\n",
+				vpu->hw->fw_d, ret);
+			goto OUT_LOAD_FW;
+		}
 	}
+	vpu->fw_loaded = true;
 
-	/* Downloading data firmware to device */
-	ret = load_requested_vpu(vpu, vpu_fw, D_FW);
-	if (ret < 0) {
-		dev_err(dev, "Failed to request %s, %d\n", VPU_D_FW, ret);
+#if VPU_RESERVED_MEM
+	ret = vpu_reserve_memory_ioremap();
+	if (ret) {
+		dev_err(dev, "vpu_reserve_memory_ioremap failed\n");
 		goto OUT_LOAD_FW;
 	}
+#endif
 
-	vpu->fw_loaded = true;
 	/* boot up vpu */
 	vpu_cfg_writel(vpu, 0x1, VPU_RESET);
 
@@ -623,12 +869,14 @@ static ssize_t vpu_debug_read(struct file *file, char __user *user_buf,
 	int ret;
 	struct device *dev = file->private_data;
 	struct mtk_vpu *vpu = dev_get_drvdata(dev);
+	struct platform_device *pdev = to_platform_device(dev);
 
 	ret = vpu_clock_enable(vpu);
 	if (ret) {
 		dev_err(vpu->dev, "[VPU] enable clock failed %d\n", ret);
 		return 0;
 	}
+	vpu_load_firmware(pdev);
 
 	/* vpu register status */
 	running = vpu_running(vpu);
@@ -663,7 +911,10 @@ static const struct file_operations vpu_debug_fops = {
 static void vpu_free_ext_mem(struct mtk_vpu *vpu, u8 fw_type)
 {
 	struct device *dev = vpu->dev;
-	size_t fw_ext_size = fw_type ? VPU_EXT_D_SIZE : VPU_EXT_P_SIZE;
+	size_t fw_ext_size = fw_type ? vpu->hw->ext_d_sz : vpu->hw->ext_p_sz;
+
+	if (!vpu->hw->ext_mem_support)
+		return;
 
 	dma_free_coherent(dev, fw_ext_size, vpu->extmem[fw_type].va,
 			  vpu->extmem[fw_type].pa);
@@ -672,11 +923,14 @@ static void vpu_free_ext_mem(struct mtk_vpu *vpu, u8 fw_type)
 static int vpu_alloc_ext_mem(struct mtk_vpu *vpu, u32 fw_type)
 {
 	struct device *dev = vpu->dev;
-	size_t fw_ext_size = fw_type ? VPU_EXT_D_SIZE : VPU_EXT_P_SIZE;
+	size_t fw_ext_size = fw_type ? vpu->hw->ext_d_sz : vpu->hw->ext_p_sz;
 	u32 vpu_ext_mem0 = fw_type ? VPU_DMEM_EXT0_ADDR : VPU_PMEM_EXT0_ADDR;
 	u32 vpu_ext_mem1 = fw_type ? VPU_DMEM_EXT1_ADDR : VPU_PMEM_EXT1_ADDR;
 	u32 offset_4gb = vpu->enable_4GB ? 0x40000000 : 0;
 
+	if (!vpu->hw->ext_mem_support)
+		return 0;
+
 	vpu->extmem[fw_type].va = dma_alloc_coherent(dev,
 					       fw_ext_size,
 					       &vpu->extmem[fw_type].pa,
@@ -703,9 +957,11 @@ static void vpu_ipi_handler(struct mtk_vpu *vpu)
 {
 	struct share_obj *rcv_obj = vpu->recv_buf;
 	struct vpu_ipi_desc *ipi_desc = vpu->ipi_desc;
+	char tmp_data[288];
 
 	if (rcv_obj->id < IPI_MAX && ipi_desc[rcv_obj->id].handler) {
-		ipi_desc[rcv_obj->id].handler(rcv_obj->share_buf,
+		memcpy_fromio(tmp_data, &rcv_obj->share_buf, rcv_obj->len);
+		ipi_desc[rcv_obj->id].handler(&tmp_data[0],
 					      rcv_obj->len,
 					      ipi_desc[rcv_obj->id].priv);
 		if (rcv_obj->id > IPI_VPU_INIT) {
@@ -719,15 +975,31 @@ static void vpu_ipi_handler(struct mtk_vpu *vpu)
 
 static int vpu_ipi_init(struct mtk_vpu *vpu)
 {
-	/* Disable VPU to host interrupt */
-	vpu_cfg_writel(vpu, 0x0, VPU_TO_HOST);
+	if (vpu->hw->type == VPU_MT8173) {
+		/* clear VPU to host interrupt */
+		vpu_cfg_writel(vpu, 0x0, VPU_TO_HOST);
+		/* get shared buffer */
+		vpu->recv_buf = (__force struct share_obj *)(vpu->reg.tcm +
+							vpu->hw->dtcm_offset);
+		vpu->send_buf = (__force struct share_obj *)(vpu->reg.tcm +
+							vpu->hw->dtcm_offset +
+							vpu->hw->share_obj_sz);
+	} else if (vpu->hw->type == VPU_MT8183) {
+		/* clear VPU to host interrupt */
+		vpu_cfg_writel(vpu, vpu->hw->ipc_int, VPU_TO_HOST);
+		/* get shared buffer */
+		vpu->send_buf = (__force struct share_obj *) (vpu->reg.tcm +
+						0x800 -
+						vpu->hw->share_obj_sz);
+
+		vpu->recv_buf = (__force struct share_obj *)(vpu->reg.tcm +
+						0x800 -
+						vpu->hw->share_obj_sz -
+						vpu->hw->share_obj_sz);
+	}
 
-	/* shared buffer initialization */
-	vpu->recv_buf = (__force struct share_obj *)(vpu->reg.tcm +
-						     VPU_DTCM_OFFSET);
-	vpu->send_buf = vpu->recv_buf + 1;
-	memset(vpu->recv_buf, 0, sizeof(struct share_obj));
-	memset(vpu->send_buf, 0, sizeof(struct share_obj));
+	memset_io(vpu->recv_buf, 0, vpu->hw->share_obj_sz);
+	memset_io(vpu->send_buf, 0, vpu->hw->share_obj_sz);
 
 	return 0;
 }
@@ -749,20 +1021,41 @@ static irqreturn_t vpu_irq_handler(int irq, void *priv)
 		return IRQ_NONE;
 	}
 	vpu_to_host = vpu_cfg_readl(vpu, VPU_TO_HOST);
-	if (vpu_to_host & VPU_IPC_INT) {
+	if (vpu_to_host & vpu->hw->ipc_int) {
 		vpu_ipi_handler(vpu);
 	} else {
 		dev_err(vpu->dev, "vpu watchdog timeout! 0x%x", vpu_to_host);
 		queue_work(vpu->wdt.wq, &vpu->wdt.ws);
 	}
 
-	/* VPU won't send another interrupt until we set VPU_TO_HOST to 0. */
-	vpu_cfg_writel(vpu, 0x0, VPU_TO_HOST);
+	mb();
+	/*
+	 * VPU won't send another interrupt until
+	 * we clear the corresponding bits.
+	 */
+	if (vpu->hw->type == VPU_MT8173)
+		vpu_cfg_writel(vpu, 0x0, VPU_TO_HOST);
+	else if (vpu->hw->type == VPU_MT8183)
+		vpu_cfg_writel(vpu, vpu->hw->ipc_int | vpu->hw->wdt_int,
+			       VPU_TO_HOST);
 	clk_disable(vpu->clk);
 
 	return IRQ_HANDLED;
 }
 
+static const struct of_device_id mtk_vpu_match[] = {
+	{
+		.compatible = "mediatek,mt8173-vpu",
+		.data = &vpu_mt8173,
+	},
+	{
+		.compatible = "mediatek,mt8183-vpu",
+		.data = &vpu_mt8183,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, mtk_vpu_match);
+
 #ifdef CONFIG_DEBUG_FS
 static struct dentry *vpu_debugfs;
 #endif
@@ -772,6 +1065,8 @@ static int mtk_vpu_probe(struct platform_device *pdev)
 	struct device *dev;
 	struct resource *res;
 	int ret = 0;
+	const struct of_device_id *of_id =
+		of_match_device(mtk_vpu_match, &pdev->dev);
 
 	dev_dbg(&pdev->dev, "initialization\n");
 
@@ -781,6 +1076,7 @@ static int mtk_vpu_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	vpu->dev = &pdev->dev;
+	vpu->hw = of_id->data;
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "tcm");
 	vpu->reg.tcm = devm_ioremap_resource(dev, res);
 	if (IS_ERR((__force void *)vpu->reg.tcm))
@@ -846,7 +1142,8 @@ static int mtk_vpu_probe(struct platform_device *pdev)
 #endif
 
 	/* Set PTCM to 96K and DTCM to 32K */
-	vpu_cfg_writel(vpu, 0x2, VPU_TCM_CFG);
+	if (vpu->hw->type == VPU_MT8173)
+		vpu_cfg_writel(vpu, 0x2, VPU_TCM_CFG);
 
 	vpu->enable_4GB = !!(totalram_pages > (SZ_2G >> PAGE_SHIFT));
 	dev_info(dev, "4GB mode %u\n", vpu->enable_4GB);
@@ -913,14 +1210,6 @@ static int mtk_vpu_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static const struct of_device_id mtk_vpu_match[] = {
-	{
-		.compatible = "mediatek,mt8173-vpu",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, mtk_vpu_match);
-
 static int mtk_vpu_remove(struct platform_device *pdev)
 {
 	struct mtk_vpu *vpu = platform_get_drvdata(pdev);
@@ -945,7 +1234,7 @@ static struct platform_driver mtk_vpu_driver = {
 	.remove	= mtk_vpu_remove,
 	.driver	= {
 		.name	= "mtk_vpu",
-		.of_match_table = mtk_vpu_match,
+		.of_match_table = of_match_ptr(mtk_vpu_match),
 	},
 };
 
diff --git a/drivers/media/platform/mtk-vpu/mtk_vpu.h b/drivers/media/platform/mtk-vpu/mtk_vpu.h
old mode 100644
new mode 100755
index d4453b4bcee9..ebf72a125434
--- a/drivers/media/platform/mtk-vpu/mtk_vpu.h
+++ b/drivers/media/platform/mtk-vpu/mtk_vpu.h
@@ -58,6 +58,9 @@ enum ipi_id {
 	IPI_VENC_H264,
 	IPI_VENC_VP8,
 	IPI_MDP,
+	IPI_MDP_INIT = IPI_MDP,
+	IPI_MDP_DEINIT,
+	IPI_MDP_FRAME,
 	IPI_MAX,
 };
 
@@ -92,6 +95,10 @@ enum rst_id {
 int vpu_ipi_register(struct platform_device *pdev, enum ipi_id id,
 		     ipi_handler_t handler, const char *name, void *priv);
 
+int vpu_ipi_send_sync_async(struct platform_device *pdev,
+		 enum ipi_id id, void *buf,
+		 unsigned int len, unsigned int wait);
+
 /**
  * vpu_ipi_send - send data from AP to vpu.
  *
@@ -183,4 +190,26 @@ int vpu_load_firmware(struct platform_device *pdev);
  **/
 void *vpu_mapping_dm_addr(struct platform_device *pdev,
 			  u32 dtcm_dmem_addr);
+
+#define VPU_RESERVED_MEM	(1)
+#if VPU_RESERVED_MEM
+/* vpu reserve memory ID definition*/
+enum vpu_reserve_mem_id_t {
+	ISP_MEM_ID,
+	MDP_MEM_ID,
+	NUMS_MEM_ID,
+};
+
+struct vpu_reserve_mblock {
+	enum vpu_reserve_mem_id_t num;
+	u64 start_phys;
+	u64 start_virt;
+	u64 size;
+};
+
+extern phys_addr_t vpu_get_reserve_mem_phys(enum vpu_reserve_mem_id_t id);
+extern phys_addr_t vpu_get_reserve_mem_virt(enum vpu_reserve_mem_id_t id);
+extern phys_addr_t vpu_get_reserve_mem_size(enum vpu_reserve_mem_id_t id);
+#endif
+
 #endif /* _MTK_VPU_H */
diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2-ioctl.c
index 7047a9ba24ef..7f1258959053 100644
--- a/drivers/media/v4l2-core/v4l2-ioctl.c
+++ b/drivers/media/v4l2-core/v4l2-ioctl.c
@@ -1286,6 +1286,38 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 	case V4L2_PIX_FMT_KONICA420:	descr = "GSPCA KONICA420"; break;
 	case V4L2_PIX_FMT_HSV24:	descr = "24-bit HSV 8-8-8"; break;
 	case V4L2_PIX_FMT_HSV32:	descr = "32-bit XHSV 8-8-8-8"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR8: descr = "8-bit Packed Bayer BGGR format"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG8: descr = "8-bit Packed Bayer GBRG format"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG8: descr = "8-bit Packed Bayer GRBG format"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB8: descr = "8-bit Packed Bayer RGGB format"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR10: descr = "10-bit Packed Bayer BGGR format"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG10: descr = "10-bit Packed Bayer GBRG format"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG10: descr = "10-bit Packed Bayer GRBG format"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB10: descr = "10-bit Packed Bayer RGGB format"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR12: descr = "12-bit Packed Bayer BGGR format"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG12: descr = "12-bit Packed Bayer GBRG format"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG12: descr = "12-bit Packed Bayer GRBG format"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB12: descr = "12-bit Packed Bayer RGGB format"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR14: descr = "14-bit Packed Bayer BGGR format"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG14: descr = "14-bit Packed Bayer GBRG format"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG14: descr = "14-bit Packed Bayer GRBG format"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB14: descr = "14-bit Packed Bayer RGGB format"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR8F: descr = "8-bit Packed Full-G Bayer BGGR format"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG8F: descr = "8-bit Packed Full-G Bayer GBRG format"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG8F: descr = "8-bit Packed Full-G Bayer GRBG format"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB8F: descr = "8-bit Packed Full-G Bayer RGGB format"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR10F: descr = "10-bit Packed Full-G Bayer BGGR format"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG10F: descr = "10-bit Packed Full-G Bayer GBRG format"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG10F: descr = "10-bit Packed Full-G Bayer GRBG format"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB10F: descr = "10-bit Packed Full-G Bayer RGGB format"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR12F: descr = "12-bit Packed Full-G Bayer BGGR format"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG12F: descr = "12-bit Packed Full-G Bayer GBRG format"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG12F: descr = "12-bit Packed Full-G Bayer GRBG format"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB12F: descr = "12-bit Packed Full-G Bayer RGGB format"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR14F: descr = "14-bit Packed Full-G Bayer BGGR format"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG14F: descr = "14-bit Packed Full-G Bayer GBRG format"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG14F: descr = "14-bit Packed Full-G Bayer GRBG format"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB14F: descr = "14-bit Packed Full-G Bayer RGGB format"; break;
 	case V4L2_SDR_FMT_CU8:		descr = "Complex U8"; break;
 	case V4L2_SDR_FMT_CU16LE:	descr = "Complex U16LE"; break;
 	case V4L2_SDR_FMT_CS8:		descr = "Complex S8"; break;
@@ -1301,6 +1333,11 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 	case V4L2_META_FMT_VSP1_HGO:	descr = "R-Car VSP1 1-D Histogram"; break;
 	case V4L2_META_FMT_VSP1_HGT:	descr = "R-Car VSP1 2-D Histogram"; break;
 	case V4L2_META_FMT_UVC:		descr = "UVC payload header metadata"; break;
+	case V4L2_META_FMT_MTISP_3A:	descr = "AE/AWB Histogram"; break;
+	case V4L2_META_FMT_MTISP_AF:	descr = "AF Histogram"; break;
+	case V4L2_META_FMT_MTISP_LCS:	descr = "Local contrast enhanced statistics"; break;
+	case V4L2_META_FMT_MTISP_LMV:	descr = "Local motion vector Histogram"; break;
+	case V4L2_META_FMT_MTISP_PARAMS: descr = "MTK ISP tuning metadata"; break;
 
 	default:
 		/* Compressed formats */
diff --git a/drivers/memory/Kconfig b/drivers/memory/Kconfig
index 63389f075f1d..4a291dabf2cc 100644
--- a/drivers/memory/Kconfig
+++ b/drivers/memory/Kconfig
@@ -129,6 +129,15 @@ config JZ4780_NEMC
 	  the Ingenic JZ4780. This controller is used to handle external
 	  memory devices such as NAND and SRAM.
 
+config MTK_EMI_MBW
+	bool "Mediatek EMI bandwidth driver"
+	depends on ARCH_MEDIATEK || COMPILE_TEST
+	help
+	  This driver is for MTK EMI control.
+	  If unsure, use N.
+	  This is the first time emi upstream.
+	  Only support emi bw statistics.
+
 config MTK_SMI
 	bool
 	depends on ARCH_MEDIATEK || COMPILE_TEST
diff --git a/drivers/memory/Makefile b/drivers/memory/Makefile
index a01ab3e22f94..82e3d862c24d 100644
--- a/drivers/memory/Makefile
+++ b/drivers/memory/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_FSL_CORENET_CF)	+= fsl-corenet-cf.o
 obj-$(CONFIG_FSL_IFC)		+= fsl_ifc.o
 obj-$(CONFIG_MVEBU_DEVBUS)	+= mvebu-devbus.o
 obj-$(CONFIG_JZ4780_NEMC)	+= jz4780-nemc.o
++obj-$(CONFIG_MTK_EMI_MBW)	+= mtk-emi.o
 obj-$(CONFIG_MTK_SMI)		+= mtk-smi.o
 obj-$(CONFIG_DA8XX_DDRCTL)	+= da8xx-ddrctl.o
 
diff --git a/drivers/memory/mtk-emi.c b/drivers/memory/mtk-emi.c
new file mode 100644
index 000000000000..5d00c05a8717
--- /dev/null
+++ b/drivers/memory/mtk-emi.c
@@ -0,0 +1,412 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2015-2016 MediaTek Inc.
+ * Author: Xi Chen <xixi.chen@mediatek.com>
+ */
+
+#include <linux/cdev.h>
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <soc/mediatek/emi.h>
+
+/* 67ms emi bw  */
+#define EMI_BW_ARRAY_SIZE	67
+
+#define MT8173_SMI_LARB_NR	6
+#define MT8167_SMI_LARB_NR	3
+#define MTK_SMI_LARB_NR_MAX	8
+#define MT8173_MMU_EN		0xf00
+#define MT8167_MMU_EN		0xfc0
+#define MT8167_LARB0_OFF	0
+#define MT8167_LARB1_OFF	8
+#define MT8167_LARB2_OFF	21
+
+/*****************************************************************************
+ *  Type Definitions
+ *****************************************************************************/
+enum DDRTYPE {
+	TYPE_LPDDR3 = 1,
+	TYPE_LPDDR4,
+	TYPE_LPDDR4X
+};
+
+enum {
+	EMI_BASE_IDX_EMI = 0,
+	EMI_BASE_IDX_EMI_CH0,
+	EMI_BASE_IDX_EMI_CH1,
+
+	NR_EMI_BASE_IDX,
+};
+
+struct emi_base_addr {
+	unsigned int phy_addr;
+	unsigned int remap_addr;
+};
+
+struct mtk_emi {
+	void __iomem *cen_emi_base;
+	void __iomem *chn_emi_base[MAX_CH];
+	void __iomem *emi_mpu_base;
+
+	struct emi_info_t emi_info;
+
+	struct timer_list emi_bw_timer;
+	struct timeval old_tv;
+
+	unsigned long long emi_bw_array[EMI_BW_ARRAY_SIZE];
+	int emi_bw_cur_idx;
+	int emi_bw_max_idx;
+};
+
+/* because timer can't pass argument, so add the global
+ * static struct device * for timer callback usage
+ */
+static struct device *emi_dev;
+
+unsigned long long emi_get_max_bw_in_last_array(struct device *dev,
+	unsigned long long arr[], unsigned int size)
+{
+	unsigned int i = 0;
+	unsigned long long max = arr[0];
+
+	while (i < size) {
+		if (arr[i] > max)
+			max = arr[i];
+		++i;
+	}
+	return max;
+}
+
+unsigned long long mtk_emi_get_max_bw(void)
+{
+	struct mtk_emi *emi;
+
+	if (!emi_dev)
+		return 0;
+
+	emi = dev_get_drvdata(emi_dev);
+	return emi_get_max_bw_in_last_array(emi_dev,
+		emi->emi_bw_array, ARRAY_SIZE(emi->emi_bw_array));
+}
+EXPORT_SYMBOL(mtk_emi_get_max_bw);
+
+void emi_update_bw_array(struct device *dev, unsigned int val)
+{
+	struct mtk_emi *emi = dev_get_drvdata(emi_dev);
+
+	if (emi->emi_bw_cur_idx == emi->emi_bw_max_idx) {
+		/* remove the first array element */
+		memmove(emi->emi_bw_array, emi->emi_bw_array + 1,
+			sizeof(unsigned long long) * (emi->emi_bw_max_idx - 1));
+		emi->emi_bw_array[emi->emi_bw_max_idx - 1] = val;
+	} else
+		emi->emi_bw_array[emi->emi_bw_cur_idx++] = val;
+}
+
+static void emi_dump_bw_array(struct device *dev)
+{
+	int i = 0;
+	const int unit = 10;
+	struct mtk_emi *emi = dev_get_drvdata(emi_dev);
+
+	while (i < emi->emi_bw_max_idx) {
+		if (i != 0 && i % unit == 0)
+			pr_info("\n");
+		pr_info("0x%x ", emi->emi_bw_array[i]);
+
+		++i;
+	}
+
+	pr_info("\n");
+}
+
+static void emi_counter_reset(struct device *dev)
+{
+	struct mtk_emi *emi = dev_get_drvdata(dev);
+
+	writel(EMI_BMEN_DEFAULT_VALUE, EMI_BMEN);
+	writel(EMI_MSEL_DEFAULT_VALUE, EMI_MSEL);
+	writel(EMI_MSEL2_DEFAULT_VALUE, EMI_MSEL2);
+	writel(EMI_BMEN2_DEFAULT_VALUE, EMI_BMEN2);
+	writel(EMI_BMRW0_DEFAULT_VALUE, EMI_BMRW0);
+}
+
+static void emi_counter_pause(struct device *dev)
+{
+	struct mtk_emi *emi = dev_get_drvdata(dev);
+	const unsigned int value = readl(EMI_BMEN);
+
+	/* BW monitor */
+	writel(value | BUS_MON_PAUSE, EMI_BMEN);
+}
+
+static void emi_counter_continue(struct device *dev)
+{
+	struct mtk_emi *emi = dev_get_drvdata(dev);
+	const unsigned int value = readl(EMI_BMEN);
+
+	/* BW monitor */
+	writel(value & (~BUS_MON_PAUSE), EMI_BMEN);
+}
+
+static void emi_counter_enable(struct device *dev, const unsigned int enable)
+{
+	unsigned int value, value_set;
+	struct mtk_emi *emi = dev_get_drvdata(dev);
+
+	value = readl(EMI_BMEN);
+	if (enable == 0) {	/* disable monitor circuit */
+		/*  bit3 =1	bit0 = 0-> clear */
+		value_set = (value) | (BUS_MON_IDLE);
+		writel(value_set, EMI_BMEN);
+
+		value_set = ((value) | (BUS_MON_IDLE)) & ~(BUS_MON_EN);
+		writel(value_set, EMI_BMEN);
+
+		value_set = ((value) & ~(BUS_MON_IDLE)) & ~(BUS_MON_EN);
+		writel(value_set, EMI_BMEN);
+	} else {		/* enable monitor circuit */
+		/*  bit3 =0	&   bit0=1 */
+		value_set = (value & ~(BUS_MON_IDLE));
+		writel(value_set, EMI_BMEN);
+
+		value_set = (value & ~(BUS_MON_IDLE)) | (BUS_MON_EN);
+		writel(value_set, EMI_BMEN);
+	}
+}
+
+/*****************************************************************************
+ *  APIs
+ *****************************************************************************/
+static void mtk_emi_mon_start(struct device *dev)
+{
+	emi_counter_enable(dev, 0);
+	emi_counter_reset(dev);
+	emi_counter_enable(dev, 1);
+}
+
+static void mtk_emi_mon_restart(struct device *dev)
+{
+	emi_counter_continue(dev);
+	emi_counter_enable(dev, 0);
+	emi_counter_reset(dev);
+	emi_counter_enable(dev, 1);
+}
+
+static void mtk_emi_mon_stop(struct device *dev)
+{
+	emi_counter_pause(dev);
+}
+
+static ssize_t emi_show_max_bw(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	unsigned long long var, bw_cpu;
+	unsigned int bw_gpu;
+	struct mtk_emi *emi = dev_get_drvdata(dev);
+
+	if (!dev) {
+		pr_warn("dev is null!!\n");
+		return 0;
+	}
+
+	var = mtk_emi_get_max_bw();
+	bw_gpu = readl(EMI_BWVL_4TH) & 0x7f;
+	bw_cpu = readl(EMI_WSCT3);
+
+	return scnprintf(buf, PAGE_SIZE,
+		"gpu_max_bw:%llu(0x%x) EMI_BWVL_4TH:0x%x, cpu:%llu(0x%x)\n",
+		var, var, bw_gpu, bw_cpu, bw_cpu);
+}
+
+DEVICE_ATTR(bw,  0440, emi_show_max_bw, NULL);
+
+static ssize_t emi_dump_bw(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	unsigned long long var;
+
+	if (!dev) {
+		pr_warn("dev is null!!\n");
+		return 0;
+	}
+
+	emi_dump_bw_array(dev);
+	var = mtk_emi_get_max_bw();
+
+	return scnprintf(buf, PAGE_SIZE,
+		"\temi_max_bw:%llu(0x%x)\n", var, var);
+}
+
+DEVICE_ATTR(dump_bw,  0440, emi_dump_bw, NULL);
+
+static int emi_bw_ms = 1;
+module_param_named(bw_ms, emi_bw_ms, int, 0664);
+
+static void emi_bw_timer_callback(struct timer_list *tm)
+{
+	struct timeval tv;
+	unsigned long long val, cur_max;
+	struct mtk_emi *emi = dev_get_drvdata(emi_dev);
+
+	do_gettimeofday(&tv);
+
+	/* pasue emi monitor for get WACT value*/
+	mtk_emi_mon_stop(emi_dev);
+
+	val = readl(EMI_WSCT4);	/* GPU BW */
+	val *= 8;
+
+	cur_max = mtk_emi_get_max_bw();
+	emi_update_bw_array(emi_dev, val);
+
+	/* set mew timer expires and restart emi monitor */
+	emi->old_tv = tv;
+	emi->emi_bw_timer.expires = jiffies + msecs_to_jiffies(emi_bw_ms);
+
+	add_timer(&(emi->emi_bw_timer));
+	mtk_emi_mon_restart(emi_dev);
+}
+
+static int emi_probe(struct platform_device *pdev)
+{
+	struct mtk_emi *emi;
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+	int i, ret;
+
+	emi = devm_kzalloc(dev, sizeof(*emi), GFP_KERNEL);
+	if (!emi)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	emi->cen_emi_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(emi->cen_emi_base)) {
+		pr_err("[EMI] unable to map cen_emi_base\n");
+		devm_kfree(dev, emi);
+		return -EINVAL;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	emi->emi_mpu_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(emi->emi_mpu_base)) {
+		pr_err("[EMI] unable to map emi_mpu_base\n");
+		devm_kfree(dev, emi);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < MAX_CH; i++) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 2 + i);
+		emi->chn_emi_base[i] = devm_ioremap_resource(dev, res);
+		if (IS_ERR(emi->chn_emi_base[i])) {
+			pr_err("[EMI] unable to map ch%d_emi_base\n", i);
+			devm_kfree(dev, emi);
+			return -EINVAL;
+		}
+	}
+
+	platform_set_drvdata(pdev, emi);
+
+	emi_dev = dev;
+	/* start emi bw monitor */
+	mtk_emi_mon_start(dev);
+
+	emi->emi_bw_max_idx = ARRAY_SIZE(emi->emi_bw_array);
+	/* setup timer */
+	timer_setup(&(emi->emi_bw_timer), NULL, 0);
+	do_gettimeofday(&(emi->old_tv));
+
+	emi->emi_bw_timer.function = emi_bw_timer_callback;
+	emi->emi_bw_timer.expires = jiffies + msecs_to_jiffies(1);
+	add_timer(&(emi->emi_bw_timer));
+
+	/* debug node */
+	ret = device_create_file(dev, &dev_attr_bw);
+	if (ret) {
+		dev_err(dev, "create bw file failed!\n");
+		goto err_create_attr_bw;
+	}
+	ret = device_create_file(dev, &dev_attr_dump_bw);
+	if (ret) {
+		dev_err(dev, "create dump_bw file failed!\n");
+		goto err_create_attr_dump_bw;
+	}
+
+	return 0;
+
+err_create_attr_dump_bw:
+	del_timer(&(emi->emi_bw_timer));
+	device_remove_file(dev, &dev_attr_bw);
+err_create_attr_bw:
+	devm_kfree(dev, emi);
+	return -ENOMEM;
+}
+
+static int emi_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_emi *emi = dev_get_drvdata(dev);
+
+	del_timer(&(emi->emi_bw_timer));
+	device_remove_file(dev, &dev_attr_dump_bw);
+	device_remove_file(dev, &dev_attr_bw);
+
+	devm_kfree(dev, emi);
+	return 0;
+}
+
+
+#ifdef CONFIG_OF
+static const struct of_device_id emi_of_ids[] = {
+	{.compatible = "mediatek,mt8183-emi",},
+	{}
+};
+#endif
+
+static struct platform_driver emi_bw_driver = {
+	.probe = emi_probe,
+	.remove = emi_remove,
+	.driver = {
+		.name = "emi_bw",
+		.owner = THIS_MODULE,
+		.pm = NULL,
+#ifdef CONFIG_OF
+		.of_match_table = emi_of_ids,
+#endif
+	},
+};
+
+
+static int __init emi_bw_init(void)
+{
+	int ret;
+
+	/* register EMI ctrl interface */
+	ret = platform_driver_register(&emi_bw_driver);
+	if (ret) {
+		pr_err("[EMI/BWL] fail to register emi_bw_driver\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit emi_bw_exit(void)
+{
+	platform_driver_unregister(&emi_bw_driver);
+}
+
+postcore_initcall(emi_bw_init);
+module_exit(emi_bw_exit);
+
diff --git a/drivers/memory/mtk-smi.c b/drivers/memory/mtk-smi.c
index 96883411cd29..a1dc34ba7332 100644
--- a/drivers/memory/mtk-smi.c
+++ b/drivers/memory/mtk-smi.c
@@ -123,20 +123,6 @@ static void mtk_smi_clk_disable(const struct mtk_smi *smi)
 	clk_disable_unprepare(smi->clk_apb);
 }
 
-int mtk_smi_larb_get(struct device *larbdev)
-{
-	int ret = pm_runtime_get_sync(larbdev);
-
-	return (ret < 0) ? ret : 0;
-}
-EXPORT_SYMBOL_GPL(mtk_smi_larb_get);
-
-void mtk_smi_larb_put(struct device *larbdev)
-{
-	pm_runtime_put_sync(larbdev);
-}
-EXPORT_SYMBOL_GPL(mtk_smi_larb_put);
-
 static int
 mtk_smi_larb_bind(struct device *dev, struct device *master, void *data)
 {
@@ -271,6 +257,7 @@ static int mtk_smi_larb_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct device_node *smi_node;
 	struct platform_device *smi_pdev;
+	struct device_link *link;
 
 	larb = devm_kzalloc(dev, sizeof(*larb), GFP_KERNEL);
 	if (!larb)
@@ -310,6 +297,12 @@ static int mtk_smi_larb_probe(struct platform_device *pdev)
 		if (!platform_get_drvdata(smi_pdev))
 			return -EPROBE_DEFER;
 		larb->smi_common_dev = &smi_pdev->dev;
+		link = device_link_add(dev, larb->smi_common_dev,
+				       DL_FLAG_PM_RUNTIME);
+		if (!link) {
+			dev_err(dev, "Unable to link smi-common dev\n");
+			return -ENODEV;
+		}
 	} else {
 		dev_err(dev, "Failed to get the smi_common device\n");
 		return -EINVAL;
@@ -333,17 +326,9 @@ static int __maybe_unused mtk_smi_larb_resume(struct device *dev)
 	const struct mtk_smi_larb_gen *larb_gen = larb->larb_gen;
 	int ret;
 
-	/* Power on smi-common. */
-	ret = pm_runtime_get_sync(larb->smi_common_dev);
-	if (ret < 0) {
-		dev_err(dev, "Failed to pm get for smi-common(%d).\n", ret);
-		return ret;
-	}
-
 	ret = mtk_smi_clk_enable(&larb->smi);
 	if (ret < 0) {
 		dev_err(dev, "Failed to enable clock(%d).\n", ret);
-		pm_runtime_put_sync(larb->smi_common_dev);
 		return ret;
 	}
 
@@ -358,7 +343,6 @@ static int __maybe_unused mtk_smi_larb_suspend(struct device *dev)
 	struct mtk_smi_larb *larb = dev_get_drvdata(dev);
 
 	mtk_smi_clk_disable(&larb->smi);
-	pm_runtime_put_sync(larb->smi_common_dev);
 	return 0;
 }
 
diff --git a/drivers/misc/eeprom/at24.c b/drivers/misc/eeprom/at24.c
index ddfcf4ade7bf..3da3670fdb74 100644
--- a/drivers/misc/eeprom/at24.c
+++ b/drivers/misc/eeprom/at24.c
@@ -24,6 +24,7 @@
 #include <linux/regmap.h>
 #include <linux/platform_data/at24.h>
 #include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
 #include <linux/gpio/consumer.h>
 
 /*
@@ -54,6 +55,13 @@
  * which won't work on pure SMBus systems.
  */
 
+static const char * const at24_supply_names[] = {
+	"power",
+	"i2c",
+};
+
+#define AT24_NUM_SUPPLIES ARRAY_SIZE(at24_supply_names)
+
 struct at24_client {
 	struct i2c_client *client;
 	struct regmap *regmap;
@@ -69,6 +77,7 @@ struct at24_data {
 	unsigned int write_max;
 	unsigned int num_addresses;
 	unsigned int offset_adj;
+	bool         is_power_on;
 
 	u32 byte_len;
 	u16 page_size;
@@ -78,6 +87,7 @@ struct at24_data {
 
 	struct gpio_desc *wp_gpio;
 
+	struct regulator_bulk_data supplies[AT24_NUM_SUPPLIES];
 	/*
 	 * Some chips tie up multiple I2C addresses; dummy devices reserve
 	 * them for us, and we'll use them with SMBus calls.
@@ -615,6 +625,53 @@ static unsigned int at24_get_offset_adj(u8 flags, unsigned int byte_len)
 	}
 }
 
+static int at24_configure_regulators(struct at24_data *at24)
+{
+	int i;
+
+	for (i = 0; i < AT24_NUM_SUPPLIES; i++)
+		at24->supplies[i].supply = at24_supply_names[i];
+
+	return devm_regulator_bulk_get(&at24->client[0].client->dev,
+				       AT24_NUM_SUPPLIES,
+				       at24->supplies);
+}
+
+static int __maybe_unused at24_runtime_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct at24_data *at24;
+
+	at24 = i2c_get_clientdata(client);
+	if (at24->is_power_on == 1) {
+		regulator_bulk_disable(AT24_NUM_SUPPLIES, at24->supplies);
+		at24->is_power_on = 0;
+	}
+	return 0;
+}
+
+static int __maybe_unused at24_runtime_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct at24_data *at24;
+	int ret = 0;
+
+	at24 = i2c_get_clientdata(client);
+	if (at24->is_power_on == 0) {
+		ret = regulator_bulk_enable(AT24_NUM_SUPPLIES, at24->supplies);
+		if (ret < 0)
+			dev_err(dev, "Failed to enable regulators\n");
+		else
+			at24->is_power_on = 1;
+	}
+	return ret;
+}
+
+static const struct dev_pm_ops at24_pm_ops = {
+	SET_RUNTIME_PM_OPS(at24_runtime_suspend,
+			   at24_runtime_resume, NULL)
+};
+
 static int at24_probe(struct i2c_client *client)
 {
 	struct regmap_config regmap_config = { };
@@ -682,6 +739,13 @@ static int at24_probe(struct i2c_client *client)
 	at24->offset_adj = at24_get_offset_adj(pdata.flags, pdata.byte_len);
 	at24->client[0].client = client;
 	at24->client[0].regmap = regmap;
+	at24->is_power_on = 0;
+
+	err = at24_configure_regulators(at24);
+	if (err) {
+		dev_err(dev, "Failed to get power regulators\n");
+		return err;
+	}
 
 	at24->wp_gpio = devm_gpiod_get_optional(dev, "wp", GPIOD_OUT_HIGH);
 	if (IS_ERR(at24->wp_gpio))
@@ -714,7 +778,9 @@ static int at24_probe(struct i2c_client *client)
 	 * Perform a one-byte test read to verify that the
 	 * chip is functional.
 	 */
+	at24_runtime_resume(dev);
 	err = at24_read(at24, 0, &test_byte, 1);
+	at24_runtime_suspend(dev);
 	pm_runtime_idle(dev);
 	if (err) {
 		err = -ENODEV;
@@ -724,7 +790,7 @@ static int at24_probe(struct i2c_client *client)
 	nvmem_config.name = dev_name(dev);
 	nvmem_config.dev = dev;
 	nvmem_config.read_only = !writable;
-	nvmem_config.root_only = true;
+	nvmem_config.root_only = false;
 	nvmem_config.owner = THIS_MODULE;
 	nvmem_config.compat = true;
 	nvmem_config.base_dev = dev;
@@ -774,6 +840,7 @@ static int at24_remove(struct i2c_client *client)
 static struct i2c_driver at24_driver = {
 	.driver = {
 		.name = "at24",
+		.pm = &at24_pm_ops,
 		.of_match_table = at24_of_match,
 		.acpi_match_table = ACPI_PTR(at24_acpi_ids),
 	},
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index ce8398e6f2c0..c8f3fe701ea7 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -23,7 +23,7 @@ obj-$(CONFIG_MMC_SDHCI_F_SDH30)	+= sdhci_f_sdh30.o
 obj-$(CONFIG_MMC_SDHCI_SPEAR)	+= sdhci-spear.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
 obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
-obj-$(CONFIG_MMC_MTK)		+= mtk-sd.o
+obj-$(CONFIG_MMC_MTK)		+= mtk-sd.o mtk-sdio-proc.o
 obj-$(CONFIG_MMC_OMAP)		+= omap.o
 obj-$(CONFIG_MMC_OMAP_HS)	+= omap_hsmmc.o
 obj-$(CONFIG_MMC_ATMELMCI)	+= atmel-mci.o
diff --git a/drivers/mmc/host/mtk-sd.c b/drivers/mmc/host/mtk-sd.c
index 0de3749c9311..8aaa5d405987 100644
--- a/drivers/mmc/host/mtk-sd.c
+++ b/drivers/mmc/host/mtk-sd.c
@@ -39,6 +39,8 @@
 #include <linux/mmc/sdio.h>
 #include <linux/mmc/slot-gpio.h>
 
+#include "mtk-sdio-proc.h"
+
 #define MAX_BD_NUM          1024
 
 /*--------------------------------------------------------------------------*/
@@ -2234,6 +2236,9 @@ static int msdc_drv_probe(struct platform_device *pdev)
 	if (ret)
 		goto end;
 
+	if (host->mmc->caps & MMC_CAP_SDIO_IRQ)
+		sdio_proc_init(host->mmc);
+
 	return 0;
 end:
 	pm_runtime_disable(host->dev);
diff --git a/drivers/mmc/host/mtk-sdio-proc.c b/drivers/mmc/host/mtk-sdio-proc.c
new file mode 100644
index 000000000000..6f4c3cd96d42
--- /dev/null
+++ b/drivers/mmc/host/mtk-sdio-proc.c
@@ -0,0 +1,342 @@
+/*
+ * Copyright (c) 2014-2015 MediaTek Inc.
+ * Author: Chaotian.Jing <chaotian.jing@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "mtk-sdio-proc.h"
+
+static struct mmc_host *host;
+
+/**
+ * sdio_proc_show dispaly the common cccr and cis.
+ */
+static int sdio_proc_show(struct seq_file *m, void *v)
+{
+	struct mmc_card *card;
+	struct sdio_cccr cccr;
+
+	WARN_ON(!host);
+	card = host->card;
+	cccr = card->cccr;
+
+	seq_puts(m, "\n=========================================\n");
+	seq_puts(m, "common cccr:\n");
+	seq_printf(m, "sdio_vsn:%x, sd_vsn:%x, multi_block%x.\n"
+			"low_speed:%x, wide_bus:%x, hight_power:%x.\n"
+			"high_speed:%x, disable_cd:%x.\n",
+			cccr.sdio_vsn, cccr.sd_vsn, cccr.multi_block,
+			cccr.low_speed, cccr.wide_bus, cccr.high_power,
+			cccr.high_speed, cccr.disable_cd);
+
+	seq_puts(m, "common cis:\n");
+	seq_printf(m, "vendor: %x, device:%x, blksize:%x, max_dtr:%x\n",
+			card->cis.vendor, card->cis.device,
+			card->cis.blksize, card->cis.max_dtr);
+
+	seq_puts(m, "read cmd format:\n");
+	seq_puts(m, "echo 0 0xReg 0xfunction> /proc/sdio\n");
+	seq_puts(m, "write cmd format:\n");
+	seq_puts(m, "echo 1 0xReg 0xfunction 0xValue> /proc/sdio\n");
+	seq_puts(m, "setspeed cmd format:\n");
+	seq_puts(m, "echo 2 0xclkfrequency > /proc/sdio\n");
+	seq_puts(m, "tune cmd format:\n");
+	seq_puts(m, "echo 3 0xloop_cycles > /proc/sdio\n");
+	seq_puts(m, "multi read cmd format:\n");
+	seq_puts(m, "echo 4 0x13 0x0 > /proc/sdio\n");
+	seq_puts(m, "multi write cmd format:\n");
+	seq_puts(m, "echo 5 0x13 0x0 0xvalue > /proc/sdio\n");
+	seq_puts(m, "Notice:value is the read result!\n");
+	seq_puts(m, "=========================================\n");
+
+	return 0;
+}
+
+static int sdio_tuning(void)
+{
+	int err = 0;
+
+	err = mmc_send_tuning(host, MMC_SEND_TUNING_BLOCK, NULL);
+	if (err)
+		pr_err("tuning result is %d.\n", err);
+	return err;
+}
+
+/**
+ * sdio_proc_write - read/write sdio function register.
+ */
+static ssize_t sdio_proc_write(struct file *file, const char *buf,
+		size_t count, loff_t *f_pos)
+{
+	struct mmc_card *card;
+	struct sdio_func *func;
+	struct mmc_ios *ios;
+	char *cmd_buf;
+	unsigned int cmd, addr, fn, value, hqa_result;
+	unsigned char result;
+	int i = 0, ret;
+	unsigned long long count_r = 0, count_w = 0, total = 0;
+
+	WARN_ON(!host);
+	card = host->card;
+	ios = &host->ios;
+
+	cmd_buf = kzalloc((count + 1), GFP_KERNEL);
+	if (!cmd_buf)
+		return -ENOMEM;
+
+	func = kzalloc(sizeof(struct sdio_func), GFP_KERNEL);
+	if (!func)
+		return -ENOMEM;
+
+	ret = copy_from_user(cmd_buf, buf, count);
+	if (ret < 0) {
+		kfree(cmd_buf);
+		kfree(func);
+		return -EFAULT;
+	}
+
+	*(cmd_buf + count) = '\0';
+	ret = sscanf(cmd_buf, "%x %x %x %x",
+			&cmd, &addr, &fn, &value);
+	if (ret == 0) {
+		pr_err("please enter cmd.\n");
+		return ret;
+	}
+
+	if ((cmd == tune) || (cmd == speed))
+		fn = 0;
+
+	/* Judge whether request fn is over the max functions. */
+	if (fn > card->sdio_funcs) {
+		pr_err("the fn is over the max sdio funcs.\n");
+		return -EFAULT;
+	}
+
+	if (fn) {
+		/**
+		 * The test read/write api don't need more func
+		 * information. So we just use the card & func->num
+		 * to the new struct func.
+		 */
+		if (card->sdio_func[fn - 1]) {
+			func->card = card;
+			func->num = card->sdio_func[fn - 1]->num;
+			func->tuples = card->sdio_func[fn - 1]->tuples;
+			func->tmpbuf = card->sdio_func[fn - 1]->tmpbuf;
+			func->max_blksize = card->sdio_func[fn - 1]->max_blksize;
+			if ((cmd == hqa_read) || (cmd == hqa_write) || (cmd == burn))
+				func->cur_blksize = 8;
+			else
+				func->cur_blksize = 1;
+			func = card->sdio_func[fn - 1];
+		} else
+			pr_err("func %d is null,.\n", fn);
+	} else {
+		/**
+		  * function 0 should not need struct func.
+		  * but the api need the parameter, so we create
+		  * the a new func for function 0.
+		  */
+		func->card = card;
+		func->tuples = card->tuples;
+		func->num = 0;
+		func->max_blksize = 16;
+		if ((cmd == hqa_read) || (cmd == hqa_write) || (cmd == burn))
+			func->cur_blksize = 16;
+		else
+			func->cur_blksize = 1;
+
+		func->tmpbuf = kmalloc(func->cur_blksize, GFP_KERNEL);
+		if (!func->tmpbuf) {
+			kfree(func);
+			return -ENOMEM;
+		}
+		memset(func->tmpbuf, 0, func->cur_blksize);
+	}
+
+	sdio_claim_host(func);
+	pr_err("===========================================\n");
+
+	switch (cmd) {
+	case read:
+		pr_err("read addr:%x, fn:%d.\n", addr, fn);
+		ret = 0;
+		if (fn == 0)
+			result = sdio_f0_readb(func, addr, &ret);
+		else
+			result = sdio_readb(func, addr, &ret);
+
+		if (ret)
+			pr_err("Read f%d reg(%x) fail(%d).\n",
+					func->num, addr, ret);
+		else
+			pr_err("f%d reg(%x) is 0x%02x.\n",
+					func->num, addr, result);
+		break;
+	case write:
+		pr_err("write addr:%x, value:%x, fn %d.\n",
+				addr, (u8)value, fn);
+		ret = 0;
+		if (fn == 0)
+			/* (0xF0 - 0xFF) are permiited for func0 */
+			sdio_f0_writeb(func, (u8)value, addr, &ret);
+		else
+			sdio_writeb(func, (u8)value, addr, &ret);
+
+		if (ret)
+			pr_err("write f%d reg(%x) fail(%d).\n",
+					func->num, addr, ret);
+		else
+			pr_err("write f%d reg(%x) success(%d).\n",
+					func->num, addr, ret);
+
+		break;
+	case speed:
+		pr_err("set frequence:%x.\n", addr);
+
+		if (addr > 200000000)
+			addr = 200000000;
+		ios->clock = addr;
+		pr_err("%s: clock %uHz busmode %u powermode %u cs %u Vdd %u width %u timing %u\n",
+				mmc_hostname(host), ios->clock, ios->bus_mode,
+				ios->power_mode, ios->chip_select, ios->vdd,
+				ios->bus_width, ios->timing);
+
+		host->ops->set_ios(host, ios);
+		break;
+	case tune:
+		value = 0;
+		pr_err("read loop / 0x200:%x.\n", addr);
+
+		do {
+			result = sdio_tuning();
+			if (result)
+				value = value + 1;
+
+			i = i + 1;
+		} while (i < addr);
+
+		pr_err("send tuning cmd is result (%d).\n", value);
+		break;
+	case hqa_read:
+		pr_err("hqa_r addr:%x, fn %d\n", addr, fn);
+		i = 0;
+		hqa_result = 0;
+		do {
+			ret = 0;
+			hqa_result = sdio_readl(func, addr, &ret);
+			if (ret)
+				pr_err("Read f%d reg(%x) fail(%d).\n",
+						func->num, addr, ret);
+
+			i = i + 1;
+		} while (i < 0x10000);
+		pr_err("Read %d cycles success:f%d reg(%x) is 0x%02x.\n",
+				i, func->num, addr, hqa_result);
+		break;
+	case hqa_write:
+		pr_err("hqa_w addr:%x, value:%x, fn %d\n",
+				addr, value, fn);
+		i = 0;
+		hqa_result = 0;
+		do {
+			ret = 0;
+			sdio_writel(func, value, addr, &ret);
+			if (ret)
+				pr_err("write f%d reg(%x) fail(%d).\n",
+						func->num, addr, ret);
+
+			i = i + 1;
+		} while (i < 0x10000);
+		pr_err("write f%d reg(%x) success(%d).\n",
+				func->num, addr, ret);
+		break;
+	case burn:
+		do {
+			ret = 0;
+			addr = 0x13;
+			value = sdio_readl(func, addr, &ret);
+			if (ret)
+				pr_err("Read f%d reg(%x) fail(%d).\n",
+						func->num, addr, ret);
+			else {
+				pr_err("********read success********\n");
+				count_r = count_r + 1;
+			}
+			msleep(20);
+
+			ret = 0;
+			addr = 0x13;
+			func->cur_blksize = 4;
+			sdio_writel(func, value, addr, &ret);
+			if (ret)
+				pr_err("write f%d reg(%x) fail(%d).\n",
+						func->num, addr, ret);
+			else {
+				pr_err("********write success*******\n");
+				count_w = count_w + 1;
+			}
+			total = total + 1;
+			msleep(20);
+			pr_err("success read:%llx, write:%llx, total:%llx.\n",
+					count_r, count_w, total);
+		} while (1);
+		break;
+	default:
+		pr_err("cmd is not valid.\n");
+		break;
+	}
+
+	pr_err("\n===========================================\n");
+	sdio_release_host(func);
+
+	kfree(cmd_buf);
+	kfree(func);
+
+	return count;
+}
+
+/**
+ * open function show some stable information.
+ */
+static int sdio_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sdio_proc_show, inode->i_private);
+}
+
+/**
+  * sdio pre is our own function.
+  * seq or single pre is the kernel function.
+  */
+static const struct file_operations sdio_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = sdio_proc_open,
+	.release = single_release,
+	.write = sdio_proc_write,
+	.read = seq_read,
+	.llseek = seq_lseek,
+};
+
+int sdio_proc_init(struct mmc_host *host_init)
+{
+	struct proc_dir_entry *prEntry;
+
+	host = host_init;
+
+	prEntry = proc_create("sdio", 0660, NULL, &sdio_proc_fops);
+	if (prEntry)
+		pr_err("[%s]/proc/sdio_proc is created.\n", __func__);
+	else
+		pr_err("[%s]Create /proc/sdio_proc failed.\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/mmc/host/mtk-sdio-proc.h b/drivers/mmc/host/mtk-sdio-proc.h
new file mode 100644
index 000000000000..33659ba69be3
--- /dev/null
+++ b/drivers/mmc/host/mtk-sdio-proc.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2014-2015 MediaTek Inc.
+ * Author: Chaotian.Jing <chaotian.jing@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+#include <linux/mmc/host.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+
+int sdio_proc_init(struct mmc_host *host);
+
+enum {
+	read = 0,
+	write,
+	speed,
+	tune,
+	hqa_read,
+	hqa_write,
+	burn
+};
diff --git a/drivers/net/wireless/ath/ath10k/htt_rx.c b/drivers/net/wireless/ath/ath10k/htt_rx.c
index a270fe097ac8..30ded20eb545 100644
--- a/drivers/net/wireless/ath/ath10k/htt_rx.c
+++ b/drivers/net/wireless/ath/ath10k/htt_rx.c
@@ -1981,7 +1981,7 @@ static bool ath10k_htt_rx_proc_rx_ind_hl(struct ath10k_htt *htt,
 	    HTT_RX_IND_MPDU_STATUS_OK &&
 	    mpdu_ranges->mpdu_range_status !=
 	    HTT_RX_IND_MPDU_STATUS_TKIP_MIC_ERR) {
-		ath10k_warn(ar, "MPDU range status: %d\n",
+		ath10k_dbg(ar, ATH10K_DBG_HTT, "MPDU range status: %d\n",
 			    mpdu_ranges->mpdu_range_status);
 		goto err;
 	}
diff --git a/drivers/net/wireless/ath/ath10k/htt_tx.c b/drivers/net/wireless/ath/ath10k/htt_tx.c
index 066b26c7db81..a9316a5a3847 100644
--- a/drivers/net/wireless/ath/ath10k/htt_tx.c
+++ b/drivers/net/wireless/ath/ath10k/htt_tx.c
@@ -1201,6 +1201,7 @@ static int ath10k_htt_tx_hl(struct ath10k_htt *htt, enum ath10k_hw_txrx_mode txm
 	struct ath10k *ar = htt->ar;
 	int res, data_len;
 	struct htt_cmd_hdr *cmd_hdr;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)msdu->data;
 	struct htt_data_tx_desc *tx_desc;
 	struct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(msdu);
 	struct sk_buff *tmp_skb;
@@ -1211,6 +1212,13 @@ static int ath10k_htt_tx_hl(struct ath10k_htt *htt, enum ath10k_hw_txrx_mode txm
 	u16 flags1 = 0;
 	u16 msdu_id = 0;
 
+	if ((ieee80211_is_action(hdr->frame_control) ||
+	     ieee80211_is_deauth(hdr->frame_control) ||
+	     ieee80211_is_disassoc(hdr->frame_control)) &&
+	     ieee80211_has_protected(hdr->frame_control)) {
+		skb_put(msdu, IEEE80211_CCMP_MIC_LEN);
+	}
+
 	data_len = msdu->len;
 
 	switch (txmode) {
diff --git a/drivers/remoteproc/mtk_scp.c b/drivers/remoteproc/mtk_scp.c
index 77f30988c803..029912daaf77 100644
--- a/drivers/remoteproc/mtk_scp.c
+++ b/drivers/remoteproc/mtk_scp.c
@@ -378,16 +378,16 @@ static struct scp_reserve_mblock scp_reserve_mblock[] = {
 		.size = 0x800000, /*8MB*/
 	},
 	{
-		.num = SCP_DIP_MEM_ID,
+		.num = SCP_MDP_MEM_ID,
 		.start_phys = 0x0,
 		.start_virt = 0x0,
-		.size = 0x900000, /*9MB*/
+		.size = 0x600000, /*6MB*/
 	},
 	{
-		.num = SCP_MDP_MEM_ID,
+		.num = SCP_DIP_MEM_ID,
 		.start_phys = 0x0,
 		.start_virt = 0x0,
-		.size = 0x600000, /*6MB*/
+		.size = 0x900000, /*9MB*/
 	},
 	{
 		.num = SCP_FD_MEM_ID,
@@ -395,6 +395,12 @@ static struct scp_reserve_mblock scp_reserve_mblock[] = {
 		.start_virt = 0x0,
 		.size = 0x100000, /*1MB*/
 	},
+	{
+		.num = SCP_FD_MEM2_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.size = 0x100000,   /*1MB*/
+	},
 };
 
 static int scp_reserve_mem_init(struct mtk_scp *scp)
diff --git a/drivers/soc/mediatek/mtk-cmdq-helper.c b/drivers/soc/mediatek/mtk-cmdq-helper.c
index fac4d33fd520..343bf13f77ef 100644
--- a/drivers/soc/mediatek/mtk-cmdq-helper.c
+++ b/drivers/soc/mediatek/mtk-cmdq-helper.c
@@ -56,6 +56,9 @@ static void cmdq_client_timeout(struct timer_list *t)
 	struct cmdq_client *client = from_timer(client, t, timer);
 
 	dev_err(client->client.dev, "cmdq timeout!\n");
+#ifdef CONFIG_MTK_CMDQ_DEBUG
+	mbox_free_channel(client->chan);
+#endif
 }
 
 struct cmdq_client *cmdq_mbox_create(struct device *dev, int index, u32 timeout)
diff --git a/drivers/tty/serial/8250/8250_mtk.c b/drivers/tty/serial/8250/8250_mtk.c
index 5b94b853387d..74849a187c1b 100644
--- a/drivers/tty/serial/8250/8250_mtk.c
+++ b/drivers/tty/serial/8250/8250_mtk.c
@@ -32,6 +32,7 @@
 #define MTK_UART_RXTRI_AD	0x14	/* RX Trigger address */
 #define MTK_UART_FRACDIV_L	0x15	/* Fractional divider LSB address */
 #define MTK_UART_FRACDIV_M	0x16	/* Fractional divider MSB address */
+#define MTK_UART_DEBUG0	0x18
 #define MTK_UART_IER_XOFFI	0x20	/* Enable XOFF character interrupt */
 #define MTK_UART_IER_RTSI	0x40	/* Enable RTS Modem status interrupt */
 #define MTK_UART_IER_CTSI	0x80	/* Enable CTS Modem status interrupt */
@@ -397,9 +398,18 @@ mtk8250_set_termios(struct uart_port *port, struct ktermios *termios,
 static int __maybe_unused mtk8250_runtime_suspend(struct device *dev)
 {
 	struct mtk8250_data *data = dev_get_drvdata(dev);
+	struct uart_8250_port *up = serial8250_get_port(data->line);
 
-	clk_disable_unprepare(data->uart_clk);
-	clk_disable_unprepare(data->bus_clk);
+	/* wait until UART in idle status */
+	while
+		(serial_in(up, MTK_UART_DEBUG0));
+
+	if (data->clk_count == 0U) {
+		dev_dbg(dev, "%s clock count is 0\n", __func__);
+	} else {
+		clk_disable_unprepare(data->bus_clk);
+		data->clk_count--;
+	}
 
 	return 0;
 }
@@ -409,16 +419,16 @@ static int __maybe_unused mtk8250_runtime_resume(struct device *dev)
 	struct mtk8250_data *data = dev_get_drvdata(dev);
 	int err;
 
-	err = clk_prepare_enable(data->uart_clk);
-	if (err) {
-		dev_warn(dev, "Can't enable clock\n");
-		return err;
-	}
-
-	err = clk_prepare_enable(data->bus_clk);
-	if (err) {
-		dev_warn(dev, "Can't enable bus clock\n");
-		return err;
+	if (data->clk_count > 0U) {
+		dev_dbg(dev, "%s clock count is %d\n", __func__,
+			data->clk_count);
+	} else {
+		err = clk_prepare_enable(data->bus_clk);
+		if (err) {
+			dev_warn(dev, "Can't enable bus clock\n");
+			return err;
+		}
+		data->clk_count++;
 	}
 
 	return 0;
@@ -428,12 +438,14 @@ static void
 mtk8250_do_pm(struct uart_port *port, unsigned int state, unsigned int old)
 {
 	if (!state)
-		pm_runtime_get_sync(port->dev);
+		if (!mtk8250_runtime_resume(port->dev))
+			pm_runtime_get_sync(port->dev);
 
 	serial8250_do_pm(port, state, old);
 
 	if (state)
-		pm_runtime_put_sync_suspend(port->dev);
+		if (!pm_runtime_put_sync_suspend(port->dev))
+			mtk8250_runtime_suspend(port->dev);
 }
 
 #ifdef CONFIG_SERIAL_8250_DMA
@@ -510,6 +522,8 @@ static int mtk8250_probe(struct platform_device *pdev)
 	if (!data)
 		return -ENOMEM;
 
+	data->clk_count = 0;
+
 	if (pdev->dev.of_node) {
 		err = mtk8250_probe_of(pdev, &uart.port, data);
 		if (err)
@@ -542,6 +556,7 @@ static int mtk8250_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, data);
 
+	pm_runtime_enable(&pdev->dev);
 	err = mtk8250_runtime_resume(&pdev->dev);
 	if (err)
 		return err;
@@ -550,9 +565,6 @@ static int mtk8250_probe(struct platform_device *pdev)
 	if (data->line < 0)
 		return data->line;
 
-	pm_runtime_set_active(&pdev->dev);
-	pm_runtime_enable(&pdev->dev);
-
 	data->rx_wakeup_irq = platform_get_irq(pdev, 1);
 
 	return 0;
@@ -565,11 +577,13 @@ static int mtk8250_remove(struct platform_device *pdev)
 	pm_runtime_get_sync(&pdev->dev);
 
 	serial8250_unregister_port(data->line);
-	mtk8250_runtime_suspend(&pdev->dev);
 
 	pm_runtime_disable(&pdev->dev);
 	pm_runtime_put_noidle(&pdev->dev);
 
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		mtk8250_runtime_suspend(&pdev->dev);
+
 	return 0;
 }
 
diff --git a/drivers/usb/mtu3/mtu3_core.c b/drivers/usb/mtu3/mtu3_core.c
index 48d10a61e271..542b67a6b5a6 100644
--- a/drivers/usb/mtu3/mtu3_core.c
+++ b/drivers/usb/mtu3/mtu3_core.c
@@ -94,6 +94,7 @@ static int mtu3_device_enable(struct mtu3 *mtu)
 {
 	void __iomem *ibase = mtu->ippc_base;
 	u32 check_clk = 0;
+	struct ssusb_mtk *ssusb = mtu->ssusb;
 
 	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);
 
@@ -107,7 +108,7 @@ static int mtu3_device_enable(struct mtu3 *mtu)
 		(SSUSB_U2_PORT_DIS | SSUSB_U2_PORT_PDN |
 		SSUSB_U2_PORT_HOST_SEL));
 
-	if (mtu->ssusb->dr_mode == USB_DR_MODE_OTG) {
+	if (mtu->ssusb->dr_mode == USB_DR_MODE_OTG && !ssusb->otg_switch.manual_drd_enabled) {
 		mtu3_setbits(ibase, SSUSB_U2_CTRL(0), SSUSB_U2_PORT_OTG_SEL);
 		if (mtu->is_u3_ip)
 			mtu3_setbits(ibase, SSUSB_U3_CTRL(0),
@@ -120,6 +121,7 @@ static int mtu3_device_enable(struct mtu3 *mtu)
 static void mtu3_device_disable(struct mtu3 *mtu)
 {
 	void __iomem *ibase = mtu->ippc_base;
+	struct ssusb_mtk *ssusb = mtu->ssusb;
 
 	if (mtu->is_u3_ip)
 		mtu3_setbits(ibase, SSUSB_U3_CTRL(0),
@@ -128,7 +130,7 @@ static void mtu3_device_disable(struct mtu3 *mtu)
 	mtu3_setbits(ibase, SSUSB_U2_CTRL(0),
 		SSUSB_U2_PORT_DIS | SSUSB_U2_PORT_PDN);
 
-	if (mtu->ssusb->dr_mode == USB_DR_MODE_OTG)
+	if (mtu->ssusb->dr_mode == USB_DR_MODE_OTG && !ssusb->otg_switch.manual_drd_enabled)
 		mtu3_clrbits(ibase, SSUSB_U2_CTRL(0), SSUSB_U2_PORT_OTG_SEL);
 
 	mtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);
@@ -183,6 +185,9 @@ static void mtu3_intr_enable(struct mtu3 *mtu)
 	value = SUSPEND_INTR | RESUME_INTR | RESET_INTR | LPM_RESUME_INTR;
 	mtu3_writel(mbase, U3D_COMMON_USB_INTR_ENABLE, value);
 
+	mtu3_clrbits(mbase, U3D_DEVICE_CONTROL, DC_SESSION);
+	mtu3_setbits(mbase, U3D_MISC_CTRL, VBUS_FRC_EN | VBUS_ON);
+
 	if (mtu->is_u3_ip) {
 		/* Enable U3 LTSSM interrupts */
 		value = HOT_RST_INTR | WARM_RST_INTR | VBUS_RISE_INTR |
@@ -759,7 +764,10 @@ static int mtu3_hw_init(struct mtu3 *mtu)
 	mtu->hw_version = mtu3_readl(mtu->ippc_base, U3D_SSUSB_HW_ID);
 
 	cap_dev = mtu3_readl(mtu->ippc_base, U3D_SSUSB_IP_DEV_CAP);
-	mtu->is_u3_ip = !!SSUSB_IP_DEV_U3_PORT_NUM(cap_dev);
+	if (mtu->max_speed <= USB_SPEED_HIGH)
+		mtu->is_u3_ip = 0;
+	else
+		mtu->is_u3_ip = !!SSUSB_IP_DEV_U3_PORT_NUM(cap_dev);
 
 	dev_info(mtu->dev, "IP version 0x%x(%s IP)\n", mtu->hw_version,
 		mtu->is_u3_ip ? "U3" : "U2");
diff --git a/drivers/usb/mtu3/mtu3_dr.c b/drivers/usb/mtu3/mtu3_dr.c
index ac60e9c8564e..7660d107e5bc 100644
--- a/drivers/usb/mtu3/mtu3_dr.c
+++ b/drivers/usb/mtu3/mtu3_dr.c
@@ -401,7 +401,7 @@ void ssusb_set_force_mode(struct ssusb_mtk *ssusb,
 		break;
 	case MTU3_DR_FORCE_HOST:
 		value |= SSUSB_U2_PORT_FORCE_IDDIG;
-		value &= ~SSUSB_U2_PORT_RG_IDDIG;
+		value &= ~(SSUSB_U2_PORT_RG_IDDIG | SSUSB_U2_PORT_OTG_SEL);
 		break;
 	case MTU3_DR_FORCE_NONE:
 		value &= ~(SSUSB_U2_PORT_FORCE_IDDIG | SSUSB_U2_PORT_RG_IDDIG);
diff --git a/drivers/usb/mtu3/mtu3_host.c b/drivers/usb/mtu3/mtu3_host.c
index c871b94f3e6f..6f9cf64fe7bb 100644
--- a/drivers/usb/mtu3/mtu3_host.c
+++ b/drivers/usb/mtu3/mtu3_host.c
@@ -29,6 +29,17 @@
 #define SSC_IP_SLEEP_EN	BIT(4)
 #define SSC_SPM_INT_EN		BIT(1)
 
+/* mt8183 etc */
+#define PERI_USB_WK_CTRL0		0x400
+#define SSUSB_INST_DP_CDDEBOUNCE	(0xf << 26)
+#define SSUSB_INST_DM_CDDEBOUNCE	(0xf << 22)
+#define SSUSB_INST_DP_CDEN		BIT(21)
+#define SSUSB_INST_DM_CDEN		BIT(20)
+#define SSUSB_INST_DP_SPM_RISE_ENABLE	BIT(19)
+#define SSUSB_INST_DP_SPM_FALL_ENABLE	BIT(18)
+#define SSUSB_INST_DM_SPM_RISE_ENABLE	BIT(17)
+#define SSUSB_INST_DM_SPM_FALL_ENABLE	BIT(16)
+
 enum ssusb_uwk_vers {
 	SSUSB_UWK_V1 = 1,
 	SSUSB_UWK_V2,
@@ -59,6 +70,22 @@ static void ssusb_wakeup_ip_sleep_set(struct ssusb_mtk *ssusb, bool enable)
 	regmap_update_bits(ssusb->uwk, reg, msk, val);
 }
 
+static void ssusb_wakeup_dm_set(struct ssusb_mtk *ssusb, bool enable)
+{
+	u32 tmp;
+
+	regmap_read(ssusb->uwk, PERI_USB_WK_CTRL0, &tmp);
+	if (enable) {
+		tmp |= SSUSB_INST_DM_SPM_RISE_ENABLE;
+		tmp |= SSUSB_INST_DM_CDDEBOUNCE;
+		tmp |= SSUSB_INST_DM_CDEN;
+	} else
+		tmp &= ~SSUSB_INST_DM_CDEN;
+
+	regmap_write(ssusb->uwk, PERI_USB_WK_CTRL0, tmp);
+	regmap_read(ssusb->uwk, PERI_USB_WK_CTRL0, &tmp);
+}
+
 int ssusb_wakeup_of_property_parse(struct ssusb_mtk *ssusb,
 				struct device_node *dn)
 {
@@ -87,8 +114,10 @@ int ssusb_wakeup_of_property_parse(struct ssusb_mtk *ssusb,
 
 void ssusb_wakeup_set(struct ssusb_mtk *ssusb, bool enable)
 {
-	if (ssusb->uwk_en)
+	if (ssusb->uwk_en) {
 		ssusb_wakeup_ip_sleep_set(ssusb, enable);
+		ssusb_wakeup_dm_set(ssusb, enable);
+	}
 }
 
 static void host_ports_num_get(struct ssusb_mtk *ssusb)
diff --git a/include/dt-bindings/clock/mt8183-clk.h b/include/dt-bindings/clock/mt8183-clk.h
index 0046506eb24c..bf133a5a8848 100644
--- a/include/dt-bindings/clock/mt8183-clk.h
+++ b/include/dt-bindings/clock/mt8183-clk.h
@@ -284,6 +284,10 @@
 #define CLK_INFRA_FBIST2FPC		100
 #define CLK_INFRA_NR_CLK		101
 
+/* PERICFG */
+#define CLK_PERIAXI                     0
+#define CLK_PERI_NR_CLK                 1
+
 /* MFGCFG */
 #define CLK_MFG_BG3D			0
 #define CLK_MFG_NR_CLK			1
diff --git a/include/linux/platform_data/mtk_scp.h b/include/linux/platform_data/mtk_scp.h
index 0031e23695f1..bc5661c43d8b 100644
--- a/include/linux/platform_data/mtk_scp.h
+++ b/include/linux/platform_data/mtk_scp.h
@@ -149,6 +149,7 @@ enum scp_reserve_mem_id_t {
 	SCP_MDP_MEM_ID,
 	SCP_DIP_MEM_ID,
 	SCP_FD_MEM_ID,
+	SCP_FD_MEM2_ID,
 	SCP_NUMS_MEM_ID,
 };
 
diff --git a/include/soc/mediatek/emi.h b/include/soc/mediatek/emi.h
new file mode 100644
index 000000000000..83bdaeb6840b
--- /dev/null
+++ b/include/soc/mediatek/emi.h
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: GPL-2.0  */
+/*
+ * Copyright (c) 2015-2016 MediaTek Inc.
+ * Author: Xi Chen <xixi.chen@mediatek.com>
+ */
+
+#ifndef _MTK_EMI_H_
+#define _MTK_EMI_H_
+
+#define MAX_CH		2
+#define MAX_RK		2
+
+struct emi_info_t {
+	unsigned int dram_type;
+	unsigned int ch_num;
+	unsigned int rk_num;
+	unsigned int rank_size[MAX_RK];
+};
+
+/*****************************************************************************
+ *  Macro Definiations
+ *****************************************************************************/
+#define EMI_REG_BASE                (0x10219000)
+#define EMI_REG_BASE_MAPPED         (emi->cen_emi_base)
+
+#define EMI_MDCT                    (EMI_REG_BASE_MAPPED + 0x078)
+#define EMI_MDCT_2ND                (EMI_REG_BASE_MAPPED + 0x07C)
+
+#define EMI_ARBA                    (EMI_REG_BASE_MAPPED + 0x100)
+#define EMI_ARBB                    (EMI_REG_BASE_MAPPED + 0x108)
+#define EMI_ARBC                    (EMI_REG_BASE_MAPPED + 0x110)
+#define EMI_ARBD                    (EMI_REG_BASE_MAPPED + 0x118)
+#define EMI_ARBE                    (EMI_REG_BASE_MAPPED + 0x120)
+#define EMI_ARBF                    (EMI_REG_BASE_MAPPED + 0x128)
+#define EMI_ARBG                    (EMI_REG_BASE_MAPPED + 0x130)
+#define EMI_ARBH                    (EMI_REG_BASE_MAPPED + 0x138)
+
+#define EMI_BMEN                    (EMI_REG_BASE_MAPPED + 0x400)
+#define EMI_BCNT                    (EMI_REG_BASE_MAPPED + 0x408)
+#define EMI_TACT                    (EMI_REG_BASE_MAPPED + 0x410)
+#define EMI_TSCT                    (EMI_REG_BASE_MAPPED + 0x418)
+#define EMI_WACT                    (EMI_REG_BASE_MAPPED + 0x420)
+#define EMI_WSCT                    (EMI_REG_BASE_MAPPED + 0x428)
+#define EMI_BACT                    (EMI_REG_BASE_MAPPED + 0x430)
+#define EMI_BSCT                    (EMI_REG_BASE_MAPPED + 0x438)
+#define EMI_MSEL                    (EMI_REG_BASE_MAPPED + 0x440)
+#define EMI_TSCT2                   (EMI_REG_BASE_MAPPED + 0x448)
+#define EMI_TSCT3                   (EMI_REG_BASE_MAPPED + 0x450)
+#define EMI_WSCT2                   (EMI_REG_BASE_MAPPED + 0x458)
+#define EMI_WSCT3                   (EMI_REG_BASE_MAPPED + 0x460)
+#define EMI_WSCT4                   (EMI_REG_BASE_MAPPED + 0x464)
+#define EMI_MSEL2                   (EMI_REG_BASE_MAPPED + 0x468)
+
+#define EMI_BMEN2                   (EMI_REG_BASE_MAPPED + 0x4E8)
+
+#define EMI_BMRW0                   (EMI_REG_BASE_MAPPED + 0x4F8)
+
+#define EMI_TTYPE1                  (EMI_REG_BASE_MAPPED + 0x500)
+#define EMI_TTYPE17                 (EMI_REG_BASE_MAPPED + 0x580)
+
+#define EMI_BWVL                    (EMI_REG_BASE_MAPPED + 0x7D0)
+#define EMI_BWVL_2ND                (EMI_REG_BASE_MAPPED + 0x7D4)
+#define EMI_BWVL_3RD                (EMI_REG_BASE_MAPPED + 0x7D8)
+#define EMI_BWVL_4TH                (EMI_REG_BASE_MAPPED + 0x7DC)
+#define EMI_BWVL_5TH                (EMI_REG_BASE_MAPPED + 0x7E0)
+
+#define EMI_CH0_REG_BASE            (0x1022D000)
+#define EMI_CH0_REG_BASE_MAPPED     (emi->chn_emi_base[0])
+#define EMI_CH0_DRS_ST2             (EMI_CH0_REG_BASE_MAPPED + 0x17C)
+#define EMI_CH0_DRS_ST3             (EMI_CH0_REG_BASE_MAPPED + 0x180)
+#define EMI_CH0_DRS_ST4             (EMI_CH0_REG_BASE_MAPPED + 0x184)
+
+#define EMI_CH1_REG_BASE            (0x10235000)
+#define EMI_CH1_REG_BASE_MAPPED     (emi->chn_emi_base[1])
+#define EMI_CH1_DRS_ST2             (EMI_CH1_REG_BASE_MAPPED + 0x17C)
+#define EMI_CH1_DRS_ST3             (EMI_CH1_REG_BASE_MAPPED + 0x180)
+#define EMI_CH1_DRS_ST4             (EMI_CH1_REG_BASE_MAPPED + 0x184)
+
+/*
+ * DEFAULT_VALUE
+ */
+#define EMI_BMEN_DEFAULT_VALUE    (0x00FF0000)
+#define EMI_BMEN2_DEFAULT_VALUE   (0x02000000)
+#define EMI_BMRW0_DEFAULT_VALUE   (0xFFFFFFFF)
+#define EMI_MSEL_DEFAULT_VALUE    (0x00030024)
+#define EMI_MSEL2_DEFAULT_VALUE   (0x000000C0)
+#define BC_OVERRUN                (0x00000100)
+
+/* EMI_BMEN */
+#define BUS_MON_EN          BIT(0)
+#define BUS_MON_PAUSE       BIT(1)
+#define BUS_MON_IDLE        BIT(3)
+
+#define MAX_DRAM_CH_NUM     (2)
+#define DRAM_RANK_NUM       (2)
+#define DRAM_PDIR_NUM       (8)
+#define EMI_TTYPE_NUM       (21)
+#define EMI_TSCT_NUM        (3)
+#define EMI_MDCT_NUM        (2)
+#define EMI_DRS_ST_NUM      (3)
+#define EMI_BW_LIMIT_NUM    (8)
+
+#define DRAMC_CG_SHIFT      (9)
+
+#define EMI_IDX_SIZE        (1024)
+
+#define EMI_BWVL_UNIT       (271)
+
+#define MBW_BUF_LEN         (0x800000)
+#define DATA_CNT_PER_BLK    (35)
+#define BLK_CNT_PER_BUF     (0x800)
+
+/* public apis */
+unsigned long long emi_get_max_bw(void);
+
+#endif
diff --git a/include/soc/mediatek/smi.h b/include/soc/mediatek/smi.h
index 7a8d87051ee8..609397d69602 100644
--- a/include/soc/mediatek/smi.h
+++ b/include/soc/mediatek/smi.h
@@ -24,26 +24,6 @@ struct mtk_smi_iommu {
 	struct mtk_smi_larb_iommu larb_imu[MTK_LARB_NR_MAX];
 };
 
-/*
- * mtk_smi_larb_get: Enable the power domain and clocks for this local arbiter.
- *                   It also initialize some basic setting(like iommu).
- * mtk_smi_larb_put: Disable the power domain and clocks for this local arbiter.
- * Both should be called in non-atomic context.
- *
- * Returns 0 if successful, negative on failure.
- */
-int mtk_smi_larb_get(struct device *larbdev);
-void mtk_smi_larb_put(struct device *larbdev);
-
-#else
-
-static inline int mtk_smi_larb_get(struct device *larbdev)
-{
-	return 0;
-}
-
-static inline void mtk_smi_larb_put(struct device *larbdev) { }
-
 #endif
 
 #endif
diff --git a/include/uapi/linux/v4l2-controls.h b/include/uapi/linux/v4l2-controls.h
index 2fb36d37f898..7279a4d78f97 100644
--- a/include/uapi/linux/v4l2-controls.h
+++ b/include/uapi/linux/v4l2-controls.h
@@ -190,6 +190,10 @@ enum v4l2_colorfx {
  * We reserve 16 controls for this driver. */
 #define V4L2_CID_USER_IMX_BASE			(V4L2_CID_USER_BASE + 0x10b0)
 
+/* The base for the mediatek ISP Pass 1 driver controls */
+/* We reserve 16 controls for this driver. */
+#define V4L2_CID_USER_MTK_CAM_BASE		(V4L2_CID_USER_BASE + 0x10c0)
+
 /* MPEG-class control IDs */
 /* The MPEG controls are applicable to all codec controls
  * and the 'MPEG' part of the define is historical */
diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
index b08f3dba87af..75ca327166eb 100644
--- a/include/uapi/linux/videodev2.h
+++ b/include/uapi/linux/videodev2.h
@@ -698,6 +698,40 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_IPU3_SGRBG10	v4l2_fourcc('i', 'p', '3', 'G') /* IPU3 packed 10-bit GRBG bayer */
 #define V4L2_PIX_FMT_IPU3_SRGGB10	v4l2_fourcc('i', 'p', '3', 'r') /* IPU3 packed 10-bit RGGB bayer */
 
+/* Vendor specific - Mediatek ISP bayer formats */
+#define V4L2_PIX_FMT_MTISP_SBGGR8   v4l2_fourcc('M', 'B', 'B', '8') /*  Packed  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG8   v4l2_fourcc('M', 'B', 'G', '8') /*  Packed  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG8   v4l2_fourcc('M', 'B', 'g', '8') /*  Packed  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB8   v4l2_fourcc('M', 'B', 'R', '8') /*  Packed  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR10  v4l2_fourcc('M', 'B', 'B', 'A') /*  Packed 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG10  v4l2_fourcc('M', 'B', 'G', 'A') /*  Packed 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG10  v4l2_fourcc('M', 'B', 'g', 'A') /*  Packed 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB10  v4l2_fourcc('M', 'B', 'R', 'A') /*  Packed 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR12  v4l2_fourcc('M', 'B', 'B', 'C') /*  Packed 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG12  v4l2_fourcc('M', 'B', 'G', 'C') /*  Packed 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG12  v4l2_fourcc('M', 'B', 'g', 'C') /*  Packed 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB12  v4l2_fourcc('M', 'B', 'R', 'C') /*  Packed 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR14  v4l2_fourcc('M', 'B', 'B', 'E') /*  Packed 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG14  v4l2_fourcc('M', 'B', 'G', 'E') /*  Packed 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG14  v4l2_fourcc('M', 'B', 'g', 'E') /*  Packed 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB14  v4l2_fourcc('M', 'B', 'R', 'E') /*  Packed 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR8F   v4l2_fourcc('M', 'F', 'B', '8') /*  Full-G  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG8F   v4l2_fourcc('M', 'F', 'G', '8') /*  Full-G  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG8F   v4l2_fourcc('M', 'F', 'g', '8') /*  Full-G  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB8F   v4l2_fourcc('M', 'F', 'R', '8') /*  Full-G  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR10F  v4l2_fourcc('M', 'F', 'B', 'A') /*  Full-G 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG10F  v4l2_fourcc('M', 'F', 'G', 'A') /*  Full-G 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG10F  v4l2_fourcc('M', 'F', 'g', 'A') /*  Full-G 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB10F  v4l2_fourcc('M', 'F', 'R', 'A') /*  Full-G 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR12F  v4l2_fourcc('M', 'F', 'B', 'C') /*  Full-G 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG12F  v4l2_fourcc('M', 'F', 'G', 'C') /*  Full-G 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG12F  v4l2_fourcc('M', 'F', 'g', 'C') /*  Full-G 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB12F  v4l2_fourcc('M', 'F', 'R', 'C') /*  Full-G 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR14F  v4l2_fourcc('M', 'F', 'B', 'E') /*  Full-G 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG14F  v4l2_fourcc('M', 'F', 'G', 'E') /*  Full-G 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG14F  v4l2_fourcc('M', 'F', 'g', 'E') /*  Full-G 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB14F  v4l2_fourcc('M', 'F', 'R', 'E') /*  Full-G 14-bit  */
+
 /* SDR formats - used only for Software Defined Radio devices */
 #define V4L2_SDR_FMT_CU8          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
 #define V4L2_SDR_FMT_CU16LE       v4l2_fourcc('C', 'U', '1', '6') /* IQ u16le */
@@ -719,6 +753,13 @@ struct v4l2_pix_format {
 #define V4L2_META_FMT_VSP1_HGT    v4l2_fourcc('V', 'S', 'P', 'T') /* R-Car VSP1 2-D Histogram */
 #define V4L2_META_FMT_UVC         v4l2_fourcc('U', 'V', 'C', 'H') /* UVC Payload Header metadata */
 
+/* Vendor specific - Mediatek ISP parameters for firmware */
+#define V4L2_META_FMT_MTISP_PARAMS v4l2_fourcc('M', 'T', 'f', 'p') /* ISP tuning parameters */
+#define V4L2_META_FMT_MTISP_3A	   v4l2_fourcc('M', 'T', 'f', 'a') /* AE/AWB histogram */
+#define V4L2_META_FMT_MTISP_AF	   v4l2_fourcc('M', 'T', 'f', 'f') /* AF histogram */
+#define V4L2_META_FMT_MTISP_LCS	   v4l2_fourcc('M', 'T', 'f', 'c') /* Local contrast enhanced statistics */
+#define V4L2_META_FMT_MTISP_LMV	   v4l2_fourcc('M', 'T', 'f', 'm') /* Local motion vector histogram */
+
 /* priv field value to indicates that subsequent fields are valid. */
 #define V4L2_PIX_FMT_PRIV_MAGIC		0xfeedcafe
 
diff --git a/sound/soc/codecs/mt6358.c b/sound/soc/codecs/mt6358.c
index 50b3fc5457ea..3edf6db3a803 100644
--- a/sound/soc/codecs/mt6358.c
+++ b/sound/soc/codecs/mt6358.c
@@ -1709,8 +1709,7 @@ static void mt6358_amic_disable(struct mt6358_priv *priv)
 
 static int mt6358_dmic_enable(struct mt6358_priv *priv)
 {
-	dev_info(priv->dev, "%s()\n", __func__);
-
+	dev_info(priv->dev, "JIAXIN2%s()\n", __func__);
 	/* mic bias */
 	/* Enable MICBIAS0, MISBIAS0 = 1P9V */
 	regmap_write(priv->regmap, MT6358_AUDENC_ANA_CON9, 0x0021);
@@ -1730,6 +1729,7 @@ static int mt6358_dmic_enable(struct mt6358_priv *priv)
 
 	/* UL turn on */
 	regmap_write(priv->regmap, MT6358_AFE_UL_SRC_CON0_L, 0x0003);
+	msleep(100);
 	return 0;
 }
 
diff --git a/sound/soc/mediatek/common/mtk-afe-fe-dai.c b/sound/soc/mediatek/common/mtk-afe-fe-dai.c
index d16563408465..10ea4fdbeb1e 100644
--- a/sound/soc/mediatek/common/mtk-afe-fe-dai.c
+++ b/sound/soc/mediatek/common/mtk-afe-fe-dai.c
@@ -241,7 +241,7 @@ int mtk_afe_fe_prepare(struct snd_pcm_substream *substream,
 	struct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);
 	struct mtk_base_afe_memif *memif = &afe->memif[rtd->cpu_dai->id];
 	int hd_audio = 0;
-	int hd_align = 1;
+	int hd_align = 0;
 
 	/* set hd mode */
 	switch (substream->runtime->format) {
@@ -254,7 +254,6 @@ int mtk_afe_fe_prepare(struct snd_pcm_substream *substream,
 		break;
 	case SNDRV_PCM_FORMAT_S24_LE:
 		hd_audio = 1;
-		hd_align = 0;
 		break;
 	default:
 		dev_err(afe->dev, "%s() error: unsupported format %d\n",
diff --git a/sound/soc/mediatek/mt8183/mt8183-dai-tdm.c b/sound/soc/mediatek/mt8183/mt8183-dai-tdm.c
old mode 100644
new mode 100755
index 8983d54a9b67..2ee7a58fd726
--- a/sound/soc/mediatek/mt8183/mt8183-dai-tdm.c
+++ b/sound/soc/mediatek/mt8183/mt8183-dai-tdm.c
@@ -15,13 +15,30 @@
 struct mtk_afe_tdm_priv {
 	int bck_id;
 	int bck_rate;
-
+	int tdm_out_mode;
+	int bck_invert;
+	int lck_invert;
 	int mclk_id;
 	int mclk_multiple; /* according to sample rate */
 	int mclk_rate;
 	int mclk_apll;
 };
 
+enum {
+	TDM_OUT_I2S = 0,
+	TDM_OUT_TDM = 1,
+};
+
+enum {
+	TDM_BCK_NON_INV = 0,
+	TDM_BCK_INV = 1,
+};
+
+enum {
+	TDM_LCK_NON_INV = 0,
+	TDM_LCK_INV = 1,
+};
+
 enum {
 	TDM_WLEN_16_BIT = 1,
 	TDM_WLEN_32_BIT = 2,
@@ -93,6 +110,25 @@ static unsigned int get_tdm_ch(unsigned int ch)
 	}
 }
 
+static unsigned int get_tdm_ch_fixup(unsigned int channels)
+{
+	if (channels > 4)
+		return 8;
+	else if (channels > 2)
+		return 4;
+	else
+		return 2;
+}
+
+static unsigned int get_tdm_ch_per_sdata(unsigned int mode,
+	unsigned int channels)
+{
+	if (mode == TDM_OUT_TDM)
+		return get_tdm_ch_fixup(channels);
+	else
+		return 2;
+}
+
 /* interconnection */
 enum {
 	HDMI_CONN_CH0 = 0,
@@ -433,8 +469,10 @@ static int mtk_dai_tdm_hw_params(struct snd_pcm_substream *substream,
 	struct mt8183_afe_private *afe_priv = afe->platform_priv;
 	int tdm_id = dai->id;
 	struct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[tdm_id];
+	unsigned int tdm_out_mode = tdm_priv->tdm_out_mode;
 	unsigned int rate = params_rate(params);
 	unsigned int channels = params_channels(params);
+	unsigned int out_channels_per_sdata = get_tdm_ch_per_sdata(tdm_out_mode, channels);
 	snd_pcm_format_t format = params_format(params);
 	unsigned int tdm_con = 0;
 
@@ -448,7 +486,7 @@ static int mtk_dai_tdm_hw_params(struct snd_pcm_substream *substream,
 
 	/* calculate bck */
 	tdm_priv->bck_rate = rate *
-			     channels *
+			     out_channels_per_sdata *
 			     snd_pcm_format_physical_width(format);
 
 	if (tdm_priv->bck_rate > tdm_priv->mclk_rate)
@@ -461,50 +499,69 @@ static int mtk_dai_tdm_hw_params(struct snd_pcm_substream *substream,
 		 __func__,
 		 tdm_id, rate, channels, format,
 		 tdm_priv->mclk_rate, tdm_priv->bck_rate);
+	dev_info(afe->dev, "%s(), out_channels_per_sdata = %d \n", __func__, out_channels_per_sdata);
 
 	/* set tdm */
-	tdm_con = 1 << BCK_INVERSE_SFT;
-	tdm_con |= 1 << LRCK_INVERSE_SFT;
-	tdm_con |= 1 << DELAY_DATA_SFT;
+	if (tdm_priv->bck_invert)
+		tdm_con |= 1 << BCK_INVERSE_SFT;
+
+	if (tdm_priv->lck_invert)
+		tdm_con |= 1 << LRCK_INVERSE_SFT;
+
+	if (tdm_priv->tdm_out_mode == TDM_OUT_I2S) {
+		tdm_con |= 1 << DELAY_DATA_SFT;
+		tdm_con |= get_tdm_lrck_width(format) << LRCK_TDM_WIDTH_SFT;
+	} else if (tdm_priv->tdm_out_mode == TDM_OUT_TDM) {
+		tdm_con |= 0 << DELAY_DATA_SFT;
+		tdm_con |= 0 << LRCK_TDM_WIDTH_SFT;
+	}
+
 	tdm_con |= 1 << LEFT_ALIGN_SFT;
 	tdm_con |= get_tdm_wlen(format) << WLEN_SFT;
-	tdm_con |= get_tdm_ch(channels) << CHANNEL_NUM_SFT;
+	tdm_con |= get_tdm_ch(out_channels_per_sdata) << CHANNEL_NUM_SFT;
 	tdm_con |= get_tdm_channel_bck(format) << CHANNEL_BCK_CYCLES_SFT;
-	tdm_con |= get_tdm_lrck_width(format) << LRCK_TDM_WIDTH_SFT;
 	regmap_write(afe->regmap, AFE_TDM_CON1, tdm_con);
 
-	switch (channels) {
-	case 1:
-	case 2:
+	if (out_channels_per_sdata == 2) {
+		switch (channels) {
+		case 1:
+		case 2:
+			tdm_con = TDM_CH_START_O30_O31 << ST_CH_PAIR_SOUT0_SFT;
+			tdm_con |= TDM_CH_ZERO << ST_CH_PAIR_SOUT1_SFT;
+			tdm_con |= TDM_CH_ZERO << ST_CH_PAIR_SOUT2_SFT;
+			tdm_con |= TDM_CH_ZERO << ST_CH_PAIR_SOUT3_SFT;
+			break;
+		case 3:
+		case 4:
+			tdm_con = TDM_CH_START_O30_O31 << ST_CH_PAIR_SOUT0_SFT;
+			tdm_con |= TDM_CH_START_O32_O33 << ST_CH_PAIR_SOUT1_SFT;
+			tdm_con |= TDM_CH_ZERO << ST_CH_PAIR_SOUT2_SFT;
+			tdm_con |= TDM_CH_ZERO << ST_CH_PAIR_SOUT3_SFT;
+			break;
+		case 5:
+		case 6:
+			tdm_con = TDM_CH_START_O30_O31 << ST_CH_PAIR_SOUT0_SFT;
+			tdm_con |= TDM_CH_START_O32_O33 << ST_CH_PAIR_SOUT1_SFT;
+			tdm_con |= TDM_CH_START_O34_O35 << ST_CH_PAIR_SOUT2_SFT;
+			tdm_con |= TDM_CH_ZERO << ST_CH_PAIR_SOUT3_SFT;
+			break;
+		case 7:
+		case 8:
+			tdm_con = TDM_CH_START_O30_O31 << ST_CH_PAIR_SOUT0_SFT;
+			tdm_con |= TDM_CH_START_O32_O33 << ST_CH_PAIR_SOUT1_SFT;
+			tdm_con |= TDM_CH_START_O34_O35 << ST_CH_PAIR_SOUT2_SFT;
+			tdm_con |= TDM_CH_START_O36_O37 << ST_CH_PAIR_SOUT3_SFT;
+			break;
+		default:
+			tdm_con = 0;
+		} 
+	} else {
 		tdm_con = TDM_CH_START_O30_O31 << ST_CH_PAIR_SOUT0_SFT;
 		tdm_con |= TDM_CH_ZERO << ST_CH_PAIR_SOUT1_SFT;
 		tdm_con |= TDM_CH_ZERO << ST_CH_PAIR_SOUT2_SFT;
 		tdm_con |= TDM_CH_ZERO << ST_CH_PAIR_SOUT3_SFT;
-		break;
-	case 3:
-	case 4:
-		tdm_con = TDM_CH_START_O30_O31 << ST_CH_PAIR_SOUT0_SFT;
-		tdm_con |= TDM_CH_START_O32_O33 << ST_CH_PAIR_SOUT1_SFT;
-		tdm_con |= TDM_CH_ZERO << ST_CH_PAIR_SOUT2_SFT;
-		tdm_con |= TDM_CH_ZERO << ST_CH_PAIR_SOUT3_SFT;
-		break;
-	case 5:
-	case 6:
-		tdm_con = TDM_CH_START_O30_O31 << ST_CH_PAIR_SOUT0_SFT;
-		tdm_con |= TDM_CH_START_O32_O33 << ST_CH_PAIR_SOUT1_SFT;
-		tdm_con |= TDM_CH_START_O34_O35 << ST_CH_PAIR_SOUT2_SFT;
-		tdm_con |= TDM_CH_ZERO << ST_CH_PAIR_SOUT3_SFT;
-		break;
-	case 7:
-	case 8:
-		tdm_con = TDM_CH_START_O30_O31 << ST_CH_PAIR_SOUT0_SFT;
-		tdm_con |= TDM_CH_START_O32_O33 << ST_CH_PAIR_SOUT1_SFT;
-		tdm_con |= TDM_CH_START_O34_O35 << ST_CH_PAIR_SOUT2_SFT;
-		tdm_con |= TDM_CH_START_O36_O37 << ST_CH_PAIR_SOUT3_SFT;
-		break;
-	default:
-		tdm_con = 0;
 	}
+
 	regmap_write(afe->regmap, AFE_TDM_CON2, tdm_con);
 
 	regmap_update_bits(afe->regmap, AFE_HDMI_OUT_CON0,
@@ -573,10 +630,58 @@ static int mtk_dai_tdm_set_sysclk(struct snd_soc_dai *dai,
 	return mtk_dai_tdm_cal_mclk(afe, tdm_priv, freq);
 }
 
+static int mtk_dai_tdm_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct mtk_base_afe *afe = dev_get_drvdata(dai->dev);
+	struct mt8183_afe_private *afe_priv = afe->platform_priv;
+	struct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[dai->id];
+
+	if (!tdm_priv) {
+		dev_warn(afe->dev, "%s(), tdm_priv == NULL", __func__);
+		return -EINVAL;
+	}
+
+	/* DAI mode*/
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		tdm_priv->tdm_out_mode = TDM_OUT_I2S;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		tdm_priv->tdm_out_mode = TDM_OUT_TDM;
+		break;
+	default:
+		tdm_priv->tdm_out_mode = TDM_OUT_I2S;
+	}
+
+	/* DAI clock inversion*/
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		tdm_priv->bck_invert = TDM_BCK_NON_INV;
+		tdm_priv->lck_invert = TDM_LCK_NON_INV;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		tdm_priv->bck_invert = TDM_BCK_NON_INV;
+		tdm_priv->lck_invert = TDM_LCK_INV;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		tdm_priv->bck_invert = TDM_BCK_INV;
+		tdm_priv->lck_invert = TDM_LCK_NON_INV;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+	default:
+		tdm_priv->bck_invert = TDM_BCK_INV;
+		tdm_priv->lck_invert = TDM_LCK_INV;
+		break;
+	}
+
+	return 0;
+}
+
 static const struct snd_soc_dai_ops mtk_dai_tdm_ops = {
 	.hw_params = mtk_dai_tdm_hw_params,
 	.trigger = mtk_dai_tdm_trigger,
 	.set_sysclk = mtk_dai_tdm_set_sysclk,
+	.set_fmt = mtk_dai_tdm_set_fmt,
 };
 
 /* dai driver */
diff --git a/sound/soc/mediatek/mt8183/mt8183-mt6358-ts3a227-max98357.c b/sound/soc/mediatek/mt8183/mt8183-mt6358-ts3a227-max98357.c
old mode 100644
new mode 100755
index 928687771b49..4fce393449fa
--- a/sound/soc/mediatek/mt8183/mt8183-mt6358-ts3a227-max98357.c
+++ b/sound/soc/mediatek/mt8183/mt8183-mt6358-ts3a227-max98357.c
@@ -56,6 +56,22 @@ mt8183_mt6358_ts3a227_max98357_dapm_routes[] = {
 	{"IT6505_8CH", NULL, "TDM"},
 };
 
+enum PINCTRL_PIN_STATE {
+	PIN_STATE_DEFAULT = 0,
+	PIN_STATE_TDM_OUT_ON,
+	PIN_STATE_TDM_OUT_OFF,
+	PIN_STATE_MAX
+};
+
+static const char * const mt8183_mt6358_ts3a227_max98357_pin_str[PIN_STATE_MAX] = {
+	"default", "aud_tdm_out_on", "aud_tdm_out_off",
+};
+
+struct mt8183_mt6358_ts3a227_max98357_priv {
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pin_states[PIN_STATE_MAX];
+};
+
 static int
 mt8183_mt6358_ts3a227_max98357_bt_sco_startup(
 	struct snd_pcm_substream *substream)
@@ -96,6 +112,49 @@ static const struct snd_soc_ops mt8183_mt6358_ts3a227_max98357_bt_sco_ops = {
 	.startup = mt8183_mt6358_ts3a227_max98357_bt_sco_startup,
 };
 
+static int mt8183_mt6358_ts3a227_max98357_tdm_startup(
+	struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct mt8183_mt6358_ts3a227_max98357_priv *priv =
+		snd_soc_card_get_drvdata(rtd->card);
+	int ret;
+
+	if (IS_ERR(priv->pin_states[PIN_STATE_TDM_OUT_ON]))
+		return PTR_ERR(priv->pin_states[PIN_STATE_TDM_OUT_ON]);
+
+	ret = pinctrl_select_state(priv->pinctrl,
+		priv->pin_states[PIN_STATE_TDM_OUT_ON]);
+	if (ret)
+		dev_err(rtd->card->dev, "%s failed to select state %d\n",
+			__func__, ret);
+
+	return ret;
+}
+
+static void mt8183_mt6358_ts3a227_max98357_tdm_shutdown(
+	struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct mt8183_mt6358_ts3a227_max98357_priv *priv =
+		snd_soc_card_get_drvdata(rtd->card);
+	int ret;
+
+	if (IS_ERR(priv->pin_states[PIN_STATE_TDM_OUT_OFF]))
+		return;
+
+	ret = pinctrl_select_state(priv->pinctrl,
+		priv->pin_states[PIN_STATE_TDM_OUT_OFF]);
+	if (ret)
+		dev_err(rtd->card->dev, "%s failed to select state %d\n",
+			__func__, ret);
+}
+
+static struct snd_soc_ops mt8183_mt6358_ts3a227_max98357_tdm_ops = {
+	.startup = mt8183_mt6358_ts3a227_max98357_tdm_startup,
+	.shutdown = mt8183_mt6358_ts3a227_max98357_tdm_shutdown,
+};
+
 static struct snd_soc_dai_link
 mt8183_mt6358_ts3a227_max98357_dai_links[] = {
 	/* FE */
@@ -281,8 +340,13 @@ mt8183_mt6358_ts3a227_max98357_dai_links[] = {
 		.codec_name = "snd-soc-dummy",
 		.codec_dai_name = "snd-soc-dummy-dai",
 		.no_pcm = 1,
+		.dai_fmt = SND_SOC_DAIFMT_I2S |
+			   SND_SOC_DAIFMT_IB_IF |
+			   SND_SOC_DAIFMT_CBM_CFM,
 		.dpcm_playback = 1,
 		.ignore_suspend = 1,
+		.be_hw_params_fixup = mt8183_i2s_hw_params_fixup,
+		.ops = &mt8183_mt6358_ts3a227_max98357_tdm_ops,
 	},
 };
 
@@ -328,7 +392,8 @@ mt8183_mt6358_ts3a227_max98357_dev_probe(struct platform_device *pdev)
 	struct snd_soc_card *card = &mt8183_mt6358_ts3a227_max98357_card;
 	struct device_node *platform_node;
 	struct snd_soc_dai_link *dai_link;
-	struct pinctrl *default_pins;
+	struct mt8183_mt6358_ts3a227_max98357_priv *priv;
+	int ret;
 	int i;
 
 	card->dev = &pdev->dev;
@@ -363,12 +428,48 @@ mt8183_mt6358_ts3a227_max98357_dev_probe(struct platform_device *pdev)
 		card->num_aux_devs = 1;
 	}
 
-	default_pins =
-		devm_pinctrl_get_select(&pdev->dev, PINCTRL_STATE_DEFAULT);
-	if (IS_ERR(default_pins)) {
-		dev_err(&pdev->dev, "%s set pins failed\n",
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "%s allocate card private data fail\n",
 			__func__);
-		return PTR_ERR(default_pins);
+		return -ENOMEM;
+	}
+
+	snd_soc_card_set_drvdata(card, priv);
+
+	priv->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR(priv->pinctrl)) {
+		dev_err(&pdev->dev, "%s devm_pinctrl_get failed\n",
+			__func__);
+		return PTR_ERR(priv->pinctrl);
+	}
+
+	for (i = 0 ; i < PIN_STATE_MAX ; i++) {
+		priv->pin_states[i] = pinctrl_lookup_state(priv->pinctrl,
+			mt8183_mt6358_ts3a227_max98357_pin_str[i]);
+		if (IS_ERR(priv->pin_states[i])) {
+			ret = PTR_ERR(priv->pin_states[i]);
+			dev_info(&pdev->dev, "%s Can't find pin state %s %d\n",
+				 __func__, mt8183_mt6358_ts3a227_max98357_pin_str[i], ret);
+		}
+	}
+
+	if (!IS_ERR(priv->pin_states[PIN_STATE_TDM_OUT_OFF])) {
+		ret = pinctrl_select_state(priv->pinctrl,
+			priv->pin_states[PIN_STATE_TDM_OUT_OFF]);
+		if (ret)
+			dev_info(&pdev->dev,
+				"%s failed to select state %d\n",
+				__func__, ret);
+	}
+
+	if (!IS_ERR(priv->pin_states[PIN_STATE_DEFAULT])) {
+		ret = pinctrl_select_state(priv->pinctrl,
+			priv->pin_states[PIN_STATE_DEFAULT]);
+		if (ret)
+			dev_info(&pdev->dev,
+				"%s failed to select state %d\n",
+				__func__, ret);
 	}
 
 	return devm_snd_soc_register_card(&pdev->dev, card);
